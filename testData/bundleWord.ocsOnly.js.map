{"version":3,"sources":["webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/agent-scheduler/lib/scheduler.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/aqueduct/lib/container-runtime-factories/baseContainerRuntimeFactory.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/aqueduct/lib/container-runtime-factories/containerRuntimeFactoryWithDefaultDataStore.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/aqueduct/lib/container-services/containerServices.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/aqueduct/lib/data-object-factories/dataObjectFactory.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/aqueduct/lib/data-object-factories/pureDataObjectFactory.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/aqueduct/lib/data-objects/dataObject.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/aqueduct/lib/data-objects/pureDataObject.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/aqueduct/lib/request-handlers/requestHandlers.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/common-utils/lib/assert.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/common-utils/lib/base64Encoding.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/common-utils/lib/bufferBrowser.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/common-utils/lib/disposal.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/common-utils/lib/eventForwarder.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/common-utils/lib/heap.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/common-utils/lib/lazy.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/common-utils/lib/logger.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/common-utils/lib/performanceBrowser.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/common-utils/lib/promises.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/common-utils/lib/timer.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/common-utils/lib/trace.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/common-utils/lib/typedEventEmitter.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/common-utils/lib/unreachable.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-definitions/lib/error.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-definitions/lib/loader.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-definitions/lib/runtime.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-loader/lib/audience.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-loader/lib/connectionStateHandler.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-loader/lib/container.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-loader/lib/containerContext.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-loader/lib/debug.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-loader/lib/deltaManager.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-loader/lib/deltaManagerProxy.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-loader/lib/deltaQueue.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-loader/lib/loader.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-loader/lib/networkUtils.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-loader/lib/nullRuntime.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-loader/lib/packageVersion.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-loader/lib/prefetchDocumentStorageService.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-loader/lib/retriableDocumentStorageService.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-loader/lib/utils.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime-definitions/dist/containerRuntime.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime-definitions/dist/containerRuntimeDirtyable.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime-definitions/dist/index.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/blobManager.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/connectionTelemetry.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/containerHandleContext.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/containerRuntime.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/dataStoreContext.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/dataStoreContexts.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/dataStoreRegistry.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/dataStores.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/debug.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/deltaScheduler.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/packageVersion.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/pendingStateManager.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/runWhileConnectedCoordinator.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/summarizer.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/summarizerHandle.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/summaryCollection.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/summaryFormat.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-runtime/lib/summaryManager.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/container-utils/lib/error.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/core-interfaces/lib/fluidPackage.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/datastore/lib/channelContext.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/datastore/lib/channelDeltaConnection.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/datastore/lib/channelStorageService.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/datastore/lib/dataStoreRuntime.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/datastore/lib/debug.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/datastore/lib/fluidHandle.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/datastore/lib/localChannelContext.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/datastore/lib/packageVersion.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/datastore/lib/remoteChannelContext.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/driver-definitions/lib/driverError.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/driver-definitions/lib/storage.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/driver-definitions/lib/urlResolver.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/driver-utils/lib/blobAggregationStorage.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/driver-utils/lib/blobCacheStorageService.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/driver-utils/lib/buildSnapshotTree.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/driver-utils/lib/documentStorageServiceProxy.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/driver-utils/lib/fluidResolvedUrl.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/driver-utils/lib/multiDocumentServiceFactory.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/driver-utils/lib/multiUrlResolver.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/driver-utils/lib/network.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/driver-utils/lib/parallelRequests.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/driver-utils/lib/readAndParse.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/driver-utils/lib/summaryForCreateNew.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/garbage-collector/lib/garbageCollector.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/garbage-collector/lib/utils.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/map/lib/debug.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/map/lib/directory.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/map/lib/localValues.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/map/lib/map.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/map/lib/mapKernel.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/map/lib/packageVersion.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/client.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/collections.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/constants.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/localReference.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/mergeTree.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/mergeTreeTracking.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/opBuilder.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/ops.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/partialLengths.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/properties.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/segmentGroupCollection.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/segmentPropertiesManager.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/snapshotChunks.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/snapshotLoader.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/snapshotV1.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/snapshotlegacy.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/sortedSegmentSet.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/merge-tree/lib/textSegment.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/protocol-base/lib/blobs.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/protocol-base/lib/protocol.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/protocol-base/lib/quorum.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/protocol-definitions/lib/protocol.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/protocol-definitions/lib/scopes.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/protocol-definitions/lib/storage.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/register-collection/lib/consensusRegisterCollection.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/register-collection/lib/consensusRegisterCollectionFactory.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/register-collection/lib/debug.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/register-collection/lib/interfaces.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/register-collection/lib/packageVersion.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/request-handler/lib/requestHandlers.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/request-handler/lib/runtimeRequestHandlerBuilder.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-definitions/dist/dataStoreContext.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-definitions/dist/dataStoreFactory.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-definitions/dist/dataStoreRegistry.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-definitions/dist/garbageCollection.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-definitions/dist/index.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-definitions/dist/protocol.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-definitions/dist/summary.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHandleContextUtils.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHelpers.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-utils/lib/objectstoragepartition.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-utils/lib/objectstorageutils.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-utils/lib/remoteObjectHandle.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-utils/lib/requestParser.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-utils/lib/serializer.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-utils/lib/summarizerNode/summarizerNode.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-utils/lib/summarizerNode/summarizerNodeUtils.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-utils/lib/summarizerNode/summarizerNodeWithGc.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-utils/lib/summaryUtils.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/runtime-utils/lib/utils.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/sequence/lib/debug.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/sequence/lib/intervalCollection.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/sequence/lib/packageVersion.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/sequence/lib/sequence.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/sequence/lib/sequenceDeltaEvent.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/sequence/lib/sequenceFactory.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/sequence/lib/sharedNumberSequence.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/sequence/lib/sharedObjectSequence.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/sequence/lib/sharedSequence.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/sequence/lib/sharedString.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/shared-object-base/lib/handle.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/shared-object-base/lib/sharedObject.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/shared-object-base/lib/summarySerializer.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/shared-object-base/lib/utils.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/shared-object-base/lib/valueType.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/synthesize/lib/dependencyContainer.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/telemetry-utils/lib/debugLogger.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/telemetry-utils/lib/eventEmitterWithErrorHandling.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/telemetry-utils/lib/events.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/@fluidframework/telemetry-utils/lib/logger.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/base64-js/index.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/debug/node_modules/ms/index.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/debug/src/browser.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/debug/src/common.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/double-ended-queue/js/deque.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/events/events.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_DataView.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_Hash.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_ListCache.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_Map.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_MapCache.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_Promise.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_Set.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_Stack.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_Symbol.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_Uint8Array.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_WeakMap.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_apply.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_arrayEach.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_arrayFilter.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_arrayLikeKeys.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_arrayPush.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_assignMergeValue.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_assignValue.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_assocIndexOf.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseAssign.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseAssignIn.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseAssignValue.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseClone.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseCreate.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseFor.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseGetAllKeys.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseGetTag.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseIsArguments.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseIsMap.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseIsNative.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseIsSet.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseIsTypedArray.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseKeys.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseKeysIn.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseMerge.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseMergeDeep.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseRest.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseSetToString.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseTimes.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_baseUnary.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_cloneArrayBuffer.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_cloneBuffer.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_cloneDataView.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_cloneRegExp.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_cloneSymbol.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_cloneTypedArray.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_copyArray.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_copyObject.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_copySymbols.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_copySymbolsIn.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_coreJsData.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_createAssigner.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_createBaseFor.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_defineProperty.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_freeGlobal.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_getAllKeys.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_getAllKeysIn.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_getMapData.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_getNative.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_getPrototype.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_getRawTag.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_getSymbols.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_getSymbolsIn.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_getTag.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_getValue.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_hashClear.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_hashDelete.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_hashGet.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_hashHas.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_hashSet.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_initCloneArray.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_initCloneByTag.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_initCloneObject.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_isIndex.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_isIterateeCall.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_isKeyable.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_isMasked.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_isPrototype.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_listCacheClear.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_listCacheDelete.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_listCacheGet.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_listCacheHas.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_listCacheSet.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_mapCacheClear.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_mapCacheDelete.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_mapCacheGet.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_mapCacheHas.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_mapCacheSet.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_nativeCreate.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_nativeKeys.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_nativeKeysIn.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_nodeUtil.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_objectToString.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_overArg.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_overRest.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_root.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_safeGet.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_setToString.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_shortOut.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_stackClear.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_stackDelete.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_stackGet.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_stackHas.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_stackSet.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/_toSource.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/cloneDeep.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/constant.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/eq.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/identity.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/isArguments.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/isArray.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/isArrayLike.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/isArrayLikeObject.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/isBuffer.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/isFunction.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/isLength.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/isMap.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/isObject.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/isObjectLike.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/isPlainObject.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/isSet.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/isTypedArray.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/keys.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/keysIn.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/merge.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/stubArray.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/stubFalse.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/lodash/toPlainObject.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/path-browserify/index.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/querystring/decode.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/querystring/encode.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/querystring/index.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/./src/documentComponent.ts","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/./src/documentModel.ts","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/./src/loader.ts","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/./src/ocs/conversionHelpers.ts","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/./src/ocs/deltaConnection.ts","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/./src/ocs/deltaStorage.ts","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/./src/ocs/documentService.ts","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/./src/ocs/documentStorage.ts","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/./src/ocs/ocsDocumentFactory.ts","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/./src/ocs/urlResolver.ts","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/./src/wordDocument.ts","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/./src/wordapi.ts","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/url/node_modules/punycode/punycode.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/url/url.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/url/util.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/uuid/dist/esm-browser/regex.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/uuid/dist/esm-browser/stringify.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/uuid/dist/esm-browser/v4.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/../../node_modules/uuid/dist/esm-browser/validate.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/./custom_modules/TextEncoder.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/./custom_modules/rng.js","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/webpack/bootstrap","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/webpack/runtime/compat get default export","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/webpack/runtime/define property getters","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/webpack/runtime/hasOwnProperty shorthand","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/webpack/runtime/make namespace object","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/webpack/runtime/node module decorator","webpack://@ms/office-wordjs-fluid-word-coauth-runtime/./src/word.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACsC;AACgB;AACY;AACE;AACpB;AACkC;AACxD;AACQ;AAClC;AACA,8BAA8B,6CAAI,GAAG;AACrC,6BAA6B,gDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAgB;AACnC;AACA,0CAA0C,mGAAkC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA,yCAAyC,uFAAoB;AAC7D;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA,gBAAgB,4CAAK,eAAe,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAK,gBAAgB,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAM;AACtB;AACA,oBAAoB,4CAAK,eAAe,QAAQ;AAChD;AACA;AACA,oBAAoB,4CAAK,IAAI,WAAW,cAAc,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAK,cAAc,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA,YAAY,4CAAK,aAAa,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,yCAAyC,uFAAoB;AAC7D;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,6CAA6C,uFAAoB;AACjE;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAK,eAAe,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uFAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAK,eAAe,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;AACA,oCAAoC,4EAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA,2BAA2B,qEAAoB;AAC/C,mDAAmD,uGAAsC;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;;;;;ACtVA;AACA;AACA;AACA;AAC8F;AACX;AACgB;AAClC;AACjE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qFAAsB;AAClD;AACA,mCAAmC,sBAAsB;AACzD,2BAA2B,aAAa;AACxC;AACA,QAAQ;AACR;AACA;AACA;AACA,uBAAuB,2EAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oFAAqB,gCAAgC,2FAA0B,0BAA0B,gFAAmB;AAC1J;AACA,oBAAoB,4FAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,uD;;;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACuE;AACN;AACW;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0DAA0D,qFAA2B;AAC5F;AACA;AACA;AACA,YAAY,6EAA0B;AACtC,YAAY,gFAAmB;AAC/B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,uE;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACwF;AACxF;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kFAAmB;AACtC;AACA;AACA;AACA;AACA,mBAAmB,gFAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kFAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACgG;AAC9B;AACF;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,yEAAqB;AAC5D,qGAAqG,4EAAqB;AAC1H;AACA,8DAA8D,sEAAqB;AACnF;AACA,+BAA+B,2EAA0B;AACzD;AACA;AACA,8DAA8D,gEAAe;AAC7E;AACA,+BAA+B,qEAAoB;AACnD;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACwF;AACb;AACT;AAChB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8EAAmB,uCAAuC,uEAA4B;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2EAAmB;AACvD,0EAA0E;AAC1E,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,8FAA8F,4EAAqB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qFAAsB;AACtD;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;;;;;;;;ACzJA;AACA;AACA;AACA;AACkE;AACe;AAC/B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,2DAAc;AAC9C;AACA;AACA;AACA;AACA;AACA,8BAA8B,+EAAoB;AAClD;AACA;AACA;AACA;AACA,uBAAuB,gFAAiB;AACxC;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uEAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gEAAe;AACrE;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,kBAAkB,KAAK;AACvB;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AAC8D;AACQ;AACA;AACT;AACU;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B,wEAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA,+BAA+B,wEAAiB;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB,uBAAuB;AAC3C,cAAc,wBAAwB;AACtC,wBAAwB,aAAa;AACrC,0BAA0B,aAAa;AACvC,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mFAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oFAAmB,KAAK,GAAG;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oFAAmB,KAAK,qEAAoB,CAAC,GAAG,GAAG;AAClE;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;;;;;ACxKA;AACA;AACA;AACA;AAC6E;AACI;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,0BAA0B,2FAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uBAAuB,+EAAoB;AAC3C;AACA;AACA,yBAAyB,cAAc,EAAE,aAAa;AACtD;AACA,aAAa;AACb;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB;AAChB;AACA;AACA,eAAe,gFAAiB;AAChC;AACA;AACA,2C;;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2DAA2D,sCAAsC;AACjG;AACA;AACA,kC;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACwC;AACjC,oCAAoC,sDAAc;AAClD,oCAAoC,sDAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mBAAmB,sDAAc;AACjC;AACA;AACA,0C;;;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACsC;AACJ;AAClC;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,oDAAsB;AACzC;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAoB;AACpD;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;;;ACxJA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACwD;AACxD;AACA;AACA;AACA;AACA;AACO,6BAA6B,iEAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACO,oBAAoB,mBAAkB;AAC7C,8C;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACkC;AACI;AACtC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;ACjJA;AACA;AACA;AACA;AAC0C;AAC1C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAe;AACzC;AACA;AACA;AACA,qBAAqB,uDAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACsC;AACtC;AACA;AACA;AACO,gCAAgC,gDAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,uC;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD,iC;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC,kC;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP,mC;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACsC;AACtC;AACA;AACA;AACO,uBAAuB,gDAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACkG;AACrC;AACG;AACzD,qCAAqC,0FAA6B;AACzE;AACA;AACA;AACA;AACA;AACA,gCAAgC,oEAA4B;AAC5D;AACA,uCAAuC,+DAAK;AAC5C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wCAAwC,iEAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM,2BAA2B,iEAAyB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mFAAsB;AACvD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,kDAAkD;AACjI,oCAAoC,iEAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oEAA4B;AAC5D;AACA;AACA;AACA,gCAAgC,kEAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAgB;AAClC;AACA,uDAAuD,kEAA0B;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iEAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6CAA6C;AACrF;AACA;AACA;AACA;AACA,sBAAsB,iEAAyB;AAC/C,YAAY,oEAAM,cAAc,kEAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oEAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9KA;AACA;AACA;AACA;AACA;AACiC;AACC;AACiC;AACG;AACD;AAC0D;AAC+E;AAC7G;AACR;AACwG;AAC3J;AACgB;AACtB;AACc;AACU;AACd;AACI;AACiC;AACb;AAClE;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kFAAgB,MAAM;AAC9C;AACA;AACA;AACA,YAAY,8EAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM,kBAAkB,kFAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kFAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wBAAwB,0FAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uFAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAA+C,EAAE,wCAAwC,KAAK,OAAO;AACnI;AACA;AACA,yBAAyB,+EAAkB;AAC3C;AACA;AACA,+BAA+B,uDAAU;AACzC,6BAA6B,6CAAI;AACjC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ,gGAAgG,EAAE;AACrJ,6CAA6C,QAAQ,6FAA6F,EAAE;AACpJ,qDAAqD,QAAQ,iFAAiF,EAAE;AAChJ,uDAAuD,QAAQ,mFAAmF,EAAE;AACpJ;AACA,2CAA2C,YAAY,mJAAmJ,EAAE;AAC5M,8CAA8C,YAAY,8IAA8I,EAAE;AAC1M,6CAA6C,YAAY,6IAA6I,EAAE;AACxM,aAAa;AACb,SAAS;AACT;AACA,sBAAsB,+EAAkB;AACxC,0CAA0C,4EAAsB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iDAAiD,0EAAe;AAChE;AACA;AACA,uCAAuC,0EAAe;AACtD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gFAAkB;AAC3C;AACA;AACA;AACA;AACA,yBAAyB,mFAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,4CAA4C,wCAAwC;AACpF,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,eAAe,4FAA+B,oBAAoB,oBAAoB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,sFAAoB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,gCAAgC,sFAAoB;AACpD;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAoD;AAC9E,uBAAuB,yCAAyC;AAChE,mBAAmB,qCAAqC;AACxD,iBAAiB,mCAAmC;AACpD,sBAAsB,wCAAwC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,oEAAM;AAClB,4CAA4C,8BAA8B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM,sBAAsB,uFAAoB;AACxD,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM,sBAAsB,uFAAoB;AACxD;AACA;AACA,6BAA6B,mFAA0C;AACvE;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA,kCAAkC,uFAAoB;AACtD;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA,sCAAsC,uFAAoB;AAC1D;AACA;AACA;AACA;AACA,2CAA2C,2FAA4B;AACvE;AACA;AACA;AACA;AACA,oCAAoC,wFAAqB;AACzD;AACA;AACA,YAAY,oEAAM;AAClB;AACA,YAAY,qFAAsB;AAClC;AACA;AACA;AACA;AACA;AACA,YAAY,qFAAsB;AAClC;AACA;AACA,YAAY,oEAAM;AAClB;AACA,8BAA8B,iDAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uFAAoB;AACpD;AACA;AACA;AACA;AACA;AACA,qCAAqC,uDAAuD;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4FAA+B,eAAe,uBAAuB;AACpF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4CAA4C,4BAA4B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sCAAsC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+CAA+C,uFAAoB;AACnE;AACA;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA;AACA;AACA,gDAAgD,qCAAqC;AACrF,aAAa;AACb;AACA;AACA;AACA;AACA,iCAAiC,+BAA+B;AAChE;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,EAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sFAAoB;AAC3C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oFAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gFAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kFAAuB;AAC3C;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sCAAsC,GAAG,yCAAyC;AAClH,mCAAmC,aAAa,GAAG,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gFAAa;AAC/B;AACA,kBAAkB,iFAAc;AAChC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,kBAAkB,gFAAa;AAC/B;AACA,kBAAkB,iFAAc;AAChC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,kBAAkB,gFAAa;AAC/B;AACA,kBAAkB,iFAAc;AAChC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gFAAa;AAC/B;AACA,kBAAkB,iFAAc;AAChC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,0EAAe;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,+CAA+C,EAAE;AACjD;AACA;AACA,4BAA4B,uFAAoB;AAChD;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oFAAkB;AAC/B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,2EAAY;AACrE,cAAc,oFAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2EAAY;AAChC,oBAAoB,2EAAY;AAChC,oBAAoB,2EAAY;AAChC;AACA;AACA;AACA,0BAA0B,oFAAqB;AAC/C,4BAA4B,oFAAqB;AACjD,yBAAyB,oFAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4EAAiB,8IAA8I,qFAAmB,GAAG,aAAa,0CAA0C,oFAAkB;AAC3R,+BAA+B,+EAAkB;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,YAAY,8CAAK,aAAa,IAAI;AAClC;AACA,gBAAgB,8CAAK,iBAAiB,sBAAsB;AAC5D,qBAAqB,oFAAkB;AACvC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD,iBAAiB;AACjB;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,YAAY,mDAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAY,kCAAkC,+EAAkB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,qBAAqB,0EAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uFAA0B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uBAAuB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uEAAY,CAAC,uEAAQ;AACzC,0DAA0D,0EAAe;AACzE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA,QAAQ,qFAAmB;AAC3B;AACA,4CAA4C,8EAA8E;AAC1H;AACA;AACA;AACA;AACA;AACA,iBAAiB,uFAAqB;AACtC,iBAAiB,wFAAsB;AACvC,iBAAiB,uFAAqB;AACtC;AACA;AACA,2BAA2B,sFAAoB,+CAA+C,KAAK;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mDAAmD;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,wFAAsB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iFAAmB,WAAW,kGAAgC;AAChG,2BAA2B,sFAAoB;AAC/C;AACA;AACA;AACA;AACA,aAAa,8EAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wFAAsB;AAC5D;AACA;AACA;AACA,2CAA2C,yFAAuB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iEAAiE;AACzG;AACA;AACA;AACA;AACA,wCAAwC,qDAAqD;AAC7F;AACA,gBAAgB;AAChB;AACA,kFAAkF;AAClF;AACA,QAAQ,oEAAM;AACd;AACA;AACA,wCAAwC,6CAA6C;AACrF;AACA;AACA;AACA,2BAA2B,oDAAc;AACzC;AACA,8BAA8B,6EAA6B,2EAA2E,kEAAiB,0BAA0B,uEAAW;AAC5L;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gCAAgC;AACpE;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;;;ACv1CA;AACA;AACA;AACA;AACqE;AACF;AACA;AACR;AAC3D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qEAAW;AAC3C;AACA,wCAAwC,uDAAa;AACrD;AACA;AACA;AACA;AACA,sCAAsC,4FAA+B,eAAe,wBAAwB;AAC5G;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gJAAgJ,wFAAqB;AACrK,SAAS;AACT;AACA;AACA,gJAAgJ,uFAAoB;AACpK,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qDAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;;;;;;ACvMA;AACA;AACA;AACA;AACkC;AACqB;AAChD,cAAc,4CAAa;AAClC,kBAAkB,oDAAO,CAAC,cAAc,uDAAU,CAAC;AACnD,iC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACkC;AAC0C;AACU;AACc;AAC1B;AACV;AACe;AACwE;AACnC;AACpF;AACU;AACgC;AACU;AACF;AAClF;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA,WAAW,uFAAyB;AACpC;AACA;AACA,kBAAkB,qFAAoB;AACtC;AACA,wBAAwB,OAAO,IAAI,cAAc;AACjD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA,4BAA4B,2EAAiB;AAC7C;AACA;AACA;AACA;AACA,qBAAqB,mFAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mEAAmE;AAC7F;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sBAAsB,0EAA0E;AAChG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,2EAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6CAAI;AACtC,mCAAmC,6CAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8EAAgB;AAC3C;AACA;AACA;AACA;AACA,gBAAgB,uFAAyB;AACzC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gEAAiB,eAAe,oCAAoC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAU;AACtC;AACA,SAAS;AACT;AACA,uBAAuB,sFAAqB;AAC5C,SAAS;AACT;AACA;AACA,6BAA6B,mDAAU;AACvC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,uBAAuB,qFAAoB;AAC3C,SAAS;AACT;AACA,kCAAkC,mDAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,uBAAuB,qFAAoB;AAC3C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC,oBAAoB,oBAAoB;AACxC,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,6FAA6B;AAC9H,iCAAiC,2FAA8B;AAC/D;AACA,kCAAkC,8FAA+B;AACjE;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gFAAc;AAC1B;AACA;AACA,qCAAqC,oEAAoE;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gFAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8CAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kCAAkC,EAAE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gCAAgC;AAC5E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0EAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qFAAoB;AACtD;AACA,yBAAyB,6EAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAiB;AACzC;AACA;AACA,yBAAyB;AACzB;AACA,gDAAgD,oFAAsB;AACtE;AACA;AACA;AACA;AACA,0BAA0B,oEAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wFAA0B,CAAC,0EAAe;AACxE;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qFAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oFAAsB;AACrD,oCAAoC,qBAAqB;AACzD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4BAA4B,2EAAgB;AAC5C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,wFAA0B,eAAe,4DAA4D,2BAA2B,6BAA6B;AACzK,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,sBAAsB,0EAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAM;AACtB;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wFAA0B,CAAC,0EAAe;AACjF,qBAAqB;AACrB,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,+BAA+B,uFAAyB;AACxD;AACA;AACA;AACA;AACA,uCAAuC,6EAAe;AACtD,8BAA8B,qFAAoB;AAClD;AACA,gBAAgB,gEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA,mCAAmC,oFAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oEAAqB;AACvC;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sGAAkC;AAC7D,oDAAoD,cAAc;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA,4DAA4D,oFAAkB;AAC9E,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA,yBAAyB,6EAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oFAAsB;AAChD;AACA;AACA,sBAAsB,oEAAqB;AAC3C;AACA,iCAAiC,uEAAuE;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW,GAAG,OAAO,GAAG,wBAAwB,GAAG,0BAA0B,GAAG,YAAY;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gFAAmB;AAC7D;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,qBAAqB;AACnF;AACA;AACA;AACA;AACA;AACA,gDAAgD,qBAAqB;AACrE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,eAAe,+EAAe;AAC9B;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA,gCAAgC,0FAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,sBAAsB,gFAAmB,sDAAsD,8CAA8C,oFAAoF;AACjO;AACA;AACA;AACA,sBAAsB,gFAAmB,+CAA+C,8CAA8C,oFAAoF;AAC1N;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kDAAkD;AAC9F;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,wCAAwC,mCAAmC;AAC3E,SAAS;AACT;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;;;;;ACrrCA;AACA;AACA;AACA;AAC8D;AAC9D;AACA;AACA;AACO,8BAA8B,wEAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,wEAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;;;;;AChHA;AACA;AACA;AACA;AACgG;AACzD;AAChC,yBAAyB,2EAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kEAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yEAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yEAAe;AACpD;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtHA;AACA;AACA;AACA;AACsC;AACJ;AACoC;AACD;AACwB;AACyB;AAC9E;AACR;AACG;AACnC;AACA;AACA;AACA;AACA,2BAA2B,qFAAkB;AAC7C;AACO,6BAA6B,gDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kEAAQ;AAC7C;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,8CAA8C;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,gDAAY;AACxC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,8CAA8C,iFAAuB;AACrE,oCAAoC,4FAAkC;AACtE;AACA,mFAAmF;AACnF;AACA,uBAAuB,yFAA4B,yCAAyC,OAAO,WAAW,6CAAI,IAAI,EAAE;AACxH;AACA;AACA,sBAAsB,+EAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iFAAuB;AAChD,oCAAoC,4FAAkC;AACtE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,wBAAwB,aAAa;AACrC;AACA,QAAQ,6CAAK,0CAA0C,yEAAe,GAAG;AACzE,gCAAgC,iEAAwB;AACxD;AACA;AACA,gBAAgB,qFAAsB;AACtC,kCAAkC,iDAAQ;AAC1C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,QAAQ,6CAAK,0CAA0C,yEAAe,GAAG;AACzE,eAAe,gFAAuC;AACtD;AACA;AACA;AACA,eAAe,4FAA+B,eAAe,YAAY;AACzE;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,4FAA+B,eAAe,uBAAuB;AACpF;AACA,+CAA+C,SAAS,qBAAqB,EAAE,sBAAsB,GAAG;AACxG,SAAS;AACT;AACA;AACA;AACA,oFAAoF,uFAAoB;AACxG,iBAAiB,aAAa,GAAG,gBAAgB,uFAAoB,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS,oBAAoB,sEAAsE,EAAE;AACrG;AACA;AACA;AACA,QAAQ,qFAAsB;AAC9B;AACA,uBAAuB,iDAAQ;AAC/B;AACA,2CAA2C,oBAAoB;AAC/D;AACA;AACA,qCAAqC,iDAAQ;AAC7C;AACA;AACA,uCAAuC,oBAAoB,oCAAoC,sBAAsB;AACrH;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,8CAA8C,qFAAkB;AAChE;AACA;AACA;AACA;AACA;AACA,6CAA6C,8FAA2B;AACxE;AACA;AACA;AACA;AACA,wBAAwB,uFAAoB,2EAA2E,uFAAoB;AAC3I;AACA,4BAA4B,uFAAoB;AAChD,4BAA4B,uFAAoB;AAChD;AACA;AACA,QAAQ,6CAAK,IAAI,SAAS,GAAG,gBAAgB,uFAAoB,EAAE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAc;AAC7B,yFAAyF,yFAAsB;AAC/G,kGAAkG,6FAA0B;AAC5H;AACA;AACA;AACA,oFAAoF,uFAAoB;AACxG,kFAAkF,qFAAkB;AACpG,SAAS;AACT;AACA;AACA,kC;;;;;;;;;;;;;;;;ACjQA;AACA;AACA;AACA;AACsE;AAC/D;AACP;AACA,qCAAqC;AACrC,sBAAsB,sEAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6EAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAQ,OAAO,8EAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wC;;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACsC;AAC/B,0BAA0B,gDAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA,uC;;;;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP,0C;;;;;;;;;;;;;;;;;ACR2E;AACD;AAC1C;AACzB,6CAA6C,qFAA2B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,cAAc,UAAU,6FAA6B,EAAE;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6CAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,0D;;;;;;;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACuE;AACgB;AACZ;AACzC;AAC3B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,4EAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,0BAA0B,yEAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qFAAoB;AAC9C;AACA;AACA,qBAAqB,6EAAe;AACpC;AACA,8CAA8C,cAAc;AAC5D;AACA,kCAAkC,yEAAe;AACjD,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oFAAsB;AACzD;AACA,yBAAyB,6CAAI;AAC7B;AACA,gEAAgE,qFAAoB;AACpF;AACA;AACA,SAAS;AACT;AACA;AACA,sCAAsC,cAAc;AACpD;AACA,0BAA0B,yEAAe;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2D;;;;;;;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AAC4B;AACoD;AAC9C;AAC3B;AACP;AACA,mBAAmB,0CAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,mBAAmB;AACnB,YAAY,6CAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6CAAI;AACnC;AACA;AACA,oBAAoB,8EAAgB;AACpC,oBAAoB,4EAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mBAAmB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;AC9Ea;AACb;AACA;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,yBAAyB;AACzB,yBAAyB;AACzB,4C;;;;;;;;;;;ACRa;AACb;AACA;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,kCAAkC;AAClC,kCAAkC;AAClC,qD;;;;;;;;;;;ACRa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,aAAa,mBAAO,CAAC,qHAAoB;AACzC,aAAa,mBAAO,CAAC,uIAA6B;AAClD,iC;;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACoE;AACM;AACpB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,4BAA4B,wFAAyB;AACrD;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,iCAAiC,qBAAqB,GAAG,OAAO;AAChE;AACA;AACA;AACA,yCAAyC,qBAAqB,GAAG,YAAY;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8CAA8C;AACtF;AACA;AACA,0DAA0D,8EAAmB;AAC7E,gBAAgB;AAChB;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;AC3FA;AACA;AACA;AACA;AAC+E;AACZ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yEAAe;AACvC;AACA;AACA,sBAAsB,+EAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,yEAAe;AAC1D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sBAAsB,yEAAe;AACrC;AACA;AACA;AACA,gBAAgB,uFAA0B;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wEAAwE;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACO;AACP;AACA;AACA,+C;;;;;;;;;;;;;;;;ACnHA;AACA;AACA;AACA;AACoE;AACM;AACnE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wFAAyB;AACrD;AACA,wBAAwB,aAAa;AACrC,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA,4CAA4C,uFAAoB;AAChE;AACA;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACyE;AACJ;AAC6B;AACI;AACM;AACrC;AACE;AACK;AACV;AACe;AACwK;AACzN;AACqC;AACV;AAC7B;AACU;AACQ;AACA;AACY;AACF;AACd;AACF;AACuB;AAC2C;AACvG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,aAAa,uFAAqB;AAClC;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB,uFAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,kCAAkC,2DAAc,oBAAoB,+EAAkB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,0BAA0B,eAAe;AAC1G,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gDAAgD,sEAAsB;AACtE;AACA;AACA;AACA,YAAY,gGAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,2EAAiB;AACvD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAU;AACxC,0BAA0B,oFAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,6BAA6B,qFAAoB;AACjD,aAAa;AACb;AACA,6CAA6C,gCAAgC;AAC7E;AACA;AACA,uCAAuC,iFAA2B;AAClE,oCAAoC,2EAAe;AACnD,uBAAuB,+EAAkB;AACzC;AACA;AACA;AACA;AACA;AACA,8BAA8B,8FAA8B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8BAA8B,oDAAU,CAAC,qEAAuB;AAChE,+BAA+B,sDAAW;AAC1C,YAAY,oEAAM,sBAAsB,wFAAoB;AAC5D;AACA,SAAS,kFAAkF,SAAS;AACpG,wGAAwG,0DAAa;AACrH,+EAA+E,+EAAkB;AACjG;AACA,uCAAuC,sEAAmB;AAC1D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAU;AACxC;AACA,kCAAkC,4DAAc,yFAAyF,mCAAmC,EAAE;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,4EAAqB;AAC7B;AACA,6BAA6B,aAAa;AAC1C,sCAAsC,aAAa;AACnD,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAAkB;AACzC;AACA,gCAAgC,uDAAU;AAC1C,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sFAA2B;AAC/D;AACA;AACA;AACA;AACA,sBAAsB,gGAAqC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2EAAY;AAChC,oBAAoB,oFAAqB;AACzC;AACA;AACA,gDAAgD,2DAAc;AAC9D,4CAA4C,6DAAgB;AAC5D;AACA;AACA;AACA;AACA,8CAA8C,uFAA0B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sFAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gFAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iFAAiB;AACpC;AACA;AACA,mBAAmB,mFAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gFAAoB;AACtD;AACA;AACA;AACA;AACA,uBAAuB,+DAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iFAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAM;AACtB;AACA;AACA,mBAAmB,iFAAiB;AACpC;AACA;AACA,mBAAmB,mFAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,cAAc,mFAAmB,CAAC,iFAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,kCAAkC,yEAAa,CAAC,iFAAgB,GAAG,UAAU;AAC7E,kCAAkC,yEAAa,CAAC,6DAAgB;AAChE;AACA;AACA,kCAAkC,yEAAa,CAAC,2DAAc;AAC9D;AACA;AACA;AACA;AACA;AACA,YAAY,gFAAgB,cAAc,6DAAgB;AAC1D;AACA;AACA;AACA,YAAY,gFAAgB,cAAc,2DAAc;AACxD;AACA,0BAA0B,oFAAoB;AAC9C,QAAQ,gFAAgB,cAAc,0DAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2CAA2C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe,wCAAwC,KAAK;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qFAAmB;AAC3B;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uEAAuE;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iFAAgB;AAC1D,YAAY,8CAAK;AACjB;AACA;AACA;AACA,qBAAqB,oFAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iFAAgB;AAC/C;AACA;AACA;AACA;AACA,8BAA8B,iFAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,8CAAI;AACzD;AACA;AACA,6CAA6C,8CAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gCAAgC,gBAAgB;AAC1E;AACA;AACA;AACA,0BAA0B,qBAAqB,gBAAgB;AAC/D;AACA;AACA;AACA,4BAA4B,yFAAqB;AACjD,YAAY,oEAAM,sBAAsB,yFAAqB;AAC7D;AACA;AACA,YAAY,oEAAM,sBAAsB,wFAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0EAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wFAAoB;AACrD;AACA;AACA;AACA;AACA;AACA,cAAc,4FAA+B,UAAU,iCAAiC;AACxF;AACA;AACA;AACA;AACA,uBAAuB,oCAAoC,GAAG,wFAAoB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,mBAAmB,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0EAAyB;AACrC,oCAAoC,iFAAgB;AACpD;AACA;AACA,6CAA6C,qBAAqB,+BAA+B;AACjG;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAqD;AACpE;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA,eAAe,4CAA4C;AAC3D;AACA,oCAAoC,iBAAiB,GAAG,wCAAwC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iBAAiB,yBAAyB;AAC/F;AACA,0BAA0B,sEAAW;AACrC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mEAAmE,gCAAgC,yBAAyB;AAC5H;AACA;AACA;AACA,YAAY,oEAAM,+FAA+F,mBAAmB,OAAO,iBAAiB;AAC5J,8HAA8H,2BAA2B,4CAA4C;AACrM;AACA;AACA,0EAA0E,+EAAkB,4BAA4B,OAAO,oBAAoB,EAAE;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,6CAA6C,yBAAyB;AACvJ;AACA;AACA;AACA,YAAY,oEAAM;AAClB,qBAAqB,qCAAqC,OAAO,iBAAiB;AAClF,kEAAkE,uFAAqB;AACvF;AACA,6EAA6E,6CAA6C,kFAAkF;AAC5M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM,8GAA8G;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qFAAoB;AAC7C;AACA;AACA,QAAQ,oEAAM,sBAAsB,wFAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iFAAgB;AACnD,mEAAmE,gBAAgB,cAAc;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iFAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA,iDAAiD,iFAAgB;AACjE;AACA,yCAAyC,8CAA8C;AACvF;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qCAAqC,uFAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe,wCAAwC,KAAK;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAM;AAC1B;AACA,iBAAiB;AACjB;AACA;AACA,wBAAwB,oEAAM;AAC9B;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,6BAA6B,qFAAoB;AACjD,aAAa;AACb;AACA;AACA;AACA;AACA,qFAAqF,sBAAsB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,eAAe,kFAAkB;AACjC;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,8BAA8B,mFAAsB;AACpD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,8BAA8B,sEAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,2EAAY;AAC9G;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC10CA;AACA;AACA;AACA;AACgF;AACiB;AACrC;AACE;AACqB;AACS;AACX;AAC0D;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,wEAAa,CAAC,uEAA2B;AACxD;AACA;AACA;AACA;AACO,oCAAoC,2EAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM,mEAAmE,GAAG;AACpF,kEAAkE,uFAAoB;AACtF,gDAAgD,uFAAoB;AACpE;AACA,YAAY,oEAAM,oBAAoB,qFAAkB;AACxD,6BAA6B,oFAAiB;AAC9C,YAAY,oEAAM;AAClB;AACA,6BAA6B,kFAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,8DAA8D,8DAA8D;AAC5H,aAAa;AACb;AACA;AACA;AACA,kBAAkB,yEAAY,UAAU,eAAe,0BAA0B,yFAA4B,EAAE,EAAE;AACjH;AACA;AACA,QAAQ,oEAAM;AACd;AACA,uCAAuC,kEAAQ;AAC/C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,QAAQ,oEAAM;AACd;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB,4DAA4D;AAClI;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAyB;AACrC,oCAAoC,iFAAgB;AACpD;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,QAAQ,+EAAgB,kBAAkB,uEAA2B;AACrE;AACA;AACA;AACA;AACA;AACA,QAAQ,+EAAgB,kBAAkB,0EAAS;AACnD;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB,oCAAoC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA,iFAAiF,gCAAgC,EAAE;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB,YAAY,oEAAM;AAClB,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uFAAoB;AACrD;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,uBAAuB;AAChC;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uEAAuE,kFAAe;AACtF;AACA,SAAS;AACT;AACA,2CAA2C,qEAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,0EAAY;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uEAA2B;AAChE;AACA,sEAAsE,uEAA2B;AACjG;AACA;AACA;AACA,sCAAsC,0EAA0B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mEAAmB;AACvC,sCAAsC,iFAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,8CAA8C,qEAAW;AACzD;AACA;AACA,gDAAgD,0EAAS;AACzD,uBAAuB,0EAAY,4CAA4C,0EAAS;AACxF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2HAA2H,kFAAe,GAAG,qFAAkB;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM,sBAAsB,uFAAoB;AAC5D,gCAAgC,wFAAqB;AACrD,SAAS;AACT;AACA,YAAY,oEAAM,sBAAsB,wFAAqB;AAC7D,gCAAgC,uFAAoB;AACpD,SAAS;AACT;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA;AACA;AACA,YAAY,yEAAyB;AACrC;AACA;AACA;AACA,QAAQ,+EAAgB,kBAAkB,uEAA2B;AACrE;AACA;AACA;AACA;AACA;AACA,QAAQ,+EAAgB,kBAAkB,0EAAS;AACnD;AACA,yBAAyB,wFAAyB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA;AACA,qFAAqF,iFAAgB;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA;AACA,mCAAmC,kEAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;;;;;;;ACjoBA;AACA;AACA;AACA;AACsE;AACR;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8DAAI;AACnC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,SAAS;AACT;AACA,uBAAuB,+EAAkB;AACzC;AACA;AACA;AACA;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;AChIO;AACP;AACA;AACA;AACA,mCAAmC,aAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACsE;AAC8B;AAC2F;AACjI;AACM;AAC6C;AACrD;AAC1B;AAC4B;AAC6B;AACnC;AACiG;AAClB;AACvI;AACA;AACA;AACA;AACO;AACP,kHAAkH,iEAAiB;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8DAAI;AACnC;AACA,sBAAsB,+EAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,uFAAoB;AACjE,uCAAuC,2EAA4B,+GAA+G,OAAO,uGAAsC,EAAE;AACjO;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mFAAqB,wCAAwC,uEAA2B;AAC3H;AACA;AACA;AACA;AACA,sCAAsC,0EAA0B;AAChE,gBAAgB,oEAAM,gEAAgE,iCAAiC;AACvH;AACA,uCAAuC,yEAA0B,yHAAyH,OAAO,uGAAsC,EAAE;AACzO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gFAAmB;AACjD;AACA;AACA;AACA,aAAa;AACb,wCAAwC,oCAAoC;AAC5E;AACA;AACA;AACA;AACA;AACA,2BAA2B,gFAAiB;AAC5C;AACA;AACA;AACA;AACA,iDAAiD,2EAA4B,mDAAmD,kFAAuB;AACvJ,kBAAkB,sGAAqC;AACvD;AACA;AACA,0BAA0B,uEAAoB;AAC9C,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA,yCAAyC,uFAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,8CAAI;AACtD,4BAA4B,iFAAkC,2GAA2G,OAAO,iGAAgC,EAAE;AAClN;AACA;AACA;AACA;AACA,4BAA4B,yEAA0B,2GAA2G,OAAO,iGAAgC,EAAE;AAC1M;AACA;AACA;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA,0DAA0D,aAAa,8BAA8B;AACrG;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,kBAAkB,mFAAmB,CAAC,iFAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,4BAA4B,wFAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA,6BAA6B,yFAAyB;AACtD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yEAAa;AAC1C;AACA;AACA;AACA;AACA,kCAAkC,6EAAa;AAC/C,mCAAmC,8EAAkB;AACrD;AACA;AACA;AACA;AACA,YAAY,oEAAM,yBAAyB,wFAAqB;AAChE,2CAA2C,uFAAoB;AAC/D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6CAA6C,qCAAqC,oCAAoC;AACtH;AACA;AACA,4BAA4B,8EAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oFAAoB;AAC3D;AACA;AACA;AACA;AACA,oBAAoB,oEAAM;AAC1B,uCAAuC,gGAAgC;AACvE;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6EAAa;AACzC;AACA;AACA;AACA;AACA;AACA,2CAA2C,uFAAoB;AAC/D,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2FAAuB;AAC3D;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,uEAAuB;AAC/B,kDAAkD,iFAAgB;AAClE,QAAQ,oEAAM,4CAA4C,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sEAA0B;AAC3C;AACA;AACA;AACA,6CAA6C,cAAc,yBAAyB;AACpF;AACA;AACA,sC;;;;;;;;;;;;;;;;;AC7XA;AACA;AACA;AACA;AACkC;AACqB;AAChD,cAAc,4CAAa;AAClC,kBAAkB,oDAAO,CAAC,cAAc,uDAAU,CAAC;AACnD,iC;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AAC2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB,EAAE;AAC/E;AACA;AACA;AACA,uCAAuC,yEAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,yEAAe;AACrE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP,0C;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACsD;AACgB;AACN;AACzB;AACmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,iCAAiC,2DAAK;AACtC;AACA;AACA;AACA;AACA,iCAAiC,2DAAK;AACtC;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,WAAW,6BAA6B;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oFAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kJAAkJ,iFAAgB;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oFAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6EAA8B;AAC3D,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA,8BAA8B,gFAAmB;AACjD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM,4BAA4B,iFAAgB;AAC9D;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM,gCAAgC,oFAAmB;AACrE;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA,QAAQ,oEAAM;AACd;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;;;;AC9UA;AACA;AACA;AACA;AACwD;AACxD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,gCAAgC,kEAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wD;;;;;;;;;;;;;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACsC;AACwC;AACgB;AACvB;AACH;AACF;AACY;AACtB;AACF;AACtD;AACA,sCAAsC;AACtC,mCAAmC;AACnC,uCAAuC;AACvC;AACO;AACP;AACO,iCAAiC,yEAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+EAAkB,yBAAyB,OAAO,2CAA2C,EAAE;AACrH;AACA,kCAAkC,+DAAK;AACvC;AACA;AACA,mCAAmC,sEAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yFAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wFAAsB;AACvC,iBAAiB,qFAAmB;AACpC,iBAAiB,oFAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kFAAgB;AACxC,gCAAgC,EAAE,YAAY,IAAI,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kEAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wCAAwC,wCAAwC;AAChF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wFAAsB;AAC9D,uCAAuC,wFAAsB;AAC7D;AACA;AACA,oCAAoC,yFAAuB;AAC3D,qCAAqC,wFAAsB;AAC3D,SAAS;AACT;AACA;AACA,6BAA6B,wFAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mFAAsB;AACvD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,qCAAqC,oBAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,4CAA4C,6QAA6Q;AACpY;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,gDAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAQ;AACxC;AACA,sBAAsB,+EAAkB;AACxC,kCAAkC,uFAA4B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iEAAiB;AAC1D;AACA;AACA;AACA,+BAA+B,+DAAgB;AAC/C;AACA,0BAA0B,aAAa;AACvC,wBAAwB,aAAa;AACrC,0BAA0B,aAAa;AACvC,uBAAuB,aAAa;AACpC,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB,EAAE,qFAAoB,WAAW,8BAA8B;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,YAAY;AAClG;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wCAAwC,0CAA0C;AAClF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kEAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,wDAAwD;AACtG;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;ACpmBA;AACA;AACA;AACA;AAC8D;AAC9D;AACO,+BAA+B,wEAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACgE;AACI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAQ;AACxC,iCAAiC,kEAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C,0BAA0B,6BAA6B;AACvD;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA,iCAAiC,wFAAsB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kEAAQ;AAC9C;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,iBAAiB,uFAAqB;AACtC;AACA;AACA;AACA,iBAAiB,wFAAsB;AACvC;AACA;AACA;AACA,iBAAiB,yFAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kEAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;;;;;;;;;;ACvQA;AACA;AACA;AACA;AACuE;AAChE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACO;AACA;AACA;AACP;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA,cAAc,KAAK,IAAI,MAAM,IAAI,MAAM,IAAI,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK,IAAI,MAAM,IAAI,MAAM,IAAI;AACnD,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,EAAE,iFAAgB,4BAA4B;AAC7D;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACsC;AAC6B;AACa;AACV;AACJ;AACV;AACjD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gEAAgE;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B,gDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+EAAkB,kCAAkC,OAAO,sCAAsC,EAAE;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,oEAAoE,sEAAY,wBAAwB,EAAE;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iCAAiC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,uCAAuC,qEAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4FAA+B,eAAe,wEAAwE;AAC9H;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0DAA0D;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qFAAkB;AACnC,iBAAiB,6FAA0B;AAC3C,mCAAmC,qBAAqB;AACxD;AACA,iBAAiB;AACjB,iBAAiB,8FAA8B;AAC/C,iBAAiB,yFAAsB;AACvC,iBAAiB,8FAA2B;AAC5C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;;;;;;;ACtWA;AACA;AACA;AACA;AACsD;AACsB;AACb;AAC/D;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA,mHAAmH,yEAAY;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,yEAAY;AAC9C;AACA;AACA;AACA,yBAAyB,kGAA+B;AACxD;AACA;AACO,kCAAkC,yEAAY;AACrD;AACA;AACA,yBAAyB,yGAAsC;AAC/D;AACA;AACA;AACO,kCAAkC,yEAAY;AACrD;AACA;AACA,yBAAyB,yGAAsC;AAC/D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oIAAoI,UAAU,uBAAuB;AACrK;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sGAAsG,sBAAsB,YAAY,yGAAsC,EAAE;AAChL;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,oEAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gCAAgC,wDAAwD,kGAA+B,CAAC,IAAI;AAC3I,mBAAmB,yEAAY;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP,wC;;;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACiE;AACC;AACF;AACzD;AACA;AACP,gCAAgC,2EAAsB;AACtD,8BAA8B,yEAAqB;AACnD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI,+EAAgB;AACpB;AACA;AACA,0C;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACsD;AACkB;AACjE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sFAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACoF;AAC7E;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK,EAAE,KAAK;AAC7D;AACA;AACA;AACA,uBAAuB,KAAK,EAAE,KAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kGAAmC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4HAA4H;AAC5H;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACgF;AACR;AAC0C;AAC9B;AACI;AACN;AACuK;AAClG;AACrH;AACkB;AACQ;AACE;AACvD;AACP;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACO,oCAAoC,2EAAiB;AAC5D;AACA;AACA;AACA;AACA,8BAA8B,0EAAe;AAC7C;AACA;AACA;AACA;AACA;AACA,gCAAgC,uFAAoB;AACpD,oCAAoC,kEAAQ;AAC5C;AACA;AACA,sBAAsB,+EAAkB,uDAAuD,OAAO,cAAc,6CAAI,IAAI,EAAE;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qEAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,gCAAgC,EAAE;AAC1H,uBAAuB,0FAAuB;AAC9C;AACA;AACA,SAAS;AACT,yCAAyC,qEAAW;AACpD;AACA;AACA;AACA;AACA;AACA,+BAA+B,8EAAW;AAC1C;AACA;AACA;AACA,gBAAgB,0FAAuB;AACvC,uBAAuB,sFAAmB;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mFAAqB;AACnE,yCAAyC,qEAAmB;AAC5D;AACA;AACA;AACA;AACA,yDAAyD,uFAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uEAAoB,8TAA8T,OAAO,wGAAsC,EAAE;AAC1a;AACA,qCAAqC,kEAAQ;AAC7C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,yCAAyC,kFAAe,GAAG,qFAAkB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uFAAoB;AACxD;AACA;AACA;AACA;AACA;AACA,eAAe,yFAAyB;AACxC;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD,+BAA+B,aAAa;AAC5C,8BAA8B,aAAa;AAC3C,kCAAkC,aAAa;AAC/C,iCAAiC,aAAa;AAC9C,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gFAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,gDAAgD,yCAAyC;AACzF,2BAA2B,mFAAmB,gCAAgC,MAAM;AACpF;AACA;AACA;AACA,mBAAmB,iFAAiB;AACpC;AACA;AACA,mBAAmB,mFAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kEAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6CAAI;AAC3B;AACA,QAAQ,qEAAM;AACd;AACA,4BAA4B,qEAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kEAAQ;AACzC;AACA;AACA;AACA,QAAQ,qEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uFAAoB;AAC1D;AACA;AACA,gCAAgC,wFAAqB;AACrD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gCAAgC,uFAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qFAAkB;AACjD;AACA;AACA,yBAAyB,oFAAiB;AAC1C;AACA,yBAAyB,kFAAe;AACxC;AACA;AACA;AACA;AACA,yDAAyD,uFAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qFAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qEAAM;AAC9B;AACA;AACA;AACA,wBAAwB,qEAAM;AAC9B;AACA,6CAA6C,gFAAiB;AAC9D,yDAAyD,uEAAoB;AAC7E,kCAAkC,uGAAqC;AACvE;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kEAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uFAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB,GAAG,UAAU;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4EAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0FAAuB;AACzD;AACA;AACA,YAAY,qEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4EAAa;AAC/C,mCAAmC,8EAAkB;AACrD;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAM;AAClB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6CAA6C,qCAAqC,oCAAoC;AACtH;AACA;AACA;AACA,kCAAkC,4EAAa;AAC/C,mCAAmC,8EAAkB;AACrD;AACA;AACA,qCAAqC,qEAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qEAAM;AAC1B,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qEAAM;AAC1B,kCAAkC,gGAAgC;AAClE;AACA;AACA;AACA;AACA;AACA,6CAA6C,qCAAqC,oCAAoC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAM;AACd;AACA;AACA,+BAA+B,kFAAe,8BAA8B,uFAAoB;AAChG,oCAAoC,kEAAgB;AACpD;AACA,6BAA6B,yFAAyB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qEAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,aAAa,8BAA8B;AACrG;AACA,QAAQ,qEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,YAAY,qEAAM,oBAAoB,qFAAkB;AACxD,gCAAgC,wFAAqB;AACrD;AACA;AACA;AACA,SAAS;AACT;AACA,YAAY,qEAAM,oBAAoB,kFAAe;AACrD,gCAAgC,uFAAoB;AACpD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;;;;;;ACrsBA;AACA;AACA;AACA;AACkC;AACqB;AAChD,cAAc,4CAAa;AAClC,kBAAkB,oDAAO,CAAC,cAAc,uDAAU,CAAC;AACnD,iC;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACoE;AACM;AACnE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uFAAoB;AACpD,4BAA4B,wFAAyB;AACrD;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uFAAoB;AAC1D;AACA;AACA,gCAAgC,wFAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uFAAoB;AACpD;AACA;AACA;AACA;AACA,yDAAyD,uFAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACyC;AACmB;AACW;AACK;AACC;AAC7E;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uDAAS;AAC5C;AACA;AACA;AACA;AACA,4BAA4B,8DAAI;AAChC,mBAAmB,uEAAsB;AACzC,SAAS;AACT;AACA;AACA,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,eAAe,iEAAgB;AAC/B;AACA;AACA,QAAQ,oEAAM;AACd,eAAe,iEAAgB;AAC/B;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd,iCAAiC,0EAAY;AAC7C,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qFAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4EAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;;;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP,0C;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACsD;AACsC;AAChC;AACoC;AAChE;AACzB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uEAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iEAAgB;AAChD,6CAA6C,qBAAqB,cAAc;AAChF;AACA;AACA,QAAQ,oEAAM;AACd;AACA,uDAAuD,8DAAiB;AACxE,+BAA+B,0EAAY,8BAA8B,8DAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gFAAmB;AAC7C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,0BAA0B,gFAAmB,oBAAoB,uBAAuB;AACxF;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gFAAmB,oBAAoB,gBAAgB;AACjF;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,YAAY,6CAAK,qCAAqC,gBAAgB;AACtE,gDAAgD,iCAAiC,GAAG,0BAA0B;AAC9G;AACA,8CAA8C,yCAAyC,GAAG,kCAAkC;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qFAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C,uC;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD,mC;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC,uC;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AAC8I;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,eAAe,gFAAkB;AACjC;AACA,WAAW,4EAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB,EAAE,wBAAwB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU,aAAa,WAAW;AACxF;AACA;AACA;AACA;AACA,oBAAoB,oEAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,eAAe,4EAAc;AAC7B;AACA;AACA,QAAQ,oEAAM;AACd,yBAAyB,8EAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,cAAc,yBAAyB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4EAAc;AAChD;AACA;AACA;AACA,wCAAwC,wCAAwC;AAChF;AACA,SAAS;AACT;AACA,yBAAyB,mCAAmC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA,2CAA2C;AAC3C,0CAA0C;AAC1C;AACA;AACA;AACA,qDAAqD,KAAK,GAAG,IAAI;AACjE;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAM;AAC1B,oBAAoB,oEAAM;AAC1B;AACA;AACA;AACA,oBAAoB,oEAAM;AAC1B;AACA;AACA,oBAAoB,6EAAe,uBAAuB,SAAS;AACnE;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;;;;;ACnVA;AACA;AACA;AACA;AAC8D;AACc;AAC5E;AACA;AACA;AACO,sCAAsC,qFAA2B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4EAAc;AACjC;AACA,eAAe,4EAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mD;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACsE;AACM;AACb;AAC7B;AAClC;AACA;AACA;AACA,2BAA2B,KAAK,EAAE,eAAe;AACjD,+BAA+B,gFAAc;AAC7C;AACA,2BAA2B,4EAAc;AACzC,uBAAuB,6CAAI;AAC3B;AACA;AACA,sBAAsB,0EAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kFAAgB;AACpD;AACA,sBAAsB,0EAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM,oBAAoB,gFAAc;AACpD;AACA;AACA,sBAAsB,0EAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,WAAW,6EAAc;AACzB;AACA,6C;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uD;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACO;AACA;AACP;AACA,8DAA8D,kEAAkE;AAChI;AACA;AACA,4C;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AAC4B;AACgC;AACrD;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAsB;AAC9B,uBAAuB,0CAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAsB;AAC9B,uBAAuB,0CAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uD;;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACsE;AACP;AACxD;AACP;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC,yEAAY;AACrD;AACA,6BAA6B,aAAa;AAC1C;AACA,yBAAyB,mGAAmC;AAC5D;AACA;AACO,iCAAiC,yEAAY;AACpD;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA,yBAAyB,kGAAkC;AAC3D;AACA;AACA;AACO,gCAAgC,yEAAY;AACnD;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,yEAAY;AACjD;AACA,6BAA6B,aAAa;AAC1C;AACA,yBAAyB,+FAA+B;AACxD;AACA;AACA;AACO,+EAA+E,0FAA0B;AACzG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP,mC;;;;;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kEAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAM;AACtB;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA,gBAAgB,oEAAM;AACtB,gBAAgB,oEAAM;AACtB;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAM;AAC1B,oBAAoB,oEAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,4BAA4B,kEAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;;;;;;AC3SA;AACA;AACA;AACA;AACgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,4EAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,8EAAgB;AACpC;AACA;AACA,wC;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,4C;;;;;;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACsD;AACtD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS,GAAG,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACkC;AACqB;AAChD,cAAc,4CAAa;AAClC,kBAAkB,oDAAO,CAAC,cAAc,uDAAU,CAAC;AACnD,iC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACyE;AACb;AACE;AACM;AACS;AACrC;AACR;AACmC;AACrB;AAC9C;AACA;AACA,cAAc,kDAAU;AACxB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA,wCAAwC;AACxC,wCAAwC,QAAQ;AAChD;AACA;AACA,gBAAgB,4EAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4EAAa;AACjB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,oBAAoB,uDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACO,8BAA8B,4EAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yDAAe;AAClD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,gBAAgB;AAChB;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ,6CAAK,cAAc,QAAQ;AACnC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ,oEAAM,8EAA8E,aAAa;AACzG;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,2BAA2B,0EAAY;AACvC;AACA;AACA;AACA;AACA;AACA,wCAAwC,0EAAY;AACpD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+EAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,6BAA6B,uFAAqB;AAClD;AACA;AACA,YAAY,oEAAM,8EAA8E,aAAa;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yEAAS,CAAC,+EAAe,2BAA2B,yEAAS,CAAC,gFAAgB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4EAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8DAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM,gGAAgG,QAAQ;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAM,gGAAgG,QAAQ;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAM,gGAAgG,QAAQ;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;;;AC1pCA;AACA;AACA;AACA;AAC8G;AACvG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,eAAe,yEAAS,CAAC,+EAAe;AACxC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,sBAAsB,oFAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,sBAAsB,oFAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yEAAS,CAAC,gFAAgB;AAC5D,gCAAgC,yEAAS,CAAC,+EAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gFAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gFAAY;AAC7C;AACA;AACA;AACA;AACA,mDAAmD,kBAAkB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+EAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,KAAK;AAClD;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;;;;;;AC7LA;AACA;AACA;AACA;AAC8D;AACM;AACR;AACO;AACnC;AACQ;AACM;AAC9C;AACA;AACA;AACA;AACA;AACO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,oBAAoB,uDAAU;AAC9B;AACA;AACA;AACA;AACA,IAAI,iGAAiG;AACrG;AACA;AACO,wBAAwB,4EAAY;AAC3C;AACA,gEAAgE,uCAAuC;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,gBAAgB,4EAAa;AAC7B;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA,oBAAoB,4EAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4EAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,2BAA2B,0EAAY;AACvC;AACA;AACA;AACA;AACA,sCAAsC,0EAAY;AAClD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ,6CAAK,QAAQ,QAAQ;AAC7B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,6BAA6B,uFAAqB;AAClD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,gBAAgB,+EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;;AC9SA;AACA;AACA;AACA;AACsG;AAC7B;AACN;AACnE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,2EAAiB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yDAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8DAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2FAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uCAAuC,8DAAgB;AACvD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yEAAS,CAAC,+EAAe,2BAA2B,yEAAS,CAAC,gFAAgB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAM,gGAAgG,QAAQ;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gFAAY;AACpD;AACA,+BAA+B;AAC/B;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oEAAM;AACtB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2FAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,gBAAgB;AAChB;AACA;AACA,qC;;;;;;;;;;;;;;;ACxkBA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP,0C;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACmE;AACN;AACE;AAClB;AACmC;AAC9B;AACgD;AACzD;AACS;AACA;AACE;AACV;AACnC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0DAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sDAAwB,CAAC,sDAAc;AAC1E;AACA;AACA,6BAA6B,iDAAS;AACtC;AACA;AACA,kCAAkC,8CAA8C;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8DAAgC;AAC3D,uCAAuC,iBAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAA+B;AAC1D,uCAAuC,iBAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAA6B;AACtD,qCAAqC,eAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DAA+B;AACxD,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4EAA+B;AACnD;AACA;AACA,mBAAmB,6DAA+B;AAClD,wBAAwB;AACxB;AACA;AACA,yBAAyB,qEAAW;AACpC;AACA;AACA,2EAA2E,iBAAiB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAoC;AAC7D,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gEAAkC;AAC3D,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qEAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qEAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gEAAwB;AAC1E,4DAA4D,0DAA0D;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qEAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+DAAmB;AACrD;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB,YAAY,oEAAM;AAClB;AACA,kCAAkC,+DAAmB;AACrD;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAsD;AACtF,uBAAuB,0BAA0B,GAAG,eAAe,SAAS,yBAAyB;AACrG,yBAAyB,YAAY,OAAO,UAAU,UAAU,mCAAmC;AACnG,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qEAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+DAAmB;AACrD;AACA;AACA;AACA;AACA,oCAAoC,sDAAsD;AAC1F,iCAAiC,2FAA2F;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA,oBAAoB,oEAAM;AAC1B,4BAA4B,6DAA+B;AAC3D;AACA;AACA,oBAAoB,oEAAM,iBAAiB,gEAAwB;AACnE,4BAA4B,6DAA+B;AAC3D;AACA;AACA;AACA,gCAAgC,2DAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uFAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qEAAW;AACjC;AACA;AACA;AACA;AACA,oBAAoB,oEAAM;AAC1B,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAM;AAC1B;AACA;AACA;AACA;AACA,gBAAgB,oEAAM;AACtB,gBAAgB,oEAAM;AACtB;AACA;AACA,qDAAqD,qDAAuB;AAC5E;AACA;AACA;AACA;AACA;AACA,0BAA0B,+DAAmB;AAC7C,aAAa;AACb;AACA;AACA;AACA,mBAAmB,6DAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA,YAAY,oEAAM;AAClB,6BAA6B,oDAAU;AACvC;AACA;AACA;AACA;AACA,6BAA6B,4DAAc;AAC3C;AACA;AACA;AACA;AACA;AACA,2BAA2B,4DAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAwB;AAC3C;AACA;AACA,mBAAmB,+DAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qEAAW;AAC/B;AACA;AACA;AACA,4BAA4B,+DAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,yCAAyC,WAAW,qBAAqB;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,yCAAyC,WAAW,qBAAqB;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;;;;;ACz0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACZ;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,0BAA0B;AACpB;AACP;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC,6BAA6B;AAC/D,4CAA4C,YAAY,GAAG,UAAU;AAC5E;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAwB;AAC/C,0BAA0B,IAAI,OAAO,4BAA4B,WAAW,oCAAoC;AAChH;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,UAAU,OAAO,0BAA0B;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAa,OAAO,0CAA0C;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qEAAW;AACrC,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,UAAU,OAAO,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,IAAI;AAClC;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,YAAY;AACzC;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qCAAqC;AACzD;AACA,kCAAkC,0BAA0B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,0BAA0B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAyD;AACjF;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;;ACrpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACP,qC;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACsG;AAChE;AACO;AACtC;AACP,2DAA2D,sDAAoB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAe;AAC9B;AACA;AACA,eAAe,4DAAgB;AAC/B;AACA;AACA,eAAe,4DAAgB;AAC/B;AACA;AACA,eAAe,6DAAiB;AAChC;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6DAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6DAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7TA;AACA;AACA;AACA;AACA;AACA;AAC6D;AAChB;AACmG;AACpE;AACd;AACjC;AAC6B;AACf;AACuB;AACI;AAC/D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yDAA2B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oDAAsB;AAC5D;AACA;AACA;AACA,uCAAuC,yDAA2B,GAAG,uDAAyB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oDAAsB;AACjE;AACA;AACA;AACA,4CAA4C,yDAA2B,GAAG,uDAAyB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAiB;AACzB,QAAQ,0DAA4B;AACpC;AACA;AACO;AACP;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,6BAA6B,GAAG,8BAA8B,GAAG,sEAAsE;AACrL;AACA,QAAQ,oEAAM;AACd;AACA,YAAY,oEAAM;AAClB,8BAA8B,6BAA6B,GAAG,8BAA8B,GAAG,iDAAiD;AAChJ,wCAAwC,aAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAoB;AAClD,6BAA6B,kDAAoB;AACjD,2BAA2B,kDAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,IAAI;AAC7B;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,wBAAwB,qDAAa;AACrC,mBAAmB,+DAAuB;AAC1C,iCAAiC,2EAAsB;AACvD,sCAAsC,uEAAuB;AAC7D;AACA;AACA;AACA,uCAAuC,+EAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8CAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA,gBAAgB,oEAAM;AACtB;AACA;AACA;AACA,gBAAgB,oEAAM,cAAc,gEAAwB;AAC5D;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAM;AACtB,gBAAgB,oEAAM;AACtB;AACA,+CAA+C,gEAAwB;AACvE;AACA;AACA;AACA;AACA,8CAA8C,uCAAuC;AACrF,+BAA+B,gDAAgD;AAC/E,gCAAgC,uBAAuB,QAAQ,qBAAqB;AACpF;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACA,uDAAuD,oDAAsB;AACpF;AACO,yDAAyD,yDAA2B,GAAG,uDAAyB;AACvH;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAsB;AACjD;AACA;AACA,2BAA2B,yDAA2B;AACtD;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,2BAA2B,uDAAyB;AACpD;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,GAAG;AAC5B;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uDAAyB;AACxD;AACA;AACA;AACA;AACA;AACA,6BAA6B,UAAU;AACvC;AACA,gDAAgD,SAAS;AACzD;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yBAAyB,GAAG,YAAY;AACzE;AACA,aAAa;AACb;AACA,oBAAoB,KAAK,IAAI,KAAK,GAAG,KAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6CAA6C;AAC3D;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wBAAwB,qDAAa;AACrC;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACP,WAAW,qEAAW;AACtB;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACO;AACP;AACA,iCAAiC,kDAAoB;AACrD;AACA;AACA;AACA;AACA;AACA,+BAA+B,kDAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,UAAU,2BAA2B;AACrC;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yDAA2B,GAAG,uDAAyB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yDAA2B,GAAG,uDAAyB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,gDAAgD,CAAC,oEAAM,iCAAiC,EAAE,EAAE;AACtG;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,2BAA2B,kDAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,UAAU,GAAG,gBAAgB;AAClE,iBAAiB;AACjB;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA,qEAAqE;AACrE,iDAAiD;AACjD;AACA,mDAAmD;AACnD,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,wCAAwC,sDAAsD;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gCAAgC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8CAAgB;AACnD,+BAA+B,sDAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gCAAgC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uBAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,iDAAiD,YAAY,iBAAiB,OAAO,uCAAuC;AAC3K;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wDAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA,mDAAmD,iDAAiD,WAAW,oBAAoB,KAAK,iBAAiB,OAAO,2CAA2C,SAAS,uCAAuC;AAC3P;AACA;AACA;AACA;AACA;AACA,yDAAyD,uBAAuB,GAAG,UAAU;AAC7F,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6BAA6B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe,aAAa,UAAU;AAC7E;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gEAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2BAA2B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gEAAwB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B,qBAAqB;AAChD;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA,YAAY,oEAAM;AAClB;AACA,YAAY,oEAAM;AAClB;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gCAAgC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO;AACtE,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gEAAwB;AAC9D;AACA;AACA;AACA;AACA;AACA,yDAAyD,gEAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8CAAgB;AACvD;AACA,kCAAkC,uBAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAA+B;AAC9C;AACA;AACA;AACA;AACA,oBAAoB,kDAAoB;AACxC;AACA;AACA,8BAA8B,+DAAuB,aAAa,2CAA2C;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+DAAuB,aAAa,0CAA0C;AAChH;AACA;AACA,0CAA0C,+DAAuB,aAAa,0CAA0C;AACxH;AACA;AACA;AACA;AACA;AACA,+CAA+C,+DAAuB;AACtE;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+BAA+B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,oCAAoC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gEAAwB;AACzD;AACA;AACA;AACA;AACA;AACA,2DAA2D,UAAU;AACrE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gEAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+DAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,gEAAwB;AACrF;AACA;AACA;AACA,kDAAkD,gEAAwB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gCAAgC,gEAAwB;AACxD;AACA;AACA,gCAAgC,+DAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yBAAyB;AAC1D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,sCAAsC,gBAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAwB;AACxD;AACA,wCAAwC,sCAAsC,kCAAkC,YAAY,QAAQ,mBAAmB,OAAO,OAAO;AACrK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sCAAsC,iCAAiC,IAAI,QAAQ,OAAO;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gEAAwB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,8EAA8E;AACjL;AACA,gEAAgE;AAChE;AACA;AACA;AACA,qBAAqB,EAAE;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,qEAA6B,GAAG,8BAA8B;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gEAAwB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gEAAwB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iBAAiB;AACrE;AACA;AACA;AACA;AACA,4EAA4E,+DAAuB;AACnG;AACA;AACA,iDAAiD,+DAAuB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA,kEAAkE,+DAAuB;AACzF;AACA;AACA,iDAAiD,+DAAuB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA,4CAA4C,+BAA+B;AAC3E;AACA;AACA;AACA,sCAAsC,4BAA4B,QAAQ,YAAY,SAAS,mBAAmB;AAClH;AACA,6CAA6C,mCAAmC,SAAS,mBAAmB;AAC5G;AACA;AACA,sCAAsC,sCAAsC,QAAQ,IAAI,QAAQ,KAAK,GAAG,QAAQ;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sCAAsC,sBAAsB,KAAK,OAAO,IAAI;AAC5H;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,8CAA8C,sCAAsC;AACpF;AACA;AACA;AACA;AACA;AACA,2EAA2E,8BAA8B;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,KAAK,QAAQ,8CAA8C;AAC1H;AACA;AACA;AACA;AACA,6BAA6B,gEAAwB;AACrD;AACA;AACA;AACA;AACA;AACA,8CAA8C,sCAAsC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gBAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kCAAkC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,8BAA8B,GAAG,8BAA8B,GAAG,+DAA+D;AAC3L;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,EAAE;AAC5D,wCAAwC,8BAA8B;AACtE;AACA;AACA;AACA;AACA;AACA,6EAA6E,8BAA8B;AAC3G;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oBAAoB,YAAY,uBAAuB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gEAAwB;AACzD;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA,4BAA4B,gEAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,wDAAwD,gEAAwB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gEAAwB;AACzD;AACA;AACA;AACA;AACA,6CAA6C,IAAI,OAAO,sCAAsC,6BAA6B,uBAAuB,SAAS,mBAAmB;AAC9K;AACA;AACA,+CAA+C,gEAAwB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gEAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,iBAAiB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4CAA4C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAM;AACtB;AACA,+CAA+C,qEAAwB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAM;AACtB;AACA,+CAA+C,qEAAwB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qEAA6B,EAAE,qDAAa;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,wDAAwD,gEAAwB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4EAA8B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qEAA6B,EAAE,qDAAa;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qEAAwB;AACpD;AACA;AACA;AACA,oDAAoD,qEAA6B,EAAE,qDAAa;AAChG;AACA;AACA;AACA;AACA;AACA,uCAAuC,kDAAoB;AAC3D,sCAAsC,kDAAoB;AAC1D;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gEAAwB,cAAc,qEAA6B;AAC3H,yGAAyG,uDAAe;AACxH;AACA;AACA;AACA,sCAAsC,4EAA8B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB,WAAW,6CAA6C,QAAQ,8BAA8B,QAAQ,iBAAiB;AAC1K;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAkE;AAC5F;AACA;AACA,gCAAgC,+BAA+B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B,QAAQ,YAAY,QAAQ,gCAAgC;AAC3H;AACA;AACA,yCAAyC,uCAAuC,SAAS,uBAAuB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,aAAa,KAAK,0BAA0B,kBAAkB,cAAc,OAAO,IAAI,OAAO,UAAU,QAAQ,iBAAiB,OAAO,0BAA0B;AACxN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,cAAc;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8BAA8B;AAC9D;AACA;AACA;AACA;AACA;AACA,4CAA4C,+BAA+B;AAC3E;AACA;AACA;AACA,sCAAsC,4BAA4B,QAAQ,YAAY,UAAU,mBAAmB;AACnH;AACA,6CAA6C,mCAAmC,SAAS,mBAAmB;AAC5G;AACA;AACA,qCAAqC,sCAAsC,aAAa,IAAI,UAAU,OAAO,QAAQ,KAAK,GAAG,QAAQ;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,sCAAsC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qCAAqC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;ACv6EA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA,8BAA8B,+DAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD,+B;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACsD;AACT;AACU;AACT;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAY,CAAC,sDAAc;AAC3D;AACA,iEAAiE;AACjE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gEAAwB;AACpD;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY,OAAO,iCAAiC,MAAM,gDAAgD;AACnJ;AACA;AACA;AACA;AACA;AACA,wCAAwC,gEAAwB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gEAAwB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAY,CAAC,sDAAc;AACnD;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,mBAAmB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gCAAgC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY,GAAG,YAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;AACA;AACA,+BAA+B,YAAY,GAAG,YAAY;AAC1D;AACA;AACA;AACA;AACA,yBAAyB,YAAY,KAAK,gBAAgB,OAAO,mBAAmB,EAAE,IAAI;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA,gBAAgB,oEAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAM;AAC1B;AACA;AACA;AACA;AACA,gBAAgB,oEAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;;;;;;ACvlBA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AAC6C;AACtC;AACP;AACA;AACA,6BAA6B,0DAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACsD;AACC;AACZ;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kDAAoB;AAC1D,yCAAyC,kDAAoB;AAC7D;AACA;AACA;AACA,oDAAoD,gEAAwB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAwB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gEAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gDAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kDAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,kDAAoB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oD;;;;;;;;;;;;;;;;;;ACtHA;AACA;AACA;AACA;AACkD;AAClD;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kEAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,KAAK,YAAY,cAAc;AACtF;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,KAAK,YAAY,cAAc;AACtF;AACA;AACA;AACA,iBAAiB,kEAAqB;AACtC;AACA;AACA;AACA,2BAA2B,KAAK,kEAAqB,EAAE;AACvD;AACA,2BAA2B,KAAK,gEAAmB,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACsE;AACR;AACM;AACG;AACtB;AACP;AACQ;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6DAAY;AAC5B;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAe;AACrC;AACA;AACA,sBAAsB,+DAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+DAAuB;AACjD;AACA;AACA,+BAA+B,uDAAe;AAC9C;AACA;AACA;AACA,sBAAsB,+EAAkB;AACxC;AACA;AACA,gDAAgD,kEAAqB;AACrE,YAAY,oEAAM;AAClB,mCAAmC,4EAAc;AACjD,SAAS;AACT;AACA,+DAA+D,qCAAqC;AACpG;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM,kFAAkF,aAAa;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAuB,CAAC,kEAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uFAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAgE;AAChG,gCAAgC,6DAAoB;AACpD;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA,0BAA0B,+DAAuB;AACjD;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAe,EAAE,+DAAuB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAe,YAAY,+DAAuB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4EAAc;AACxC;AACA;AACA,0C;;;;;;;;;;;;;;;;;;;;;;AC7JA;AACA;AACA;AACA;AACsE;AACR;AACc;AACrB;AACZ;AACyC;AAClC;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA,sBAAsB,+EAAkB;AACxC;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4DAA4D,KAAK,kEAAqB,EAAE;AACxF;AACA,0BAA0B,gEAAmB,CAAC,GAAG,MAAM;AACvD,mDAAmD,KAAK;AACxD;AACA,sBAAsB,+EAAa;AACnC;AACA,sBAAsB,gFAAc;AACpC;AACA,8BAA8B,+EAA8B;AAC5D;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,+EAAa;AACvC,0BAA0B,kEAAqB;AAC/C,0BAA0B,gFAAc;AACxC;AACA,kCAAkC,+EAA8B,CAAC,kEAAqB;AACtF;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gEAAwB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,wDAA0B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAM,wBAAwB,gEAAwB;AAC1E;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4EAAc;AAC5C;AACA;AACA;AACA;AACA,eAAe,gEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;;ACzMA;AACA;AACA;AACA;AACA;AACsD;AACQ;AACa;AACH;AAC7B;AACwB;AAC5D;AACP;AACA;AACA;AACA;AACA;AACA,sBAAsB,+EAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+EAAa;AACvC;AACA,0BAA0B,gFAAc;AACxC;AACA,kCAAkC,+EAA8B;AAChE;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+EAAa;AACnC;AACA,sBAAsB,gFAAc;AACpC;AACA,8BAA8B,+EAA8B;AAC5D;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA;AACA,sBAAsB,+EAAa;AACnC;AACA,sBAAsB,gFAAc;AACpC;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,uDAAe;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAwB;AACxD;AACA,8EAA8E,gEAAwB;AACtG;AACA;AACA,uBAAuB,wDAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB,YAAY,uDAAe;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,4C;;;;;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AAC0D;AACE;AACrD,0BAA0B,mDAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wEAAgC;AACrE,wCAAwC,wEAAgC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4EAA+B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB,iEAAyB;AAC7C;AACA;AACA,4BAA4B,qEAAqE;AACjG,0CAA0C,YAAY,QAAQ,mBAAmB,QAAQ,aAAa;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,IAAI;AACrD;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,kBAAkB;AAC7E;AACA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAyB;AACrC,2CAA2C,+CAAG,uDAAuD;AACrG,2BAA2B,+CAAG,2BAA2B,UAAU,OAAO;AAC1E;AACA,iCAAiC,wBAAwB;AACzD,gBAAgB;AAChB;AACA;AACA;AACA,uBAAuB;AACvB,YAAY,iEAAyB;AACrC,2CAA2C,+CAAG,uDAAuD;AACrG,2BAA2B,+CAAG,2BAA2B,UAAU,OAAO;AAC1E;AACA,iCAAiC,wBAAwB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;;;;;ACnOA;AACA;AACA;AACA;AAC4E;AACb;AAC/D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mBAAmB,+EAAa;AAChC;AACA,mBAAmB,oFAAkB;AACrC;AACA,YAAY,6EAAe,wBAAwB,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6EAAe,wBAAwB,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,4BAA4B,aAAa,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yBAAyB,aAAa,WAAW;AAC9E;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,oBAAoB,+EAAa;AACjC,oBAAoB,gFAAc;AAClC,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iFAAe;AACnC,oBAAoB,kFAAgB;AACpC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oFAAkB;AACtC,oBAAoB,gFAAc;AAClC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+EAAa;AACjC,oBAAoB,sFAAoB;AACxC,sBAAsB;AACtB;AACA;AACA;AACO;AACP;AACA,cAAc,+EAAa;AAC3B;AACA,cAAc,gFAAc;AAC5B;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,iC;;;;;;;;;;;;;;;;;ACzJA;AACA;AACA;AACA;AACoE;AAClC;AAC3B;AACP;AACA,aAAa,wFAAsB;AACnC,aAAa,yFAAuB;AACpC,aAAa,qFAAmB;AAChC,aAAa,oFAAkB;AAC/B,aAAa,kFAAgB;AAC7B,aAAa,sFAAoB;AACjC,aAAa,uFAAqB;AAClC,aAAa,wFAAsB;AACnC,aAAa,yFAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,0BAA0B,2CAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wFAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yFAAuB;AACxC;AACA;AACA;AACA;AACA,iBAAiB,qFAAmB;AACpC;AACA;AACA;AACA;AACA;AACA,iBAAiB,oFAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACyC;AAC2E;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM,kEAAkE,SAAS;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,2EAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2DAA2D;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAS;AACnC;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM,4DAA4D,SAAS;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM,0DAA0D,SAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gDAAgD;AAChF;AACA;AACA,6BAA6B,kEAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM,sEAAsE,eAAe;AACnG,QAAQ,oEAAM,uEAAuE,MAAM,8BAA8B,qBAAqB;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM,oEAAoE,eAAe;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gCAAgC;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,wEAAc;AAC/C;AACA;AACA,uBAAuB,6EAAe;AACtC,mBAAmB,6EAAe;AAClC,mBAAmB,6EAAe;AAClC,+BAA+B,6EAAe;AAC9C,0BAA0B,6EAAe;AACzC,yBAAyB,6EAAe;AACxC;AACA;AACA,kC;;;;;;;;;;;;;;;AC5RA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC,oC;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B,kC;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B,mC;;;;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACuF;AACE;AACvB;AACwB;AAC1D;AACU;AAC1C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACO,0CAA0C,4EAAY;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,wGAAuC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mGAAkC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAiB;AAC5C,2BAA2B,0DAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB,EAAE;AACvD;AACA;AACA;AACA,0BAA0B,+EAAa;AACvC;AACA,0BAA0B,gFAAc;AACxC;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,uBAAuB,4EAAc;AACrC;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,QAAQ,6CAAK,gCAAgC,QAAQ;AACrD;AACA;AACA,6BAA6B,uFAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6EAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,uD;;;;;;;;;;;;;;;;ACxOA;AACA;AACA;AACA;AAC4E;AAC9B;AAC9C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,+BAA+B,qFAA2B;AAC1D;AACA;AACA;AACA;AACA,+BAA+B,qFAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAU;AAC9B;AACA,8D;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACkC;AACqB;AAChD,cAAc,4CAAa;AAClC,kBAAkB,oDAAO,CAAC,cAAc,uDAAU,CAAC;AACnD,iC;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC,sC;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP,0C;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA,QAAQ,oEAAM;AACd;AACA;AACA,+EAA+E,yBAAyB;AACxG;AACA;AACA;AACA;AACA,4DAA4D,kBAAkB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2C;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACiF;AACjF;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAiB;AAChC;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wD;;;;;;;;;;;AClCa;AACb;AACA;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC,iBAAiB,KAAK;AAC3D,4C;;;;;;;;;;;ACtBa;AACb;AACA;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,8BAA8B;AAC9B,8BAA8B;AAC9B,4C;;;;;;;;;;;ACRa;AACb;AACA;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,+BAA+B;AAC/B,+BAA+B;AAC/B,6C;;;;;;;;;;;ACRa;AACb;AACA;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,iBAAiB;AACjB;AACA,iBAAiB;AACjB,6C;;;;;;;;;;;ACTa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,aAAa,mBAAO,CAAC,2GAAoB;AACzC,aAAa,mBAAO,CAAC,6GAAqB;AAC1C,aAAa,mBAAO,CAAC,2GAAoB;AACzC,aAAa,mBAAO,CAAC,6GAAqB;AAC1C,aAAa,mBAAO,CAAC,2FAAY;AACjC,aAAa,mBAAO,CAAC,yFAAW;AAChC,iC;;;;;;;;;;;ACtBa;AACb;AACA;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,oC;;;;;;;;;;;ACNa;AACb;AACA;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,wBAAwB,GAAG,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE,kCAAkC,KAAK;AAC9G,wBAAwB;AACxB,mC;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,KAAK,OAAO,0BAA0B,GAAG,KAAK;AAChG;AACA;AACA;AACA,uD;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,IAAI;AACtB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACO;AACP,+CAA+C,MAAM;AACrD;AACA;AACA;AACA;AACA,IAAI,oEAAM;AACV;AACA;AACO;AACA;AACP,IAAI,oEAAM;AACV;AACA;AACA;AACA,sDAAsD,MAAM,IAAI,YAAY;AAC5E;AACA;AACA;AACA;AACO;AACP;AACA;AACA,sCAAsC,aAAa,EAAE;AACrD,uCAAuC,aAAa,EAAE;AACtD;AACA,8BAA8B,QAAQ,yGAAyG,EAAE;AACjJ;AACA;AACA,4C;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACsD;AACtD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA,wCAAwC,UAAU,GAAG,KAAK;AAC1D;AACA;AACA,wCAAwC,UAAU,GAAG,KAAK;AAC1D;AACA;AACA,oCAAoC,UAAU,GAAG,KAAK;AACtD;AACA;AACA,kD;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACsD;AAC2C;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA,wBAAwB,aAAa;AACrC,+BAA+B,aAAa;AAC5C,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,sBAAsB,sEAAmB;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oEAAiB;AACnC;AACA;AACA,mBAAmB,sEAAmB;AACtC;AACA;AACA;AACA,8C;;;;;;;;;;;;;;AClEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA,yBAAyB,kDAAkD;AAC3E;AACA,+CAA+C,KAAK,GAAG,WAAW;AAClE;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AAC+D;AACW;AAC7B;AAC7C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uFAAyB;AAC3C,uBAAuB,wEAAuB;AAC9C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;;;ACtGA;AACA;AACA;AACA;AACkF;AACX;AACY;AACgF;AACnK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY,oEAAkB;AAChE;AACA,oDAAoD,6EAA2B;AAC/E;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,4BAA4B,mEAAa;AACzC;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,4BAA4B,6DAAW,+BAA+B,qBAAqB,iFAAiF;AAC5K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iEAAW;AACzD,sGAAsG,oEAAkB;AACxH;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA,wFAAwF,oCAAoC,MAAM,wBAAwB;AAC1J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB,GAAG,mEAAa;AACxD,iCAAiC,6DAAW;AAC5C;AACA;AACA;AACA,SAAS;AACT,eAAe,iCAAiC,GAAG,6EAAuB;AAC1E;AACA;AACA;AACA;AACA,gDAAgD,6EAA2B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4HAA4H,oEAAkB;AAC9I,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB,GAAG,6EAAuB;AAC5D;AACA,gDAAgD,oEAAkB;AAClE;AACA;AACA;AACA,+BAA+B,mEAAa;AAC5C;AACA,eAAe,mBAAmB,GAAG,6EAAuB;AAC5D;AACA;AACA;AACA;AACA,gDAAgD,6EAA2B;AAC3E;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM,sFAAsF,sBAAsB,KAAK,kBAAkB;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sGAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mEAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uGAAsC;AACvD;AACA,oBAAoB,oEAAM;AAC1B;AACA;AACA;AACA,iBAAiB,iGAAgC;AACjD;AACA;AACA;AACA;AACA,+BAA+B,eAAe,GAAG,iFAA2B;AAC5E,wBAAwB,oEAAM;AAC9B;AACA;AACA,6CAA6C,uGAAsC;AACnF;AACA,wBAAwB,oEAAM;AAC9B;AACA;AACA;AACA,wBAAwB,oEAAM;AAC9B;AACA;AACA,mCAAmC,6DAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6EAAe,wDAAwD,KAAK;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yHAAyH,uIAAuI,2EAAyB;AAChS,0C;;;;;;;;;;;;;;;;;;;;;;;;ACzcA;AACA;AACA;AACA;AACsD;AACiB;AAClB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU,GAAG,UAAU;AACzD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,eAAe,MAAM,UAAU;AAC7H,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wBAAwB,6DAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,aAAa,iBAAiB;AACvE;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,8CAA8C,iFAAgB;AAC9D;AACA;AACA;AACA,8BAA8B,iFAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,yCAAyC,iFAAgB;AACzD;AACA;AACA;AACA,8BAA8B,iFAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;;;;;;;;;;;AClOA;AACA;AACA;AACA;AACmE;AACH;AACC;AACf;AACG;AACrD;AACA,gCAAgC,6DAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mCAAmC,2DAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qEAAW;AACzD;AACA;AACA;AACA,kGAAkG;AAClG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8EAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,8EAAW,iBAAiB,YAAY;AAC/F,iDAAiD,qBAAqB,SAAS;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8EAAW;AAC9B;AACA;AACA,sBAAsB,8EAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,0EAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,QAAQ,oEAAM;AACd;AACA,sHAAsH,Y;AACtH;AACA,mGAAmG;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+HAA+H,wLAAwL,2EAAyB;AACvV,gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjSA;AACA;AACA;AACA;AACyI;AACvC;AAChC;AAClE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,4EAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,iBAAiB,gFAAc;AAC/B;AACA;AACA;AACA,8BAA8B,wEAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gFAAc;AAC/B;AACA;AACA;AACA;AACA,iBAAiB,sFAAoB;AACrC;AACA;AACA;AACA;AACA,iBAAiB,kFAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,oEAAM;AACV;AACA;AACA;AACA;AACA;AACA,4BAA4B,8EAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gFAAkB;AACtD;AACA;AACA,iCAAiC,wEAAa;AAC9C;AACA;AACA;AACA,iCAAiC,wEAAa;AAC9C;AACA;AACA;AACA,iCAAiC,8EAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;;;AC1QA;AACA;AACA;AACA;AACO;AACP,iC;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACkC;AACqB;AAChD,cAAc,4CAAa;AAClC,kBAAkB,oDAAO,CAAC,cAAc,uDAAU,CAAC;AACnD,iC;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACsC;AACkB;AACjD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qEAAuB;AACjD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qEAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO,GAAG,qCAAqC,GAAG,qCAAqC;AACtI,8BAA8B,OAAO,MAAM,KAAK,MAAM,OAAO,MAAM,KAAK;AACxE,8BAA8B,sEAAwB,6BAA6B,GAAG,kBAAkB;AACxG,8BAA8B,sEAAwB,2BAA2B,GAAG,gBAAgB;AACpG,8BAA8B,sEAAwB,0BAA0B,GAAG,eAAe;AAClG,8BAA8B,sEAAwB,wBAAwB,GAAG,aAAa;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAwB;AACjD,wBAAwB,+EAAiC;AACzD;AACA;AACA;AACA;AACA,eAAe,sEAAwB;AACvC;AACA;AACA,uBAAuB,gFAAkC;AACzD,qBAAqB,8EAAgC;AACrD,yBAAyB,yEAA2B;AACpD,uBAAuB,+EAAiC;AACxD,qBAAqB,6EAA+B;AACpD;AACA,8BAA8B,8EAAgC;AAC9D,uBAAuB,+EAAiC;AACxD,qBAAqB,+EAAiC;AACtD;AACA;AACA,uBAAuB,kFAAoC;AAC3D,wBAAwB,mFAAqC;AAC7D,sBAAsB,mFAAqC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8EAAgC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gCAAgC,oEAAsB;AACtD;AACA;AACA,gBAAgB,oEAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH,8EAAgC;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,8EAAgC;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,8EAAgC;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,8EAAgC;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8EAAgC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8EAAgC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACO,qCAAqC,gDAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8EAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;;;;ACljBA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP,0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACgF;AAClB;AACd;AACQ;AACiC;AAClB;AACmC;AAC1E;AAC4C;AACQ;AACpF;AACA;AACO,oCAAoC,4EAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kCAAkC;AAC1E,SAAS;AACT,0BAA0B,8DAAgB,kBAAkB,+EAAkB;AAC9E;AACA;AACA;AACA;AACA;AACA,2DAA2D,mEAAkB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,yEAAwB;AACjF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,qCAAqC,0DAAS,oIAAoI,oFAAmC;AACrN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uEAAyB;AACjD;AACA;AACA;AACA,iCAAiC,6EAA+B;AAChE;AACA;AACA;AACA;AACA,6BAA6B,sEAAwB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2EAA6B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAwB;AACjD,wBAAwB,gFAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4FAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,yFAAwC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gFAAa;AACnC;AACA,sBAAsB,iFAAc;AACpC;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,kBAAkB,qFAAkB;AACpC;AACA,kBAAkB,iFAAc;AAChC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qEAAuB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8CAAK,IAAI,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,2BAA2B,6EAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc,4CAA4C,kFAAsB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB,EAAE;AAC3B;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAM;AAClB;AACA;AACA;AACA,YAAY,qEAAM,kBAAkB,wFAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iFAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,aAAa,wFAAwF,qEAAuB,mBAAmB;AAC5M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA,cAAc,4CAA4C;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;ACpiBA;AACA;AACA;AACA;AAC+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wEAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACwD;AACV;AACgB;AACA;AACf;AACD;AACvC;AACP;AACA,0BAA0B,kFAAoC;AAC9D;AACA;AACA;AACA,4BAA4B,6EAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,iCAAiC,uDAAY;AAC7C;AACA;AACA;AACA;AACA,iCAAiC,uDAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAU;AAC9B;AACO;AACP;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,8BAA8B,uEAAoB;AAClD;AACA;AACA;AACA;AACA,iCAAiC,uEAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAU;AAC9B;AACO;AACP;AACA;AACA;AACA,4BAA4B,wDAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,8BAA8B,uEAAoB;AAClD;AACA;AACA;AACA;AACA,iCAAiC,uEAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAU;AAC9B;AACA,2C;;;;;;;;;;;;;;;;AC9HA;AACA;AACA;AACA;AACgE;AACd;AAClD;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO,mCAAmC,2DAAc;AACxD;AACA,wCAAwC,yFAA2C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8EAAgC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yEAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACgE;AACd;AAClD;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO,mCAAmC,2DAAc;AACxD;AACA,wCAAwC,yFAA2C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8EAAgC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yEAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACoF;AACjC;AACnD;AACO,0BAA0B,mEAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uFAA+B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B,4DAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;;;;ACtJA;AACA;AACA;AACA;AACwD;AACL;AACK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,4DAAqB;AACvD;AACA,wCAAwC,iFAAmC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,sEAAwB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mEAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mEAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wEAA0B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;;;;;AC1LA;AACA;AACA;AACA;AAC8D;AACI;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,wEAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAiB;AAChC;AACA;AACA,kC;;;;;;;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACkC;AACoB;AACc;AAC2B;AACF;AAC/C;AACU;AACxD;AACA;AACA;AACO,2BAA2B,0FAA6B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAkB;AAC5C;AACA;AACA,sBAAsB,+EAAkB;AACxC;AACA,mEAAmE,OAAO,iBAAiB,6CAAI,IAAI,EAAE;AACrG,+BAA+B,0EAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC,oBAAoB,aAAa;AACjC,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uFAAoB;AAC7D;AACA;AACA;AACA,yCAAyC,uFAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,2EAA2E,uFAAoB;AAC/F;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA,mCAAmC,iEAAiB;AACpD;AACA,0BAA0B,4FAA6B;AACvD;AACA;AACA;AACA,0BAA0B,wCAAwC;AAClE;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA,6CAA6C,iBAAiB,SAAS;AACvE;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA,mCAAmC,iEAAiB;AACpD;AACA;AACA;AACA;AACA,0BAA0B,wCAAwC;AAClE;AACA,YAAY,oEAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;;;;ACvWA;AACA;AACA;AACA;AACgE;AAChE;AACA;AACA;AACO,gCAAgC,0EAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,iC;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B,qC;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,yEAAyE,KAAK;AAC9E;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,uGAAuG,EAAE;AACzG;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,wBAAwB,YAAY,mCAAmC,EAAE;AACzE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA,+C;;;;;;;;;;;;;;;;;;AC3HA;AACA;AACA;AACA;AAC2D;AACZ;AAC0B;AACzE;AACA;AACA;AACO,0BAA0B,oDAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAAa;AACnC,yBAAyB,4CAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAe;AACnD;AACA,kCAAkC,uDAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,4EAAuC;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+DAA0B,CAAC,yEAAe,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,KAAK,GAAG,QAAQ,GAAG,KAAK,GAAG,MAAM;AACnD;AACA;AACA,uC;;;;;;;;;;;;;;;AC1FiE;AACjE;AACA;AACA;AACA;AACA;AACO,4CAA4C,2EAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yD;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACA,+BAA+B,sCAAsC;AACrE;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wCAAwC;AACvE;AACA;AACA,kC;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACoF;AACpF;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,WAAW,+GAA+G;AACjL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,WAAW,oBAAoB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,WAAW,4DAA4D;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW,oBAAoB;AACzF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,sBAAsB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,oCAAoC,eAAe,EAAE,wCAAwC,EAAE,mBAAmB;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB,EAAE,wCAAwC,EAAE,UAAU;AACpG;AACA;AACA,6DAA6D,iFAAuB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACO;AACP,0CAA0C,4CAA4C;AACtF;AACA;AACA,yBAAyB,yEAAe;AACxC,qCAAqC;AACrC;AACA;AACA;AACA,4DAA4D,mBAAkB;AAC9E,gCAAgC,gBAAgB;AAChD,YAAY,mBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB,GAAG,gBAAgB;AACvE,YAAY,mBAAkB;AAC9B,YAAY,mBAAkB,YAAY,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,6BAA6B,gBAAgB,GAAG,gBAAgB;AAChE;AACA,6BAA6B,yEAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2CAA2C;AACzE;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,YAAY;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;ACzgBY;;AAEZ,yBAAkB;AAClB,mBAAmB;AACnB,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,UAAU;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;ACrJA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACjKA;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe;AACf,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4CAA4C;;AAEvD;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA,MAAM,GAAiB;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,wDAAU;;AAEnC,OAAO,WAAW;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;;;;;;;;;;AC3QA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,6DAAI;AACpC;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACpQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,WAAY;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6DAA6D,aAAa;AAC1E;AACA,6DAA6D,aAAa;AAC1E;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;;;;;;;;;;AChfA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;;AAEA;;;;;;;;;;;ACNA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,cAAc,mBAAO,CAAC,yDAAY;AAClC,cAAc,mBAAO,CAAC,yDAAY;AAClC,cAAc,mBAAO,CAAC,yDAAY;;AAElC;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC/BA,qBAAqB,mBAAO,CAAC,uEAAmB;AAChD,sBAAsB,mBAAO,CAAC,yEAAoB;AAClD,mBAAmB,mBAAO,CAAC,mEAAiB;AAC5C,mBAAmB,mBAAO,CAAC,mEAAiB;AAC5C,mBAAmB,mBAAO,CAAC,mEAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC/BA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;;AAEA;;;;;;;;;;;ACNA,oBAAoB,mBAAO,CAAC,qEAAkB;AAC9C,qBAAqB,mBAAO,CAAC,uEAAmB;AAChD,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,kBAAkB,mBAAO,CAAC,iEAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC/BA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;;AAEA;;;;;;;;;;;ACNA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;;AAEA;;;;;;;;;;;ACNA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,eAAe,mBAAO,CAAC,2DAAa;AACpC,eAAe,mBAAO,CAAC,2DAAa;AACpC,eAAe,mBAAO,CAAC,2DAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC1BA,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;;AAEA;;;;;;;;;;;ACLA,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;;AAEA;;;;;;;;;;;ACLA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;;AAEA;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,MAAM;AACjB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxBA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,kBAAkB,mBAAO,CAAC,+DAAe;AACzC,cAAc,mBAAO,CAAC,uDAAW;AACjC,eAAe,mBAAO,CAAC,yDAAY;AACnC,cAAc,mBAAO,CAAC,yDAAY;AAClC,mBAAmB,mBAAO,CAAC,iEAAgB;;AAE3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnBA,sBAAsB,mBAAO,CAAC,yEAAoB;AAClD,SAAS,mBAAO,CAAC,6CAAM;;AAEvB;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnBA,sBAAsB,mBAAO,CAAC,yEAAoB;AAClD,SAAS,mBAAO,CAAC,6CAAM;;AAEvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC3BA,SAAS,mBAAO,CAAC,6CAAM;;AAEvB;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACpBA,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,WAAW,mBAAO,CAAC,iDAAQ;;AAE3B;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChBA,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,aAAa,mBAAO,CAAC,qDAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChBA,qBAAqB,mBAAO,CAAC,uEAAmB;;AAEhD;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;;;;;;;;;;;ACxBA,YAAY,mBAAO,CAAC,qDAAU;AAC9B,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,mBAAmB,mBAAO,CAAC,mEAAiB;AAC5C,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,oBAAoB,mBAAO,CAAC,qEAAkB;AAC9C,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,mBAAmB,mBAAO,CAAC,mEAAiB;AAC5C,aAAa,mBAAO,CAAC,uDAAW;AAChC,qBAAqB,mBAAO,CAAC,uEAAmB;AAChD,qBAAqB,mBAAO,CAAC,uEAAmB;AAChD,sBAAsB,mBAAO,CAAC,yEAAoB;AAClD,cAAc,mBAAO,CAAC,uDAAW;AACjC,eAAe,mBAAO,CAAC,yDAAY;AACnC,YAAY,mBAAO,CAAC,mDAAS;AAC7B,eAAe,mBAAO,CAAC,yDAAY;AACnC,YAAY,mBAAO,CAAC,mDAAS;AAC7B,WAAW,mBAAO,CAAC,iDAAQ;AAC3B,aAAa,mBAAO,CAAC,qDAAU;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;ACrKA,eAAe,mBAAO,CAAC,yDAAY;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;AC7BA,oBAAoB,mBAAO,CAAC,qEAAkB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;;AAEA;;;;;;;;;;;ACfA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,cAAc,mBAAO,CAAC,uDAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnBA,aAAa,mBAAO,CAAC,uDAAW;AAChC,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,qBAAqB,mBAAO,CAAC,uEAAmB;;AAEhD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC3BA,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,mBAAmB,mBAAO,CAAC,iEAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACjBA,aAAa,mBAAO,CAAC,uDAAW;AAChC,mBAAmB,mBAAO,CAAC,iEAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACjBA,iBAAiB,mBAAO,CAAC,6DAAc;AACvC,eAAe,mBAAO,CAAC,2DAAa;AACpC,eAAe,mBAAO,CAAC,yDAAY;AACnC,eAAe,mBAAO,CAAC,2DAAa;;AAEpC;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC9CA,aAAa,mBAAO,CAAC,uDAAW;AAChC,mBAAmB,mBAAO,CAAC,iEAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACjBA,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,eAAe,mBAAO,CAAC,yDAAY;AACnC,mBAAmB,mBAAO,CAAC,iEAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC3DA,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,iBAAiB,mBAAO,CAAC,+DAAe;;AAExC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC7BA,eAAe,mBAAO,CAAC,yDAAY;AACnC,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,mBAAmB,mBAAO,CAAC,mEAAiB;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChCA,YAAY,mBAAO,CAAC,qDAAU;AAC9B,uBAAuB,mBAAO,CAAC,2EAAqB;AACpD,cAAc,mBAAO,CAAC,yDAAY;AAClC,oBAAoB,mBAAO,CAAC,qEAAkB;AAC9C,eAAe,mBAAO,CAAC,yDAAY;AACnC,aAAa,mBAAO,CAAC,qDAAU;AAC/B,cAAc,mBAAO,CAAC,yDAAY;;AAElC;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;ACzCA,uBAAuB,mBAAO,CAAC,2EAAqB;AACpD,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,sBAAsB,mBAAO,CAAC,yEAAoB;AAClD,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,sBAAsB,mBAAO,CAAC,yEAAoB;AAClD,kBAAkB,mBAAO,CAAC,+DAAe;AACzC,cAAc,mBAAO,CAAC,uDAAW;AACjC,wBAAwB,mBAAO,CAAC,2EAAqB;AACrD,eAAe,mBAAO,CAAC,yDAAY;AACnC,iBAAiB,mBAAO,CAAC,6DAAc;AACvC,eAAe,mBAAO,CAAC,yDAAY;AACnC,oBAAoB,mBAAO,CAAC,mEAAiB;AAC7C,mBAAmB,mBAAO,CAAC,iEAAgB;AAC3C,cAAc,mBAAO,CAAC,yDAAY;AAClC,oBAAoB,mBAAO,CAAC,mEAAiB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC7FA,eAAe,mBAAO,CAAC,yDAAY;AACnC,eAAe,mBAAO,CAAC,2DAAa;AACpC,kBAAkB,mBAAO,CAAC,iEAAgB;;AAE1C;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChBA,eAAe,mBAAO,CAAC,yDAAY;AACnC,qBAAqB,mBAAO,CAAC,uEAAmB;AAChD,eAAe,mBAAO,CAAC,yDAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACbA,iBAAiB,mBAAO,CAAC,+DAAe;;AAExC;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACfA,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA,kBAAkB,KAA0B;;AAE5C;AACA,gCAAgC,QAAa;;AAE7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AClCA,uBAAuB,mBAAO,CAAC,2EAAqB;;AAEpD;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACfA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChBA,aAAa,mBAAO,CAAC,uDAAW;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACjBA,uBAAuB,mBAAO,CAAC,2EAAqB;;AAEpD;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnBA,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,sBAAsB,mBAAO,CAAC,yEAAoB;;AAElD;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,OAAO,WAAW;AAC7B,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACvCA,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,iBAAiB,mBAAO,CAAC,+DAAe;;AAExC;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO,WAAW;AAC7B,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACfA,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,mBAAmB,mBAAO,CAAC,mEAAiB;;AAE5C;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO,WAAW;AAC7B,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACfA,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;;AAEA;;;;;;;;;;;ACLA,eAAe,mBAAO,CAAC,2DAAa;AACpC,qBAAqB,mBAAO,CAAC,uEAAmB;;AAEhD;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxBA,gBAAgB,mBAAO,CAAC,6DAAc;;AAEtC;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,GAAG;AACH,CAAC;;AAED;;;;;;;;;;;ACVA;AACA,iBAAiB,KAAmC,IAAI,IAAM,sBAAsB,IAAM;;AAE1F;;;;;;;;;;;ACHA,qBAAqB,mBAAO,CAAC,uEAAmB;AAChD,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,WAAW,mBAAO,CAAC,iDAAQ;;AAE3B;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACfA,qBAAqB,mBAAO,CAAC,uEAAmB;AAChD,mBAAmB,mBAAO,CAAC,mEAAiB;AAC5C,aAAa,mBAAO,CAAC,qDAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChBA,gBAAgB,mBAAO,CAAC,6DAAc;;AAEtC;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACjBA,mBAAmB,mBAAO,CAAC,mEAAiB;AAC5C,eAAe,mBAAO,CAAC,2DAAa;;AAEpC;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChBA,cAAc,mBAAO,CAAC,yDAAY;;AAElC;AACA;;AAEA;;;;;;;;;;;ACLA,aAAa,mBAAO,CAAC,uDAAW;;AAEhC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC7CA,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,gBAAgB,mBAAO,CAAC,2DAAa;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;AC7BA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,mBAAmB,mBAAO,CAAC,mEAAiB;AAC5C,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,gBAAgB,mBAAO,CAAC,2DAAa;;AAErC;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxBA,eAAe,mBAAO,CAAC,2DAAa;AACpC,UAAU,mBAAO,CAAC,iDAAQ;AAC1B,cAAc,mBAAO,CAAC,yDAAY;AAClC,UAAU,mBAAO,CAAC,iDAAQ;AAC1B,cAAc,mBAAO,CAAC,yDAAY;AAClC,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,eAAe,mBAAO,CAAC,2DAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACZA,mBAAmB,mBAAO,CAAC,mEAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChBA,mBAAmB,mBAAO,CAAC,mEAAiB;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC7BA,mBAAmB,mBAAO,CAAC,mEAAiB;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACtBA,mBAAmB,mBAAO,CAAC,mEAAiB;;AAE5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACtBA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzBA,uBAAuB,mBAAO,CAAC,2EAAqB;AACpD,oBAAoB,mBAAO,CAAC,qEAAkB;AAC9C,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,kBAAkB,mBAAO,CAAC,iEAAgB;AAC1C,sBAAsB,mBAAO,CAAC,yEAAoB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC5EA,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,mBAAmB,mBAAO,CAAC,mEAAiB;AAC5C,kBAAkB,mBAAO,CAAC,iEAAgB;;AAE1C;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACjBA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxBA,SAAS,mBAAO,CAAC,6CAAM;AACvB,kBAAkB,mBAAO,CAAC,+DAAe;AACzC,cAAc,mBAAO,CAAC,yDAAY;AAClC,eAAe,mBAAO,CAAC,yDAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACdA,iBAAiB,mBAAO,CAAC,+DAAe;;AAExC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnBA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACZA,mBAAmB,mBAAO,CAAC,mEAAiB;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AClCA,mBAAmB,mBAAO,CAAC,mEAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AClBA,mBAAmB,mBAAO,CAAC,mEAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACfA,mBAAmB,mBAAO,CAAC,mEAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzBA,WAAW,mBAAO,CAAC,mDAAS;AAC5B,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,UAAU,mBAAO,CAAC,iDAAQ;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACpBA,iBAAiB,mBAAO,CAAC,+DAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACjBA,iBAAiB,mBAAO,CAAC,+DAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACfA,iBAAiB,mBAAO,CAAC,+DAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACfA,iBAAiB,mBAAO,CAAC,+DAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACrBA,gBAAgB,mBAAO,CAAC,6DAAc;;AAEtC;AACA;;AAEA;;;;;;;;;;;ACLA,cAAc,mBAAO,CAAC,yDAAY;;AAElC;AACA;;AAEA;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnBA,iBAAiB,mBAAO,CAAC,+DAAe;;AAExC;AACA,kBAAkB,KAA0B;;AAE5C;AACA,gCAAgC,QAAa;;AAE7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,CAAC;;AAED;;;;;;;;;;;AC7BA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACdA,YAAY,mBAAO,CAAC,qDAAU;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnCA,iBAAiB,mBAAO,CAAC,+DAAe;;AAExC;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACpBA,sBAAsB,mBAAO,CAAC,yEAAoB;AAClD,eAAe,mBAAO,CAAC,2DAAa;;AAEpC;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;;AAEA;;;;;;;;;;;ACbA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACpCA,gBAAgB,mBAAO,CAAC,6DAAc;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACbA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,UAAU,mBAAO,CAAC,iDAAQ;AAC1B,eAAe,mBAAO,CAAC,2DAAa;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACjCA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;;;;;;;;;;ACzBA,gBAAgB,mBAAO,CAAC,6DAAc;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA;AACA,mBAAmB,SAAS,GAAG,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,SAAS;AACtB;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA,WAAW,SAAS,GAAG,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACpBA,sBAAsB,mBAAO,CAAC,yEAAoB;AAClD,mBAAmB,mBAAO,CAAC,iEAAgB;;AAE3C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA,6BAA6B,kBAAkB,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA,8CAA8C,kBAAkB,EAAE;AAClE;AACA;AACA;;AAEA;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzBA,iBAAiB,mBAAO,CAAC,6DAAc;AACvC,eAAe,mBAAO,CAAC,yDAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChCA,kBAAkB,mBAAO,CAAC,+DAAe;AACzC,mBAAmB,mBAAO,CAAC,iEAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChCA,WAAW,mBAAO,CAAC,mDAAS;AAC5B,gBAAgB,mBAAO,CAAC,2DAAa;;AAErC;AACA,kBAAkB,KAA0B;;AAE5C;AACA,gCAAgC,QAAa;;AAE7C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACrCA,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,eAAe,mBAAO,CAAC,yDAAY;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACpCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AClCA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,eAAe,mBAAO,CAAC,2DAAa;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC5BA,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,mBAAmB,mBAAO,CAAC,mEAAiB;AAC5C,mBAAmB,mBAAO,CAAC,iEAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC7DA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,eAAe,mBAAO,CAAC,2DAAa;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC1BA,uBAAuB,mBAAO,CAAC,2EAAqB;AACpD,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,eAAe,mBAAO,CAAC,2DAAa;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC1BA,oBAAoB,mBAAO,CAAC,qEAAkB;AAC9C,eAAe,mBAAO,CAAC,2DAAa;AACpC,kBAAkB,mBAAO,CAAC,+DAAe;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACpCA,oBAAoB,mBAAO,CAAC,qEAAkB;AAC9C,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,kBAAkB,mBAAO,CAAC,+DAAe;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC/BA,gBAAgB,mBAAO,CAAC,6DAAc;AACtC,qBAAqB,mBAAO,CAAC,uEAAmB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA,YAAY,SAAS,GAAG,SAAS;AACjC;AACA;AACA;AACA,YAAY,SAAS,GAAG,SAAS;AACjC;AACA;AACA;AACA,UAAU,QAAQ,iBAAiB,GAAG,iBAAiB;AACvD;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACjBA,iBAAiB,mBAAO,CAAC,+DAAe;AACxC,aAAa,mBAAO,CAAC,qDAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,UAAU;AACV;AACA,aAAa,SAAS;AACtB,UAAU;AACV;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/BA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,8BAA8B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU,yBAAyB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,qBAAqB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,WAAW;AACX;AACA,qCAAqC;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA,gDAAgD;AAChD;AACA,WAAW;AACX;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD;AAChD;AACA,KAAK;AACL,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,8DAA8D;;AAE9D;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AChhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AC/Da;;AAEb,cAAc,GAAG,+FAAmC;AACpD,cAAc,GAAG,mGAAuC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHxD;;GAEG;AACsE;AACzB;AACQ;AAER;AAEzC,MAAM,iBAAkB,SAAQ,gEAAU;IAe7C,IAAW,aAAa;QACpB,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;YACtB,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAC;SACjE;QACD,OAAO,IAAI,CAAC,cAAc,CAAC;IAC/B,CAAC;IAED;;;;;;OAMG;IACO,qBAAqB;QAC3B,8EAAkC,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;QAC5D,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;IAC7B,CAAC;IAED;;;OAGG;IACH,mEAAmE;IACnE,gEAAgE;IAChE,6DAA6D;IAC7D,oEAAoE;IACpE,gEAAgE;IAEhE;;OAEG;IACa,cAAc;;YAC1B,uEAAuE;YACvE,IAAI,CAAC,cAAc,GAAG,MAAM,8EAAkC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC9E,CAAC;KAAA;;AAjDsB,4BAAU,GAAG,mBAAmB,CAAC;AAExD;;GAEG;AACoB,yBAAO,GAAG,IAAI,uEAAiB,CAClD,iBAAiB,CAAC,UAAU,EAC5B,iBAAiB,EACjB,CAAC,qEAAoB,EAAE,EAAE,6EAAuB,EAAE,CAAC,EACnD,EAAE,CACL,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACf6E;AAC3B;AAgBxD,SAAS,MAAM,CACX,aAA+B,EAC/B,GAAM,EACN,GAAiC;IAEjC,aAAa,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;AACvC,CAAC;AAED,SAAe,MAAM,CACjB,aAA+B,EAC/B,GAAM;;QAEN,MAAM,SAAS,GAAG,aAAa,CAAC,GAAG,CAA6C,GAAG,CAAC,CAAC;QACrF,IAAI,CAAC,SAAS,EAAE;YACZ,MAAM,IAAI,KAAK,CAAC,mCAAmC,GAAG,EAAE,CAAC,CAAC;SAC7D;QACD,OAAO,MAAM,SAAS,CAAC,GAAG,EAAE,CAAC;IACjC,CAAC;CAAA;AAEM,MAAM,aAAa;IA2EtB,YACoB,UAAwB,EACxB,WAAsB,EACtB,YAAuB,EACvB,kBAA6B,EAC7B,gBAA2B,EAC3B,aAA8B;QAL9B,eAAU,GAAV,UAAU,CAAc;QACxB,gBAAW,GAAX,WAAW,CAAW;QACtB,iBAAY,GAAZ,YAAY,CAAW;QACvB,uBAAkB,GAAlB,kBAAkB,CAAW;QAC7B,qBAAgB,GAAhB,gBAAgB,CAAW;QAC3B,kBAAa,GAAb,aAAa,CAAiB;IAC/C,CAAC;IAjFJ;;OAEG;IACI,MAAM,CAAC,oBAAoB,CAC9B,OAA+B,EAC/B,aAA+B;QAE/B,MAAM,UAAU,GAAG,yEAAmB,CAAC,OAAO,CAAC,CAAC;QAEhD,UAAU,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE;YAC1B,QAAQ,EAAE,wCAAwC;YAClD,mBAAmB,EAAE,CAAC,KAAK,CAAC;SAC/B,CAAC,CAAC;QACH,UAAU,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE;YAC1B,QAAQ,EAAE,wCAAwC;YAClD,mBAAmB,EAAE,CAAC,KAAK,CAAC;SAC/B,CAAC,CAAC;QACH,UAAU,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE;YAC1B,QAAQ,EAAE,wCAAwC;YAClD,mBAAmB,EAAE,CAAC,KAAK,CAAC;SAC/B,CAAC,CAAC;QAEH,MAAM,CAAC,aAAa,EAAE,YAAY,EAAE,UAAU,CAAC,CAAC;QAChD,MAAM,WAAW,GAAG,iEAAgB,CAAC,OAAO,CAAC,CAAC;QAC9C,MAAM,CAAC,aAAa,EAAE,aAAa,EAAE,WAAW,CAAC,CAAC;QAElD,MAAM,YAAY,GAAG,iEAAgB,CAAC,OAAO,CAAC,CAAC;QAC/C,MAAM,CAAC,aAAa,EAAE,cAAc,EAAE,YAAY,CAAC,CAAC;QAEpD,MAAM,kBAAkB,GAAG,iEAAgB,CAAC,OAAO,CAAC,CAAC;QACrD,MAAM,CAAC,aAAa,EAAE,oBAAoB,EAAE,kBAAkB,CAAC,CAAC;QAEhE,MAAM,gBAAgB,GAAG,iEAAgB,CAAC,OAAO,CAAC,CAAC;QACnD,MAAM,CAAC,aAAa,EAAE,kBAAkB,EAAE,gBAAgB,CAAC,CAAC;QAE5D,MAAM,aAAa,GAAG,uEAAsB,CAAC,OAAO,CAAC,CAAC;QACtD,MAAM,CAAC,aAAa,EAAE,eAAe,EAAE,aAAa,CAAC,CAAC;QAEtD,OAAO,IAAI,aAAa,CACpB,UAAU,EACV,WAAW,EACX,YAAY,EACZ,kBAAkB,EAClB,gBAAgB,EAChB,aAAa,CAChB,CAAC;IACN,CAAC;IAED;;;;OAIG;IACI,MAAM,CAAO,oBAAoB,CAAC,aAA+B;;YACpE,MAAM,CAAC,UAAU,EAAE,WAAW,EAAE,YAAY,EAAE,kBAAkB,EAAE,gBAAgB,EAAE,aAAa,CAAC,GAC9F,MAAM,OAAO,CAAC,GAAG,CAAC;gBACd,MAAM,CAAC,aAAa,EAAE,YAAY,CAAC;gBACnC,MAAM,CAAC,aAAa,EAAE,aAAa,CAAC;gBACpC,MAAM,CAAC,aAAa,EAAE,cAAc,CAAC;gBACrC,MAAM,CAAC,aAAa,EAAE,oBAAoB,CAAC;gBAC3C,MAAM,CAAC,aAAa,EAAE,kBAAkB,CAAC;gBACzC,MAAM,CAAC,aAAa,EAAE,eAAe,CAAC;aACzC,CAAC,CAAC;YAEP,OAAO,IAAI,aAAa,CACpB,UAAU,EACV,WAAW,EACX,YAAY,EACZ,kBAAkB,EAClB,gBAAgB,EAChB,aAAa,CAChB,CAAC;QACN,CAAC;KAAA;CAUJ;;;;;;;;;;;;;;;;;;;AC5HD;;GAEG;AACoF;AAE7B;AAKI;AAEN;AAEjD,MAAM,cAAc;IAGvB,YAAY,eAAwB;QAChC,MAAM,cAAc,GAA6B,EAAE,CAAC;QAEpD,IAAI,CAAC,eAAe,EAAE;YAClB,cAAc,CAAC,SAAS,GAAG,IAAI,CAAC;YAChC,cAAc,CAAC,iBAAiB,GAAG,KAAK,CAAC;SAC5C;QAED,IAAI,CAAC,cAAc,GAAG,IAAI,iGAA2C,CACjE,yEAAyB,EACzB,IAAI,GAAG,CAAC,CAAC,CAAC,4EAA4B,EAAE,OAAO,CAAC,OAAO,CAAC,yEAAyB,CAAC,CAAC,CAAC,CAAC,EACrF,EAAE,EACF,EAAE,EACF,cAAc,CACjB,CAAC;IACN,CAAC;IAED;;OAEG;IACI,IAAI,CAAC,GAAsB;QAC9B,IAAI,MAAc,CAAC;QAEnB,IAAI,OAAO,GAAG,CAAC,OAAO,KAAK,QAAQ,EAAE;YACjC,MAAM,GAAG,GAAG,CAAC,OAAO,CAAC;SACxB;aAAM;YACH,MAAM,IAAI,KAAK,CAAC,6BAA6B,OAAO,GAAG,CAAC,OAAO,GAAG,CAAC,CAAC;SACvE;QAED,IAAI,MAAM,KAAK,4EAA4B,EAAE;YACzC,MAAM,IAAI,KAAK,CAAC,mBAAmB,MAAM,GAAG,CAAC,CAAC;SACjD;QAED,OAAO,OAAO,CAAC,OAAO,CAAC,EAAE,WAAW,EAAE,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC;IACjE,CAAC;IAED;;OAEG;IACI,SAAS,CACZ,WAAyB,EACzB,sBAA+C,EAC/C,MAAgB;QAEhB,MAAM,MAAM,GAAG,EAAE,WAAW,EAAE,IAAI,CAAC,cAAc,EAAE,CAAC;QACpD,MAAM,UAAU,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC;QAC3D,MAAM,WAAW,GAAG;YAChB,UAAU;YACV,sBAAsB;YACtB,MAAM,EAAE,+EAAkB,CAAC,MAAM,CAAC;YAClC,OAAO,EAAE;gBACL,MAAM;aACT;YACD,WAAW;SACd,CAAC;QAEF,OAAO,IAAI,oEAAM,CAAC,WAAW,CAAC,CAAC;IACnC,CAAC;CACJ;;;;;;;;;;;;;;;;;;;AC3ED;;GAEG;AAU2C;AAoB9C,MAAM,gCAAgC,GAAG,IAAI,GAAG,CAAS;IACrD,yEAAyE;IACzE,kFAAgB;IAChB,uFAAqB;IACrB,qFAAmB;IACnB,oFAAkB;CACrB,CAAC,CAAC;AAEH;;;GAGG;AACH,SAAS,8BAA8B,CAAC,IAAY;IAChD,qJAAqJ;IACrJ,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAE7B,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;QACpB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;YACpC,MAAM,KAAK,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;YAErB,IACI,OAAO,KAAK,CAAC,MAAM,KAAK,QAAQ;gBAChC,KAAK,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC;gBACzB,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC;gBAC9B,KAAK,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,EAC7B;gBACE,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;aAC/C;YAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;gBAC/C,MAAM,GAAG,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAE9B,sFAAsF;gBACtF,oBAAoB;gBACpB,IACI,OAAO,GAAG,KAAK,QAAQ;oBACvB,sFAAsF;oBACtF,GAAG,KAAK,IAAI;oBACZ,gEAAgE;oBAChE,CAAC,OAAO,GAAG,CAAC,qBAAqB,KAAK,WAAW,IAAI,OAAO,GAAG,CAAC,qBAAqB,KAAK,QAAQ,CAAC,EACrG;oBACE,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;iBAC/C;aACJ;YAED,OAAO,EAAE,OAAO,EAAE,GAA4C,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC;SACtF;KACJ;IAED,IACI,CAAC,GAAG,CAAC,IAAI,KAAK,YAAY,IAAI,GAAG,CAAC,IAAI,KAAK,aAAa,CAAC;QACzD,OAAO,GAAG,CAAC,QAAQ,KAAK,QAAQ;QAChC,OAAO,GAAG,CAAC,MAAM,KAAK,QAAQ,EAChC;QACE,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;KAC/C;IAED,OAAO,EAAE,OAAO,EAAE,GAAuC,EAAE,IAAI,EAAE,QAAQ,EAAE,CAAC;IAC5E,uGAAuG;AAC3G,CAAC;AAED;;GAEG;AACH,SAAS,wBAAwB,CAAI,IAAiB,EAAE,IAAO;IAC3D,IAAI,IAAI,KAAK,wFAAsB,IAAI,IAAI,KAAK,yFAAuB,EAAE;QACrE,MAAM,IAAI,KAAK,CAAC,cAAc,CAAC,CAAC;KACnC;IAED,OAAO;QACH,oBAAoB,EAAE,CAAC,CAAC;QAExB,wEAAwE;QACxE,QAAQ,EAAE,IAAI;QAEd,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;QAC1B,uBAAuB,EAAE,CAAC,CAAC;QAC3B,IAAI;KACP,CAAC;AACN,CAAC;AAUD;;GAEG;AACH,SAAS,2BAA2B,CAChC,KAAQ,EAAE,0CAA0C;AACpD,QAAuB,EACvB,OAAkD,EAClD,qBAA6B,EAC7B,cAAsB;IAEtB,OAAO,gCACA,OAAO,KAEV,QAAQ;QACR,qBAAqB;QACrB,cAAc;QAEd,mEAAmE;QACnE,IAAI,EAAE,CAAC;QAEP,6GAA6G;QAC7G,4GAA4G;QAC5G,iBAAiB;QACjB,EAAE;QACF,4DAA4D;QAC5D,SAAS,EAAE,CAAC,GACuB,CAAC;AAC5C,CAAC;AAED;;;;;;;;GAQG;AACI,SAAS,iCAAiC,CAC7C,QAAgB,EAChB,qBAA6B,EAC7B,cAAsB,EACtB,OAAyB;IAEzB,OAAO,2BAA2B,CAAC,UAAU,EAAE,QAAQ,EAAE,OAAO,EAAE,qBAAqB,EAAE,cAAc,CAAC,CAAC;AAC7G,CAAC;AAED;;GAEG;AACH,SAAS,0CAA0C,CAC/C,6BAAqC,EACrC,sBAA8B,EAC9B,OAA8C;;IAE9C,MAAM,QAAQ,GAAgC,EAAE,CAAC;IACjD,IAAI,qBAAqB,GAAG,sBAAsB,CAAC;IACnD,IAAI,yBAAyB,GAAG,6BAA6B,CAAC;IAE9D,KAAK,IAAI,UAAU,GAAG,CAAC,EAAE,UAAU,GAAG,OAAO,CAAC,MAAM,EAAE,UAAU,IAAI,CAAC,EAAE;QACnE,MAAM,KAAK,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;QAElC,KAAK,IAAI,YAAY,GAAG,CAAC,EAAE,YAAY,GAAG,KAAK,CAAC,QAAQ,CAAC,MAAM,EAAE,YAAY,IAAI,CAAC,EAAE;YAChF,MAAM,qBAAqB,GAAG,qBAAqB,CAAC;YACpD,qBAAqB,IAAI,CAAC,CAAC;YAE3B,8EAA8E;YAC9E,MAAM,OAAO,GAAG,KAAK,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;YAE7C,IAAI,CAAC,gCAAgC,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBACrD,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;aACxD;YAED,+EAA+E;YAC/E,MAAM,4BAA4B,SAAG,OAAO,CAAC,qBAAqB,mCAAI,yBAAyB,CAAC;YAEhG,IAAI,4BAA4B,GAAG,yBAAyB,EAAE;gBAC1D,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;aAC9C;YAED,yBAAyB,GAAG,4BAA4B,CAAC;YAEzD,MAAM,gBAAgB,GAAG,2BAA2B,CAChD,UAAU,EACV,KAAK,CAAC,MAAM,EACZ,OAAO,EACP,4BAA4B,EAC5B,qBAAqB,CACxB,CAAC;YAEF,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;SACnC;KACJ;IAED,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;QACvB,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;KACjD;IAED,OAAO,QAAQ,CAAC;AACpB,CAAC;AAED;;GAEG;AACH,SAAS,uCAAuC,CAC5C,6BAAqC,EACrC,sBAA8B,EAC9B,OAAyC;IAEzC,IAAI,aAAqC,CAAC;IAE1C,IAAI,OAAO,CAAC,IAAI,KAAK,YAAY,EAAE;QAC/B,aAAa,GAAG,wBAAwB,CAAc,wFAAsB,EAAE;YAC1E,QAAQ,EAAE,OAAO,CAAC,QAAQ;YAC1B,MAAM,EAAE,iBAAiB,CAAC,OAAO,CAAC,MAAM,CAAC;SAC5C,CAAC,CAAC;KACN;SAAM;QACH,aAAa,GAAG,wBAAwB,CAAS,yFAAuB,EAAE,OAAO,CAAC,QAAQ,CAAC,CAAC;KAC/F;IAED,MAAM,gBAAgB,GAAG,2BAA2B,CAChD,QAAQ;IACR,iEAAiE;IACjE,IAAI,EAAE,WAAW;IACjB,aAAa,EACb,6BAA6B,EAC7B,sBAAsB,CACzB,CAAC;IAEF,OAAO,gBAAgB,CAAC;AAC5B,CAAC;AAED;;GAEG;AACI,SAAS,kCAAkC,CAC9C,OAA2C;IAE3C,MAAM,aAAa,GAAG,8BAA8B,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IAEnE,IAAI,aAAa,CAAC,IAAI,KAAK,UAAU,EAAE;QACnC,OAAO,0CAA0C,CAC7C,OAAO,CAAC,qBAAqB,EAC7B,OAAO,CAAC,sBAAsB,EAC9B,aAAa,CAAC,OAAO,CACxB,CAAC;KACL;IAED,OAAO;QACH,uCAAuC,CACnC,OAAO,CAAC,qBAAqB,EAC7B,OAAO,CAAC,sBAAsB,EAC9B,aAAa,CAAC,OAAO,CACxB;KACJ,CAAC;AACN,CAAC;AAED;;GAEG;AACI,SAAS,iBAAiB,CAAC,MAAc;IAC5C,OAAO;QACH,OAAO,EAAE;YACL,YAAY,EAAE;gBACV,8CAA8C;gBAC9C,WAAW,EAAE,IAAI;aACpB;SACJ;QAED,oDAAoD;QACpD,IAAI,EAAE,OAAO;QAEb,UAAU,EAAE,EAAE;QAEd,4CAA4C;QAC5C,MAAM,EAAE,CAAC,mFAAiB,EAAE,oFAAkB,CAAC;QAE/C,IAAI,EAAE;YACF,EAAE,EAAE,MAAM;SACb;KACJ,CAAC;AACN,CAAC;;;;;;;;;;;;;;;;;;;AC9SD;;GAEG;AACmC;AAaQ;AAEmC;AASjF;;GAEG;AACI,MAAM,iCACT,SAAQ,gDAAY;IA6DpB;;;;;;;OAOG;IACH,YACqB,OAAmC,EACpC,QAAgB,EACf,KAAY,EACb,QAAiB,EAChB,aAEmD,EACnD,eAKa;QAE9B,KAAK,EAAE,CAAC;QAdS,YAAO,GAAP,OAAO,CAA4B;QACpC,aAAQ,GAAR,QAAQ,CAAQ;QACf,UAAK,GAAL,KAAK,CAAO;QACb,aAAQ,GAAR,QAAQ,CAAS;QAChB,kBAAa,GAAb,aAAa,CAEsC;QACnD,oBAAe,GAAf,eAAe,CAKF;QA/ElC;;WAEG;QACa,mBAAc,GAAoB,EAAE,CAAC,CAAC,4DAA4D;QAElH;;WAEG;QACa,SAAI,GAAG,OAAO,CAAC,CAAC,mCAAmC;QAEnE;;WAEG;QACa,mBAAc,GAAG,MAAM,CAAC,gBAAgB,CAAC,CAAC,+FAA+F;QAEzJ;;WAEG;QACa,YAAO,GAAG,OAAO,CAAC,CAAC,gCAAgC;QAEnE;;WAEG;QACa,oBAAe,GAAgC,EAAE,CAAC,CAAC,mDAAmD;QAEtH;;WAEG;QACa,mBAAc,GAAqB,EAAE,CAAC,CAAC,mDAAmD;QAE1G;;WAEG;QACa,yBAAoB,GAAyB;YACzD,uCAAuC;YACvC,SAAS,EAAE,MAAM,CAAC,gBAAgB;YAClC,cAAc,EAAE,MAAM,CAAC,gBAAgB;YAEvC,kDAAkD;YAClD,OAAO,EAAE;gBACL,QAAQ,EAAE,MAAM,CAAC,gBAAgB;gBACjC,cAAc,EAAE,MAAM,CAAC,gBAAgB;gBACvC,MAAM,EAAE,MAAM,CAAC,gBAAgB;gBAC/B,OAAO,EAAE,MAAM,CAAC,gBAAgB;aACnC;SACJ,CAAC;QAOe,8BAAyB,GAA8D,EAAE,CAAC;QACnG,YAAO,GAAG,KAAK,CAAC;QAEhB,kBAAa,GAAG,IAAI,CAAC;QACrB,+BAA0B,GAAG,CAAC,CAAC,CAAC,0CAA0C;IA0BlF,CAAC;IAED;;OAEG;IACI,gBAAgB;QACnB,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;IAC/B,CAAC;IAED;;OAEG;IACI,gCAAgC;QACnC,IAAI,IAAI,CAAC,yBAAyB,CAAC,MAAM,KAAK,CAAC,EAAE;YAC7C,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;SACrD;QAED,MAAM,MAAM,GAAuC;YAC/C,KAAK,EAAE,IAAI,CAAC,yBAAyB,CAAC,MAAM;YAC5C,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC;gBACjB;oBACI,QAAQ,EAAE,IAAI,CAAC,yBAAyB;oBACxC,MAAM,EAAE,IAAI,CAAC,QAAQ;iBACxB;aACqC,CAAC;YAC3C,UAAU,EACN,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,yBAAyB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,uBAAuB;SACxG,CAAC;QAEF,mBAAmB;QACnB,IAAI,CAAC,yBAAyB,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,yBAAyB,CAAC,MAAM,CAAC,CAAC;QAEhF,OAAO,MAAM,CAAC;IAClB,CAAC;IAED;;OAEG;IACI,uBAAuB,CAAC,iBAAqD;QAChF,MAAM,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC,iBAAiB,CAAC,CAAC;QACtD,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,kEAAwB,EAAE,OAAO,CAAC,CAAC;IACvD,CAAC;IAED;;OAEG;IACH,IAAW,MAAM;QACb,OAAO;YACH,UAAU,EAAE,kEAAwB;YACpC,GAAG,EAAE,MAAM,CAAC,gBAAgB;YAC5B,GAAG,EAAE,MAAM,CAAC,gBAAgB;YAC5B,MAAM,EAAE,CAAC,mFAAiB,EAAE,oFAAkB,CAAC;YAC/C,QAAQ,EAAE,gEAAsB;YAChC,IAAI,EAAE,IAAI,CAAC,KAAK;YAChB,GAAG,EAAE,IAAI,CAAC,OAAO;SACpB,CAAC;IACN,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,QAA4B;QACtC,IAAI,IAAI,CAAC,OAAO,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;SACjD;QAED,kGAAkG;QAClG,cAAc,CAAC,GAAG,EAAE;YAChB,IAAI,IAAI,CAAC,OAAO,EAAE;gBACd,OAAO;aACV;YAED,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;gBAC5B,IAAI,IAAI,CAAC,aAAa,EAAE;oBACpB,2FAA2F;oBAC3F,4FAA4F;oBAC5F,2BAA2B;oBAC3B,IAAI,CAAC,yBAAyB,CAAC,IAAI,iCAC5B,OAAO,KACV,qBAAqB,EAAE,OAAO,CAAC,uBAAuB,IACxD,CAAC;iBACN;qBAAM;oBACH,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;iBAChD;aACJ;YAED,IAAI,IAAI,CAAC,aAAa,EAAE;gBACpB,4FAA4F;gBAC5F,MAAM,SAAS,GAAgC,EAAE,CAAC;gBAElD,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;oBAC5B,MAAM,gBAAgB,GAAG,IAAI,CAAC,eAAe,CACzC,IAAI,CAAC,QAAQ,EACb,OAAO,CAAC,uBAAuB,EAC/B,IAAI,CAAC,0BAA0B,EAC/B,OAAO,CACV,CAAC;oBAEF,IAAI,CAAC,0BAA0B,IAAI,CAAC,CAAC;oBAErC,SAAS,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;iBACpC;gBAED,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,kEAAwB,EAAE,SAAS,CAAC,CAAC;aACxD;YAED,2EAA2E;YAC3E,IAAI,CAAC,OAAO,CAAC,4BAA4B,EAAE,CAAC;QAChD,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;OAEG;IACH,wJAAwJ;IACjJ,YAAY,CAAC,QAAa;QAC7B,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC,CAAC;IAC3E,CAAC;IAED;;OAEG;IACI,KAAK;QACR,IAAI,IAAI,CAAC,OAAO,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;SACzD;QAED,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACpB,IAAI,CAAC,OAAO,CAAC,kBAAkB,EAAE,CAAC;IACtC,CAAC;CACJ;;;;;;;;;;;;;;;AC9OD;;GAEG;AACI,MAAM,qCAAqC;IAG9C;;;OAGG;IACH,YACI,MAAkC,EACjB,iBAEmD;QAFnD,sBAAiB,GAAjB,iBAAiB,CAEkC;QAEpE,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IAC1B,CAAC;IAED;;OAEG;IACI,GAAG,CAAC,IAAY,EAAE,EAAU;QAC/B,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACf,MAAM,IAAI,KAAK,CAAC,8EAA8E,CAAC,CAAC;SACnG;QAED,IAAI,IAAI,KAAK,CAAC,EAAE;YACZ,MAAM,IAAI,KAAK,CACX,iGAAiG,CACpG,CAAC;SACL;QAED,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,yBAAyB,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;QACjE,MAAM,QAAQ,GAAoE,EAAE,CAAC;QAErF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;YACxC,MAAM,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;YAC3B,MAAM,OAAO,GAAG,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;YAEhD,wEAAwE;YACxE,MAAM,gBAAgB,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,cAAc,GAAG,EAAE,CAAC,CAAC;YAEtE,QAAQ,CAAC,IAAI,CAAC,GAAG,gBAAgB,CAAC,CAAC;YAEnC,yFAAyF;YACzF,IAAI,gBAAgB,CAAC,MAAM,KAAK,OAAO,CAAC,MAAM,EAAE;gBAC5C,MAAM;aACT;SACJ;QAED,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC;QAEzB,OAAO,OAAO,CAAC,OAAO,CAAC;YACnB,QAAQ;YACR,aAAa,EAAE,KAAK;SACvB,CAAC,CAAC;IACP,CAAC;CACJ;;;;;;;;;;;;;;;;;;;;;;ACtDqH;AAEV;AACtC;AACC;AACF;AACoB;AAQzF;;;;;;;GAOG;AACI,MAAM,yBAAyB;IASlC,YACI,MAAkC,EAClB,WAAyB,EACzC,QAAgB,EACC,KAAY,EAC7B,QAAiB;QAHD,gBAAW,GAAX,WAAW,CAAc;QAExB,UAAK,GAAL,KAAK,CAAO;QARjC,qGAAqG;QACrG,4BAA4B;QACpB,eAAU,GAAG,KAAK,CAAC;QAqB3B;;WAEG;QACa,aAAQ,GAAG,SAAS,CAAC;QAfjC,IAAI,CAAC,QAAQ,GAAG,IAAI,8EAAgC,EAAE,CAAC;QACvD,IAAI,CAAC,aAAa,GAAG,IAAI,gFAAqC,CAAC,MAAM,EAAE,kFAAkC,CAAC,CAAC;QAC3G,IAAI,CAAC,gBAAgB,GAAG,IAAI,+EAAiC,CACzD,MAAM,EACN,QAAQ,EACR,KAAK,EACL,QAAQ,EACR,kFAAkC,EAClC,iFAAiC,CACpC,CAAC;IACN,CAAC;IAOD;;OAEG;IACI,gBAAgB;QACnB,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC1C,CAAC;IAED;;OAEG;IACI,qBAAqB;QACxB,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;IAC/C,CAAC;IAED;;OAEG;IACI,oBAAoB,CAAC,MAAe;QACvC,IAAI,IAAI,CAAC,UAAU,EAAE;YACjB,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAC;SAC9E;QAED,IACI,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,IAAI,CAAC,KAAK,CAAC,EAAE;YAChC,MAAM,CAAC,IAAI,KAAK,OAAO;YACvB,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,mFAAiB,CAAC,KAAK,CAAC,CAAC;YAC/C,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,oFAAkB,CAAC,KAAK,CAAC,CAAC;YAChD,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,wFAAsB,CAAC,KAAK,CAAC,CAAC,EACtD;YACE,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,CAAC;SACrC;QAED,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IAClD,CAAC;IAED;;OAEG;IACI,uBAAuB;QAC1B,2EAA2E;QAC3E,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;OAEG;IACI,gBAAgB;QACnB,IAAI,CAAC,gBAAgB,CAAC,gBAAgB,EAAE,CAAC;IAC7C,CAAC;IAED;;OAEG;IACI,gCAAgC;QACnC,OAAO,IAAI,CAAC,gBAAgB,CAAC,gCAAgC,EAAE,CAAC;IACpE,CAAC;IAED;;OAEG;IACI,uBAAuB,CAAC,iBAAqD;QAChF,IAAI,CAAC,gBAAgB,CAAC,uBAAuB,CAAC,iBAAiB,CAAC,CAAC;IACrE,CAAC;CACJ;AAED;;;;GAIG;AACI,MAAM,gCAAgC;IAWzC,YAAY,eAA0C;QAVtD;;WAEG;QACa,iBAAY,GAAG,yEAA+B,CAAC;QAQ3D,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC;IAC5C,CAAC;IAED;;OAEG;IACI,qBAAqB,CAAC,WAAyB,EAAE,OAA8B;QAClF,IAAI,CAAC,qEAAuB,CAAC,WAAW,CAAC,EAAE;YACvC,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC,CAAC;SAClE;QAED,IAAI,IAAI,CAAC,gBAAgB,KAAK,SAAS,EAAE;YACrC,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAC;SAC9E;QAED,MAAM,eAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC;QAC9C,IAAI,CAAC,gBAAgB,GAAG,SAAS,CAAC;QAElC,OAAO,OAAO,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;IAC5C,CAAC;IAED;;OAEG;IACI,eAAe,CAClB,iBAA+B,EAC/B,qBAAmC,EACnC,OAA8B;QAE9B,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;IACrD,CAAC;CACJ;;;;;;;;;;;;;;;ACxKD;;GAEG;AACI,MAAM,gCAAgC;IAA7C;QAYI;;WAEG;QACa,aAAQ,GAAG,SAAS,CAAC,CAAC,wEAAwE;IAoDlH,CAAC;IAlEW,UAAU;QACd,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;IAC/D,CAAC;IAED;;OAEG;IACH,IAAW,aAAa;QACpB,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;IAC7B,CAAC;IAOD;;OAEG;IACI,eAAe,CAAC,QAAmB;QACtC,2EAA2E;QAC3E,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IACjC,CAAC;IAED;;OAEG;IACI,WAAW,CAAC,UAAyB,EAAE,MAAc;QACxD,iEAAiE;QACjE,OAAO,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;IAC/B,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,KAAY,EAAE,QAAkB,EAAE,QAAgB,EAAE,IAAY;QACzE,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;IAC7B,CAAC;IAED;;OAEG;IACI,UAAU,CAAC,KAAsB;QACpC,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;IAC7B,CAAC;IAED;;OAEG;IACI,QAAQ,CAAC,GAAW;QACvB,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;IAC7B,CAAC;IAED;;OAEG;IACI,wBAAwB,CAAC,QAAsB,EAAE,QAAyB;QAC7E,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;IAC7B,CAAC;IAED;;OAEG;IACI,eAAe,CAAC,OAAuB;QAC1C,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;IAC7B,CAAC;CACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7EwD;AACd;AACI;AAES;AACwC;AAC1C;AAGtD,MAAM,aAAa,GAAsB;IACrC,MAAM,EAAE,EAAE;IACV,OAAO,EAAE,4EAA4B;CACxC,CAAC;AAmBF;;;;;;;GAOG;AACH,SAAe,aAAa,CACxB,YAA8B,EAC9B,QAAiB;;QAEjB,MAAM,MAAM,GAAG,qEAAiB,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;QACtD,MAAM,IAAI,GAAG;YACT,EAAE,EAAE,YAAY,CAAC,MAAM;SAC1B,CAAC;QAEF,MAAM,WAAW,GAAG,IAAI,+DAAqB,EAAE,CAAC;QAChD,MAAM,WAAW,GAAG,wBAAwB,CAAC;QAC7C,MAAM,mBAAmB,GAAG,MAAM,WAAW,CAAC,OAAO,CAAC,EAAE,GAAG,EAAE,WAAW,EAAE,CAAC,CAAC;QAE5E,MAAM,eAAe,GAAG,IAAI,uEAAyB,CACjD,YAAY,CAAC,MAAM,EACnB,mBAAmB,EACnB,YAAY,CAAC,QAAQ,EACrB,IAAI,EACJ,QAAQ,CACX,CAAC;QACF,MAAM,sBAAsB,GAAG,IAAI,8EAAgC,CAAC,eAAe,CAAC,CAAC;QAErF,IAAI,QAAQ,EAAE;YACV,mFAAmF;YACnF,eAAe,CAAC,gBAAgB,EAAE,CAAC;SACtC;QAED,MAAM,UAAU,GAAG,IAAI,mDAAc,CAAC,KAAK,CAAC,oBAAoB,CAAC,CAAC;QAClE,MAAM,MAAM,GAAG,UAAU,CAAC,SAAS,CAAC,WAAW,EAAE,sBAAsB,EAAE,MAAM,CAAC,CAAC;QAEjF,wGAAwG;QACxG,wCAAwC;QACxC,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC,EAAE,GAAG,EAAE,WAAW,EAAE,CAAC,CAAC;QAE7D,IAAI,6BAAkE,CAAC;QACvE,IAAI,6BAAyD,CAAC;QAE9D,MAAM,wBAAwB,GAAG,IAAI,OAAO,CAAoB,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE;YAC/E,6BAA6B,GAAG,MAAM,CAAC;YACvC,6BAA6B,GAAG,MAAM,CAAC;QAC3C,CAAC,CAAC,CAAC;QAEH,MAAM,MAAM,GAAG,CAAO,MAAc,EAAE,GAAW,EAAiB,EAAE;YAChE,MAAM,QAAQ,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC;YAE/C,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE;gBACzB,oHAAoH;gBACpH,OAAO;aACV;YAED,IAAI,QAAQ,CAAC,QAAQ,KAAK,cAAc,EAAE;gBACtC,MAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC,CAAC;aACzE;YAED,qHAAqH;YACrH,MAAM,iBAAiB,GAAG,QAAQ,CAAC,KAAK,CAAC;YACzC,IAAI,CAAC,iBAAiB,IAAI,CAAC,CAAC,iBAAiB,YAAY,iEAAiB,CAAC,EAAE;gBACzE,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;aAChD;YAED,6BAA6B,CAAC,iBAAiB,CAAC,CAAC;QACrD,CAAC,EAAC;QAEF,SAAS,CAAC,EAAE,CAAC,gBAAgB,EAAE,GAAG,EAAE;YAChC,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,6BAA6B,CAAC,CAAC,CAAC,CAAC,CAAC;QAC/E,CAAC,CAAC,CAAC;QACH,MAAM,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;QAElC,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE;YACtB,MAAM,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE,CAChC,SAAS,CAAC,EAAE,CAAC,WAAW,EAAE,GAAG,EAAE;gBAC3B,OAAO,EAAE,CAAC;YACd,CAAC,CAAC,CACL,CAAC;SACL;QAED,MAAM,MAAM,GAAG,SAAS,CAAC,SAAS,EAAE,CAAC;QACrC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;YACrB,MAAM,MAAM,CAAC,OAAO,CAAC,MAAM,EAAE,aAAa,CAAC,CAAC;SAC/C;QAED,MAAM,iBAAiB,GAAG,MAAM,wBAAwB,CAAC;QACzD,MAAM,YAAY,GAAG,IAAI,uDAAY,CAAC,iBAAiB,EAAE,GAAG,EAAE,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC;QAElF,OAAO,CAAC,YAAY,EAAE,eAAe,CAAC,CAAC;IAC3C,CAAC;CAAA;AAED;;;;;;GAMG;AACI,SAAe,wBAAwB,CAC1C,YAA8B;;QAE9B,OAAO,MAAM,aAAa,CAAC,YAAY,EAAE,KAAK,CAAC,YAAY,CAAC,CAAC;IACjE,CAAC;CAAA;AAED;;;;;;GAMG;AACI,SAAe,sBAAsB,CACxC,YAA8B;;QAE9B,OAAO,MAAM,aAAa,CAAC,YAAY,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;IAChE,CAAC;CAAA;;;;;;;;;;;;;;;;;;;ACtJD;;GAEG;AACI,MAAM,wBAAwB,GAAG,cAAc,CAAC;AAEvD;;GAEG;AACI,MAAM,sBAAsB,GAAG,sCAAsC,CAAC;AAE7E;;GAEG;AACI,MAAM,+BAA+B,GAAG,cAAc,CAAC;AAE9D;;;;;GAKG;AACI,SAAS,uBAAuB,CAAC,WAAyB;IAC7D,IAAI,WAAW,CAAC,IAAI,KAAK,OAAO,EAAE;QAC9B,OAAO,KAAK,CAAC;KAChB;IAED,OAAO,CACH,WAAW,CAAC,SAAS,CAAC,cAAc,CAAC,KAAK,KAAK;QAC/C,WAAW,CAAC,GAAG,KAAK,mBAAmB,sBAAsB,IAAI,wBAAwB,EAAE,CAC9F,CAAC;AACN,CAAC;AAED;;GAEG;AACI,MAAM,qBAAqB;IAC9B;;OAEG;IACI,OAAO,CAAC,OAAiB;QAC5B,IAAI,OAAO,CAAC,GAAG,KAAK,aAAa,wBAAwB,EAAE,EAAE;YACzD,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;SACtC;QAED,MAAM,QAAQ,GAAsB;YAChC,SAAS,EAAE;gBACP,cAAc,EAAE,KAAK;aACxB;YAED,gFAAgF;YAChF,MAAM,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE;YACnB,IAAI,EAAE,OAAO;YAEb,2GAA2G;YAC3G,+FAA+F;YAC/F,GAAG,EAAE,GAAG,+BAA+B,OAAO,sBAAsB,IAAI,wBAAwB,EAAE;SACrG,CAAC;QAEF,OAAO,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;IACrC,CAAC;IAED;;OAEG;IACI,cAAc,CAAC,YAA0B,EAAE,YAAoB;QAClE,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;IAC/D,CAAC;CACJ;;;;;;;;;;;;;;;AChED;;GAEG;AACI,MAAM,YAAY;IACrB,YAA4B,SAA4B,EAAkB,KAAiB;QAA/D,cAAS,GAAT,SAAS,CAAmB;QAAkB,UAAK,GAAL,KAAK,CAAY;IAAG,CAAC;IAE/F,IAAW,KAAK;QACZ,OAAO,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC;IACxC,CAAC;IAED;;OAEG;IACI,OAAO;QACV,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC;IACjC,CAAC;IAED;;OAEG;IACI,WAAW;QACd,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC;IAClC,CAAC;IAED;;OAEG;IACI,YAAY;QACf,OAAO,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC;IACnC,CAAC;IAED;;OAEG;IACI,kBAAkB;QACrB,OAAO,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC;IACzC,CAAC;IAED;;OAEG;IACI,gBAAgB;QACnB,OAAO,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC;IACvC,CAAC;IAED;;OAEG;IACI,OAAO;QACV,OAAO,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC;IACpC,CAAC;CACJ;;;;;;;;;;;;;;;;ACxD6G;AAKtE;AAyBxC,MAAM,OAAO;IACF,6BAA6B,CAChC,UAAkB,EAClB,OAAmC;QAEnC,IAAI,KAAwC,EAAE,EAE7C;QACD,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;IACtD,CAAC;IAEM,2BAA2B,CAAC,UAAkB,EAAE,OAAmC;QACtF,IAAI,KAAwC,EAAE,EAE7C;QACD,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;IACtD,CAAC;IAEM,mBAAmB,CAAC,YAA8B;QACrD,IAAI,IAAuC,EAAE;YACzC,OAAO,iFAAwB,CAAC,YAAY,CAAC,CAAC;SACjD;QACD,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;IACrD,CAAC;IAEM,iBAAiB,CAAC,YAA8B;QACnD,IAAI,IAAuC,EAAE;YACzC,OAAO,+EAAsB,CAAC,YAAY,CAAC,CAAC;SAC/C;QACD,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;IACrD,CAAC;CACJ;AAED;;;;GAIG;AACI,SAAS,WAAW;IACvB,OAAO,IAAI,OAAO,EAAE,CAAC;AACzB,CAAC;;;;;;;;;;;;AC1ED;AACA,CAAC;;AAED;AACA,mBAAmB,KAA0B;AAC7C;AACA,kBAAkB,KAAyB;AAC3C;AACA,kBAAkB,KAAyB,IAAI,IAAM;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,SAAS;AACrB;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,KAAK;AACL,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;;AAExB,yCAAyC,qBAAqB;;AAE9D;AACA;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;;AAEtD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,iBAAiB;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE,IAEU;AACZ;AACA,EAAE,mCAAmB;AACrB;AACA,GAAG;AAAA,kGAAC;AACJ,EAAE,MAAM,EAUN;;AAEF,CAAC;;;;;;;;;;;;;ACjhBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,0EAAU;AACjC,WAAW,mBAAO,CAAC,8CAAQ;;AAE3B,aAAa;AACb,yBAAe;AACf,yBAAqB;AACrB,yBAAc;;AAEd,yBAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,KAAK;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,2CAA2C,KAAK;AAChD,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,mBAAO,CAAC,4DAAa;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,MAAM;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3tBa;;AAEb;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;;;ACfA,iEAAe,cAAc,EAAE,UAAU,EAAE,eAAe,EAAE,gBAAgB,EAAE,UAAU,GAAG,yCAAyC,E;;;;;;;;;;;;;;;ACA/F;AACrC;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA,ygBAAygB;AACzgB;AACA;AACA;AACA;;AAEA,OAAO,qDAAQ;AACf;AACA;;AAEA;AACA;;AAEA,iEAAe,SAAS,E;;;;;;;;;;;;;;;;AC7BG;AACY;;AAEvC;AACA;AACA,+CAA+C,4CAAG,IAAI;;AAEtD;AACA,kCAAkC;;AAElC;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;;AAEA,SAAS,sDAAS;AAClB;;AAEA,iEAAe,EAAE,E;;;;;;;;;;;;;;;ACvBc;;AAE/B;AACA,qCAAqC,mDAAU;AAC/C;;AAEA,iEAAe,QAAQ,E;;;;;;;;;;;;;;;;ACNV;;AAEN;AACP;;AAEA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;;AAEA;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;;;ACrCa;;AAEb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;UCtBA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCzBA;WACA;WACA;WACA;WACA;WACA,gCAAgC,YAAY;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;WCNA;WACA;WACA;WACA;WACA,E;;;;;;;;;;;;ACJA;;GAEG;AACqC;AAExC,uHAAuH;AACvH,IAAI,KAA2C,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE;IAC3E,MAAM,gBAAgB,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC;IAE3C,6DAA6D;IAC7D,SAAS,wBAAwB,CAAC,EAAc;QAC5C,oEAAoE;QACpE,gBAAgB,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;IACjC,CAAC;IAED,UAAU,CAAC,cAAc,GAAG,wBAAwB,CAAC;CACxD;AAED;;;;GAIG;AACH,SAAS,IAAI;IACT,kBAAkB,CAAC,qDAAW,EAAE,CAAC,CAAC;AACtC,CAAC;AAED,IAAI,EAAE,CAAC","file":"bundleWord.ocsOnly.js","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { EventEmitter } from \"events\";\nimport { assert } from \"@fluidframework/common-utils\";\nimport { FluidDataStoreRuntime } from \"@fluidframework/datastore\";\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { SharedMap } from \"@fluidframework/map\";\nimport { ConsensusRegisterCollection } from \"@fluidframework/register-collection\";\nimport debug from \"debug\";\nimport { v4 as uuid } from \"uuid\";\n// Note: making sure this ID is unique and does not collide with storage provided clientID\nconst UnattachedClientId = `${uuid()}_unattached`;\nclass AgentScheduler extends EventEmitter {\n    constructor(runtime, context, consensusRegisterCollection) {\n        super();\n        this.runtime = runtime;\n        this.context = context;\n        this.consensusRegisterCollection = consensusRegisterCollection;\n        // Set of tasks registered by this client.\n        // Has no relationship with lists below.\n        // The only requirement here - a task can be registered by a client only once.\n        // Other clients can pick these tasks.\n        this.registeredTasks = new Set();\n        // List of all tasks client is capable of running (essentially expressed desire to run)\n        // Client will proactively attempt to pick them up these tasks if they are not assigned to other clients.\n        // This is a strict superset of tasks running in the client.\n        this.locallyRunnableTasks = new Map();\n        // Set of registered tasks client is currently running.\n        // It's subset of this.locallyRunnableTasks\n        this.runningTasks = new Set();\n    }\n    static async load(runtime, context) {\n        let root;\n        let consensusRegisterCollection;\n        if (!runtime.existing) {\n            root = SharedMap.create(runtime, \"root\");\n            root.bindToContext();\n            consensusRegisterCollection = ConsensusRegisterCollection.create(runtime);\n            consensusRegisterCollection.bindToContext();\n            root.set(\"scheduler\", consensusRegisterCollection.handle);\n        }\n        else {\n            root = await runtime.getChannel(\"root\");\n            const handle = await root.wait(\"scheduler\");\n            assert(handle !== undefined, 0x116 /* \"Missing handle on scheduler load\" */);\n            consensusRegisterCollection = await handle.get();\n        }\n        const agentScheduler = new AgentScheduler(runtime, context, consensusRegisterCollection);\n        agentScheduler.initialize();\n        return agentScheduler;\n    }\n    get IAgentScheduler() { return this; }\n    get clientId() {\n        if (this.runtime.attachState === AttachState.Detached) {\n            return UnattachedClientId;\n        }\n        const clientId = this.runtime.clientId;\n        assert(!!clientId, 0x117 /* \"Trying to get missing clientId!\" */);\n        return clientId;\n    }\n    async register(...taskUrls) {\n        for (const taskUrl of taskUrls) {\n            if (this.registeredTasks.has(taskUrl)) {\n                throw new Error(`${taskUrl} is already registered`);\n            }\n        }\n        const unregisteredTasks = [];\n        for (const taskUrl of taskUrls) {\n            this.registeredTasks.add(taskUrl);\n            // Only register for a new task.\n            const currentClient = this.getTaskClientId(taskUrl);\n            if (currentClient === undefined) {\n                unregisteredTasks.push(taskUrl);\n            }\n        }\n        return this.registerCore(unregisteredTasks);\n    }\n    async pick(taskId, worker) {\n        if (this.locallyRunnableTasks.has(taskId)) {\n            throw new Error(`${taskId} is already attempted`);\n        }\n        this.locallyRunnableTasks.set(taskId, worker);\n        // Note: we are not checking for this.context.deltaManager.clientDetails.capabilities.interactive\n        // in isActive(). This check is done by users of this class - containerRuntime.ts (for \"leader\") and\n        // TaskManager. In the future, as new usage shows up, we may need to reconsider that.\n        // I'm adding assert here to catch that case and make decision on which way we go - push requirements\n        // to consumers to make a choice, or centrally make this call here.\n        assert(this.context.deltaManager.clientDetails.capabilities.interactive, 0x118 /* \"Bad client interactive check\" */);\n        // Check the current status and express interest if it's a new one (undefined) or currently unpicked (null).\n        if (this.isActive()) {\n            const currentClient = this.getTaskClientId(taskId);\n            if (currentClient === undefined || currentClient === null) {\n                debug(`Requesting ${taskId}`);\n                await this.writeCore(taskId, this.clientId);\n            }\n        }\n    }\n    async release(...taskUrls) {\n        const active = this.isActive();\n        for (const taskUrl of taskUrls) {\n            if (!this.locallyRunnableTasks.has(taskUrl)) {\n                throw new Error(`${taskUrl} was never registered`);\n            }\n            // Note - the assumption is - we are connected.\n            // If not - all tasks should have been dropped already on disconnect / attachment\n            assert(active, 0x119 /* \"This agent became inactive while releasing\" */);\n            if (this.getTaskClientId(taskUrl) !== this.clientId) {\n                throw new Error(`${taskUrl} was never picked`);\n            }\n        }\n        return this.releaseCore([...taskUrls]);\n    }\n    pickedTasks() {\n        return Array.from(this.runningTasks.values());\n    }\n    async registerCore(taskUrls) {\n        if (taskUrls.length > 0) {\n            const registersP = [];\n            for (const taskUrl of taskUrls) {\n                debug(`Registering ${taskUrl}`);\n                registersP.push(this.writeCore(taskUrl, null));\n            }\n            await Promise.all(registersP);\n            // The registers should have up to date results now. Check the status.\n            for (const taskUrl of taskUrls) {\n                const taskStatus = this.getTaskClientId(taskUrl);\n                // Task should be either registered (null) or picked up.\n                assert(taskStatus !== undefined, 0x11a /* `Unsuccessful registration` */);\n                if (taskStatus === null) {\n                    debug(`Registered ${taskUrl}`);\n                }\n                else {\n                    debug(`${taskStatus} is running ${taskUrl}`);\n                }\n            }\n        }\n    }\n    async releaseCore(taskUrls) {\n        if (taskUrls.length > 0) {\n            const releasesP = [];\n            for (const taskUrl of taskUrls) {\n                debug(`Releasing ${taskUrl}`);\n                // Remove from local map so that it can be picked later.\n                this.locallyRunnableTasks.delete(taskUrl);\n                releasesP.push(this.writeCore(taskUrl, null));\n            }\n            await Promise.all(releasesP);\n        }\n    }\n    async clearTasks(taskUrls) {\n        assert(this.isActive(), 0x11b /* \"Trying to clear tasks on inactive agent\" */);\n        const clearP = [];\n        for (const taskUrl of taskUrls) {\n            debug(`Clearing ${taskUrl}`);\n            clearP.push(this.writeCore(taskUrl, null));\n        }\n        await Promise.all(clearP);\n    }\n    getTaskClientId(url) {\n        return this.consensusRegisterCollection.read(url);\n    }\n    async writeCore(key, clientId) {\n        await this.consensusRegisterCollection.write(key, clientId);\n    }\n    initialize() {\n        const quorum = this.runtime.getQuorum();\n        // A client left the quorum. Iterate and clear tasks held by that client.\n        // Ideally a leader should do this cleanup. But it's complicated when a leader itself leaves.\n        // Probably okay for now to have every client try to do this.\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        quorum.on(\"removeMember\", async (clientId) => {\n            assert(this.runtime.objectsRoutingContext.isAttached, 0x11c /* \"Detached object routing context\" */);\n            // Cleanup only if connected. If not, cleanup will happen in initializeCore() that runs on connection.\n            if (this.isActive()) {\n                const leftTasks = [];\n                for (const taskUrl of this.consensusRegisterCollection.keys()) {\n                    if (this.getTaskClientId(taskUrl) === clientId) {\n                        leftTasks.push(taskUrl);\n                    }\n                }\n                await this.clearTasks(leftTasks);\n            }\n        });\n        // Listeners for new/released tasks. All clients will try to grab at the same time.\n        // May be we want a randomized timer (Something like raft) to reduce chattiness?\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        this.consensusRegisterCollection.on(\"atomicChanged\", async (key, currentClient) => {\n            // Check if this client was chosen.\n            if (this.isActive() && currentClient === this.clientId) {\n                this.onNewTaskAssigned(key);\n            }\n            else {\n                await this.onTaskReassigned(key, currentClient);\n            }\n        });\n        if (this.isActive()) {\n            this.initializeCore();\n        }\n        this.runtime.on(\"connected\", () => {\n            if (this.isActive()) {\n                this.initializeCore();\n            }\n        });\n        if (this.runtime.attachState === AttachState.Detached) {\n            this.runtime.waitAttached().then(() => {\n                this.clearRunningTasks();\n            }).catch((error) => {\n                this.sendErrorEvent(\"AgentScheduler_clearRunningTasks\", error);\n            });\n        }\n        this.runtime.on(\"disconnected\", () => {\n            if (this.runtime.attachState !== AttachState.Detached) {\n                this.clearRunningTasks();\n            }\n        });\n    }\n    onNewTaskAssigned(key) {\n        assert(!this.runningTasks.has(key), 0x11d /* \"task is already running\" */);\n        this.runningTasks.add(key);\n        const worker = this.locallyRunnableTasks.get(key);\n        if (worker === undefined) {\n            this.sendErrorEvent(\"AgentScheduler_UnwantedChange\", undefined, key);\n        }\n        else {\n            this.emit(\"picked\", key);\n            worker().catch((error) => {\n                this.sendErrorEvent(\"AgentScheduler_FailedWork\", error, key);\n            });\n        }\n    }\n    async onTaskReassigned(key, currentClient) {\n        if (this.runningTasks.has(key)) {\n            this.runningTasks.delete(key);\n            this.emit(\"released\", key);\n        }\n        assert(currentClient !== undefined, 0x11e /* \"client is undefined\" */);\n        if (this.isActive()) {\n            // attempt to pick up task if we are connected.\n            // If not, initializeCore() will do it when connected\n            if (currentClient === null) {\n                if (this.locallyRunnableTasks.has(key)) {\n                    debug(`Requesting ${key}`);\n                    await this.writeCore(key, this.clientId);\n                }\n            }\n            // Check if the op came from dropped client\n            // This could happen when \"old\" ops are submitted on reconnection.\n            // They carry \"old\" ref seq number, but if write is not contested, it will get accepted\n            else if (this.runtime.getQuorum().getMember(currentClient) === undefined) {\n                await this.writeCore(key, null);\n            }\n        }\n    }\n    isActive() {\n        // Scheduler should be active in detached container.\n        if (this.runtime.attachState === AttachState.Detached) {\n            return true;\n        }\n        if (!this.runtime.connected) {\n            return false;\n        }\n        // Note: we are not checking for this.context.deltaManager.clientDetails.capabilities.interactive\n        // here. This is done by users of this class - containerRuntime.ts (for \"leader\") and TaskManager.\n        // In the future, as new usage shows up, we may need to reconsider that.\n        // I'm adding assert in pick() to catch that case and make decision on which way we go - push requirements\n        // to consumers to make a choice, or centrally make this call here.\n        return this.context.deltaManager.active;\n    }\n    initializeCore() {\n        // Nobody released the tasks held by last client in previous session.\n        // Check to see if this client needs to do this.\n        const clearCandidates = [];\n        const tasks = [];\n        for (const [taskUrl] of this.locallyRunnableTasks) {\n            if (!this.getTaskClientId(taskUrl)) {\n                debug(`Requesting ${taskUrl}`);\n                tasks.push(this.writeCore(taskUrl, this.clientId));\n            }\n        }\n        for (const taskUrl of this.consensusRegisterCollection.keys()) {\n            const currentClient = this.getTaskClientId(taskUrl);\n            if (currentClient && this.runtime.getQuorum().getMember(currentClient) === undefined) {\n                clearCandidates.push(taskUrl);\n            }\n        }\n        tasks.push(this.clearTasks(clearCandidates));\n        Promise.all(tasks).catch((error) => {\n            this.sendErrorEvent(\"AgentScheduler_InitError\", error);\n        });\n    }\n    clearRunningTasks() {\n        const tasks = this.runningTasks;\n        this.runningTasks = new Set();\n        if (this.isActive()) {\n            // Clear all tasks with UnattachedClientId (if was unattached) and reapply for tasks with new clientId\n            // If we are simply disconnected, then proper cleanup will be done on connection.\n            this.initializeCore();\n        }\n        for (const task of tasks) {\n            this.emit(\"lost\", task);\n        }\n    }\n    sendErrorEvent(eventName, error, key) {\n        this.runtime.logger.sendErrorEvent({ eventName, key }, error);\n    }\n}\nclass AgentSchedulerRuntime extends FluidDataStoreRuntime {\n    constructor(dataStoreContext, sharedObjectRegistry) {\n        super(dataStoreContext, sharedObjectRegistry);\n        this.agentSchedulerP = AgentScheduler.load(this, dataStoreContext);\n    }\n    async request(request) {\n        const response = await super.request(request);\n        if (response.status === 404) {\n            if (request.url === \"\" || request.url === \"/\") {\n                const agentScheduler = await this.agentSchedulerP;\n                return { status: 200, mimeType: \"fluid/object\", value: agentScheduler };\n            }\n        }\n        return response;\n    }\n}\nexport class AgentSchedulerFactory {\n    constructor() {\n        this.type = AgentSchedulerFactory.type;\n    }\n    get IFluidDataStoreFactory() { return this; }\n    static get registryEntry() {\n        return [this.type, Promise.resolve(new AgentSchedulerFactory())];\n    }\n    async instantiateDataStore(context) {\n        const mapFactory = SharedMap.getFactory();\n        const consensusRegisterCollectionFactory = ConsensusRegisterCollection.getFactory();\n        const dataTypes = new Map();\n        dataTypes.set(mapFactory.type, mapFactory);\n        dataTypes.set(consensusRegisterCollectionFactory.type, consensusRegisterCollectionFactory);\n        return new AgentSchedulerRuntime(context, dataTypes);\n    }\n}\nAgentSchedulerFactory.type = \"_scheduler\";\n//# sourceMappingURL=scheduler.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { FluidDataStoreRegistry, ContainerRuntime, } from \"@fluidframework/container-runtime\";\nimport { IContainerRuntime, } from \"@fluidframework/container-runtime-definitions\";\nimport { buildRuntimeRequestHandler, innerRequestHandler, } from \"@fluidframework/request-handler\";\nimport { DependencyContainer } from \"@fluidframework/synthesize\";\n/**\n * BaseContainerRuntimeFactory produces container runtimes with a given data store and service registry, as well as\n * given request handlers.  It can be subclassed to implement a first-time initialization procedure for the containers\n * it creates.\n */\nexport class BaseContainerRuntimeFactory {\n    /**\n     * @param registryEntries - The data store registry for containers produced\n     * @param serviceRegistry - The service registry for containers produced\n     * @param requestHandlers - Request handlers for containers produced\n     * @param runtimeOptions - The runtime options passed to the ContainerRuntime when instantiating it\n     */\n    constructor(registryEntries, providerEntries = [], requestHandlers = [], runtimeOptions) {\n        this.registryEntries = registryEntries;\n        this.providerEntries = providerEntries;\n        this.requestHandlers = requestHandlers;\n        this.runtimeOptions = runtimeOptions;\n        this.registry = new FluidDataStoreRegistry(registryEntries);\n    }\n    get IFluidDataStoreRegistry() { return this.registry; }\n    get IRuntimeFactory() { return this; }\n    /**\n     * {@inheritDoc @fluidframework/container-definitions#IRuntimeFactory.instantiateRuntime}\n     */\n    async instantiateRuntime(context) {\n        const parentDependencyContainer = context.scope.IFluidDependencySynthesizer;\n        const dc = new DependencyContainer(parentDependencyContainer);\n        for (const entry of Array.from(this.providerEntries)) {\n            dc.register(entry.type, entry.provider);\n        }\n        // Create a scope object that passes through everything except for IFluidDependencySynthesizer\n        // which we will replace with the new one we just created.\n        const scope = context.scope;\n        scope.IFluidDependencySynthesizer = dc;\n        const runtime = await ContainerRuntime.load(context, this.registryEntries, buildRuntimeRequestHandler(...this.requestHandlers, innerRequestHandler), this.runtimeOptions, scope);\n        // we register the runtime so developers of providers can use it in the factory pattern.\n        dc.register(IContainerRuntime, runtime);\n        if (!runtime.existing) {\n            // If it's the first time through.\n            await this.containerInitializingFirstTime(runtime);\n        }\n        // This always gets called at the end of initialize on first time or from existing.\n        await this.containerHasInitialized(runtime);\n        return runtime;\n    }\n    /**\n     * Subclasses may override containerInitializingFirstTime to perform any setup steps at the time the container\n     * is created. This likely includes creating any initial data stores that are expected to be there at the outset.\n     * @param runtime - The container runtime for the container being initialized\n     */\n    async containerInitializingFirstTime(runtime) { }\n    /**\n     * Subclasses may override containerHasInitialized to perform any steps after the container has initialized.\n     * This likely includes loading any data stores that are expected to be there at the outset.\n     * @param runtime - The container runtime for the container being initialized\n     */\n    async containerHasInitialized(runtime) { }\n}\n//# sourceMappingURL=baseContainerRuntimeFactory.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { innerRequestHandler, } from \"@fluidframework/request-handler\";\nimport { defaultRouteRequestHandler } from \"../request-handlers\";\nimport { BaseContainerRuntimeFactory } from \"./baseContainerRuntimeFactory\";\nconst defaultDataStoreId = \"default\";\n/**\n * A ContainerRuntimeFactory that initializes Containers with a single default data store, which can be requested from\n * the container with an empty URL.\n *\n * This factory should be exposed as fluidExport off the entry point to your module.\n */\nexport class ContainerRuntimeFactoryWithDefaultDataStore extends BaseContainerRuntimeFactory {\n    constructor(defaultFactory, registryEntries, providerEntries = [], requestHandlers = [], runtimeOptions) {\n        super(registryEntries, providerEntries, [\n            ...requestHandlers,\n            defaultRouteRequestHandler(defaultDataStoreId),\n            innerRequestHandler,\n        ], runtimeOptions);\n        this.defaultFactory = defaultFactory;\n    }\n    /**\n     * {@inheritDoc BaseContainerRuntimeFactory.containerInitializingFirstTime}\n     */\n    async containerInitializingFirstTime(runtime) {\n        await runtime.createRootDataStore(this.defaultFactory.type, defaultDataStoreId);\n    }\n}\nContainerRuntimeFactoryWithDefaultDataStore.defaultDataStoreId = defaultDataStoreId;\n//# sourceMappingURL=containerRuntimeFactoryWithDefaultDataStore.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { create404Response, createResponseError, } from \"@fluidframework/runtime-utils\";\n// TODO: should this just be \"s\"?\nexport const serviceRoutePathRoot = \"_services\";\n/**\n * This class is a simple starter class for building a Container Service. It simply provides routing\n */\nexport class BaseContainerService {\n    constructor(runtime) {\n        this.runtime = runtime;\n    }\n    get IFluidRouter() { return this; }\n    async request(request) {\n        return {\n            status: 200,\n            mimeType: \"fluid/object\",\n            value: this,\n        };\n    }\n}\n/**\n * ContainerService Factory that will only create one instance of the service for the Container.\n */\nclass SingletonContainerServiceFactory {\n    constructor(serviceFn) {\n        this.serviceFn = serviceFn;\n    }\n    async getService(runtime) {\n        if (!this.service) {\n            this.service = this.serviceFn(runtime);\n        }\n        return this.service;\n    }\n}\n/**\n * Given a collection of IContainerServices will produce a RequestHandler for them all\n * @param serviceRegistry - Collection of Container Services\n */\nexport const generateContainerServicesRequestHandler = (serviceRegistry) => {\n    const factories = new Map();\n    new Map(serviceRegistry).forEach((fn, id) => {\n        factories.set(id, new SingletonContainerServiceFactory(fn));\n    });\n    return async (request, runtime) => {\n        if (request.pathParts[0] !== serviceRoutePathRoot) {\n            // If the request is not for a service we return undefined so the next handler can use it\n            return undefined;\n        }\n        if (request.pathParts.length < 2) {\n            // If there is not service to route to then return a failure\n            return createResponseError(400, \"request did not specify a service to route to\", request);\n        }\n        const factory = factories.get(request.pathParts[1]);\n        if (!factory) {\n            // If we can't find a registry entry then return\n            return create404Response(request);\n        }\n        const service = await factory.getService(runtime);\n        const router = service.IFluidRouter;\n        const subRequest = request.createSubRequest(2);\n        if (router) {\n            return router.request(subRequest);\n        }\n        if (!request.isLeaf(2)) {\n            // If there is not terminating route but a sub-route was requested then we will fail.\n            return createResponseError(400, \"request sub-url for service that doesn't support routing\", request);\n        }\n        // Otherwise we will just return the service\n        return {\n            status: 200,\n            mimeType: \"fluid/object\",\n            value: service,\n        };\n    };\n};\n//# sourceMappingURL=containerServices.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { DirectoryFactory, MapFactory, SharedDirectory, SharedMap, } from \"@fluidframework/map\";\nimport { FluidDataStoreRuntime } from \"@fluidframework/datastore\";\nimport { PureDataObjectFactory } from \"./pureDataObjectFactory\";\n/**\n * DataObjectFactory is the IFluidDataStoreFactory for use with DataObjects.\n * It facilitates DataObject's features (such as its shared directory) by\n * ensuring relevant shared objects etc are available to the factory.\n *\n * Generics:\n * O - represents a type that will define optional providers that will be injected\n * S - the initial state type that the produced data object may take during creation\n */\nexport class DataObjectFactory extends PureDataObjectFactory {\n    constructor(type, ctor, sharedObjects = [], optionalProviders, registryEntries, runtimeFactory = FluidDataStoreRuntime) {\n        const mergedObjects = [...sharedObjects];\n        if (!sharedObjects.find((factory) => factory.type === DirectoryFactory.Type)) {\n            // User did not register for directory\n            mergedObjects.push(SharedDirectory.getFactory());\n        }\n        // TODO: Remove SharedMap factory when compatibility with SharedMap DataObject is no longer needed in 0.10\n        if (!sharedObjects.find((factory) => factory.type === MapFactory.Type)) {\n            // User did not register for map\n            mergedObjects.push(SharedMap.getFactory());\n        }\n        super(type, ctor, mergedObjects, optionalProviders, registryEntries, runtimeFactory);\n    }\n}\n//# sourceMappingURL=dataObjectFactory.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { FluidDataStoreRuntime, mixinRequestHandler, } from \"@fluidframework/datastore\";\nimport { FluidDataStoreRegistry } from \"@fluidframework/container-runtime\";\nimport { DependencyContainer, } from \"@fluidframework/synthesize\";\nimport { PureDataObject, } from \"../data-objects\";\n/**\n * Proxy over PureDataObject\n * Does delayed creation & initialization of PureDataObject\n*/\nasync function createDataObject(ctor, context, sharedObjectRegistry, optionalProviders, runtimeClassArg, initProps) {\n    // base\n    let runtimeClass = runtimeClassArg;\n    // request mixin in\n    runtimeClass = mixinRequestHandler(async (request, runtimeArg) => (await PureDataObject.getDataObject(runtimeArg)).request(request), runtimeClass);\n    // Create a new runtime for our data store\n    // The runtime is what Fluid uses to create DDS' and route to your data store\n    const runtime = new runtimeClass(context, sharedObjectRegistry);\n    // Create object right away.\n    // This allows object to register various callbacks with runtime before runtime\n    // becomes globally available. But it's not full initialization - constructor can't\n    // access DDSs or other services of runtime as objects are not fully initialized.\n    // In order to use object, we need to go through full initialization by calling finishInitialization().\n    const dependencyContainer = new DependencyContainer(context.scope.IFluidDependencySynthesizer);\n    const providers = dependencyContainer.synthesize(optionalProviders, {});\n    const instance = new ctor({ runtime, context, providers, initProps });\n    // if it's a newly created object, we need to wait for it to finish initialization\n    // as that results in creation of DDSs, before it gets attached, providing atomic\n    // guarantee of creation.\n    // WARNING: we can't do the same (yet) for already existing PureDataObject!\n    // This will result in deadlock, as it tries to resolve internal handles, but any\n    // handle resolution goes through root (container runtime), which can't route it back\n    // to this data store, as it's still not initialized and not known to container runtime yet.\n    // In the future, we should address it by using relative paths for handles and be able to resolve\n    // local DDSs while data store is not fully initialized.\n    if (!runtime.existing) {\n        await instance.finishInitialization();\n    }\n    return { instance, runtime };\n}\n/**\n * PureDataObjectFactory is a barebones IFluidDataStoreFactory for use with PureDataObject.\n * Consumers should typically use DataObjectFactory instead unless creating\n * another base data store factory.\n *\n * Generics:\n * TObj - DataObject (concrete type)\n * O - represents a type that will define optional providers that will be injected\n * S - the initial state type that the produced data store may take during creation\n * E - represents events that will be available in the EventForwarder\n */\nexport class PureDataObjectFactory {\n    constructor(type, ctor, sharedObjects, optionalProviders, registryEntries, runtimeClass = FluidDataStoreRuntime) {\n        this.type = type;\n        this.ctor = ctor;\n        this.optionalProviders = optionalProviders;\n        this.runtimeClass = runtimeClass;\n        if (this.type === \"\") {\n            throw new Error(\"undefined type member\");\n        }\n        if (registryEntries !== undefined) {\n            this.registry = new FluidDataStoreRegistry(registryEntries);\n        }\n        this.sharedObjectRegistry = new Map(sharedObjects.map((ext) => [ext.type, ext]));\n    }\n    get IFluidDataStoreFactory() { return this; }\n    get IFluidDataStoreRegistry() {\n        return this.registry;\n    }\n    /**\n     * Convenience helper to get the data store's/factory's data store registry entry.\n     * The return type hides the factory's generics, easing grouping of registry\n     * entries that differ only in this way into the same array.\n     * @returns The NamedFluidDataStoreRegistryEntry\n     */\n    get registryEntry() {\n        return [this.type, Promise.resolve(this)];\n    }\n    /**\n     * This is where we do data store setup.\n     *\n     * @param context - data store context used to load a data store runtime\n     */\n    async instantiateDataStore(context) {\n        const { runtime } = await createDataObject(this.ctor, context, this.sharedObjectRegistry, this.optionalProviders, this.runtimeClass);\n        return runtime;\n    }\n    /**\n     * Creates a new instance of the object. Uses parent context's registry to build package path to this factory.\n     * In other words, registry of context passed in has to contain this factory, with the name that matches\n     * this factory's type.\n     * It is intended to be used by data store objects that create sub-objects.\n     * @param context - The context being used to create the runtime\n     * (the created object will have its own new context created as well)\n     * @param initialState - The initial state to provide to the created data store.\n     * @returns an object created by this factory. Data store and objects created are not attached to container.\n     * They get attached only when a handle to one of them is attached to already attached objects.\n     */\n    async createChildInstance(parentContext, initialState) {\n        return this.createNonRootInstanceCore(parentContext.containerRuntime, [...parentContext.packagePath, this.type], initialState);\n    }\n    /**\n     * Creates a new instance of the object. Uses peer context's registry and its package path to identify this factory.\n     * In other words, registry of context passed in has to have this factory.\n     * Intended to be used by data store objects that need to create peers (similar) instances of existing objects.\n     * @param context - The component context being used to create the object\n     * (the created object will have its own new context created as well)\n     * @param initialState - The initial state to provide to the created component.\n     * @returns an object created by this factory. Data store and objects created are not attached to container.\n     * They get attached only when a handle to one of them is attached to already attached objects.\n     */\n    async createPeerInstance(peerContext, initialState) {\n        return this.createNonRootInstanceCore(peerContext.containerRuntime, peerContext.packagePath, initialState);\n    }\n    /**\n     * Creates a new instance of the object. Uses container's registry to find this factory.\n     * It's expected that only container owners would use this functionality, as only such developers\n     * have knowledge of entries in container registry.\n     * The name in this registry for such record should match type of this factory.\n     * @param runtime - container runtime. It's registry is used to create an object.\n     * @param initialState - The initial state to provide to the created component.\n     * @returns an object created by this factory. Data store and objects created are not attached to container.\n     * They get attached only when a handle to one of them is attached to already attached objects.\n     */\n    async createInstance(runtime, initialState) {\n        return this.createNonRootInstanceCore(runtime, [this.type], initialState);\n    }\n    /**\n     * Creates a new root instance of the object. Uses container's registry to find this factory.\n     * It's expected that only container owners would use this functionality, as only such developers\n     * have knowledge of entries in container registry.\n     * The name in this registry for such record should match type of this factory.\n     * @param runtime - container runtime. It's registry is used to create an object.\n     * @param initialState - The initial state to provide to the created component.\n     * @returns an object created by this factory. Data store and objects created are not attached to container.\n     * They get attached only when a handle to one of them is attached to already attached objects.\n     */\n    async createRootInstance(rootDataStoreId, runtime, initialState) {\n        const context = runtime.createDetachedRootDataStore([this.type], rootDataStoreId);\n        return this.createInstanceCore(context, initialState);\n    }\n    async createNonRootInstanceCore(containerRuntime, packagePath, initialState) {\n        const context = containerRuntime.createDetachedDataStore(packagePath);\n        return this.createInstanceCore(context, initialState);\n    }\n    async createInstanceCore(context, initialState) {\n        const { instance, runtime } = await createDataObject(this.ctor, context, this.sharedObjectRegistry, this.optionalProviders, this.runtimeClass, initialState);\n        await context.attachRuntime(this, runtime);\n        return instance;\n    }\n}\n//# sourceMappingURL=pureDataObjectFactory.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { MapFactory, SharedDirectory } from \"@fluidframework/map\";\nimport { RequestParser, create404Response } from \"@fluidframework/runtime-utils\";\nimport { PureDataObject } from \"./pureDataObject\";\n/**\n * DataObject is a base data store that is primed with a root directory. It\n * ensures that it is created and ready before you can access it.\n *\n * Having a single root directory allows for easier development. Instead of creating\n * and registering channels with the runtime any new DDS that is set on the root\n * will automatically be registered.\n *\n * Generics:\n * O - represents a type that will define optional providers that will be injected\n * S - the initial state type that the produced data store may take during creation\n * E - represents events that will be available in the EventForwarder\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport class DataObject extends PureDataObject {\n    constructor() {\n        super(...arguments);\n        this.rootDirectoryId = \"root\";\n    }\n    async request(request) {\n        const requestParser = RequestParser.create(request);\n        const itemId = requestParser.pathParts[0];\n        if (itemId === \"bigBlobs\") {\n            const value = this.root.get(requestParser.pathParts.join(\"/\"));\n            if (value === undefined) {\n                return create404Response(requestParser);\n            }\n            return { mimeType: \"fluid/object\", status: 200, value };\n        }\n        else {\n            return super.request(requestParser);\n        }\n    }\n    /**\n     * The root directory will either be ready or will return an error. If an error is thrown\n     * the root has not been correctly created/set.\n     */\n    get root() {\n        if (!this.internalRoot) {\n            throw new Error(this.getUninitializedErrorString(`root`));\n        }\n        return this.internalRoot;\n    }\n    /**\n     * Initializes internal objects and calls initialization overrides.\n     * Caller is responsible for ensuring this is only invoked once.\n     */\n    async initializeInternal() {\n        if (!this.runtime.existing) {\n            // Create a root directory and register it before calling initializingFirstTime\n            this.internalRoot = SharedDirectory.create(this.runtime, this.rootDirectoryId);\n            this.internalRoot.bindToContext();\n        }\n        else {\n            // data store has a root directory so we just need to set it before calling initializingFromExisting\n            this.internalRoot = await this.runtime.getChannel(this.rootDirectoryId);\n            // This will actually be an ISharedMap if the channel was previously created by the older version of\n            // DataObject which used a SharedMap.  Since SharedMap and SharedDirectory are compatible unless\n            // SharedDirectory-only commands are used on SharedMap, this will mostly just work for compatibility.\n            if (this.internalRoot.attributes.type === MapFactory.Type) {\n                this.runtime.logger.send({\n                    category: \"generic\",\n                    eventName: \"MapDataObject\",\n                    message: \"Legacy document, SharedMap is masquerading as SharedDirectory in DataObject\",\n                });\n            }\n        }\n        await super.initializeInternal();\n    }\n    getUninitializedErrorString(item) {\n        return `${item} must be initialized before being accessed.`;\n    }\n}\n//# sourceMappingURL=dataObject.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { FluidObjectHandle } from \"@fluidframework/datastore\";\nimport { assert, EventForwarder } from \"@fluidframework/common-utils\";\nimport { handleFromLegacyUri } from \"@fluidframework/request-handler\";\nimport { serviceRoutePathRoot } from \"../container-services\";\nimport { defaultFluidObjectRequestHandler } from \"../request-handlers\";\n/**\n * This is a bare-bones base class that does basic setup and enables for factory on an initialize call.\n * You probably don't want to inherit from this data store directly unless\n * you are creating another base data store class\n *\n * Generics:\n * O - represents a type that will define optional providers that will be injected\n * S - the initial state type that the produced data store may take during creation\n * E - represents events that will be available in the EventForwarder\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport class PureDataObject extends EventForwarder {\n    constructor(props) {\n        super();\n        this._disposed = false;\n        this.runtime = props.runtime;\n        this.context = props.context;\n        this.providers = props.providers;\n        this.initProps = props.initProps;\n        assert(this.runtime._dataObject === undefined, 0x0bd /* \"Object runtime already has DataObject!\" */);\n        this.runtime._dataObject = this;\n        // Create a FluidObjectHandle with empty string as `path`. This is because reaching this PureDataObject is the\n        // same as reaching its routeContext (FluidDataStoreRuntime) so there is so the relative path to it from the\n        // routeContext is empty.\n        this.innerHandle = new FluidObjectHandle(this, \"\", this.runtime.objectsRoutingContext);\n        // Container event handlers\n        this.runtime.once(\"dispose\", () => {\n            this._disposed = true;\n            this.dispose();\n        });\n    }\n    get disposed() { return this._disposed; }\n    get id() { return this.runtime.id; }\n    get IFluidRouter() { return this; }\n    get IFluidLoadable() { return this; }\n    get IFluidHandle() { return this.innerHandle; }\n    /**\n     * Handle to a data store\n     */\n    get handle() { return this.innerHandle; }\n    static async getDataObject(runtime) {\n        const obj = runtime._dataObject;\n        assert(obj !== undefined, 0x0bc /* \"Runtime has no DataObject!\" */);\n        await obj.finishInitialization();\n        return obj;\n    }\n    // #region IFluidRouter\n    /**\n     * Return this object if someone requests it directly\n     * We will return this object in two scenarios:\n     *  1. the request url is a \"/\"\n     *  2. the request url is empty\n     */\n    async request(req) {\n        return defaultFluidObjectRequestHandler(this, req);\n    }\n    // #endregion IFluidRouter\n    // #region IFluidLoadable\n    // #endregion IFluidLoadable\n    /**\n     * Call this API to ensure PureDataObject is fully initialized\n     * initialization happens on demand, only on as-needed bases.\n     * In most cases you should allow factory/object to decide when to finish initialization.\n     * But if you are supplying your own implementation of DataStoreRuntime factory and overriding some methods\n     * and need fully initialized object, then you can call this API to ensure object is fully initialized.\n     */\n    async finishInitialization() {\n        if (this.initializeP !== undefined) {\n            return this.initializeP;\n        }\n        this.initializeP = this.initializeInternal();\n        return this.initializeP;\n    }\n    /**\n     * Internal initialize implementation. Overwriting this will change the flow of the PureDataObject and should\n     * generally not be done.\n     *\n     * Calls initializingFirstTime, initializingFromExisting, and hasInitialized. Caller is\n     * responsible for ensuring this is only invoked once.\n     */\n    async initializeInternal() {\n        var _a;\n        await this.preInitialize();\n        if (this.runtime.existing) {\n            assert(this.initProps === undefined, 0x0be /* \"Trying to initialize from existing while initProps is set!\" */);\n            await this.initializingFromExisting();\n        }\n        else {\n            await this.initializingFirstTime((_a = this.context.createProps) !== null && _a !== void 0 ? _a : this.initProps);\n        }\n        await this.hasInitialized();\n    }\n    /**\n     * Retreive Fluid object using the handle get or the older requestFluidObject_UNSAFE call to fetch by ID\n     *\n     * @param key - key that object (handle/id) is stored with in the directory\n     * @param directory - directory containing the object\n     * @param getObjectFromDirectory - optional callback for fetching object from the directory, allows users to\n     * define custom types/getters for object retrieval\n     */\n    async getFluidObjectFromDirectory(key, directory, getObjectFromDirectory) {\n        const handleOrId = getObjectFromDirectory ? getObjectFromDirectory(key, directory) : directory.get(key);\n        if (typeof handleOrId === \"string\") {\n            // For backwards compatibility with older stored IDs\n            // We update the storage with the handle so that this code path is less and less trafficked\n            const fluidObject = await this.requestFluidObject_UNSAFE(handleOrId);\n            if (fluidObject.IFluidLoadable && fluidObject.handle) {\n                directory.set(key, fluidObject.handle);\n            }\n            return fluidObject;\n        }\n        else {\n            const handle = handleOrId === null || handleOrId === void 0 ? void 0 : handleOrId.IFluidHandle;\n            return await (handle ? handle.get() : this.requestFluidObject_UNSAFE(key));\n        }\n    }\n    /**\n     * @deprecated\n     * Gets the data store of a given id. Will follow the pattern of the container for waiting.\n     * @param id - data store id\n     */\n    async requestFluidObject_UNSAFE(id) {\n        return handleFromLegacyUri(`/${id}`, this.context.containerRuntime).get();\n    }\n    /**\n     * Gets the service at a given id.\n     * @param id - service id\n     */\n    async getService(id) {\n        return handleFromLegacyUri(`/${serviceRoutePathRoot}/${id}`, this.context.containerRuntime).get();\n    }\n    /**\n     * Called every time the data store is initialized, before initializingFirstTime or\n     * initializingFromExisting is called.\n     */\n    async preInitialize() { }\n    /**\n     * Called the first time the data store is initialized (new creations with a new\n     * data store runtime)\n     *\n     * @param props - Optional props to be passed in on create\n     */\n    async initializingFirstTime(props) { }\n    /**\n     * Called every time but the first time the data store is initialized (creations\n     * with an existing data store runtime)\n     */\n    async initializingFromExisting() { }\n    /**\n     * Called every time the data store is initialized after create or existing.\n     */\n    async hasInitialized() { }\n    /**\n     * Called when the host container closes and disposes itself\n     */\n    dispose() {\n        super.dispose();\n    }\n}\n//# sourceMappingURL=pureDataObject.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { buildRuntimeRequestHandler } from \"@fluidframework/request-handler\";\nimport { RequestParser, create404Response } from \"@fluidframework/runtime-utils\";\n/**\n * A mountable view is only required if the view needs to be mounted across a bundle boundary.  Mounting across\n * bundle boundaries breaks some frameworks, so the mountable view is used to ensure the mounting is done within\n * the same bundle as the view.  For example, React hooks don't work if mounted across bundles since there will\n * be two React instances, breaking the Rules of Hooks.  When cross-bundle mounting isn't required, the mountable\n * view isn't necessary.\n *\n * When a request is received with a mountableView: true header, this request handler will reissue the request\n * without the header, and respond with a mountable view of the given class using the response.\n * @param MountableViewClass - The type of mountable view to use when responding\n */\nexport const mountableViewRequestHandler = (MountableViewClass, handlers) => {\n    const nestedHandler = buildRuntimeRequestHandler(...handlers);\n    return async (request, runtime) => {\n        var _a;\n        const mountableView = ((_a = request.headers) === null || _a === void 0 ? void 0 : _a.mountableView) === true;\n        let newRequest = request;\n        if (mountableView) {\n            // Reissue the request without the mountableView header.\n            // We'll repack whatever the response is if we can.\n            const headers = Object.assign({}, request.headers);\n            delete headers.mountableView;\n            newRequest = {\n                url: request.url,\n                headers,\n            };\n        }\n        const response = await nestedHandler(newRequest, runtime);\n        if (mountableView && response.status === 200 && MountableViewClass.canMount(response.value)) {\n            return {\n                status: 200,\n                mimeType: \"fluid/object\",\n                value: new MountableViewClass(response.value),\n            };\n        }\n        return response;\n    };\n};\n/**\n * Pipe through container request into internal request.\n * If request is empty and default url is provided, redirect request to such default url.\n * @param defaultRootId - optional default root data store ID to pass request in case request is empty.\n */\nexport const defaultRouteRequestHandler = (defaultRootId) => {\n    return async (request, runtime) => {\n        const parser = RequestParser.create(request);\n        if (parser.pathParts.length === 0) {\n            return runtime.IFluidHandleContext.resolveHandle({\n                url: `/${defaultRootId}${parser.query}`,\n                headers: request.headers\n            });\n        }\n        return undefined; // continue search\n    };\n};\n/**\n * Default request handler for a Fluid object that returns the object itself if:\n *  1. the request url is a \"/\"\n *  2. the request url is empty\n * Returns a 404 error for any other url.\n */\nexport function defaultFluidObjectRequestHandler(fluidObject, request) {\n    if (request.url === \"/\" || request.url === \"\") {\n        return { mimeType: \"fluid/object\", status: 200, value: fluidObject };\n    }\n    else {\n        return create404Response(request);\n    }\n}\n//# sourceMappingURL=requestHandlers.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.\n */\nexport function assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { IsoBuffer } from \"./indexNode\";\nexport const fromBase64ToUtf8 = (input) => IsoBuffer.from(input, \"base64\").toString(\"utf-8\");\nexport const fromUtf8ToBase64 = (input) => IsoBuffer.from(input, \"utf8\").toString(\"base64\");\n/**\n * Convenience function to convert unknown encoding to utf8 that avoids\n * buffer copies/encode ops when no conversion is needed\n * @param input - The source string to convert\n * @param encoding - The source string's encoding\n */\nexport const toUtf8 = (input, encoding) => {\n    switch (encoding) {\n        case \"utf8\":\n        case \"utf-8\":\n            return input;\n        default:\n            return IsoBuffer.from(input, encoding).toString();\n    }\n};\n//# sourceMappingURL=base64Encoding.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as base64js from \"base64-js\";\nimport { assert } from \"./assert\";\n/**\n * Converts a Uint8Array to a string of the provided encoding\n * Useful when the array might be an IsoBuffer\n * @param arr - The array to convert\n * @param encoding - Optional target encoding; only \"utf8\" and \"base64\" are\n * supported, with \"utf8\" being default\n * @returns The converted string\n */\nexport function Uint8ArrayToString(arr, encoding) {\n    switch (encoding) {\n        case \"base64\": {\n            return base64js.fromByteArray(arr);\n        }\n        case \"utf8\":\n        case \"utf-8\":\n        case undefined: {\n            return new TextDecoder().decode(arr);\n        }\n        default: {\n            throw new Error(\"invalid/unsupported encoding\");\n        }\n    }\n}\n/**\n * Convert base64 or utf8 string to array buffer\n * @param encoding - input string's encoding\n */\nexport const stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;\n/**\n * Convert binary blob to string format\n *\n * @param blob - the binary blob\n * @param encoding - output string's encoding\n * @returns the blob in string format\n */\nexport const bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);\n/**\n * Determines if an object is an array buffer\n * Will detect and reject TypedArrays, like Uint8Array.\n * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with\n * math properly (i.e. take into account byteOffset at minimum).\n * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or\n * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and\n * ignoring byteOffice, length)\n * @param obj - The object to determine if it is an ArrayBuffer\n */\nexport function isArrayBuffer(obj) {\n    const maybe = obj;\n    return obj instanceof ArrayBuffer\n        || (typeof maybe === \"object\"\n            && maybe !== null\n            && typeof maybe.byteLength === \"number\"\n            && typeof maybe.slice === \"function\"\n            && maybe.byteOffset === undefined\n            && maybe.buffer === undefined);\n}\n/**\n * Minimal implementation of Buffer for our usages in the browser environment.\n */\nexport class IsoBuffer extends Uint8Array {\n    /**\n     * Convert the buffer to a string.\n     * Only supports encoding the whole string (unlike the Node Buffer equivalent)\n     * and only utf8 and base64 encodings\n     * @param encoding\n     */\n    toString(encoding) {\n        return Uint8ArrayToString(this, encoding);\n    }\n    /**\n     * @param value - string | ArrayBuffer\n     * @param encodingOrOffset - string | number\n     * @param length - number\n     */\n    static from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n            return IsoBuffer.fromString(value, encodingOrOffset);\n            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)\n        }\n        else if (value !== null && typeof value === \"object\" && isArrayBuffer(value.buffer)) {\n            // Support currently for full array, no view ports! (though it can be added in future)\n            assert(value.byteOffset === 0, 0x000 /* \"nonzero isobuffer byte offset\" */);\n            assert(value.byteLength === value.buffer.byteLength, 0x001 /* \"unexpected isobuffer byte length\" */);\n            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);\n        }\n        else if (isArrayBuffer(value)) {\n            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        else {\n            throw new TypeError();\n        }\n    }\n    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;\n        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;\n        if (offset < 0 ||\n            offset > arrayBuffer.byteLength ||\n            validLength < 0 ||\n            validLength + offset > arrayBuffer.byteLength) {\n            throw new RangeError();\n        }\n        return new IsoBuffer(arrayBuffer, offset, validLength);\n    }\n    static fromString(str, encoding) {\n        switch (encoding) {\n            case \"base64\": {\n                const sanitizedString = this.sanitizeBase64(str);\n                const encoded = base64js.toByteArray(sanitizedString);\n                return new IsoBuffer(encoded.buffer);\n            }\n            case \"utf8\":\n            case \"utf-8\":\n            case undefined: {\n                const encoded = new TextEncoder().encode(str);\n                return new IsoBuffer(encoded.buffer);\n            }\n            default: {\n                throw new Error(\"invalid/unsupported encoding\");\n            }\n        }\n    }\n    static isBuffer(obj) {\n        throw new Error(\"unimplemented\");\n    }\n    /**\n     * Sanitize a base64 string to provide to base64-js library.  base64-js\n     * is not as tolerant of the same malformed base64 as Node's Buffer is.\n     * @param str\n     */\n    static sanitizeBase64(str) {\n        let sanitizedStr = str;\n        // Remove everything after padding - Node buffer ignores everything\n        // after any padding whereas base64-js does not\n        sanitizedStr = sanitizedStr.split(\"=\")[0];\n        // Remove invalid characters - Node buffer strips invalid characters\n        // whereas base64-js replaces them with \"A\"\n        sanitizedStr = sanitizedStr.replace(/[^\\w+-/]/g, \"\");\n        // Check for missing padding - Node buffer tolerates missing padding\n        // whereas base64-js does not\n        if (sanitizedStr.length % 4 !== 0) {\n            const paddingArray = [\"\", \"===\", \"==\", \"=\"];\n            sanitizedStr += paddingArray[sanitizedStr.length % 4];\n        }\n        return sanitizedStr;\n    }\n}\n//# sourceMappingURL=bufferBrowser.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nexport function doIfNotDisposed(disposable, f) {\n    return (...args) => {\n        if (disposable.disposed) {\n            throw new Error(\"Already disposed\");\n        }\n        else {\n            return f(...args);\n        }\n    };\n}\n//# sourceMappingURL=disposal.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { TypedEventEmitter } from \"./typedEventEmitter\";\n/**\n * Base class used for forwarding events from a source EventEmitter.\n * This can be useful when all arbitrary listeners need to be removed,\n * but the primary source needs to stay intact.\n */\nexport class EventForwarder extends TypedEventEmitter {\n    constructor(source) {\n        super();\n        this.isDisposed = false;\n        this.forwardingEvents = new Map();\n        if (source !== undefined) {\n            // NewListener event is raised whenever someone starts listening to this events, so\n            // we keep track of events being listened to, and start forwarding from the source\n            // event emitter per event listened to on this\n            const removeListenerHandler = (event) => this.unforwardEvent(source, event);\n            const newListenerHandler = (event) => this.forwardEvent(source, event);\n            this.on(EventForwarder.removeListenerEvent, removeListenerHandler);\n            this.on(EventForwarder.newListenerEvent, newListenerHandler);\n        }\n    }\n    static isEmitterEvent(event) {\n        return event === EventForwarder.newListenerEvent || event === EventForwarder.removeListenerEvent;\n    }\n    get disposed() { return this.isDisposed; }\n    dispose() {\n        this.isDisposed = true;\n        for (const listenerRemovers of this.forwardingEvents.values()) {\n            for (const listenerRemover of listenerRemovers.values()) {\n                try {\n                    listenerRemover();\n                }\n                catch (_a) {\n                    // Should be fine because of removeAllListeners below\n                }\n            }\n        }\n        this.removeAllListeners();\n        this.forwardingEvents.clear();\n    }\n    forwardEvent(source, ...events) {\n        for (const event of events) {\n            if (source !== undefined && event !== undefined && !EventForwarder.isEmitterEvent(event)) {\n                let sources = this.forwardingEvents.get(event);\n                if (sources === undefined) {\n                    sources = new Map();\n                    this.forwardingEvents.set(event, sources);\n                }\n                if (!sources.has(source)) {\n                    const listener = (...args) => this.emit(event, ...args);\n                    sources.set(source, () => source.off(event, listener));\n                    source.on(event, listener);\n                }\n            }\n        }\n    }\n    unforwardEvent(source, ...events) {\n        for (const event of events) {\n            if (event !== undefined && !EventForwarder.isEmitterEvent(event)) {\n                const sources = this.forwardingEvents.get(event);\n                if (sources === null || sources === void 0 ? void 0 : sources.has(source)) {\n                    if (this.listenerCount(event) === 0) {\n                        const listenerRemover = sources.get(source);\n                        if (listenerRemover !== undefined) {\n                            listenerRemover();\n                        }\n                        sources.delete(source);\n                        if (sources.size === 0) {\n                            this.forwardingEvents.delete(event);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nEventForwarder.newListenerEvent = \"newListener\";\nEventForwarder.removeListenerEvent = \"removeListener\";\n//# sourceMappingURL=eventForwarder.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A comparer for numbers\n */\nexport const NumberComparer = {\n    /**\n     * The compare function for numbers,\n     * @returns difference of the two number\n     */\n    compare: (a, b) => a - b,\n    /**\n     * The minimum value of a javascript number, which is Number.MIN_VALUE\n     */\n    min: Number.MIN_VALUE,\n};\n/**\n * Ordered Heap data structure implementation\n */\nexport class Heap {\n    /**\n     * Creates an instance of Heap with comparer\n     * @param comp - a comparer that specify how elements are ordered\n     */\n    constructor(comp) {\n        this.comp = comp;\n        this.L = [{ value: comp.min, position: 0 }];\n    }\n    /**\n     * Return the smallest element in the heap as determined by the order of the comparer\n     *\n     * @returns heap node containing the smallest element\n     */\n    peek() {\n        return this.L[1];\n    }\n    /**\n     * Get and remove the smallest element in the heap as determined by the order of the comparer\n     *\n     * @returns the smallest value in the heap\n     */\n    get() {\n        this.swap(1, this.count());\n        const x = this.L.pop();\n        this.fixdown(1);\n        return x.value;\n    }\n    /**\n     * Add a value to the heap\n     *\n     * @param x - value to add\n     * @returns the heap node that contains the value\n     */\n    add(x) {\n        const node = { value: x, position: this.L.length };\n        this.L.push(node);\n        this.fixup(this.count());\n        return node;\n    }\n    /**\n     * Allows for heap to be updated after a node's value changes\n     */\n    update(node) {\n        const k = node.position;\n        if (this.isGreaterThanParent(k)) {\n            this.fixup(k);\n        }\n        else {\n            this.fixdown(k);\n        }\n    }\n    /**\n     * Removes the given node from the heap\n     *\n     * @param node - the node to remove from the heap\n     */\n    remove(node) {\n        // Move the node we want to remove to the end of the array\n        const position = node.position;\n        this.swap(node.position, this.L.length - 1);\n        this.L.splice(this.L.length - 1);\n        // Update the swapped node assuming we didn't remove the end of the list\n        if (position !== this.L.length) {\n            this.update(this.L[position]);\n        }\n    }\n    /**\n     * Get the number of elements in the Heap\n     *\n     * @returns the number of elements in the Heap\n     */\n    count() {\n        return this.L.length - 1;\n    }\n    fixup(pos) {\n        let k = pos;\n        while (this.isGreaterThanParent(k)) {\n            const parent = k >> 1;\n            this.swap(k, parent);\n            k = parent;\n        }\n    }\n    isGreaterThanParent(k) {\n        return k > 1 && (this.comp.compare(this.L[k >> 1].value, this.L[k].value) > 0);\n    }\n    fixdown(pos) {\n        let k = pos;\n        while ((k << 1) <= this.count()) {\n            let j = k << 1;\n            if ((j < this.count()) && (this.comp.compare(this.L[j].value, this.L[j + 1].value) > 0)) {\n                j++;\n            }\n            if (this.comp.compare(this.L[k].value, this.L[j].value) <= 0) {\n                break;\n            }\n            this.swap(k, j);\n            k = j;\n        }\n    }\n    swap(k, j) {\n        const tmp = this.L[k];\n        this.L[k] = this.L[j];\n        this.L[k].position = k;\n        this.L[j] = tmp;\n        this.L[j].position = j;\n    }\n}\n//# sourceMappingURL=heap.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n  * Helper class for lazy initialized values. Ensures the value is only generated once, and remain immutable\n  */\nexport class Lazy {\n    /**\n     * Instantiates an instance of Lazy<T>\n     * @param valueGenerator - the function that will generate the value when value is accessed the first time\n     */\n    constructor(valueGenerator) {\n        this.valueGenerator = valueGenerator;\n        this._evaluated = false;\n    }\n    /**\n     * Return true if the value as been generated, otherwise false\n     */\n    get evaluated() {\n        return this._evaluated;\n    }\n    /**\n     * Get the value. If this is the first call the value will be generated\n     */\n    get value() {\n        if (!this._evaluated) {\n            this._evaluated = true;\n            this._value = this.valueGenerator();\n        }\n        return this._value;\n    }\n}\n//# sourceMappingURL=lazy.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Null logger\n * It can be used in places where logger instance is required, but events should be not send over.\n */\nexport class BaseTelemetryNullLogger {\n    /**\n     * Send an event with the logger\n     *\n     * @param event - the event to send\n     */\n    send(event) {\n        return;\n    }\n}\n/**\n * Null logger\n * It can be used in places where logger instance is required, but events should be not send over.\n */\nexport class TelemetryNullLogger {\n    send(event) {\n    }\n    sendTelemetryEvent(event, error) {\n    }\n    sendErrorEvent(event, error) {\n    }\n    sendPerformanceEvent(event, error) {\n    }\n    logGenericError(eventName, error) {\n    }\n    logException(event, exception) {\n    }\n    debugAssert(condition, event) {\n    }\n    shipAssert(condition, event) {\n    }\n}\n//# sourceMappingURL=logger.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nexport const performance = window.performance;\n//# sourceMappingURL=performanceBrowser.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A deferred creates a promise and the ability to resolve or reject it\n */\nexport class Deferred {\n    constructor() {\n        this.completed = false;\n        this.p = new Promise((resolve, reject) => {\n            this.res = resolve;\n            this.rej = reject;\n        });\n    }\n    /**\n     * Returns whether the underlying promise has been completed\n     */\n    get isCompleted() {\n        return this.completed;\n    }\n    /**\n     * Retrieves the underlying promise for the deferred\n     *\n     * @returns the underlying promise\n     */\n    get promise() {\n        return this.p;\n    }\n    /**\n     * Resolves the promise\n     *\n     * @param value - the value to resolve the promise with\n     */\n    resolve(value) {\n        if (this.res !== undefined) {\n            this.completed = true;\n            this.res(value);\n        }\n    }\n    /**\n     * Rejects the promise\n     *\n     * @param value - the value to reject the promise with\n     */\n    reject(error) {\n        if (this.rej !== undefined) {\n            this.completed = true;\n            this.rej(error);\n        }\n    }\n}\n/**\n * A lazy evaluated promise. The execute function is delayed until\n * the promise is used, e.g. await, then, catch ...\n * The execute function is only called once.\n * All calls are then proxied to the promise returned by the execute method.\n */\nexport class LazyPromise {\n    constructor(execute) {\n        this.execute = execute;\n    }\n    get [Symbol.toStringTag]() {\n        return this.getPromise()[Symbol.toStringTag];\n    }\n    async then(onfulfilled, onrejected) {\n        return this.getPromise().then(...arguments);\n    }\n    async catch(onrejected) {\n        return this.getPromise().catch(...arguments);\n    }\n    async finally(onfinally) {\n        return this.getPromise().finally(...arguments);\n    }\n    async getPromise() {\n        if (this.result === undefined) {\n            this.result = this.execute();\n        }\n        return this.result;\n    }\n}\n//# sourceMappingURL=promises.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"./assert\";\nimport { Deferred } from \"./promises\";\n/**\n * This class is a thin wrapper over setTimeout and clearTimeout which\n * makes it simpler to keep track of recurring timeouts with the same\n * or similar handlers and timeouts.\n */\nexport class Timer {\n    constructor(defaultTimeout, defaultHandler, getCurrentTick = () => Date.now()) {\n        this.defaultTimeout = defaultTimeout;\n        this.defaultHandler = defaultHandler;\n        this.getCurrentTick = getCurrentTick;\n    }\n    /**\n     * Returns true if the timer is running.\n     */\n    get hasTimer() {\n        return !!this.runningState;\n    }\n    /**\n     * Calls setTimeout and tracks the resulting timeout.\n     * @param ms - overrides default timeout in ms\n     * @param handler - overrides default handler\n     */\n    start(ms = this.defaultTimeout, handler = this.defaultHandler) {\n        this.startCore(ms, handler, ms);\n    }\n    /**\n     * Calls clearTimeout on the underlying timeout if running.\n     */\n    clear() {\n        if (!this.runningState) {\n            return;\n        }\n        clearTimeout(this.runningState.timeout);\n        this.runningState = undefined;\n    }\n    /**\n     * Restarts the timer with the new handler and duration.\n     * If a new handler is passed, the original handler may\n     * never execute.\n     * This is a potentially more efficient way to clear and start\n     * a new timer.\n     * @param ms - overrides previous or default timeout in ms\n     * @param handler - overrides previous or default handler\n     */\n    restart(ms, handler) {\n        var _a, _b;\n        if (!this.runningState) {\n            // If restart is called first, it behaves as a call to start\n            this.start(ms, handler);\n        }\n        else {\n            const duration = ms !== null && ms !== void 0 ? ms : this.runningState.intendedDuration;\n            const handlerToUse = (_b = handler !== null && handler !== void 0 ? handler : (_a = this.runningState.restart) === null || _a === void 0 ? void 0 : _a.handler) !== null && _b !== void 0 ? _b : this.runningState.handler;\n            const remainingTime = this.calculateRemainingTime(this.runningState);\n            if (duration < remainingTime) {\n                // If remaining time exceeds restart duration, do a hard restart.\n                // The existing timeout time is too long.\n                this.start(duration, handlerToUse);\n            }\n            else if (duration === remainingTime) {\n                // The existing timeout time is perfect, just update handler and data.\n                this.runningState.handler = handlerToUse;\n                this.runningState.restart = undefined;\n                this.runningState.intendedDuration = duration;\n            }\n            else {\n                // If restart duration exceeds remaining time, set restart info.\n                // Existing timeout will start a new timeout for remaining time.\n                this.runningState.restart = {\n                    startTick: this.getCurrentTick(),\n                    duration,\n                    handler: handlerToUse,\n                };\n            }\n        }\n    }\n    startCore(duration, handler, intendedDuration) {\n        this.clear();\n        this.runningState = {\n            startTick: this.getCurrentTick(),\n            duration,\n            intendedDuration,\n            handler,\n            timeout: setTimeout(() => this.handler(), duration),\n        };\n    }\n    handler() {\n        assert(!!this.runningState, 0x00a /* \"Running timer missing handler\" */);\n        const restart = this.runningState.restart;\n        if (restart !== undefined) {\n            // Restart with remaining time\n            const remainingTime = this.calculateRemainingTime(restart);\n            this.startCore(remainingTime, () => restart.handler(), restart.duration);\n        }\n        else {\n            // Run clear first, in case the handler decides to start again\n            const handler = this.runningState.handler;\n            this.clear();\n            handler();\n        }\n    }\n    calculateRemainingTime(runningTimeout) {\n        const elapsedTime = this.getCurrentTick() - runningTimeout.startTick;\n        return runningTimeout.duration - elapsedTime;\n    }\n}\n/**\n * This class is a wrapper over setTimeout and clearTimeout which\n * makes it simpler to keep track of recurring timeouts with the\n * same handlers and timeouts, while also providing a promise that\n * resolves when it times out.\n */\nexport class PromiseTimer {\n    constructor(defaultTimeout, defaultHandler) {\n        this.timer = new Timer(defaultTimeout, () => this.wrapHandler(defaultHandler));\n    }\n    get hasTimer() {\n        return this.timer.hasTimer;\n    }\n    async start(ms, handler) {\n        this.clear();\n        this.deferred = new Deferred();\n        this.timer.start(ms, handler ? () => this.wrapHandler(handler) : undefined);\n        return this.deferred.promise;\n    }\n    clear() {\n        this.timer.clear();\n        if (this.deferred) {\n            this.deferred.resolve({ timerResult: \"cancel\" });\n            this.deferred = undefined;\n        }\n    }\n    wrapHandler(handler) {\n        handler();\n        assert(!!this.deferred, 0x00b /* \"Handler executed without deferred\" */);\n        this.deferred.resolve({ timerResult: \"timeout\" });\n        this.deferred = undefined;\n    }\n}\n//# sourceMappingURL=timer.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { performance } from \"./indexNode\";\n/**\n * Helper class for tracing performance of events\n * Time measurements are in milliseconds as a floating point with a decimal\n */\nexport class Trace {\n    constructor(startTick) {\n        this.startTick = startTick;\n        this.lastTick = startTick;\n    }\n    static start() {\n        const startTick = performance.now();\n        return new Trace(startTick);\n    }\n    trace() {\n        const tick = performance.now();\n        const event = {\n            totalTimeElapsed: tick - this.startTick,\n            duration: tick - this.lastTick,\n            tick,\n        };\n        this.lastTick = tick;\n        return event;\n    }\n}\n//# sourceMappingURL=trace.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { EventEmitter } from \"events\";\n/**\n * Event Emitter helper class the supports emitting typed events\n */\nexport class TypedEventEmitter extends EventEmitter {\n    constructor() {\n        super();\n        this.addListener = super.addListener.bind(this);\n        this.on = super.on.bind(this);\n        this.once = super.once.bind(this);\n        this.prependListener = super.prependListener.bind(this);\n        this.prependOnceListener = super.prependOnceListener.bind(this);\n        this.removeListener = super.removeListener.bind(this);\n        this.off = super.off.bind(this);\n    }\n}\n//# sourceMappingURL=typedEventEmitter.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This function can be used to assert at compile time that a given value has type never.\n * One common usage is in the default case of a switch block,\n * to ensure that all cases are explicitly handled.\n */\nexport function unreachableCase(_, message = \"Unreachable Case\") {\n    throw new Error(message);\n}\n//# sourceMappingURL=unreachable.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Different error types the Container may report out to the Host\n */\nexport var ContainerErrorType;\n(function (ContainerErrorType) {\n    /**\n     * Some error, most likely an exception caught by runtime and propagated to container as critical error\n     */\n    ContainerErrorType[\"genericError\"] = \"genericError\";\n    /**\n     * Throttling error from server. Server is busy and is asking not to reconnect for some time\n     */\n    ContainerErrorType[\"throttlingError\"] = \"throttlingError\";\n    /**\n     * Data loss error detected by Container / DeltaManager. Likely points to storage issue.\n     */\n    ContainerErrorType[\"dataCorruptionError\"] = \"dataCorruptionError\";\n    /**\n     * Error encountered when processing an operation. May correlate with data corruption.\n     */\n    ContainerErrorType[\"dataProcessingError\"] = \"dataProcessingError\";\n})(ContainerErrorType || (ContainerErrorType = {}));\n//# sourceMappingURL=error.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Accepted header keys for requests coming to the Loader\n */\nexport var LoaderHeader;\n(function (LoaderHeader) {\n    /**\n     * Override the Loader's default caching behavior for this container.\n     */\n    LoaderHeader[\"cache\"] = \"fluid-cache\";\n    LoaderHeader[\"clientDetails\"] = \"fluid-client-details\";\n    /**\n     * Start the container in a paused, unconnected state. Defaults to false\n     */\n    LoaderHeader[\"pause\"] = \"pause\";\n    LoaderHeader[\"reconnect\"] = \"fluid-reconnect\";\n    LoaderHeader[\"sequenceNumber\"] = \"fluid-sequence-number\";\n    /**\n     * One of the following:\n     * null or \"null\": use ops, no snapshots\n     * undefined: fetch latest snapshot\n     * otherwise, version sha to load snapshot\n     */\n    LoaderHeader[\"version\"] = \"version\";\n})(LoaderHeader || (LoaderHeader = {}));\n//# sourceMappingURL=loader.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n// Represents the attachment state of the entity.\nexport var AttachState;\n(function (AttachState) {\n    AttachState[\"Detached\"] = \"Detached\";\n    AttachState[\"Attaching\"] = \"Attaching\";\n    AttachState[\"Attached\"] = \"Attached\";\n})(AttachState || (AttachState = {}));\n// Represents the bind state of the entity.\nexport var BindState;\n(function (BindState) {\n    BindState[\"NotBound\"] = \"NotBound\";\n    BindState[\"Binding\"] = \"Binding\";\n    BindState[\"Bound\"] = \"Bound\";\n})(BindState || (BindState = {}));\nexport const IRuntimeFactory = \"IRuntimeFactory\";\n//# sourceMappingURL=runtime.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { EventEmitter } from \"events\";\n/**\n * Audience represents all clients connected to the op stream.\n */\nexport class Audience extends EventEmitter {\n    constructor() {\n        super(...arguments);\n        this.members = new Map();\n    }\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    /**\n     * Adds a new client to the audience\n     */\n    addMember(clientId, details) {\n        this.members.set(clientId, details);\n        this.emit(\"addMember\", clientId, details);\n    }\n    /**\n     * Removes a client from the audience\n     */\n    removeMember(clientId) {\n        this.members.delete(clientId);\n        this.emit(\"removeMember\", clientId);\n    }\n    /**\n     * Retrieves all the members in the audience\n     */\n    getMembers() {\n        return new Map(this.members);\n    }\n    /**\n     * Retrieves a specific member of the audience\n     */\n    getMember(clientId) {\n        return this.members.get(clientId);\n    }\n    /**\n     * Clears the audience\n     */\n    clear() {\n        const clientIds = this.members.keys();\n        for (const clientId of clientIds) {\n            this.removeMember(clientId);\n        }\n    }\n}\n//# sourceMappingURL=audience.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { EventEmitterWithErrorHandling, PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nimport { assert, Timer } from \"@fluidframework/common-utils\";\nimport { connectEventName, ConnectionState } from \"./container\";\nexport class ConnectionStateHandler extends EventEmitterWithErrorHandling {\n    constructor(handler, logger) {\n        var _a;\n        super();\n        this.handler = handler;\n        this.logger = logger;\n        this._connectionState = ConnectionState.Disconnected;\n        this._clientSentOps = false;\n        this.prevClientLeftTimer = new Timer((_a = \n        // Default is 90 sec for which we are going to wait for its own \"leave\" message.\n        this.handler.maxClientLeaveWaitTime) !== null && _a !== void 0 ? _a : 90000, () => {\n            this.leaveReceivedResult = false;\n            this.applyForConnectedState(\"timeout\");\n        });\n    }\n    get connectionState() {\n        return this._connectionState;\n    }\n    get connected() {\n        return this.connectionState === ConnectionState.Connected;\n    }\n    get clientId() {\n        return this._clientId;\n    }\n    get pendingClientId() {\n        return this._pendingClientId;\n    }\n    // This is true when this client submitted any ops.\n    clientSentOps(connectionMode) {\n        assert(this._connectionState === ConnectionState.Connected, 0x1d7 /* \"Ops could only be sent when connected\" */);\n        this._clientSentOps = true;\n        this.clientConnectionMode = connectionMode;\n    }\n    receivedAddMemberEvent(clientId) {\n        // This is the only one that requires the pending client ID\n        if (clientId === this.pendingClientId) {\n            // Start the event in case we are waiting for leave or timeout.\n            if (this.prevClientLeftTimer.hasTimer) {\n                this.waitEvent = PerformanceEvent.start(this.logger, {\n                    eventName: \"WaitBeforeClientLeave\",\n                    waitOnClientId: this._clientId,\n                    hadOutstandingOps: this.handler.shouldClientJoinWrite(),\n                });\n            }\n            this.applyForConnectedState(\"addMemberEvent\");\n        }\n    }\n    applyForConnectedState(source) {\n        var _a;\n        const protocolHandler = this.handler.protocolHandler();\n        // Move to connected state only if we are in Connecting state, we have seen our join op\n        // and there is no timer running which means we are not waiting for previous client to leave\n        // or timeout has occured while doing so.\n        if (this.pendingClientId !== this.clientId\n            && this.pendingClientId !== undefined\n            && protocolHandler !== undefined && protocolHandler.quorum.getMember(this.pendingClientId) !== undefined\n            && !this.prevClientLeftTimer.hasTimer) {\n            (_a = this.waitEvent) === null || _a === void 0 ? void 0 : _a.end({ leaveReceived: this.leaveReceivedResult, source });\n            this.setConnectionState(ConnectionState.Connected);\n        }\n        else {\n            // Adding this event temporarily so that we can get help debugging if something goes wrong.\n            this.logger.sendTelemetryEvent({\n                eventName: \"connectedStateRejected\",\n                source,\n                pendingClientId: this.pendingClientId,\n                clientId: this.clientId,\n                hasTimer: this.prevClientLeftTimer.hasTimer,\n                inQuorum: protocolHandler !== undefined && this.pendingClientId !== undefined\n                    && protocolHandler.quorum.getMember(this.pendingClientId) !== undefined,\n            });\n        }\n    }\n    receivedRemoveMemberEvent(clientId) {\n        // If the client which has left was us, then finish the timer.\n        if (this.clientId === clientId) {\n            this.prevClientLeftTimer.clear();\n            this.leaveReceivedResult = true;\n            this.applyForConnectedState(\"removeMemberEvent\");\n        }\n    }\n    receivedDisconnectEvent(reason) {\n        this.setConnectionState(ConnectionState.Disconnected, reason);\n    }\n    receivedConnectEvent(connectionMode, details, opsBehind) {\n        const oldState = this._connectionState;\n        this._connectionState = ConnectionState.Connecting;\n        // Stash the clientID to detect when transitioning from connecting (socket.io channel open) to connected\n        // (have received the join message for the client ID)\n        // This is especially important in the reconnect case. It's possible there could be outstanding\n        // ops sent by this client, so we should keep the old client id until we see our own client's\n        // join message. after we see the join message for out new connection with our new client id,\n        // we know there can no longer be outstanding ops that we sent with the previous client id.\n        this._pendingClientId = details.clientId;\n        this.emit(connectEventName, opsBehind);\n        // Report telemetry after we set client id!\n        this.handler.logConnectionStateChangeTelemetry(ConnectionState.Connecting, oldState);\n        const protocolHandler = this.handler.protocolHandler();\n        // Check if we already processed our own join op through delta storage!\n        // we are fetching ops from storage in parallel to connecting to ordering service\n        // Given async processes, it's possible that we have already processed our own join message before\n        // connection was fully established.\n        // Note that we might be still initializing quorum - connection is established proactively on load!\n        if ((protocolHandler !== undefined && protocolHandler.quorum.getMember(details.clientId) !== undefined)\n            || connectionMode === \"read\") {\n            this.setConnectionState(ConnectionState.Connected);\n        }\n    }\n    setConnectionState(value, reason) {\n        var _a;\n        if (this.connectionState === value) {\n            // Already in the desired state - exit early\n            this.logger.sendErrorEvent({ eventName: \"setConnectionStateSame\", value });\n            return;\n        }\n        const oldState = this._connectionState;\n        this._connectionState = value;\n        if (value === ConnectionState.Connected) {\n            assert(oldState === ConnectionState.Connecting, 0x1d8 /* \"Should only transition from Connecting state\" */);\n            // Mark our old client should have left in the quorum if it's still there\n            if (this._clientId !== undefined) {\n                const client = (_a = this.handler.protocolHandler()) === null || _a === void 0 ? void 0 : _a.quorum.getMember(this._clientId);\n                if (client !== undefined) {\n                    client.shouldHaveLeft = true;\n                }\n            }\n            this._clientId = this.pendingClientId;\n            // Set _clientSentOps to false as this is a fresh connection.\n            this._clientSentOps = false;\n        }\n        else if (value === ConnectionState.Disconnected) {\n            // Important as we process our own joinSession message through delta request\n            this._pendingClientId = undefined;\n            // Only wait for \"leave\" message if we have some outstanding ops and the client was write client as\n            // server would not accept ops from read client. Also check if the timer is not already running as we\n            // could receive \"Disconnected\" event multiple times without getting connected and in that case we\n            // don't want to reset the timer as we still want to wait on original client which started this timer.\n            // We also check the dirty state of this connection as we only want to wait for the client leave of the\n            // client which created the ops. This helps with situation where a client disconnects immediately after\n            // getting connected without sending any ops(from previous client). In this case, we would join as write\n            // because there would be a diff between client seq number and clientSeqNumberObserved but then we don't\n            // want to wait for newly disconnected client to leave as it has not sent any ops yet.\n            if (this.handler.shouldClientJoinWrite()\n                && this.clientConnectionMode === \"write\"\n                && this.prevClientLeftTimer.hasTimer === false\n                && this._clientSentOps) {\n                this.leaveReceivedResult = undefined;\n                this.prevClientLeftTimer.restart();\n            }\n            else {\n                // Adding this event temporarily so that we can get help debugging if something goes wrong.\n                this.logger.sendTelemetryEvent({\n                    eventName: \"noWaitOnDisconnected\",\n                    clientConnectionMode: this.clientConnectionMode,\n                    hasTimer: this.prevClientLeftTimer.hasTimer,\n                    clientSentOps: this._clientSentOps,\n                    shouldClientJoinWrite: this.handler.shouldClientJoinWrite(),\n                });\n            }\n        }\n        if (this.handler.isContainerLoaded()) {\n            this.handler.propagateConnectionState();\n        }\n        // Report telemetry after we set client id!\n        this.handler.logConnectionStateChangeTelemetry(this._connectionState, oldState, reason);\n    }\n}\n//# sourceMappingURL=connectionStateHandler.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n// eslint-disable-next-line import/no-internal-modules\nimport merge from \"lodash/merge\";\nimport { v4 as uuid } from \"uuid\";\nimport { assert, performance } from \"@fluidframework/common-utils\";\nimport { isFluidCodeDetails, } from \"@fluidframework/core-interfaces\";\nimport { AttachState, } from \"@fluidframework/container-definitions\";\nimport { CreateContainerError, DataCorruptionError, extractSafePropertiesFromMessage, } from \"@fluidframework/container-utils\";\nimport { BlobCacheStorageService, readAndParse, OnlineStatus, isOnline, ensureFluidResolvedUrl, combineAppAndProtocolSummary, readAndParseFromBlobs, buildSnapshotTree, } from \"@fluidframework/driver-utils\";\nimport { isSystemMessage, ProtocolOpHandler, QuorumProxy, } from \"@fluidframework/protocol-base\";\nimport { FileMode, MessageType, TreeEntry, } from \"@fluidframework/protocol-definitions\";\nimport { ChildLogger, EventEmitterWithErrorHandling, PerformanceEvent, raiseConnectedEvent, TelemetryLogger, connectedEventName, disconnectedEventName, } from \"@fluidframework/telemetry-utils\";\nimport { Audience } from \"./audience\";\nimport { ContainerContext } from \"./containerContext\";\nimport { debug } from \"./debug\";\nimport { DeltaManager } from \"./deltaManager\";\nimport { DeltaManagerProxy } from \"./deltaManagerProxy\";\nimport { RelativeLoader } from \"./loader\";\nimport { pkgVersion } from \"./packageVersion\";\nimport { parseUrl, convertProtocolAndAppSummaryToSnapshotTree } from \"./utils\";\nimport { ConnectionStateHandler } from \"./connectionStateHandler\";\nconst detachedContainerRefSeqNumber = 0;\nexport const connectEventName = \"connect\";\nconst dirtyContainerEvent = \"dirty\";\nconst savedContainerEvent = \"saved\";\nexport var ConnectionState;\n(function (ConnectionState) {\n    /**\n     * The document is no longer connected to the delta server\n     */\n    ConnectionState[ConnectionState[\"Disconnected\"] = 0] = \"Disconnected\";\n    /**\n     * The document has an inbound connection but is still pending for outbound deltas\n     */\n    ConnectionState[ConnectionState[\"Connecting\"] = 1] = \"Connecting\";\n    /**\n     * The document is fully connected\n     */\n    ConnectionState[ConnectionState[\"Connected\"] = 2] = \"Connected\";\n})(ConnectionState || (ConnectionState = {}));\n/**\n * Waits until container connects to delta storage and gets up-to-date\n * Useful when resolving URIs and hitting 404, due to container being loaded from (stale) snapshot and not being\n * up to date. Host may chose to wait in such case and retry resolving URI.\n * Warning: Will wait infinitely for connection to establish if there is no connection.\n * May result in deadlock if Container.setAutoReconnect(false) is called and never switched back to auto-reconnect.\n * @returns true: container is up to date, it processed all the ops that were know at the time of first connection\n *          false: storage does not provide indication of how far the client is. Container processed\n *          all the ops known to it, but it maybe still behind.\n */\nexport async function waitContainerToCatchUp(container) {\n    // Make sure we stop waiting if container is closed.\n    if (container.closed) {\n        throw new Error(\"Container is closed\");\n    }\n    return new Promise((accept, reject) => {\n        const deltaManager = container.deltaManager;\n        container.on(\"closed\", reject);\n        const waitForOps = () => {\n            assert(container.connectionState !== ConnectionState.Disconnected, 0x0cd /* \"Container disconnected while waiting for ops!\" */);\n            const hasCheckpointSequenceNumber = deltaManager.hasCheckpointSequenceNumber;\n            const connectionOpSeqNumber = deltaManager.lastKnownSeqNumber;\n            if (deltaManager.lastSequenceNumber === connectionOpSeqNumber) {\n                accept(hasCheckpointSequenceNumber);\n                return;\n            }\n            const callbackOps = (message) => {\n                if (connectionOpSeqNumber <= message.sequenceNumber) {\n                    accept(hasCheckpointSequenceNumber);\n                    deltaManager.off(\"op\", callbackOps);\n                }\n            };\n            deltaManager.on(\"op\", callbackOps);\n        };\n        if (container.connectionState !== ConnectionState.Disconnected) {\n            waitForOps();\n            return;\n        }\n        const callback = () => {\n            deltaManager.off(connectEventName, callback);\n            waitForOps();\n        };\n        deltaManager.on(connectEventName, callback);\n        container.resume();\n    });\n}\nexport class CollabWindowTracker {\n    constructor(submit, activeConnection, NoopTimeFrequency = 2000, NoopCountFrequency = 300) {\n        this.submit = submit;\n        this.activeConnection = activeConnection;\n        this.NoopTimeFrequency = NoopTimeFrequency;\n        this.NoopCountFrequency = NoopCountFrequency;\n        this.opsCountSinceNoop = 0;\n    }\n    /**\n     * Schedules as ack to the server to update the reference sequence number\n     */\n    scheduleSequenceNumberUpdate(message, immediateNoOp) {\n        // Exit early for inactive (not in quorum or not writers) clients.\n        // They don't take part in the minimum sequence number calculation.\n        if (!this.activeConnection()) {\n            this.stopSequenceNumberUpdate();\n            return;\n        }\n        // While processing a message, an immediate no-op can be requested.\n        // i.e. to expedite approve or commit phase of quorum.\n        if (immediateNoOp) {\n            this.stopSequenceNumberUpdate();\n            this.submit(MessageType.NoOp, \"\"); // This can be anything other than null\n            return;\n        }\n        // Filter out system messages.\n        if (isSystemMessage(message)) {\n            return;\n        }\n        // We don't acknowledge no-ops to avoid acknowledgement cycles (i.e. ack the MSN\n        // update, which updates the MSN, then ack the update, etc...). Also, don't\n        // count system messages in ops count.\n        assert(message.type !== MessageType.NoOp, 0x0ce /* \"Don't acknowledge no-ops\" */);\n        if (this.lastNoopTime === undefined) {\n            this.lastNoopTime = Date.now();\n        }\n        this.opsCountSinceNoop++;\n        // If the ops count since last op is greater than NoopCountFrequency and time since last noop is\n        // greater than NoopTimeFrequency, then send a Noop.\n        // We will send a message(Noop) to update our reference sequence number upon receiving a server\n        // operation. This allows the server to know our true reference sequence number and be able to\n        // correctly update the minimum sequence number (MSN).\n        if (this.opsCountSinceNoop >= this.NoopCountFrequency\n            && Date.now() - this.lastNoopTime >= this.NoopTimeFrequency) {\n            this.stopSequenceNumberUpdate();\n            this.submit(MessageType.NoOp, null);\n        }\n    }\n    stopSequenceNumberUpdate() {\n        this.opsCountSinceNoop = 0;\n        this.lastNoopTime = undefined;\n    }\n}\nexport class Container extends EventEmitterWithErrorHandling {\n    constructor(loader, config) {\n        var _a, _b;\n        super();\n        this.loader = loader;\n        // Tells if container can reconnect on losing fist connection\n        // If false, container gets closed on loss of connection.\n        this._canReconnect = true;\n        this.loaded = false;\n        this._attachState = AttachState.Detached;\n        this.resumedOpProcessingAfterLoad = false;\n        this.firstConnection = true;\n        this.manualReconnectInProgress = false;\n        this.connectionTransitionTimes = [];\n        this.messageCountAfterDisconnection = 0;\n        this.attachInProgress = false;\n        this._dirtyContainer = false;\n        this._closed = false;\n        this.collabWindowTracker = new CollabWindowTracker((type, contents) => this._deltaManager.submit(type, contents), () => this.activeConnection(), (_a = this.loader.services.options) === null || _a === void 0 ? void 0 : _a.noopTimeFrequency, (_b = this.loader.services.options) === null || _b === void 0 ? void 0 : _b.noopCountFrequency);\n        this._audience = new Audience();\n        // Initialize from config\n        this.containerUrl = config.containerUrl;\n        this.clientDetailsOverride = config.clientDetailsOverride;\n        this._id = config.id;\n        this._resolvedUrl = config.resolvedUrl;\n        if (config.canReconnect !== undefined) {\n            this._canReconnect = config.canReconnect;\n        }\n        // Create logger for data stores to use\n        const type = this.client.details.type;\n        const interactive = this.client.details.capabilities.interactive;\n        const clientType = `${interactive ? \"interactive\" : \"noninteractive\"}${type !== undefined && type !== \"\" ? `/${type}` : \"\"}`;\n        // Need to use the property getter for docId because for detached flow we don't have the docId initially.\n        // We assign the id later so property getter is used.\n        this.subLogger = ChildLogger.create(loader.services.subLogger, undefined, {\n            all: {\n                clientType,\n                loaderVersion: pkgVersion,\n                containerId: uuid(),\n                docId: () => this.id,\n                containerAttachState: () => this._attachState,\n                containerLoaded: () => this.loaded,\n            },\n            // we need to be judicious with our logging here to avoid generting too much data\n            // all data logged here should be broadly applicable, and not specific to a\n            // specific error or class of errors\n            error: {\n                // load information to associate errors with the specific load point\n                dmInitialSeqNumber: () => { var _a; return (_a = this._deltaManager) === null || _a === void 0 ? void 0 : _a.initialSequenceNumber; },\n                dmLastKnownSeqNumber: () => { var _a; return (_a = this._deltaManager) === null || _a === void 0 ? void 0 : _a.lastKnownSeqNumber; },\n                containerLoadedFromVersionId: () => { var _a; return (_a = this.loadedFromVersion) === null || _a === void 0 ? void 0 : _a.id; },\n                containerLoadedFromVersionDate: () => { var _a; return (_a = this.loadedFromVersion) === null || _a === void 0 ? void 0 : _a.date; },\n                // message information to associate errors with the specific execution state\n                dmLastMsqSeqNumber: () => { var _a, _b; return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.sequenceNumber; },\n                dmLastMsqSeqTimestamp: () => { var _a, _b; return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.timestamp; },\n                dmLastMsqSeqClientId: () => { var _a, _b; return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.clientId; },\n            },\n        });\n        // Prefix all events in this file with container-loader\n        this.logger = ChildLogger.create(this.subLogger, \"Container\");\n        this.connectionStateHandler = new ConnectionStateHandler({\n            protocolHandler: () => this._protocolHandler,\n            logConnectionStateChangeTelemetry: (value, oldState, reason) => this.logConnectionStateChangeTelemetry(value, oldState, reason),\n            propagateConnectionState: () => this.propagateConnectionState(),\n            isContainerLoaded: () => this.loaded,\n            shouldClientJoinWrite: () => this._deltaManager.shouldJoinWrite(),\n            maxClientLeaveWaitTime: this.loader.services.options.maxClientLeaveWaitTime,\n        }, this.logger);\n        this.connectionStateHandler.on(connectEventName, (opsBehind) => {\n            this.emit(connectEventName, opsBehind);\n        });\n        this._deltaManager = this.createDeltaManager();\n        // keep track of last time page was visible for telemetry\n        if (typeof document === \"object\" && document !== null) {\n            this.lastVisible = document.hidden ? performance.now() : undefined;\n            document.addEventListener(\"visibilitychange\", () => {\n                if (document.hidden) {\n                    this.lastVisible = performance.now();\n                }\n                else {\n                    // settimeout so this will hopefully fire after disconnect event if being hidden caused it\n                    setTimeout(() => this.lastVisible = undefined, 0);\n                }\n            });\n        }\n        // We observed that most users of platform do not check Container.connected event on load, causing bugs.\n        // As such, we are raising events when new listener pops up.\n        // Note that we can raise both \"disconnected\" & \"connect\" events at the same time,\n        // if we are in connecting stage.\n        this.on(\"newListener\", (event, listener) => {\n            // Fire events on the end of JS turn, giving a chance for caller to be in consistent state.\n            Promise.resolve().then(() => {\n                switch (event) {\n                    case dirtyContainerEvent:\n                        if (this._dirtyContainer) {\n                            listener(this._dirtyContainer);\n                        }\n                        break;\n                    case savedContainerEvent:\n                        if (!this._dirtyContainer) {\n                            listener(this._dirtyContainer);\n                        }\n                        break;\n                    case connectedEventName:\n                        if (this.connected) {\n                            listener(event, this.clientId);\n                        }\n                        break;\n                    case disconnectedEventName:\n                        if (!this.connected) {\n                            listener(event);\n                        }\n                        break;\n                    case connectEventName:\n                        if (this.connectionState !== ConnectionState.Disconnected) {\n                            listener(event);\n                        }\n                        break;\n                    default:\n                }\n            }).catch((error) => {\n                this.logger.sendErrorEvent({ eventName: \"RaiseConnectedEventError\" }, error);\n            });\n        });\n    }\n    /**\n     * Load an existing container.\n     */\n    static async load(loader, loadOptions, pendingLocalState) {\n        const container = new Container(loader, {\n            containerUrl: loadOptions.containerUrl,\n            clientDetailsOverride: loadOptions.clientDetailsOverride,\n            id: loadOptions.docId,\n            resolvedUrl: loadOptions.resolvedUrl,\n            canReconnect: loadOptions.canReconnect,\n        });\n        return PerformanceEvent.timedExecAsync(container.logger, { eventName: \"Load\" }, async (event) => {\n            return new Promise((res, rej) => {\n                const version = loadOptions.version;\n                // always load unpaused with pending ops\n                const pause = pendingLocalState !== undefined ? false : loadOptions.pause;\n                const onClosed = (err) => {\n                    // Depending where error happens, we can be attempting to connect to web socket\n                    // and continuously retrying (consider offline mode)\n                    // Host has no container to close, so it's prudent to do it here\n                    const error = err !== null && err !== void 0 ? err : CreateContainerError(\"Container closed without an error\");\n                    container.close(error);\n                    rej(error);\n                };\n                container.on(\"closed\", onClosed);\n                container.load(version, pause === true, pendingLocalState)\n                    .finally(() => {\n                    container.removeListener(\"closed\", onClosed);\n                })\n                    .then((props) => {\n                    event.end(props);\n                    res(container);\n                }, (error) => {\n                    const err = CreateContainerError(error);\n                    onClosed(err);\n                });\n            });\n        });\n    }\n    /**\n     * Create a new container in a detached state.\n     */\n    static async createDetached(loader, codeDetails) {\n        const container = new Container(loader, {});\n        await container.createDetached(codeDetails);\n        return container;\n    }\n    /**\n     * Create a new container in a detached state that is initialized with a\n     * snapshot from a previous detached container.\n     */\n    static async rehydrateDetachedFromSnapshot(loader, snapshot) {\n        const container = new Container(loader, {});\n        await container.rehydrateDetachedFromSnapshot(snapshot);\n        return container;\n    }\n    get storageService() {\n        if (this._storageService === undefined) {\n            throw new Error(\"Attempted to access storageService before it was defined\");\n        }\n        return this._storageService;\n    }\n    get context() {\n        if (this._context === undefined) {\n            throw new Error(\"Attempted to access context before it was defined\");\n        }\n        return this._context;\n    }\n    get protocolHandler() {\n        if (this._protocolHandler === undefined) {\n            throw new Error(\"Attempted to access protocolHandler before it was defined\");\n        }\n        return this._protocolHandler;\n    }\n    get IFluidRouter() { return this; }\n    get resolvedUrl() {\n        return this._resolvedUrl;\n    }\n    get loadedFromVersion() {\n        return this._loadedFromVersion;\n    }\n    /**\n     * {@inheritDoc DeltaManager.readonly}\n     * @deprecated - use readOnlyInfo\n     */\n    get readonly() {\n        return this._deltaManager.readonly;\n    }\n    /**\n     * {@inheritDoc DeltaManager.readonlyPermissions}\n     * @deprecated - use readOnlyInfo\n     */\n    get readonlyPermissions() {\n        return this._deltaManager.readonlyPermissions;\n    }\n    /**\n     * {@inheritDoc DeltaManager.readOnlyInfo}\n     */\n    get readOnlyInfo() {\n        return this._deltaManager.readOnlyInfo;\n    }\n    /**\n     * {@inheritDoc DeltaManager.forceReadonly}\n     */\n    forceReadonly(readonly) {\n        this._deltaManager.forceReadonly(readonly);\n    }\n    get closed() {\n        return this._closed;\n    }\n    get id() {\n        var _a;\n        return (_a = this._id) !== null && _a !== void 0 ? _a : \"\";\n    }\n    get deltaManager() {\n        return this._deltaManager;\n    }\n    get connectionState() {\n        return this.connectionStateHandler.connectionState;\n    }\n    get connected() {\n        return this.connectionStateHandler.connected;\n    }\n    /**\n     * Service configuration details. If running in offline mode will be undefined otherwise will contain service\n     * configuration details returned as part of the initial connection.\n     */\n    get serviceConfiguration() {\n        return this._deltaManager.serviceConfiguration;\n    }\n    /**\n     * The server provided id of the client.\n     * Set once this.connected is true, otherwise undefined\n     */\n    get clientId() {\n        return this.connectionStateHandler.clientId;\n    }\n    /**\n     * The server provided claims of the client.\n     * Set once this.connected is true, otherwise undefined\n     */\n    get scopes() {\n        return this._deltaManager.scopes;\n    }\n    get clientDetails() {\n        return this._deltaManager.clientDetails;\n    }\n    /**\n     * @deprecated use codeDetails\n     */\n    get chaincodePackage() {\n        return this.codeDetails;\n    }\n    get codeDetails() {\n        var _a, _b;\n        return (_b = (_a = this._context) === null || _a === void 0 ? void 0 : _a.codeDetails) !== null && _b !== void 0 ? _b : this.getCodeDetailsFromQuorum();\n    }\n    /**\n     * Flag indicating whether the document already existed at the time of load\n     */\n    get existing() {\n        return this._existing;\n    }\n    /**\n     * Retrieves the audience associated with the document\n     */\n    get audience() {\n        return this._audience;\n    }\n    /**\n     * Returns true if container is dirty.\n     * Which means data loss if container is closed at that same moment\n     * Most likely that happens when there is no network connection to ordering service\n     */\n    get isDirty() {\n        return this._dirtyContainer;\n    }\n    get serviceFactory() { return this.loader.services.documentServiceFactory; }\n    get urlResolver() { return this.loader.services.urlResolver; }\n    get options() { return this.loader.services.options; }\n    get scope() { return this.loader.services.scope; }\n    get codeLoader() { return this.loader.services.codeLoader; }\n    /**\n     * Retrieves the quorum associated with the document\n     */\n    getQuorum() {\n        return this.protocolHandler.quorum;\n    }\n    close(error) {\n        var _a, _b, _c;\n        if (this._closed) {\n            return;\n        }\n        this._closed = true;\n        this.collabWindowTracker.stopSequenceNumberUpdate();\n        this._deltaManager.close(error);\n        (_a = this._protocolHandler) === null || _a === void 0 ? void 0 : _a.close();\n        (_b = this._context) === null || _b === void 0 ? void 0 : _b.dispose(error !== undefined ? new Error(error.message) : undefined);\n        assert(this.connectionState === ConnectionState.Disconnected, 0x0cf /* \"disconnect event was not raised!\" */);\n        if (error !== undefined) {\n            // Log current sequence number - useful if we have access to a file to understand better\n            // what op caused trouble (if it's related to op processing).\n            // Runtime may provide sequence number as part of error object - this may not match DeltaManager\n            // knowledge as old ops are processed when data stores / DDS are re-hydrated when delay-loaded\n            this.logger.sendErrorEvent({\n                eventName: \"ContainerClose\",\n                sequenceNumber: (_c = error.sequenceNumber) !== null && _c !== void 0 ? _c : this._deltaManager.lastSequenceNumber,\n            }, error);\n        }\n        else {\n            assert(this.loaded, 0x0d0 /* \"Container in non-loaded state before close!\" */);\n            this.logger.sendTelemetryEvent({ eventName: \"ContainerClose\" });\n        }\n        this.emit(\"closed\", error);\n        this.removeAllListeners();\n    }\n    closeAndGetPendingLocalState() {\n        // runtime matches pending ops to successful ones by clientId and client seq num, so we need to close the\n        // container at the same time we get pending state, otherwise this container could reconnect and resubmit with\n        // a new clientId and a future container using stale pending state without the new clientId would resubmit them\n        this._deltaManager.close();\n        assert(this.attachState === AttachState.Attached, 0x0d1 /* \"Container should be attached before close\" */);\n        assert(this.resolvedUrl !== undefined && this.resolvedUrl.type === \"fluid\", 0x0d2 /* \"resolved url should be valid Fluid url\" */);\n        const pendingState = {\n            pendingRuntimeState: this.context.getPendingLocalState(),\n            url: this.resolvedUrl.url,\n        };\n        this.close();\n        return JSON.stringify(pendingState);\n    }\n    get attachState() {\n        return this._attachState;\n    }\n    serialize() {\n        assert(this.attachState === AttachState.Detached, 0x0d3 /* \"Should only be called in detached container\" */);\n        const appSummary = this.context.createSummary();\n        const protocolSummary = this.captureProtocolSummary();\n        const snapshotTree = convertProtocolAndAppSummaryToSnapshotTree(protocolSummary, appSummary);\n        return JSON.stringify(snapshotTree);\n    }\n    async attach(request) {\n        var _a;\n        assert(this.loaded, 0x0d4 /* \"not loaded\" */);\n        assert(!this.closed, 0x0d5 /* \"closed\" */);\n        // If container is already attached or attach is in progress, return.\n        if (this._attachState === AttachState.Attached || this.attachInProgress) {\n            return;\n        }\n        this.attachInProgress = true;\n        try {\n            assert(this.deltaManager.inbound.length === 0, 0x0d6 /* \"Inbound queue should be empty when attaching\" */);\n            // Only take a summary if the container is in detached state, otherwise we could have local changes.\n            // In failed attach call, we would already have a summary cached.\n            if (this._attachState === AttachState.Detached) {\n                // Get the document state post attach - possibly can just call attach but we need to change the\n                // semantics around what the attach means as far as async code goes.\n                const appSummary = this.context.createSummary();\n                const protocolSummary = this.captureProtocolSummary();\n                this.cachedAttachSummary = combineAppAndProtocolSummary(appSummary, protocolSummary);\n                // Set the state as attaching as we are starting the process of attaching container.\n                // This should be fired after taking the summary because it is the place where we are\n                // starting to attach the container to storage.\n                // Also, this should only be fired in detached container.\n                this._attachState = AttachState.Attaching;\n                this.emit(\"attaching\");\n            }\n            assert(!!this.cachedAttachSummary, 0x0d7 /* \"Summary should be there either by this attach call or previous attach call!!\" */);\n            const createNewResolvedUrl = await this.urlResolver.resolve(request);\n            ensureFluidResolvedUrl(createNewResolvedUrl);\n            // Actually go and create the resolved document\n            if (this.service === undefined) {\n                this.service = await this.serviceFactory.createContainer(this.cachedAttachSummary, createNewResolvedUrl, this.subLogger);\n            }\n            const resolvedUrl = this.service.resolvedUrl;\n            ensureFluidResolvedUrl(resolvedUrl);\n            this._resolvedUrl = resolvedUrl;\n            const url = await this.urlResolver.getAbsoluteUrl(resolvedUrl, \"\", (_a = this._context) === null || _a === void 0 ? void 0 : _a.codeDetails);\n            assert(url !== undefined, 0x0d8 /* \"Container url undefined\" */);\n            this.containerUrl = url;\n            const parsedUrl = parseUrl(resolvedUrl.url);\n            if (parsedUrl === undefined) {\n                throw new Error(\"Unable to parse Url\");\n            }\n            const [, docId] = parsedUrl.id.split(\"/\");\n            this._id = decodeURI(docId);\n            if (this._storageService === undefined) {\n                this._storageService = await this.getDocumentStorageService();\n            }\n            // This we can probably just pass the storage service to the blob manager - although ideally\n            // there just isn't a blob manager\n            this._attachState = AttachState.Attached;\n            this.emit(\"attached\");\n            this.cachedAttachSummary = undefined;\n            // Propagate current connection state through the system.\n            this.propagateConnectionState();\n            if (!this.closed) {\n                this.resumeInternal({ fetchOpsFromStorage: false, reason: \"createDetached\" });\n            }\n        }\n        finally {\n            this.attachInProgress = false;\n        }\n    }\n    async request(path) {\n        return PerformanceEvent.timedExecAsync(this.logger, { eventName: \"Request\" }, async () => {\n            return this.context.request(path);\n        });\n    }\n    async snapshot(tagMessage, fullTree = false) {\n        // Only snapshot once a code quorum has been established\n        if (!this.protocolHandler.quorum.has(\"code\") && !this.protocolHandler.quorum.has(\"code2\")) {\n            this.logger.sendTelemetryEvent({ eventName: \"SkipSnapshot\" });\n            return;\n        }\n        // Stop inbound message processing while we complete the snapshot\n        try {\n            await this.deltaManager.inbound.pause();\n            await this.snapshotCore(tagMessage, fullTree);\n        }\n        catch (ex) {\n            this.logger.sendErrorEvent({ eventName: \"SnapshotExceptionError\" }, ex);\n            throw ex;\n        }\n        finally {\n            this.deltaManager.inbound.resume();\n        }\n    }\n    setAutoReconnect(reconnect) {\n        if (reconnect && this.closed) {\n            throw new Error(\"Attempting to setAutoReconnect() a closed DeltaManager\");\n        }\n        this._deltaManager.setAutomaticReconnect(reconnect);\n        this.logger.sendTelemetryEvent({\n            eventName: reconnect ? \"AutoReconnectEnabled\" : \"AutoReconnectDisabled\",\n            connectionMode: this._deltaManager.connectionMode,\n            connectionState: ConnectionState[this.connectionState],\n        });\n        // If container state is not attached and resumed, then don't connect to delta stream. Also don't set the\n        // manual reconnection flag to true as we haven't made the initial connection yet.\n        if (reconnect && this._attachState === AttachState.Attached && this.resumedOpProcessingAfterLoad) {\n            if (this.connectionState === ConnectionState.Disconnected) {\n                // Only track this as a manual reconnection if we are truly the ones kicking it off.\n                this.manualReconnectInProgress = true;\n            }\n            // Ensure connection to web socket\n            this.connectToDeltaStream({ reason: \"autoReconnect\" }).catch((error) => {\n                // All errors are reported through events (\"error\" / \"disconnected\") and telemetry in DeltaManager\n                // So there shouldn't be a need to record error here.\n                // But we have number of cases where reconnects do not happen, and no errors are recorded, so\n                // adding this log point for easier diagnostics\n                this.logger.sendTelemetryEvent({ eventName: \"setAutoReconnectError\" }, error);\n            });\n        }\n    }\n    resume() {\n        if (!this.closed) {\n            this.resumeInternal({ reason: \"DocumentOpenResume\" });\n        }\n    }\n    resumeInternal(args) {\n        assert(!this.closed, 0x0d9 /* \"Attempting to setAutoReconnect() a closed DeltaManager\" */);\n        // Resume processing ops\n        if (!this.resumedOpProcessingAfterLoad) {\n            this.resumedOpProcessingAfterLoad = true;\n            this._deltaManager.inbound.resume();\n            this._deltaManager.outbound.resume();\n            this._deltaManager.inboundSignal.resume();\n        }\n        // Ensure connection to web socket\n        // All errors are reported through events (\"error\" / \"disconnected\") and telemetry in DeltaManager\n        this.connectToDeltaStream(args).catch(() => { });\n    }\n    get storage() {\n        return this._storageService;\n    }\n    /**\n     * Raise non-critical error to host. Calling this API will not close container.\n     * For critical errors, please call Container.close(error).\n     * @param error - an error to raise\n     */\n    raiseContainerWarning(warning) {\n        // Some \"warning\" events come from outside the container and are logged\n        // elsewhere (e.g. summarizing container). We shouldn't log these here.\n        if (warning.logged !== true) {\n            this.logContainerError(warning);\n        }\n        this.emit(\"warning\", warning);\n    }\n    async reloadContext() {\n        return this.reloadContextCore().catch((error) => {\n            this.close(CreateContainerError(error));\n            throw error;\n        });\n    }\n    hasNullRuntime() {\n        return this.context.hasNullRuntime();\n    }\n    async getAbsoluteUrl(relativeUrl) {\n        var _a;\n        if (this.resolvedUrl === undefined) {\n            return undefined;\n        }\n        return this.urlResolver.getAbsoluteUrl(this.resolvedUrl, relativeUrl, (_a = this._context) === null || _a === void 0 ? void 0 : _a.codeDetails);\n    }\n    async proposeCodeDetails(codeDetails) {\n        if (!isFluidCodeDetails(codeDetails)) {\n            throw new Error(\"Provided codeDetails are not IFluidCodeDetails\");\n        }\n        if (this.codeLoader.IFluidCodeDetailsComparer) {\n            const comparision = await this.codeLoader.IFluidCodeDetailsComparer.compare(codeDetails, this.getCodeDetailsFromQuorum());\n            if (comparision !== undefined && comparision <= 0) {\n                throw new Error(\"Proposed code details should be greater than the current\");\n            }\n        }\n        return this.getQuorum().propose(\"code\", codeDetails)\n            .then(() => true)\n            .catch(() => false);\n    }\n    async reloadContextCore() {\n        var _a, _b, _c;\n        const codeDetails = this.getCodeDetailsFromQuorum();\n        await Promise.all([\n            this.deltaManager.inbound.pause(),\n            this.deltaManager.inboundSignal.pause()\n        ]);\n        if ((await this.context.satisfies(codeDetails) === true) && !this.hasNullRuntime()) {\n            this.deltaManager.inbound.resume();\n            this.deltaManager.inboundSignal.resume();\n            return;\n        }\n        let state = { hotSwap: false };\n        if (this.options.hotSwapContext === true) {\n            const prevState = await this.context.snapshotRuntimeState();\n            state = { hotSwap: true, prevState };\n        }\n        this.context.dispose(new Error(\"ContextDisposedForReload\"));\n        // We always hot-swap, but we don't fire the contextDisposed event\n        // if we are transitioning from a null runtime to a real runtime\n        // with detached container we no longer need the null runtime, but for legacy\n        // reasons need to keep it around (old documents without summary before code proposal).\n        // client's shouldn't need to care about this transition, as it is a implementation detail.\n        // if we didn't do this check, the clients would need to do it themselves,\n        // which would futher spread the usage of the hasNullRuntime property\n        // making it harder to deprecate.\n        if (this.hasNullRuntime()) {\n            if (!state.hotSwap) {\n                state = { hotSwap: true, prevState: {} };\n            }\n        }\n        else {\n            this.emit(\"contextDisposed\", codeDetails, (_a = this.context) === null || _a === void 0 ? void 0 : _a.codeDetails);\n        }\n        if (this.closed) {\n            return;\n        }\n        if (!state.hotSwap) {\n            this.close();\n            return;\n        }\n        let snapshot;\n        const blobs = new Map();\n        if (state.prevState.snapshot !== undefined) {\n            snapshot = buildSnapshotTree(state.prevState.snapshot.entries, blobs);\n            /**\n             * Should be removed / updated after issue #2914 is fixed.\n             * There are currently two scenarios where this is called:\n             * 1. When a new code proposal is accepted - This should be set to true before `this.loadContext` is\n             * called which creates and loads the ContainerRuntime. This is because for \"read\" mode clients this\n             * flag is false which causes ContainerRuntime to create the internal components again.\n             * 2. When the first client connects in \"write\" mode - This happens when a client does not create the\n             * Container in detached mode. In this case, when the code proposal is accepted, we come here and we\n             * need to create the internal data stores in ContainerRuntime.\n             * Once we move to using detached container everywhere, this can move outside this block.\n             */\n            this._existing = true;\n        }\n        if (blobs.size > 0) {\n            const blobSize = (_b = this.storageService.policies) === null || _b === void 0 ? void 0 : _b.minBlobSize;\n            this._storageService =\n                new BlobCacheStorageService(this.storageService, blobs);\n            // ensure we did not lose that policy in the process of wrapping\n            assert(blobSize === ((_c = this._storageService.policies) === null || _c === void 0 ? void 0 : _c.minBlobSize), 0x0da /* \"blob size policy\" */);\n        }\n        const attributes = {\n            branch: this.id,\n            minimumSequenceNumber: this._deltaManager.minimumSequenceNumber,\n            sequenceNumber: this._deltaManager.lastSequenceNumber,\n            term: this._deltaManager.referenceTerm,\n        };\n        await this.loadContext(codeDetails, attributes, snapshot, state.prevState);\n        this.deltaManager.inbound.resume();\n        this.deltaManager.inboundSignal.resume();\n    }\n    async snapshotCore(tagMessage, fullTree = false) {\n        // Snapshots base document state and currently running context\n        const root = this.snapshotBase();\n        const dataStoreEntries = await this.context.snapshot(tagMessage, fullTree);\n        // And then combine\n        if (dataStoreEntries !== null) {\n            root.entries.push(...dataStoreEntries.entries);\n        }\n        // Generate base snapshot message\n        const deltaDetails = `${this._deltaManager.lastSequenceNumber}:${this._deltaManager.minimumSequenceNumber}`;\n        const message = `Commit @${deltaDetails} ${tagMessage}`;\n        // Pull in the prior version and snapshot tree to store against\n        const lastVersion = await this.getVersion(this.id);\n        const parents = lastVersion !== undefined ? [lastVersion.id] : [];\n        // Write the full snapshot\n        return this.storageService.write(root, parents, message, \"\");\n    }\n    snapshotBase() {\n        const entries = [];\n        const quorumSnapshot = this.protocolHandler.quorum.snapshot();\n        entries.push({\n            mode: FileMode.File,\n            path: \"quorumMembers\",\n            type: TreeEntry.Blob,\n            value: {\n                contents: JSON.stringify(quorumSnapshot.members),\n                encoding: \"utf-8\",\n            },\n        });\n        entries.push({\n            mode: FileMode.File,\n            path: \"quorumProposals\",\n            type: TreeEntry.Blob,\n            value: {\n                contents: JSON.stringify(quorumSnapshot.proposals),\n                encoding: \"utf-8\",\n            },\n        });\n        entries.push({\n            mode: FileMode.File,\n            path: \"quorumValues\",\n            type: TreeEntry.Blob,\n            value: {\n                contents: JSON.stringify(quorumSnapshot.values),\n                encoding: \"utf-8\",\n            },\n        });\n        // Save attributes for the document\n        const documentAttributes = {\n            branch: this.id,\n            minimumSequenceNumber: this._deltaManager.minimumSequenceNumber,\n            sequenceNumber: this._deltaManager.lastSequenceNumber,\n            term: this._deltaManager.referenceTerm,\n        };\n        entries.push({\n            mode: FileMode.File,\n            path: \".attributes\",\n            type: TreeEntry.Blob,\n            value: {\n                contents: JSON.stringify(documentAttributes),\n                encoding: \"utf-8\",\n            },\n        });\n        // Output the tree\n        const root = {\n            entries,\n        };\n        return root;\n    }\n    async getVersion(version) {\n        const versions = await this.storageService.getVersions(version, 1);\n        return versions[0];\n    }\n    recordConnectStartTime() {\n        if (this.connectionTransitionTimes[ConnectionState.Disconnected] === undefined) {\n            this.connectionTransitionTimes[ConnectionState.Disconnected] = performance.now();\n        }\n    }\n    async connectToDeltaStream(args) {\n        this.recordConnectStartTime();\n        // All agents need \"write\" access, including summarizer.\n        if (!this._canReconnect || !this.client.details.capabilities.interactive) {\n            args.mode = \"write\";\n        }\n        return this._deltaManager.connect(args);\n    }\n    /**\n     * Load container.\n     *\n     * @param specifiedVersion - one of the following\n     *   - null: use ops, no snapshots\n     *   - undefined - fetch latest snapshot\n     *   - otherwise, version sha to load snapshot\n     * @param pause - start the container in a paused state\n     */\n    async load(specifiedVersion, pause, pendingLocalState) {\n        if (this._resolvedUrl === undefined) {\n            throw new Error(\"Attempting to load without a resolved url\");\n        }\n        this.service = await this.serviceFactory.createDocumentService(this._resolvedUrl, this.subLogger);\n        let startConnectionP;\n        // Ideally we always connect as \"read\" by default.\n        // Currently that works with SPO & r11s, because we get \"write\" connection when connecting to non-existing file.\n        // We should not rely on it by (one of them will address the issue, but we need to address both)\n        // 1) switching create new flow to one where we create file by posting snapshot\n        // 2) Fixing quorum workflows (have retry logic)\n        // That all said, \"read\" does not work with memorylicious workflows (that opens two simultaneous\n        // connections to same file) in two ways:\n        // A) creation flow breaks (as one of the clients \"sees\" file as existing, and hits #2 above)\n        // B) Once file is created, transition from view-only connection to write does not work - some bugs to be fixed.\n        const connectionArgs = { reason: \"DocumentOpen\", mode: \"write\" };\n        // Start websocket connection as soon as possible. Note that there is no op handler attached yet, but the\n        // DeltaManager is resilient to this and will wait to start processing ops until after it is attached.\n        if (!pause) {\n            startConnectionP = this.connectToDeltaStream(connectionArgs);\n            startConnectionP.catch((error) => { });\n        }\n        this._storageService = await this.getDocumentStorageService();\n        this._attachState = AttachState.Attached;\n        // Fetch specified snapshot, but intentionally do not load from snapshot if specifiedVersion is null\n        const { snapshot, versionId } = await this.fetchSnapshotTree(specifiedVersion);\n        const attributes = await this.getDocumentAttributes(this.storageService, snapshot);\n        // Attach op handlers to start processing ops\n        this.attachDeltaManagerOpHandler(attributes);\n        // ...load in the existing quorum\n        // Initialize the protocol handler\n        const protocolHandlerP = this.loadAndInitializeProtocolState(attributes, this.storageService, snapshot);\n        let loadDetailsP;\n        // Initialize document details - if loading a snapshot use that - otherwise we need to wait on\n        // the initial details\n        if (snapshot !== undefined) {\n            this._existing = true;\n            loadDetailsP = Promise.resolve();\n        }\n        else {\n            if (startConnectionP === undefined) {\n                startConnectionP = this.connectToDeltaStream(connectionArgs);\n            }\n            // Intentionally don't .catch on this promise - we'll let any error throw below in the await.\n            loadDetailsP = startConnectionP.then((details) => {\n                this._existing = details.existing;\n            });\n        }\n        // LoadContext directly requires protocolHandler to be ready, and eventually calls\n        // instantiateRuntime which will want to know existing state.  Wait for these promises to finish.\n        [this._protocolHandler] = await Promise.all([protocolHandlerP, loadDetailsP]);\n        const codeDetails = this.getCodeDetailsFromQuorum();\n        await this.loadContext(codeDetails, attributes, snapshot, undefined, pendingLocalState);\n        // Propagate current connection state through the system.\n        this.propagateConnectionState();\n        if (!pause) {\n            this.resume();\n        }\n        // Internal context is fully loaded at this point\n        this.loaded = true;\n        return {\n            existing: this._existing,\n            sequenceNumber: attributes.sequenceNumber,\n            version: versionId,\n        };\n    }\n    async createDetached(source) {\n        if (!isFluidCodeDetails(source)) {\n            this.logger.send({\n                eventName: \"DetachCreateNotIFluidCodeDetails\",\n                category: \"warning\",\n            });\n        }\n        const attributes = {\n            branch: \"\",\n            sequenceNumber: detachedContainerRefSeqNumber,\n            term: 1,\n            minimumSequenceNumber: 0,\n        };\n        // Seed the base quorum to be an empty list with a code quorum set\n        const committedCodeProposal = {\n            key: \"code\",\n            value: source,\n            approvalSequenceNumber: 0,\n            commitSequenceNumber: 0,\n            sequenceNumber: 0,\n        };\n        const members = [];\n        const proposals = [];\n        const values = [[\"code\", committedCodeProposal]];\n        this.attachDeltaManagerOpHandler(attributes);\n        // We know this is create detached flow without snapshot.\n        this._existing = false;\n        // Need to just seed the source data in the code quorum. Quorum itself is empty\n        this._protocolHandler = this.initializeProtocolState(attributes, members, proposals, values);\n        // The load context - given we seeded the quorum - will be great\n        await this.createDetachedContext(attributes);\n        this.propagateConnectionState();\n        this.loaded = true;\n    }\n    async rehydrateDetachedFromSnapshot(snapshotTree) {\n        const attributes = await this.getDocumentAttributes(undefined, snapshotTree);\n        assert(attributes.sequenceNumber === 0, 0x0db /* \"Seq number in detached container should be 0!!\" */);\n        this.attachDeltaManagerOpHandler(attributes);\n        // We know this is create detached flow with snapshot.\n        this._existing = true;\n        // ...load in the existing quorum\n        // Initialize the protocol handler\n        this._protocolHandler =\n            await this.loadAndInitializeProtocolState(attributes, undefined, snapshotTree);\n        await this.createDetachedContext(attributes, snapshotTree);\n        this.loaded = true;\n        this.propagateConnectionState();\n    }\n    async getDocumentStorageService() {\n        return this._deltaManager.connectToStorage();\n    }\n    async getDocumentAttributes(storage, tree) {\n        if (tree === undefined) {\n            return {\n                branch: this.id,\n                minimumSequenceNumber: 0,\n                sequenceNumber: 0,\n                term: 1,\n            };\n        }\n        // Backward compatibility: old docs would have \".attributes\" instead of \"attributes\"\n        const attributesHash = \".protocol\" in tree.trees\n            ? tree.trees[\".protocol\"].blobs.attributes\n            : tree.blobs[\".attributes\"];\n        const attributes = storage !== undefined ? await readAndParse(storage, attributesHash)\n            : readAndParseFromBlobs(tree.trees[\".protocol\"].blobs, attributesHash);\n        // Backward compatibility for older summaries with no term\n        if (attributes.term === undefined) {\n            attributes.term = 1;\n        }\n        return attributes;\n    }\n    async loadAndInitializeProtocolState(attributes, storage, snapshot) {\n        let members = [];\n        let proposals = [];\n        let values = [];\n        if (snapshot !== undefined) {\n            const baseTree = \".protocol\" in snapshot.trees ? snapshot.trees[\".protocol\"] : snapshot;\n            if (storage !== undefined) {\n                [members, proposals, values] = await Promise.all([\n                    readAndParse(storage, baseTree.blobs.quorumMembers),\n                    readAndParse(storage, baseTree.blobs.quorumProposals),\n                    readAndParse(storage, baseTree.blobs.quorumValues),\n                ]);\n            }\n            else {\n                members = readAndParseFromBlobs(snapshot.trees[\".protocol\"].blobs, baseTree.blobs.quorumMembers);\n                proposals = readAndParseFromBlobs(snapshot.trees[\".protocol\"].blobs, baseTree.blobs.quorumProposals);\n                values = readAndParseFromBlobs(snapshot.trees[\".protocol\"].blobs, baseTree.blobs.quorumValues);\n            }\n        }\n        const protocolHandler = this.initializeProtocolState(attributes, members, proposals, values);\n        return protocolHandler;\n    }\n    initializeProtocolState(attributes, members, proposals, values) {\n        const protocol = new ProtocolOpHandler(attributes.minimumSequenceNumber, attributes.sequenceNumber, attributes.term, members, proposals, values, (key, value) => this.submitMessage(MessageType.Propose, { key, value }), (sequenceNumber) => this.submitMessage(MessageType.Reject, sequenceNumber));\n        const protocolLogger = ChildLogger.create(this.subLogger, \"ProtocolHandler\");\n        protocol.quorum.on(\"error\", (error) => {\n            protocolLogger.sendErrorEvent(error);\n        });\n        // Track membership changes and update connection state accordingly\n        protocol.quorum.on(\"addMember\", (clientId, details) => {\n            this.connectionStateHandler.receivedAddMemberEvent(clientId);\n        });\n        protocol.quorum.on(\"removeMember\", (clientId) => {\n            this.connectionStateHandler.receivedRemoveMemberEvent(clientId);\n        });\n        protocol.quorum.on(\"addProposal\", (proposal) => {\n            if (proposal.key === \"code\" || proposal.key === \"code2\") {\n                this.emit(\"codeDetailsProposed\", proposal.value, proposal);\n            }\n        });\n        protocol.quorum.on(\"approveProposal\", (sequenceNumber, key, value) => {\n            debug(`approved ${key}`);\n            if (key === \"code\" || key === \"code2\") {\n                debug(`codeProposal ${JSON.stringify(value)}`);\n                if (!isFluidCodeDetails(value)) {\n                    this.logger.send({\n                        eventName: \"CodeProposalNotIFluidCodeDetails\",\n                        category: \"warning\",\n                    });\n                }\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                this.reloadContext();\n            }\n        });\n        return protocol;\n    }\n    captureProtocolSummary() {\n        const quorumSnapshot = this.protocolHandler.quorum.snapshot();\n        // Save attributes for the document\n        const documentAttributes = {\n            branch: this.id,\n            minimumSequenceNumber: this.protocolHandler.minimumSequenceNumber,\n            sequenceNumber: this.protocolHandler.sequenceNumber,\n            term: this.protocolHandler.term,\n        };\n        const summary = {\n            tree: {\n                attributes: {\n                    content: JSON.stringify(documentAttributes),\n                    type: 2 /* Blob */,\n                },\n                quorumMembers: {\n                    content: JSON.stringify(quorumSnapshot.members),\n                    type: 2 /* Blob */,\n                },\n                quorumProposals: {\n                    content: JSON.stringify(quorumSnapshot.proposals),\n                    type: 2 /* Blob */,\n                },\n                quorumValues: {\n                    content: JSON.stringify(quorumSnapshot.values),\n                    type: 2 /* Blob */,\n                },\n            },\n            type: 1 /* Tree */,\n        };\n        return summary;\n    }\n    getCodeDetailsFromQuorum() {\n        const quorum = this.protocolHandler.quorum;\n        let pkg = quorum.get(\"code\");\n        // Back compat\n        if (pkg === undefined) {\n            pkg = quorum.get(\"code2\");\n        }\n        return pkg;\n    }\n    get client() {\n        var _a;\n        const client = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.client) !== undefined\n            ? this.options.client\n            : {\n                details: {\n                    capabilities: { interactive: true },\n                },\n                mode: \"read\",\n                permission: [],\n                scopes: [],\n                user: { id: \"\" },\n            };\n        if (this.clientDetailsOverride !== undefined) {\n            merge(client.details, this.clientDetailsOverride);\n        }\n        return client;\n    }\n    /**\n     * Returns true if connection is active, i.e. it's \"write\" connection and\n     * container runtime was notified about this connection (i.e. we are up-to-date and could send ops).\n     * This happens after client received its own joinOp and thus is in the quorum.\n     * If it's not true, runtime is not in position to send ops.\n     */\n    activeConnection() {\n        return this.connectionState === ConnectionState.Connected && this._deltaManager.connectionMode === \"write\";\n    }\n    createDeltaManager() {\n        const deltaManager = new DeltaManager(() => this.service, this.client, ChildLogger.create(this.subLogger, \"DeltaManager\"), this._canReconnect, () => this.activeConnection());\n        deltaManager.on(connectEventName, (details, opsBehind) => {\n            var _a;\n            this.connectionStateHandler.receivedConnectEvent(this._deltaManager.connectionMode, details, opsBehind);\n            // Back-compat for new client and old server.\n            this._audience.clear();\n            for (const priorClient of (_a = details.initialClients) !== null && _a !== void 0 ? _a : []) {\n                this._audience.addMember(priorClient.clientId, priorClient.client);\n            }\n        });\n        deltaManager.once(\"submitOp\", (message) => {\n            this.connectionStateHandler.clientSentOps(this._deltaManager.connectionMode);\n        });\n        deltaManager.on(\"disconnect\", (reason) => {\n            this.manualReconnectInProgress = false;\n            this.connectionStateHandler.receivedDisconnectEvent(reason);\n        });\n        deltaManager.on(\"throttled\", (warning) => {\n            this.raiseContainerWarning(warning);\n        });\n        deltaManager.on(\"readonly\", (readonly) => {\n            this.emit(\"readonly\", readonly);\n        });\n        return deltaManager;\n    }\n    attachDeltaManagerOpHandler(attributes) {\n        var _a;\n        this._deltaManager.on(\"closed\", (error) => {\n            this.close(error);\n        });\n        // If we're the outer frame, do we want to do this?\n        // Begin fetching any pending deltas once we know the base sequence #. Can this fail?\n        // It seems like something, like reconnection, that we would want to retry but otherwise allow\n        // the document to load\n        this._deltaManager.attachOpHandler(attributes.minimumSequenceNumber, attributes.sequenceNumber, (_a = attributes.term) !== null && _a !== void 0 ? _a : 1, {\n            process: (message) => this.processRemoteMessage(message),\n            processSignal: (message) => {\n                this.processSignal(message);\n            },\n        });\n    }\n    logConnectionStateChangeTelemetry(value, oldState, reason) {\n        // Log actual event\n        const time = performance.now();\n        this.connectionTransitionTimes[value] = time;\n        const duration = time - this.connectionTransitionTimes[oldState];\n        let durationFromDisconnected;\n        let connectionMode;\n        let connectionInitiationReason;\n        let autoReconnect;\n        let checkpointSequenceNumber;\n        let sequenceNumber;\n        let opsBehind;\n        if (value === ConnectionState.Disconnected) {\n            autoReconnect = this._deltaManager.reconnectMode;\n        }\n        else {\n            connectionMode = this._deltaManager.connectionMode;\n            sequenceNumber = this.deltaManager.lastSequenceNumber;\n            if (value === ConnectionState.Connected) {\n                durationFromDisconnected = time - this.connectionTransitionTimes[ConnectionState.Disconnected];\n                durationFromDisconnected = TelemetryLogger.formatTick(durationFromDisconnected);\n            }\n            else {\n                // This info is of most interest on establishing connection only.\n                checkpointSequenceNumber = this.deltaManager.lastKnownSeqNumber;\n                if (this.deltaManager.hasCheckpointSequenceNumber) {\n                    opsBehind = checkpointSequenceNumber - sequenceNumber;\n                }\n            }\n            if (this.firstConnection) {\n                connectionInitiationReason = \"InitialConnect\";\n            }\n            else if (this.manualReconnectInProgress) {\n                connectionInitiationReason = \"ManualReconnect\";\n            }\n            else {\n                connectionInitiationReason = \"AutoReconnect\";\n            }\n        }\n        this.logger.sendPerformanceEvent({\n            eventName: `ConnectionStateChange_${ConnectionState[value]}`,\n            from: ConnectionState[oldState],\n            duration,\n            durationFromDisconnected,\n            reason,\n            connectionInitiationReason,\n            socketDocumentId: this._deltaManager.socketDocumentId,\n            pendingClientId: this.connectionStateHandler.pendingClientId,\n            clientId: this.clientId,\n            connectionMode,\n            autoReconnect,\n            opsBehind,\n            online: OnlineStatus[isOnline()],\n            lastVisible: this.lastVisible !== undefined ? performance.now() - this.lastVisible : undefined,\n            checkpointSequenceNumber,\n            sequenceNumber,\n        });\n        if (value === ConnectionState.Connected) {\n            this.firstConnection = false;\n            this.manualReconnectInProgress = false;\n        }\n    }\n    propagateConnectionState() {\n        const logOpsOnReconnect = this.connectionState === ConnectionState.Connected &&\n            !this.firstConnection &&\n            this._deltaManager.connectionMode === \"write\";\n        if (logOpsOnReconnect) {\n            this.messageCountAfterDisconnection = 0;\n        }\n        const state = this.connectionState === ConnectionState.Connected;\n        if (!this.context.disposed) {\n            this.context.setConnectionState(state, this.clientId);\n        }\n        assert(this.protocolHandler !== undefined, 0x0dc /* \"Protocol handler should be set here\" */);\n        this.protocolHandler.quorum.setConnectionState(state, this.clientId);\n        raiseConnectedEvent(this.logger, this, state, this.clientId);\n        if (logOpsOnReconnect) {\n            this.logger.sendTelemetryEvent({ eventName: \"OpsSentOnReconnect\", count: this.messageCountAfterDisconnection });\n        }\n    }\n    submitContainerMessage(type, contents, batch, metadata) {\n        const outboundMessageType = type;\n        switch (outboundMessageType) {\n            case MessageType.Operation:\n            case MessageType.RemoteHelp:\n            case MessageType.Summarize:\n                break;\n            default:\n                this.close(CreateContainerError(`Runtime can't send arbitrary message type: ${type}`));\n                return -1;\n        }\n        return this.submitMessage(type, contents, batch, metadata);\n    }\n    submitMessage(type, contents, batch, metadata) {\n        if (this.connectionState !== ConnectionState.Connected) {\n            this.logger.sendErrorEvent({ eventName: \"SubmitMessageWithNoConnection\", type });\n            return -1;\n        }\n        this.messageCountAfterDisconnection += 1;\n        this.collabWindowTracker.stopSequenceNumberUpdate();\n        return this._deltaManager.submit(type, contents, batch, metadata);\n    }\n    processRemoteMessage(message) {\n        // Check and report if we're getting messages from a clientId that we previously\n        // flagged as shouldHaveLeft, or from a client that's not in the quorum but should be\n        if (message.clientId != null) {\n            let errorMsg;\n            const client = this.getQuorum().getMember(message.clientId);\n            if (client === undefined && message.type !== MessageType.ClientJoin) {\n                errorMsg = \"messageClientIdMissingFromQuorum\";\n            }\n            else if ((client === null || client === void 0 ? void 0 : client.shouldHaveLeft) === true) {\n                errorMsg = \"messageClientIdShouldHaveLeft\";\n            }\n            if (errorMsg !== undefined) {\n                const error = new DataCorruptionError(errorMsg, extractSafePropertiesFromMessage(message));\n                this.close(CreateContainerError(error));\n            }\n        }\n        const local = this.clientId === message.clientId;\n        // Forward non system messages to the loaded runtime for processing\n        if (!isSystemMessage(message)) {\n            this.context.process(message, local, undefined);\n        }\n        // Allow the protocol handler to process the message\n        const result = this.protocolHandler.processMessage(message, local);\n        this.collabWindowTracker.scheduleSequenceNumberUpdate(message, result.immediateNoOp === true);\n        this.emit(\"op\", message);\n        return result;\n    }\n    submitSignal(message) {\n        this._deltaManager.submitSignal(JSON.stringify(message));\n    }\n    processSignal(message) {\n        // No clientId indicates a system signal message.\n        if (message.clientId === null) {\n            const innerContent = message.content;\n            if (innerContent.type === MessageType.ClientJoin) {\n                const newClient = innerContent.content;\n                this._audience.addMember(newClient.clientId, newClient.client);\n            }\n            else if (innerContent.type === MessageType.ClientLeave) {\n                const leftClientId = innerContent.content;\n                this._audience.removeMember(leftClientId);\n            }\n        }\n        else {\n            const local = this.clientId === message.clientId;\n            this.context.processSignal(message, local);\n        }\n    }\n    /**\n     * Get the most recent snapshot, or a specific version.\n     * @param specifiedVersion - The specific version of the snapshot to retrieve\n     * @returns The snapshot requested, or the latest snapshot if no version was specified, plus version ID\n     */\n    async fetchSnapshotTree(specifiedVersion) {\n        var _a;\n        if (specifiedVersion === null) {\n            return {};\n        }\n        const version = await this.getVersion(specifiedVersion !== null && specifiedVersion !== void 0 ? specifiedVersion : this.id);\n        if (version === undefined && specifiedVersion !== undefined) {\n            // We should have a defined version to load from if specified version requested\n            this.logger.sendErrorEvent({ eventName: \"NoVersionFoundWhenSpecified\", id: specifiedVersion });\n        }\n        this._loadedFromVersion = version;\n        const snapshot = (_a = await this.storageService.getSnapshotTree(version)) !== null && _a !== void 0 ? _a : undefined;\n        if (snapshot === undefined && version !== undefined) {\n            this.logger.sendErrorEvent({ eventName: \"getSnapshotTreeFailed\", id: version.id });\n        }\n        return { snapshot, versionId: version === null || version === void 0 ? void 0 : version.id };\n    }\n    async loadContext(codeDetails, attributes, snapshot, previousRuntimeState = {}, pendingLocalState) {\n        var _a, _b;\n        assert(((_a = this._context) === null || _a === void 0 ? void 0 : _a.disposed) !== false, 0x0dd /* \"Existing context not disposed\" */);\n        // If this assert fires, our state tracking is likely not synchronized between COntainer & runtime.\n        if (this._dirtyContainer) {\n            this.logger.sendErrorEvent({ eventName: \"DirtyContainerReloadContainer\" });\n        }\n        // The relative loader will proxy requests to '/' to the loader itself assuming no non-cache flags\n        // are set. Global requests will still go directly to the loader\n        const loader = new RelativeLoader(this.loader, () => this.containerUrl);\n        const previousCodeDetails = (_b = this._context) === null || _b === void 0 ? void 0 : _b.codeDetails;\n        this._context = await ContainerContext.createOrLoad(this, this.scope, this.codeLoader, codeDetails, snapshot, attributes, new DeltaManagerProxy(this._deltaManager), new QuorumProxy(this.protocolHandler.quorum), loader, (warning) => this.raiseContainerWarning(warning), (type, contents, batch, metadata) => this.submitContainerMessage(type, contents, batch, metadata), (message) => this.submitSignal(message), (error) => this.close(error), Container.version, previousRuntimeState, (dirty) => {\n            this._dirtyContainer = dirty;\n            this.emit(dirty ? dirtyContainerEvent : savedContainerEvent);\n        }, pendingLocalState);\n        loader.resolveContainer(this);\n        this.emit(\"contextChanged\", codeDetails, previousCodeDetails);\n    }\n    /**\n     * Creates a new, unattached container context\n     */\n    async createDetachedContext(attributes, snapshot) {\n        const codeDetails = this.getCodeDetailsFromQuorum();\n        if (codeDetails === undefined) {\n            throw new Error(\"pkg should be provided in create flow!!\");\n        }\n        await this.loadContext(codeDetails, attributes, snapshot);\n    }\n    // Please avoid calling it directly.\n    // raiseContainerWarning() is the right flow for most cases\n    logContainerError(warning) {\n        this.logger.sendErrorEvent({ eventName: \"ContainerWarning\" }, warning);\n    }\n}\nContainer.version = \"^0.1.0\";\n//# sourceMappingURL=container.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { AttachState, } from \"@fluidframework/container-definitions\";\nimport { PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nimport { assert, LazyPromise } from \"@fluidframework/common-utils\";\nimport { NullChaincode, NullRuntime } from \"./nullRuntime\";\nconst PackageNotFactoryError = \"Code package does not implement IRuntimeFactory\";\nexport class ContainerContext {\n    constructor(container, scope, codeLoader, codeDetails, _baseSnapshot, attributes, deltaManager, quorum, loader, raiseContainerWarning, submitFn, submitSignalFn, closeFn, version, previousRuntimeState, updateDirtyContainerState, pendingLocalState) {\n        this.container = container;\n        this.scope = scope;\n        this.codeLoader = codeLoader;\n        this.codeDetails = codeDetails;\n        this._baseSnapshot = _baseSnapshot;\n        this.attributes = attributes;\n        this.deltaManager = deltaManager;\n        this.quorum = quorum;\n        this.loader = loader;\n        this.raiseContainerWarning = raiseContainerWarning;\n        this.submitFn = submitFn;\n        this.submitSignalFn = submitSignalFn;\n        this.closeFn = closeFn;\n        this.version = version;\n        this.previousRuntimeState = previousRuntimeState;\n        this.updateDirtyContainerState = updateDirtyContainerState;\n        this.pendingLocalState = pendingLocalState;\n        this._disposed = false;\n        this.fluidModuleP = new LazyPromise(async () => {\n            if (this.codeDetails === undefined) {\n                const fluidExport = new NullChaincode();\n                return {\n                    fluidExport,\n                };\n            }\n            const fluidModule = await PerformanceEvent.timedExecAsync(this.logger, { eventName: \"CodeLoad\" }, async () => this.codeLoader.load(this.codeDetails));\n            return fluidModule;\n        });\n        this.logger = container.subLogger;\n        this.attachListener();\n    }\n    static async createOrLoad(container, scope, codeLoader, codeDetails, baseSnapshot, attributes, deltaManager, quorum, loader, raiseContainerWarning, submitFn, submitSignalFn, closeFn, version, previousRuntimeState, updateDirtyContainerState, pendingLocalState) {\n        const context = new ContainerContext(container, scope, codeLoader, codeDetails, baseSnapshot, attributes, deltaManager, quorum, loader, raiseContainerWarning, submitFn, submitSignalFn, closeFn, version, previousRuntimeState, updateDirtyContainerState, pendingLocalState);\n        await context.load();\n        return context;\n    }\n    get id() {\n        return this.container.id;\n    }\n    get clientId() {\n        return this.container.clientId;\n    }\n    get clientDetails() {\n        return this.container.clientDetails;\n    }\n    get existing() {\n        return this.container.existing;\n    }\n    get branch() {\n        return this.attributes.branch;\n    }\n    get connected() {\n        return this.container.connected;\n    }\n    get canSummarize() {\n        return \"summarize\" in this.runtime;\n    }\n    get serviceConfiguration() {\n        return this.container.serviceConfiguration;\n    }\n    get audience() {\n        return this.container.audience;\n    }\n    get options() {\n        return this.container.options;\n    }\n    get configuration() {\n        const config = {\n            scopes: this.container.scopes,\n        };\n        return config;\n    }\n    get baseSnapshot() {\n        return this._baseSnapshot;\n    }\n    get storage() {\n        return this.container.storage;\n    }\n    get runtime() {\n        if (this._runtime === undefined) {\n            throw new Error(\"Attempted to access runtime before it was defined\");\n        }\n        return this._runtime;\n    }\n    get disposed() {\n        return this._disposed;\n    }\n    attachListener() {\n        this.container.once(\"attaching\", () => {\n            var _a, _b;\n            (_b = (_a = this._runtime) === null || _a === void 0 ? void 0 : _a.setAttachState) === null || _b === void 0 ? void 0 : _b.call(_a, AttachState.Attaching);\n        });\n        this.container.once(\"attached\", () => {\n            var _a, _b;\n            (_b = (_a = this._runtime) === null || _a === void 0 ? void 0 : _a.setAttachState) === null || _b === void 0 ? void 0 : _b.call(_a, AttachState.Attached);\n        });\n    }\n    dispose(error) {\n        if (this._disposed) {\n            return;\n        }\n        this._disposed = true;\n        this.runtime.dispose(error);\n        this.quorum.dispose();\n        this.deltaManager.dispose();\n    }\n    async snapshot(tagMessage = \"\", fullTree = false) {\n        return this.runtime.snapshot(tagMessage, fullTree);\n    }\n    getLoadedFromVersion() {\n        return this.container.loadedFromVersion;\n    }\n    /**\n     * Snapshot and close the runtime, and return its state if available\n     */\n    async snapshotRuntimeState() {\n        return this.runtime.stop();\n    }\n    get attachState() {\n        return this.container.attachState;\n    }\n    createSummary() {\n        return this.runtime.createSummary();\n    }\n    setConnectionState(connected, clientId) {\n        const runtime = this.runtime;\n        assert(connected === this.connected, 0x0de /* \"Mismatch in connection state while setting\" */);\n        runtime.setConnectionState(connected, clientId);\n    }\n    process(message, local, context) {\n        this.runtime.process(message, local, context);\n    }\n    processSignal(message, local) {\n        this.runtime.processSignal(message, local);\n    }\n    async request(path) {\n        return this.runtime.request(path);\n    }\n    async reloadContext() {\n        return this.container.reloadContext();\n    }\n    hasNullRuntime() {\n        return this.runtime instanceof NullRuntime;\n    }\n    async getAbsoluteUrl(relativeUrl) {\n        return this.container.getAbsoluteUrl(relativeUrl);\n    }\n    getPendingLocalState() {\n        return this.runtime.getPendingLocalState();\n    }\n    /**\n     * Determines if the current code details of the context\n     * satisfy the incoming constraint code details\n     */\n    async satisfies(constraintCodeDetails) {\n        const comparers = [];\n        const maybeCompareCodeLoader = this.codeLoader;\n        if (maybeCompareCodeLoader.IFluidCodeDetailsComparer !== undefined) {\n            comparers.push(maybeCompareCodeLoader.IFluidCodeDetailsComparer);\n        }\n        const maybeCompareExport = (await this.fluidModuleP).fluidExport;\n        if ((maybeCompareExport === null || maybeCompareExport === void 0 ? void 0 : maybeCompareExport.IFluidCodeDetailsComparer) !== undefined) {\n            comparers.push(maybeCompareExport.IFluidCodeDetailsComparer);\n        }\n        // if there are not comparers it is not possible to know\n        // if the current satisfy the incoming, so return false,\n        // as assuming they do not satisfy is safer .e.g we will\n        // reload, rather than potentially running with\n        // incompatible code\n        if (comparers.length === 0) {\n            return false;\n        }\n        for (const comparer of comparers) {\n            const satisfies = await comparer.satisfies(this.codeDetails, constraintCodeDetails);\n            if (satisfies === false) {\n                return false;\n            }\n        }\n        return true;\n    }\n    async load() {\n        const maybeFactory = (await this.fluidModuleP).fluidExport.IRuntimeFactory;\n        if (maybeFactory === undefined) {\n            throw new Error(PackageNotFactoryError);\n        }\n        this._runtime = await maybeFactory.instantiateRuntime(this);\n    }\n}\n//# sourceMappingURL=containerContext.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport registerDebug from \"debug\";\nimport { pkgName, pkgVersion } from \"./packageVersion\";\nexport const debug = registerDebug(\"fluid:container-loader\");\ndebug(`Package: ${pkgName} - Version: ${pkgVersion}`);\n//# sourceMappingURL=debug.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { v4 as uuid } from \"uuid\";\nimport { ContainerErrorType, } from \"@fluidframework/container-definitions\";\nimport { assert, performance, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { PerformanceEvent, TelemetryLogger, safeRaiseEvent } from \"@fluidframework/telemetry-utils\";\nimport { LoaderCachingPolicy, } from \"@fluidframework/driver-definitions\";\nimport { isSystemMessage } from \"@fluidframework/protocol-base\";\nimport { MessageType, ScopeType, } from \"@fluidframework/protocol-definitions\";\nimport { canRetryOnError, createWriteError, createGenericNetworkError, getRetryDelayFromError, ParallelRequests, } from \"@fluidframework/driver-utils\";\nimport { CreateContainerError, CreateProcessingError, DataCorruptionError, } from \"@fluidframework/container-utils\";\nimport { debug } from \"./debug\";\nimport { DeltaQueue } from \"./deltaQueue\";\nimport { logNetworkFailure, waitForConnectedState } from \"./networkUtils\";\nimport { RetriableDocumentStorageService } from \"./retriableDocumentStorageService\";\nimport { PrefetchDocumentStorageService } from \"./prefetchDocumentStorageService\";\nconst MaxReconnectDelaySeconds = 8;\nconst InitialReconnectDelaySeconds = 1;\nconst MissingFetchDelaySeconds = 0.1;\nconst MaxFetchDelaySeconds = 10;\nconst MaxBatchDeltas = 5000; // Please see Issue #5211 for data around batch sizing\nconst DefaultChunkSize = 16 * 1024;\nfunction getNackReconnectInfo(nackContent) {\n    const reason = `Nack: ${nackContent.message}`;\n    const canRetry = nackContent.code !== 403;\n    return createGenericNetworkError(reason, canRetry, nackContent.retryAfter, nackContent.code);\n}\nfunction createReconnectError(prefix, err) {\n    const error = CreateContainerError(err);\n    const error2 = Object.create(error);\n    error2.message = `${prefix}: ${error.message}`;\n    error2.canRetry = true;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return error2;\n}\nexport var ReconnectMode;\n(function (ReconnectMode) {\n    ReconnectMode[\"Never\"] = \"Never\";\n    ReconnectMode[\"Disabled\"] = \"Disabled\";\n    ReconnectMode[\"Enabled\"] = \"Enabled\";\n})(ReconnectMode || (ReconnectMode = {}));\n/**\n * Implementation of IDocumentDeltaConnection that does not support submitting\n * or receiving ops. Used in storage-only mode.\n */\nclass NoDeltaStream extends TypedEventEmitter {\n    constructor() {\n        super(...arguments);\n        this.clientId = \"storage-only client\";\n        this.claims = {\n            scopes: [ScopeType.DocRead],\n        };\n        this.mode = \"read\";\n        this.existing = true;\n        this.maxMessageSize = 0;\n        this.version = \"\";\n        this.initialMessages = [];\n        this.initialSignals = [];\n        this.initialClients = [];\n        this.serviceConfiguration = undefined;\n        this.checkpointSequenceNumber = undefined;\n    }\n    submit(messages) {\n        this.emit(\"nack\", this.clientId, messages.map((operation) => {\n            return {\n                operation,\n                content: { message: \"Cannot submit with storage-only connection\", code: 403 },\n            };\n        }));\n    }\n    submitSignal(message) {\n        this.emit(\"nack\", this.clientId, {\n            operation: message,\n            content: { message: \"Cannot submit signal with storage-only connection\", code: 403 },\n        });\n    }\n    close() {\n    }\n}\n/**\n * Manages the flow of both inbound and outbound messages. This class ensures that shared objects receive delta\n * messages in order regardless of possible network conditions or timings causing out of order delivery.\n */\nexport class DeltaManager extends TypedEventEmitter {\n    constructor(serviceProvider, client, logger, reconnectAllowed, _active) {\n        super();\n        this.serviceProvider = serviceProvider;\n        this.client = client;\n        this.logger = logger;\n        this._active = _active;\n        // tracks host requiring read-only mode.\n        this._forceReadonly = false;\n        this.pending = [];\n        this.fetching = false;\n        // The minimum sequence number and last sequence number received from the server\n        this.minSequenceNumber = 0;\n        // There are three numbers we track\n        // * lastQueuedSequenceNumber is the last queued sequence number. If there are gaps in seq numbers, then this number\n        //   is not updated until we cover that gap, so it increases each time by 1.\n        // * lastObservedSeqNumber is  an estimation of last known sequence number for container in storage. It's initially\n        //   populated at web socket connection time (if storage provides that info) and is  updated once ops shows up.\n        //   It's never less than lastQueuedSequenceNumber\n        // * lastProcessedSequenceNumber - last processed sequence number\n        this.lastQueuedSequenceNumber = 0;\n        this.lastObservedSeqNumber = 0;\n        this.lastProcessedSequenceNumber = 0;\n        this.baseTerm = 0;\n        // The sequence number we initially loaded from\n        this.initSequenceNumber = 0;\n        this.clientSequenceNumber = 0;\n        this.clientSequenceNumberObserved = 0;\n        this.closed = false;\n        this.deltaStreamDelayId = uuid();\n        this.deltaStorageDelayId = uuid();\n        this.messageBuffer = [];\n        this.connectFirstConnection = true;\n        this.throttlingIdSet = new Set();\n        this.timeTillThrottling = 0;\n        // True if current connection has checkpoint information\n        // I.e. we know how far behind the client was at the time of establishing connection\n        this._hasCheckpointSequenceNumber = false;\n        this.opHandler = (documentId, messages) => {\n            if (messages instanceof Array) {\n                this.enqueueMessages(messages);\n            }\n            else {\n                this.enqueueMessages([messages]);\n            }\n        };\n        this.signalHandler = (message) => {\n            this._inboundSignal.push(message);\n        };\n        // Always connect in write mode after getting nacked.\n        this.nackHandler = (documentId, messages) => {\n            const message = messages[0];\n            // TODO: we should remove this check when service updates?\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            if (this._readonlyPermissions) {\n                this.close(createWriteError(\"WriteOnReadOnlyDocument\"));\n            }\n            // check message.content for Back-compat with old service.\n            const reconnectInfo = message.content !== undefined\n                ? getNackReconnectInfo(message.content) :\n                createGenericNetworkError(`Nack: unknown reason`, true);\n            if (this.reconnectMode !== ReconnectMode.Enabled) {\n                this.logger.sendErrorEvent({\n                    eventName: \"NackWithNoReconnect\",\n                    reason: reconnectInfo.message,\n                    mode: this.connectionMode,\n                });\n            }\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.reconnectOnError(\"write\", reconnectInfo);\n        };\n        // Connection mode is always read on disconnect/error unless the system mode was write.\n        this.disconnectHandler = (disconnectReason) => {\n            // Note: we might get multiple disconnect calls on same socket, as early disconnect notification\n            // (\"server_disconnect\", ODSP-specific) is mapped to \"disconnect\"\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.reconnectOnError(this.defaultReconnectionMode, createReconnectError(\"Disconnect\", disconnectReason));\n        };\n        this.errorHandler = (error) => {\n            // Observation based on early pre-production telemetry:\n            // We are getting transport errors from WebSocket here, right before or after \"disconnect\".\n            // This happens only in Firefox.\n            logNetworkFailure(this.logger, { eventName: \"DeltaConnectionError\" }, error);\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.reconnectOnError(this.defaultReconnectionMode, createReconnectError(\"error\", error));\n        };\n        this.pongHandler = (latency) => {\n            this.emit(\"pong\", latency);\n        };\n        this.clientDetails = this.client.details;\n        this.defaultReconnectionMode = this.client.mode;\n        this._reconnectMode = reconnectAllowed ? ReconnectMode.Enabled : ReconnectMode.Never;\n        this._inbound = new DeltaQueue((op) => {\n            this.processInboundMessage(op);\n        });\n        this._inbound.on(\"error\", (error) => {\n            this.close(CreateProcessingError(error, this.lastMessage));\n        });\n        // Outbound message queue. The outbound queue is represented as a queue of an array of ops. Ops contained\n        // within an array *must* fit within the maxMessageSize and are guaranteed to be ordered sequentially.\n        this._outbound = new DeltaQueue((messages) => {\n            if (this.connection === undefined) {\n                throw new Error(\"Attempted to submit an outbound message without connection\");\n            }\n            this.connection.submit(messages);\n        });\n        this._outbound.on(\"error\", (error) => {\n            this.close(CreateContainerError(error));\n        });\n        // Inbound signal queue\n        this._inboundSignal = new DeltaQueue((message) => {\n            if (this.handler === undefined) {\n                throw new Error(\"Attempted to process an inbound signal without a handler attached\");\n            }\n            this.handler.processSignal({\n                clientId: message.clientId,\n                content: JSON.parse(message.content),\n            });\n        });\n        this._inboundSignal.on(\"error\", (error) => {\n            this.close(CreateContainerError(error));\n        });\n        // Require the user to start the processing\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._inbound.pause();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._outbound.pause();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._inboundSignal.pause();\n    }\n    get active() { return this._active(); }\n    get disposed() { return this.closed; }\n    get IDeltaSender() { return this; }\n    /**\n     * Tells if  current connection has checkpoint information.\n     * I.e. we know how far behind the client was at the time of establishing connection\n     */\n    get hasCheckpointSequenceNumber() {\n        // Valid to be called only if we have active connection.\n        assert(this.connection !== undefined, 0x0df /* \"Missing active connection\" */);\n        return this._hasCheckpointSequenceNumber;\n    }\n    get inbound() {\n        return this._inbound;\n    }\n    get outbound() {\n        return this._outbound;\n    }\n    get inboundSignal() {\n        return this._inboundSignal;\n    }\n    get initialSequenceNumber() {\n        return this.initSequenceNumber;\n    }\n    get lastSequenceNumber() {\n        return this.lastProcessedSequenceNumber;\n    }\n    get lastMessage() {\n        return this.lastProcessedMessage;\n    }\n    get lastKnownSeqNumber() {\n        return this.lastObservedSeqNumber;\n    }\n    get referenceTerm() {\n        return this.baseTerm;\n    }\n    get minimumSequenceNumber() {\n        return this.minSequenceNumber;\n    }\n    get maxMessageSize() {\n        var _a, _b, _c, _d, _e;\n        return (_e = (_c = (_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.serviceConfiguration) === null || _b === void 0 ? void 0 : _b.maxMessageSize) !== null && _c !== void 0 ? _c : (_d = this.connection) === null || _d === void 0 ? void 0 : _d.maxMessageSize) !== null && _e !== void 0 ? _e : DefaultChunkSize;\n    }\n    get version() {\n        if (this.connection === undefined) {\n            throw new Error(\"Cannot check version without a connection\");\n        }\n        return this.connection.version;\n    }\n    get serviceConfiguration() {\n        var _a;\n        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.serviceConfiguration;\n    }\n    get scopes() {\n        var _a;\n        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.claims.scopes;\n    }\n    get socketDocumentId() {\n        var _a;\n        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.claims.documentId;\n    }\n    /**\n     * The current connection mode, initially read.\n     */\n    get connectionMode() {\n        if (this.connection === undefined) {\n            return \"read\";\n        }\n        return this.connection.mode;\n    }\n    /**\n     * Tells if container is in read-only mode.\n     * Data stores should listen for \"readonly\" notifications and disallow user\n     * making changes to data stores.\n     * Readonly state can be because of no storage write permission,\n     * or due to host forcing readonly mode for container.\n     * It is undefined if we have not yet established websocket connection\n     * and do not know if user has write access to a file.\n     * @deprecated - use readOnlyInfo\n     */\n    get readonly() {\n        if (this._forceReadonly) {\n            return true;\n        }\n        return this._readonlyPermissions;\n    }\n    /**\n     * Tells if user has no write permissions for file in storage\n     * It is undefined if we have not yet established websocket connection\n     * and do not know if user has write access to a file.\n     * @deprecated - use readOnlyInfo\n     */\n    get readonlyPermissions() {\n        return this._readonlyPermissions;\n    }\n    get readOnlyInfo() {\n        const storageOnly = this.connection !== undefined && this.connection instanceof NoDeltaStream;\n        if (storageOnly || this._forceReadonly || this._readonlyPermissions === true) {\n            return {\n                readonly: true,\n                forced: this._forceReadonly,\n                permissions: this._readonlyPermissions,\n                storageOnly,\n            };\n        }\n        return { readonly: this._readonlyPermissions };\n    }\n    /**\n     * Automatic reconnecting enabled or disabled.\n     * If set to Never, then reconnecting will never be allowed.\n     */\n    get reconnectMode() {\n        return this._reconnectMode;\n    }\n    shouldJoinWrite() {\n        return this.clientSequenceNumber !== this.clientSequenceNumberObserved;\n    }\n    async connectToStorage() {\n        var _a, _b, _c;\n        if (this.storageService !== undefined) {\n            return this.storageService;\n        }\n        const service = this.serviceProvider();\n        if (service === undefined) {\n            throw new Error(\"Not attached\");\n        }\n        let storageService = await service.connectToStorage();\n        // Enable prefetching for the service unless it has a caching policy set otherwise:\n        if (((_a = storageService.policies) === null || _a === void 0 ? void 0 : _a.caching) !== LoaderCachingPolicy.NoCaching) {\n            storageService = new PrefetchDocumentStorageService(storageService);\n        }\n        this.storageService = new RetriableDocumentStorageService(storageService, this, this.logger);\n        // ensure we did not lose that policy in the process of wrapping\n        assert(((_b = storageService.policies) === null || _b === void 0 ? void 0 : _b.minBlobSize) === ((_c = this.storageService.policies) === null || _c === void 0 ? void 0 : _c.minBlobSize), 0x0e0 /* \"lost minBlobSize policy\" */);\n        return this.storageService;\n    }\n    /**\n     * Enables or disables automatic reconnecting.\n     * Will throw an error if reconnectMode set to Never.\n     */\n    setAutomaticReconnect(reconnect) {\n        assert(this._reconnectMode !== ReconnectMode.Never, 0x0e1 /* \"Cannot toggle automatic reconnect if reconnect is set to Never.\" */);\n        this._reconnectMode = reconnect ? ReconnectMode.Enabled : ReconnectMode.Disabled;\n    }\n    /**\n     * Sends signal to runtime (and data stores) to be read-only.\n     * Hosts may have read only views, indicating to data stores that no edits are allowed.\n     * This is independent from this._readonlyPermissions (permissions) and this.connectionMode\n     * (server can return \"write\" mode even when asked for \"read\")\n     * Leveraging same \"readonly\" event as runtime & data stores should behave the same in such case\n     * as in read-only permissions.\n     * But this.active can be used by some DDSes to figure out if ops can be sent\n     * (for example, read-only view still participates in code proposals / upgrades decisions)\n     *\n     * Forcing Readonly does not prevent DDS from generating ops. It is up to user code to honour\n     * the readonly flag. If ops are generated, they will accumulate locally and not be sent. If\n     * there are pending in the outbound queue, it will stop sending until force readonly is\n     * cleared.\n     *\n     * @param readonly - set or clear force readonly.\n     */\n    forceReadonly(readonly) {\n        const oldValue = this.readonly;\n        this._forceReadonly = readonly;\n        if (oldValue !== this.readonly) {\n            let reconnect = false;\n            if (this.readonly === true) {\n                // If we switch to readonly while connected, we should disconnect first\n                // See comment in the \"readonly\" event handler to deltaManager set up by\n                // the ContainerRuntime constructor\n                reconnect = this.disconnectFromDeltaStream(\"Force readonly\");\n            }\n            safeRaiseEvent(this, this.logger, \"readonly\", this.readonly);\n            if (reconnect) {\n                // reconnect if we disconnected from before.\n                this.triggerConnect({ reason: \"forceReadonly\", mode: \"read\", fetchOpsFromStorage: false });\n            }\n        }\n    }\n    set_readonlyPermissions(readonly) {\n        const oldValue = this.readonly;\n        this._readonlyPermissions = readonly;\n        if (oldValue !== this.readonly) {\n            safeRaiseEvent(this, this.logger, \"readonly\", this.readonly);\n        }\n    }\n    dispose() {\n        throw new Error(\"Not implemented.\");\n    }\n    /**\n     * Sets the sequence number from which inbound messages should be returned\n     */\n    attachOpHandler(minSequenceNumber, sequenceNumber, term, handler) {\n        debug(\"Attached op handler\", sequenceNumber);\n        this.initSequenceNumber = sequenceNumber;\n        this.lastProcessedSequenceNumber = sequenceNumber;\n        this.baseTerm = term;\n        this.minSequenceNumber = minSequenceNumber;\n        this.lastQueuedSequenceNumber = sequenceNumber;\n        this.lastObservedSeqNumber = sequenceNumber;\n        // We will use same check in other places to make sure all the seq number above are set properly.\n        assert(this.handler === undefined, 0x0e2 /* \"DeltaManager already has attached op handler!\" */);\n        this.handler = handler;\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        assert(!!this.handler, 0x0e3 /* \"Newly set op handler is null/undefined!\" */);\n        this._inbound.resume();\n        this._inboundSignal.resume();\n        // We could have connected to delta stream before getting here\n        // If so, it's time to process any accumulated ops\n        // Or request OPs from snapshot / or point zero (if we have no ops at all)\n        if (this.pending.length > 0) {\n            this.processPendingOps(\"DocumentOpen\");\n        }\n        else if (this.connection !== undefined || this.connectionP !== undefined) {\n            this.fetchMissingDeltas(\"DocumentOpen\", this.lastQueuedSequenceNumber);\n        }\n    }\n    static detailsFromConnection(connection) {\n        return {\n            claims: connection.claims,\n            clientId: connection.clientId,\n            existing: connection.existing,\n            checkpointSequenceNumber: connection.checkpointSequenceNumber,\n            get initialClients() { return connection.initialClients; },\n            maxMessageSize: connection.maxMessageSize,\n            mode: connection.mode,\n            serviceConfiguration: connection.serviceConfiguration,\n            version: connection.version,\n        };\n    }\n    async connect(args) {\n        const connection = await this.connectCore(args);\n        return DeltaManager.detailsFromConnection(connection);\n    }\n    /**\n     * Start the connection. Any error should result in container being close.\n     * And report the error if it excape for any reason.\n     * @param args - The connection arguments\n     */\n    triggerConnect(args) {\n        this.connectCore(args).catch((err) => {\n            // Errors are raised as \"error\" event and close container.\n            // Have a catch-all case in case we missed something\n            if (!this.closed) {\n                this.logger.sendErrorEvent({ eventName: \"ConnectException\" }, err);\n            }\n        });\n    }\n    async connectCore(args) {\n        var _a, _b, _c;\n        if (this.connection !== undefined) {\n            return this.connection;\n        }\n        if (this.connectionP !== undefined) {\n            return this.connectionP;\n        }\n        const fetchOpsFromStorage = (_a = args.fetchOpsFromStorage) !== null && _a !== void 0 ? _a : true;\n        let requestedMode = (_b = args.mode) !== null && _b !== void 0 ? _b : this.defaultReconnectionMode;\n        // if we have any non-acked ops from last connection, reconnect as \"write\".\n        // without that we would connect in view-only mode, which will result in immediate\n        // firing of \"connected\" event from Container and switch of current clientId (as tracked\n        // by all DDSes). This will make it impossible to figure out if ops actually made it through,\n        // so DDSes will immediately resubmit all pending ops, and some of them will be duplicates, corrupting document\n        if (this.shouldJoinWrite()) {\n            requestedMode = \"write\";\n        }\n        // Note: There is race condition here.\n        // We want to issue request to storage as soon as possible, to\n        // reduce latency of becoming current, thus this code here.\n        // But there is no ordering between fetching OPs and connection to delta stream\n        // As result, we might be behind by the time we connect to delta stream\n        // In case of r/w connection, that's not an issue, because we will hear our\n        // own \"join\" message and realize any gap client has in ops.\n        // But for view-only connection, we have no such signal, and with no traffic\n        // on the wire, we might be always behind.\n        // See comment at the end of setupNewSuccessfulConnection()\n        this.logger.debugAssert(this.handler !== undefined || fetchOpsFromStorage); // on boot, always fetch ops!\n        if (fetchOpsFromStorage && this.handler !== undefined) {\n            this.fetchMissingDeltas(args.reason, this.lastQueuedSequenceNumber);\n        }\n        const docService = this.serviceProvider();\n        if (docService === undefined) {\n            throw new Error(\"Container is not attached\");\n        }\n        if (((_c = docService.policies) === null || _c === void 0 ? void 0 : _c.storageOnly) === true) {\n            const connection = new NoDeltaStream();\n            this.connectionP = new Promise((resolve) => {\n                this.setupNewSuccessfulConnection(connection, \"read\");\n                resolve(connection);\n            });\n            return this.connectionP;\n        }\n        // The promise returned from connectCore will settle with a resolved connection or reject with error\n        const connectCore = async () => {\n            let connection;\n            let delay = InitialReconnectDelaySeconds;\n            let connectRepeatCount = 0;\n            const connectStartTime = performance.now();\n            // This loop will keep trying to connect until successful, with a delay between each iteration.\n            while (connection === undefined) {\n                if (this.closed) {\n                    throw new Error(\"Attempting to connect a closed DeltaManager\");\n                }\n                connectRepeatCount++;\n                try {\n                    this.client.mode = requestedMode;\n                    connection = await docService.connectToDeltaStream(this.client);\n                }\n                catch (origError) {\n                    const error = CreateContainerError(origError);\n                    // Socket.io error when we connect to wrong socket, or hit some multiplexing bug\n                    if (!canRetryOnError(origError)) {\n                        this.close(error);\n                        // eslint-disable-next-line @typescript-eslint/no-throw-literal\n                        throw error;\n                    }\n                    // Log error once - we get too many errors in logs when we are offline,\n                    // and unfortunately there is no reliable way to detect that.\n                    if (connectRepeatCount === 1) {\n                        logNetworkFailure(this.logger, {\n                            delay,\n                            eventName: \"DeltaConnectionFailureToConnect\",\n                        }, origError);\n                    }\n                    const retryDelayFromError = getRetryDelayFromError(origError);\n                    delay = retryDelayFromError !== null && retryDelayFromError !== void 0 ? retryDelayFromError : Math.min(delay * 2, MaxReconnectDelaySeconds);\n                    if (retryDelayFromError !== undefined) {\n                        this.emitDelayInfo(this.deltaStreamDelayId, retryDelayFromError, error);\n                    }\n                    await waitForConnectedState(delay * 1000);\n                }\n            }\n            // If we retried more than once, log an event about how long it took\n            if (connectRepeatCount > 1) {\n                this.logger.sendTelemetryEvent({\n                    attempts: connectRepeatCount,\n                    duration: TelemetryLogger.formatTick(performance.now() - connectStartTime),\n                    eventName: \"MultipleDeltaConnectionFailures\",\n                });\n            }\n            this.setupNewSuccessfulConnection(connection, requestedMode);\n            return connection;\n        };\n        // This promise settles as soon as we know the outcome of the connection attempt\n        this.connectionP = new Promise((resolve, reject) => {\n            // Regardless of how the connection attempt concludes, we'll clear the promise and remove the listener\n            // Reject the connection promise if the DeltaManager gets closed during connection\n            const cleanupAndReject = (error) => {\n                this.connectionP = undefined;\n                this.removeListener(\"closed\", cleanupAndReject);\n                reject(error);\n            };\n            this.on(\"closed\", cleanupAndReject);\n            // Attempt the connection\n            connectCore().then((connection) => {\n                this.connectionP = undefined;\n                this.removeListener(\"closed\", cleanupAndReject);\n                resolve(connection);\n            }).catch(cleanupAndReject);\n        });\n        return this.connectionP;\n    }\n    flush() {\n        if (this.messageBuffer.length === 0) {\n            return;\n        }\n        // The prepareFlush event allows listeners to append metadata to the batch prior to submission.\n        this.emit(\"prepareSend\", this.messageBuffer);\n        this._outbound.push(this.messageBuffer);\n        this.messageBuffer = [];\n    }\n    /**\n     * Submits the given delta returning the client sequence number for the message. Contents is the actual\n     * contents of the message. appData is optional metadata that can be attached to the op by the app.\n     *\n     * If batch is set to true then the submit will be batched - and as a result guaranteed to be ordered sequentially\n     * in the global sequencing space. The batch will be flushed either when flush is called or when a non-batched\n     * op is submitted.\n     */\n    submit(type, contents, batch = false, metadata) {\n        // TODO need to fail if gets too large\n        // const serializedContent = JSON.stringify(this.messageBuffer);\n        // const maxOpSize = this.context.deltaManager.maxMessageSize;\n        var _a, _b;\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (this.readonly) {\n            this.close(CreateContainerError(\"Op is sent in read-only document state\"));\n            return -1;\n        }\n        // reset clientSequenceNumber if we are using new clientId.\n        // we keep info about old connection as long as possible to be able to account for all non-acked ops\n        // that we pick up on next connection.\n        assert(!!this.connection, 0x0e4 /* \"Lost old connection!\" */);\n        if (this.lastSubmittedClientId !== ((_a = this.connection) === null || _a === void 0 ? void 0 : _a.clientId)) {\n            this.lastSubmittedClientId = (_b = this.connection) === null || _b === void 0 ? void 0 : _b.clientId;\n            this.clientSequenceNumber = 0;\n            this.clientSequenceNumberObserved = 0;\n        }\n        const service = this.clientDetails.type === undefined || this.clientDetails.type === \"\"\n            ? \"unknown\"\n            : this.clientDetails.type;\n        // Start adding trace for the op.\n        const traces = [\n            {\n                action: \"start\",\n                service,\n                timestamp: Date.now(),\n            }\n        ];\n        const message = {\n            clientSequenceNumber: ++this.clientSequenceNumber,\n            contents: JSON.stringify(contents),\n            metadata,\n            referenceSequenceNumber: this.lastProcessedSequenceNumber,\n            traces,\n            type,\n        };\n        this.emit(\"submitOp\", message);\n        if (!batch) {\n            this.flush();\n            this.messageBuffer.push(message);\n            this.flush();\n        }\n        else {\n            this.messageBuffer.push(message);\n        }\n        return message.clientSequenceNumber;\n    }\n    submitSignal(content) {\n        if (this.connection !== undefined) {\n            this.connection.submitSignal(content);\n        }\n        else {\n            this.logger.sendErrorEvent({ eventName: \"submitSignalDisconnected\" });\n        }\n    }\n    async getDeltas(telemetryEventSuffix, from, // exclusive\n    to, // exclusive\n    callback) {\n        const docService = this.serviceProvider();\n        if (docService === undefined) {\n            throw new Error(\"Delta manager is not attached\");\n        }\n        if (this.deltaStorageP === undefined) {\n            this.deltaStorageP = docService.connectToDeltaStorage();\n        }\n        const telemetryEvent = PerformanceEvent.start(this.logger, {\n            eventName: `GetDeltas_${telemetryEventSuffix}`,\n            from,\n            to,\n        });\n        let deltasRetrievedTotal = 0;\n        let requests = 0;\n        let lastFetch;\n        const manager = new ParallelRequests(from + 1, // from is exclusive, but ParallelRequests uses inclusive left\n        to, // exclusive right\n        MaxBatchDeltas, this.logger, async (request, _from, _to, strongTo) => {\n            requests++;\n            return this.getSingleOpBatch(request, _from, _to, telemetryEvent, strongTo);\n        }, (deltas) => {\n            deltasRetrievedTotal += deltas.length;\n            lastFetch = deltas[deltas.length - 1].sequenceNumber;\n            PerformanceEvent.timedExec(this.logger, { eventName: \"GetDeltas_OpProcessing\", count: deltas.length }, () => callback(deltas), { end: true, cancel: \"error\" });\n        });\n        // Staging: starting with no concurrency, listening for feedback first.\n        // In future releases we will switch to actual concurrency\n        await manager.run(1 /* concurrency */);\n        telemetryEvent.end({\n            lastFetch,\n            deltasRetrievedTotal,\n            requests,\n            lastQueuedSequenceNumber: this.lastQueuedSequenceNumber,\n        });\n    }\n    /**\n     * Retrieve single batch of ops\n     * @param request - request index\n     * @param from - inclusive boundary\n     * @param to - exclusive boundary\n     * @param telemetryEvent - telemetry event used to track consecutive batch of requests\n     * @param strongTo - tells if ops in range from...to have to be there and have to be retrieved.\n     * If false, returning less ops would mean we reached end of file.\n     * @returns - an object with resulting ops and cancellation / partial result flags\n     */\n    async getSingleOpBatch(request, from, to, telemetryEvent, strongTo) {\n        let deltaStorage;\n        let lastSuccessTime;\n        let retry = 0;\n        const deltas = [];\n        let deltasRetrievedTotal = 0;\n        const nothing = { partial: false, cancel: true, payload: [] };\n        const start = performance.now();\n        while (!this.closed) {\n            retry++;\n            let delay = Math.min(MaxFetchDelaySeconds, MissingFetchDelaySeconds * Math.pow(2, retry));\n            let canRetry = false;\n            try {\n                // Connect to the delta storage endpoint\n                if (deltaStorage === undefined) {\n                    deltaStorage = await this.deltaStorageP;\n                }\n                // Issue async request for deltas - limit the number fetched to MaxBatchDeltas\n                canRetry = true;\n                assert(deltaStorage !== undefined, 0x0e5 /* \"delta storage undefined while getting single batch!\" */);\n                // left is inclusive for ParallelRequests, but exclusive for IDocumentDeltaStorageService\n                // right is exclusive for both\n                const deltasP = deltaStorage.get(from - 1, to);\n                const { messages, partialResult } = await deltasP;\n                deltas.push(...messages);\n                const deltasRetrievedLast = messages.length;\n                deltasRetrievedTotal += deltasRetrievedLast;\n                if (deltasRetrievedLast !== 0 || !strongTo) {\n                    telemetryEvent.reportProgress({\n                        chunkDeltas: deltasRetrievedTotal,\n                        chunkFrom: from,\n                        chunkTo: to,\n                        chunkRequests: retry,\n                        chunkDuration: TelemetryLogger.formatTick(performance.now() - start),\n                    });\n                    return { payload: deltas, cancel: false, partial: partialResult };\n                }\n                // Storage does not have ops we need.\n                // Attempt to fetch more deltas. If we didn't receive any in the previous call we up our retry\n                // count since something prevented us from seeing those deltas\n                if (lastSuccessTime === undefined) {\n                    lastSuccessTime = Date.now();\n                }\n                else if (Date.now() - lastSuccessTime > 30000) {\n                    // If we are connected and receiving proper responses from server, but can't get any ops back,\n                    // then give up after some time. This likely indicates the issue with ordering service not flushing\n                    // ops to storage quick enough, and possibly waiting for summaries, while summarizer can't get\n                    // current as it can't get ops.\n                    telemetryEvent.cancel({\n                        category: \"error\",\n                        error: \"too many retries\",\n                        retry,\n                        request,\n                        deltasRetrievedTotal,\n                        replayFrom: from,\n                        to,\n                    });\n                    this.close(createGenericNetworkError(\"Failed to retrieve ops from storage: giving up after too many retries\", false /* canRetry */));\n                    return nothing;\n                }\n            }\n            catch (origError) {\n                canRetry = canRetry && canRetryOnError(origError);\n                const error = CreateContainerError(origError);\n                lastSuccessTime = undefined;\n                logNetworkFailure(this.logger, {\n                    eventName: \"GetDeltas_Error\",\n                    fetchTo: to,\n                    from,\n                    request,\n                    retry,\n                }, origError);\n                if (!canRetry) {\n                    // It's game over scenario.\n                    telemetryEvent.cancel({ category: \"error\" }, origError);\n                    this.close(error);\n                    return nothing;\n                }\n                const retryAfter = getRetryDelayFromError(origError);\n                if (retryAfter !== undefined && retryAfter >= 0) {\n                    this.emitDelayInfo(this.deltaStorageDelayId, retryAfter, error);\n                    delay = retryAfter;\n                }\n            }\n            if (to !== undefined && this.lastQueuedSequenceNumber >= to) {\n                // the client caught up while we were trying to fetch ops from storage\n                // bail out since we no longer need to request these ops\n                return nothing;\n            }\n            await waitForConnectedState(delay * 1000);\n        }\n        // Might need to change to non-error event\n        telemetryEvent.cancel({ error: \"container closed\" });\n        return nothing;\n    }\n    /**\n     * Closes the connection and clears inbound & outbound queues.\n     */\n    close(error) {\n        var _a;\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        (_a = this.storageService) === null || _a === void 0 ? void 0 : _a.dispose();\n        // This raises \"disconnect\" event if we have active connection.\n        this.disconnectFromDeltaStream(error !== undefined ? `${error.message}` : \"Container closed\");\n        this._inbound.clear();\n        this._outbound.clear();\n        this._inboundSignal.clear();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._inbound.pause();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._inboundSignal.pause();\n        // Drop pending messages - this will ensure catchUp() does not go into infinite loop\n        this.pending = [];\n        // Notify everyone we are in read-only state.\n        // Useful for data stores in case we hit some critical error,\n        // to switch to a mode where user edits are not accepted\n        this.set_readonlyPermissions(true);\n        // This needs to be the last thing we do (before removing listeners), as it causes\n        // Container to dispose context and break ability of data stores / runtime to \"hear\"\n        // from delta manager, including notification (above) about readonly state.\n        this.emit(\"closed\", error);\n        this.removeAllListeners();\n    }\n    refreshDelayInfo(id) {\n        this.throttlingIdSet.delete(id);\n        if (this.throttlingIdSet.size === 0) {\n            this.timeTillThrottling = 0;\n        }\n    }\n    emitDelayInfo(id, delaySeconds, error) {\n        const timeNow = Date.now();\n        this.throttlingIdSet.add(id);\n        if (delaySeconds > 0 && (timeNow + delaySeconds > this.timeTillThrottling)) {\n            this.timeTillThrottling = timeNow + delaySeconds;\n            const throttlingError = {\n                errorType: ContainerErrorType.throttlingError,\n                message: `Service busy/throttled: ${error.message}`,\n                retryAfterSeconds: delaySeconds,\n            };\n            this.emit(\"throttled\", throttlingError);\n        }\n    }\n    /**\n     * Once we've successfully gotten a connection, we need to set up state, attach event listeners, and process\n     * initial messages.\n     * @param connection - The newly established connection\n     */\n    setupNewSuccessfulConnection(connection, requestedMode) {\n        var _a;\n        // Old connection should have been cleaned up before establishing a new one\n        assert(this.connection === undefined, 0x0e6 /* \"old connection exists on new connection setup\" */);\n        this.connection = connection;\n        // Does information in scopes & mode matches?\n        // If we asked for \"write\" and got \"read\", then file is read-only\n        // But if we ask read, server can still give us write.\n        const readonly = !connection.claims.scopes.includes(ScopeType.DocWrite);\n        assert(requestedMode === \"read\" || readonly === (this.connectionMode === \"read\"), 0x0e7 /* \"claims/connectionMode mismatch\" */);\n        assert(!readonly || this.connectionMode === \"read\", 0x0e8 /* \"readonly perf with write connection\" */);\n        this.set_readonlyPermissions(readonly);\n        this.refreshDelayInfo(this.deltaStreamDelayId);\n        if (this.closed) {\n            // Raise proper events, Log telemetry event and close connection.\n            this.disconnectFromDeltaStream(`Disconnect on close`);\n            return;\n        }\n        // We cancel all ops on lost of connectivity, and rely on DDSes to resubmit them.\n        // Semantics are not well defined for batches (and they are broken right now on disconnects anyway),\n        // but it's safe to assume (until better design is put into place) that batches should not exist\n        // across multiple connections. Right now we assume runtime will not submit any ops in disconnected\n        // state. As requirements change, so should these checks.\n        assert(this.messageBuffer.length === 0, 0x0e9 /* \"messageBuffer is not empty on new connection\" */);\n        this._outbound.resume();\n        connection.on(\"op\", this.opHandler);\n        connection.on(\"signal\", this.signalHandler);\n        connection.on(\"nack\", this.nackHandler);\n        connection.on(\"disconnect\", this.disconnectHandler);\n        connection.on(\"error\", this.errorHandler);\n        connection.on(\"pong\", this.pongHandler);\n        const initialMessages = connection.initialMessages;\n        this._hasCheckpointSequenceNumber = false;\n        // Some storages may provide checkpointSequenceNumber to identify how far client is behind.\n        const checkpointSequenceNumber = connection.checkpointSequenceNumber;\n        if (checkpointSequenceNumber !== undefined) {\n            this._hasCheckpointSequenceNumber = true;\n            this.updateLatestKnownOpSeqNumber(checkpointSequenceNumber);\n        }\n        // Update knowledge of how far we are behind, before raising \"connect\" event\n        // This is duplication of what enqueueMessages() does, but we have to raise event before we get there,\n        // so duplicating update logic here as well.\n        if (initialMessages.length > 0) {\n            this._hasCheckpointSequenceNumber = true;\n            this.updateLatestKnownOpSeqNumber(initialMessages[initialMessages.length - 1].sequenceNumber);\n        }\n        // Notify of the connection\n        // WARNING: This has to happen before processInitialMessages() call below.\n        // If not, we may not update Container.pendingClientId in time before seeing our own join session op.\n        this.emit(\"connect\", DeltaManager.detailsFromConnection(connection), this._hasCheckpointSequenceNumber ? this.lastKnownSeqNumber - this.lastSequenceNumber : undefined);\n        this.processInitialMessages(initialMessages, (_a = connection.initialSignals) !== null && _a !== void 0 ? _a : [], this.connectFirstConnection ? \"InitialOps\" : \"ReconnectOps\");\n        // If we got some initial ops, then we know the gap and call above fetched ops to fill it.\n        // Same is true for \"write\" mode even if we have no ops - we will get self \"join\" ops very very soon.\n        // However if we are connecting as view-only, then there is no good signal to realize if client is behind.\n        // Thus we have to hit storage to see if any ops are there.\n        if (initialMessages.length === 0) {\n            if (checkpointSequenceNumber !== undefined) {\n                // We know how far we are behind (roughly). If it's non-zero gap, fetch ops right away.\n                if (checkpointSequenceNumber > this.lastQueuedSequenceNumber) {\n                    this.fetchMissingDeltas(\"AfterConnection\", this.lastQueuedSequenceNumber);\n                }\n                // we do not know the gap, and we will not learn about it if socket is quite - have to ask.\n            }\n            else if (connection.mode !== \"write\") {\n                this.fetchMissingDeltas(\"AfterConnection\", this.lastQueuedSequenceNumber);\n            }\n        }\n        this.connectFirstConnection = false;\n    }\n    /**\n     * Disconnect the current connection.\n     * @param reason - Text description of disconnect reason to emit with disconnect event\n     */\n    disconnectFromDeltaStream(reason) {\n        if (this.connection === undefined) {\n            return false;\n        }\n        const connection = this.connection;\n        // Avoid any re-entrancy - clear object reference\n        this.connection = undefined;\n        // Remove listeners first so we don't try to retrigger this flow accidentally through reconnectOnError\n        connection.off(\"op\", this.opHandler);\n        connection.off(\"signal\", this.signalHandler);\n        connection.off(\"nack\", this.nackHandler);\n        connection.off(\"disconnect\", this.disconnectHandler);\n        connection.off(\"error\", this.errorHandler);\n        connection.off(\"pong\", this.pongHandler);\n        // We cancel all ops on lost of connectivity, and rely on DDSes to resubmit them.\n        // Semantics are not well defined for batches (and they are broken right now on disconnects anyway),\n        // but it's safe to assume (until better design is put into place) that batches should not exist\n        // across multiple connections. Right now we assume runtime will not submit any ops in disconnected\n        // state. As requirements change, so should these checks.\n        assert(this.messageBuffer.length === 0, 0x0ea /* \"messageBuffer is not empty on disconnect\" */);\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._outbound.pause();\n        this._outbound.clear();\n        this.emit(\"disconnect\", reason);\n        connection.close();\n        return true;\n    }\n    /**\n     * Disconnect the current connection and reconnect.\n     * @param connection - The connection that wants to reconnect - no-op if it's different from this.connection\n     * @param requestedMode - Read or write\n     * @param reconnectInfo - Error reconnect information including whether or not to reconnect\n     * @returns A promise that resolves when the connection is reestablished or we stop trying\n     */\n    async reconnectOnError(requestedMode, error) {\n        // We quite often get protocol errors before / after observing nack/disconnect\n        // we do not want to run through same sequence twice.\n        // If we're already disconnected/disconnecting it's not appropriate to call this again.\n        assert(this.connection !== undefined, 0x0eb /* \"Missing connection for reconnect\" */);\n        this.disconnectFromDeltaStream(error.message);\n        // If reconnection is not an option, close the DeltaManager\n        const canRetry = canRetryOnError(error);\n        if (this.reconnectMode === ReconnectMode.Never || !canRetry) {\n            // Do not raise container error if we are closing just because we lost connection.\n            // Those errors (like IdleDisconnect) would show up in telemetry dashboards and\n            // are very misleading, as first initial reaction - some logic is broken.\n            this.close(canRetry ? undefined : error);\n        }\n        // If closed then we can't reconnect\n        if (this.closed) {\n            return;\n        }\n        if (this.reconnectMode === ReconnectMode.Enabled) {\n            const delay = getRetryDelayFromError(error);\n            if (delay !== undefined) {\n                this.emitDelayInfo(this.deltaStreamDelayId, delay, error);\n                await waitForConnectedState(delay * 1000);\n            }\n            this.triggerConnect({ reason: \"reconnect\", mode: requestedMode, fetchOpsFromStorage: false });\n        }\n    }\n    processInitialMessages(messages, signals, reason) {\n        if (messages.length > 0) {\n            this.catchUp(messages, reason);\n        }\n        for (const signal of signals) {\n            this._inboundSignal.push(signal);\n        }\n    }\n    // returns parts of message (in string format) that should never change for a given message.\n    // Used for message comparison. It attempts to avoid comparing fields that potentially may differ.\n    // for example, it's not clear if serverMetadata or timestamp property is a property of message or server state.\n    // We only extract the most obvious fields that are sufficient (with high probability) to detect sequence number\n    // reuse.\n    // Also payload goes to telemetry, so no PII, including content!!\n    // Note: It's possible for a duplicate op to be broadcasted and have everything the same except the timestamp.\n    comparableMessagePayload(m) {\n        return `${m.clientId}-${m.type}-${m.minimumSequenceNumber}-${m.referenceSequenceNumber}-${m.timestamp}`;\n    }\n    enqueueMessages(messages, telemetryEventSuffix = \"OutOfOrderMessage\") {\n        var _a, _b, _c;\n        if (this.handler === undefined) {\n            // We did not setup handler yet.\n            // This happens when we connect to web socket faster than we get attributes for container\n            // and thus faster than attachOpHandler() is called\n            // this.lastProcessedSequenceNumber is still zero, so we can't rely on this.fetchMissingDeltas()\n            // to do the right thing.\n            this.pending = this.pending.concat(messages);\n            return;\n        }\n        let duplicateStart;\n        let duplicateEnd;\n        let duplicateCount = 0;\n        if (messages.length > 0) {\n            this.updateLatestKnownOpSeqNumber(messages[messages.length - 1].sequenceNumber);\n        }\n        const n = (_a = this.previouslyProcessedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber;\n        assert(n === undefined || n === this.lastQueuedSequenceNumber, 0x0ec /* \"Unexpected value for previously processed message's sequence number\" */);\n        for (const message of messages) {\n            // Check that the messages are arriving in the expected order\n            if (message.sequenceNumber <= this.lastQueuedSequenceNumber) {\n                duplicateCount++;\n                if (duplicateStart === undefined || duplicateStart > message.sequenceNumber) {\n                    duplicateStart = message.sequenceNumber;\n                }\n                if (duplicateEnd === undefined || duplicateEnd < message.sequenceNumber) {\n                    duplicateEnd = message.sequenceNumber;\n                }\n                // Validate that we do not have data loss, i.e. sequencing is reset and started again\n                // with numbers that this client already observed before.\n                if (((_b = this.previouslyProcessedMessage) === null || _b === void 0 ? void 0 : _b.sequenceNumber) === message.sequenceNumber) {\n                    const message1 = this.comparableMessagePayload(this.previouslyProcessedMessage);\n                    const message2 = this.comparableMessagePayload(message);\n                    if (message1 !== message2) {\n                        const error = new DataCorruptionError(\"Two messages with same seq# and different payload!\", {\n                            clientId: (_c = this.connection) === null || _c === void 0 ? void 0 : _c.clientId,\n                            sequenceNumber: message.sequenceNumber,\n                            message1,\n                            message2,\n                        });\n                        this.close(error);\n                    }\n                }\n            }\n            else if (message.sequenceNumber !== this.lastQueuedSequenceNumber + 1) {\n                this.pending.push(message);\n                this.fetchMissingDeltas(telemetryEventSuffix, this.lastQueuedSequenceNumber, message.sequenceNumber);\n            }\n            else {\n                this.lastQueuedSequenceNumber = message.sequenceNumber;\n                this.previouslyProcessedMessage = message;\n                this._inbound.push(message);\n                if (this.pending.length > 0) {\n                    // we processed a correctly sequenced inbound op while some are pending\n                    // pending might include ops after the current sequence number, so process them now\n                    this.processPendingOps(`EnqueueMessages_${telemetryEventSuffix}`);\n                }\n            }\n        }\n        if (duplicateCount !== 0) {\n            this.logger.sendTelemetryEvent({\n                eventName: `DuplicateMessages_${telemetryEventSuffix}`,\n                start: duplicateStart,\n                end: duplicateEnd,\n                count: duplicateCount,\n            });\n        }\n    }\n    processInboundMessage(message) {\n        var _a, _b;\n        const startTime = Date.now();\n        this.lastProcessedMessage = message;\n        // All non-system messages are coming from some client, and should have clientId\n        // System messages may have no clientId (but some do, like propose, noop, summarize)\n        assert(message.clientId !== undefined\n            || isSystemMessage(message), 0x0ed /* \"non-system message have to have clientId\" */);\n        // if we have connection, and message is local, then we better treat is as local!\n        assert(this.connection === undefined\n            || this.connection.clientId !== message.clientId\n            || this.lastSubmittedClientId === message.clientId, 0x0ee /* \"Not accounting local messages correctly\" */);\n        if (this.lastSubmittedClientId !== undefined && this.lastSubmittedClientId === message.clientId) {\n            const clientSequenceNumber = message.clientSequenceNumber;\n            assert(this.clientSequenceNumberObserved < clientSequenceNumber, 0x0ef /* \"client seq# not growing\" */);\n            assert(clientSequenceNumber <= this.clientSequenceNumber, 0x0f0 /* \"Incoming local client seq# > generated by this client\" */);\n            this.clientSequenceNumberObserved = clientSequenceNumber;\n        }\n        // TODO Remove after SPO picks up the latest build.\n        if (typeof message.contents === \"string\"\n            && message.contents !== \"\"\n            && message.type !== MessageType.ClientLeave) {\n            message.contents = JSON.parse(message.contents);\n        }\n        // Add final ack trace.\n        if (message.traces !== undefined && message.traces.length > 0) {\n            const service = this.clientDetails.type === undefined || this.clientDetails.type === \"\"\n                ? \"unknown\"\n                : this.clientDetails.type;\n            message.traces.push({\n                action: \"end\",\n                service,\n                timestamp: Date.now(),\n            });\n        }\n        // Watch the minimum sequence number and be ready to update as needed\n        if (this.minSequenceNumber > message.minimumSequenceNumber) {\n            throw new DataCorruptionError(\"msn moves backwards\", Object.assign(Object.assign({}, extractLogSafeMessageProperties(message)), { clientId: (_a = this.connection) === null || _a === void 0 ? void 0 : _a.clientId }));\n        }\n        this.minSequenceNumber = message.minimumSequenceNumber;\n        if (message.sequenceNumber !== this.lastProcessedSequenceNumber + 1) {\n            throw new DataCorruptionError(\"non-seq seq#\", Object.assign(Object.assign({}, extractLogSafeMessageProperties(message)), { clientId: (_b = this.connection) === null || _b === void 0 ? void 0 : _b.clientId }));\n        }\n        this.lastProcessedSequenceNumber = message.sequenceNumber;\n        // Back-compat for older server with no term\n        if (message.term === undefined) {\n            message.term = 1;\n        }\n        this.baseTerm = message.term;\n        if (this.handler === undefined) {\n            throw new Error(\"Attempted to process an inbound message without a handler attached\");\n        }\n        this.handler.process(message);\n        const endTime = Date.now();\n        this.emit(\"op\", message, endTime - startTime);\n    }\n    /**\n     * Retrieves the missing deltas between the given sequence numbers\n     */\n    fetchMissingDeltas(telemetryEventSuffix, fromArg, to) {\n        var _a;\n        // Exit out early if we're already fetching deltas\n        if (this.fetching) {\n            return;\n        }\n        if (this.closed) {\n            this.logger.sendTelemetryEvent({ eventName: \"fetchMissingDeltasClosedConnection\" });\n            return;\n        }\n        assert(fromArg === this.lastQueuedSequenceNumber, 0x0f1 /* \"from arg\" */);\n        let from = fromArg;\n        const n = (_a = this.previouslyProcessedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber;\n        if (n !== undefined) {\n            // If we already processed at least one op, then we have this.previouslyProcessedMessage populated\n            // and can use it to validate that we are operating on same file, i.e. it was not overwritten.\n            // Knowing about this mechanism, we could ask for op we already observed to increase validation.\n            // This is especially useful when coming out of offline mode or loading from\n            // very old cached (by client / driver) snapshot.\n            assert(n === fromArg, 0x0f2 /* \"previouslyProcessedMessage\" */);\n            assert(from > 0, 0x0f3 /* \"not positive\" */);\n            from--;\n        }\n        this.fetching = true;\n        this.getDeltas(telemetryEventSuffix, from, to, (messages) => {\n            this.refreshDelayInfo(this.deltaStorageDelayId);\n            this.enqueueMessages(messages, telemetryEventSuffix);\n        }).finally(() => {\n            this.refreshDelayInfo(this.deltaStorageDelayId);\n            this.fetching = false;\n        }).catch((error) => {\n            this.logger.sendErrorEvent({ eventName: \"GetDeltas_Exception\" }, error);\n        });\n    }\n    catchUp(messages, telemetryEventSuffix) {\n        const props = {\n            eventName: `CatchUp_${telemetryEventSuffix}`,\n            messageCount: messages.length,\n            pendingCount: this.pending.length,\n        };\n        if (messages.length !== 0) {\n            props.from = messages[0].sequenceNumber;\n            props.to = messages[messages.length - 1].sequenceNumber;\n            props.messageGap = this.handler !== undefined ? props.from - this.lastQueuedSequenceNumber - 1 : undefined;\n        }\n        this.logger.sendPerformanceEvent(props);\n        this.enqueueMessages(messages, telemetryEventSuffix);\n    }\n    /**\n     * Sorts pending ops and attempts to apply them\n     */\n    processPendingOps(telemetryEventSuffix) {\n        if (this.handler !== undefined) {\n            const pendingSorted = this.pending.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n            this.pending = [];\n            this.enqueueMessages(pendingSorted, telemetryEventSuffix);\n        }\n    }\n    updateLatestKnownOpSeqNumber(seq) {\n        if (this.lastObservedSeqNumber < seq) {\n            this.lastObservedSeqNumber = seq;\n        }\n    }\n}\n// TODO: move this elsewhere and use it more broadly for DataCorruptionError/DataProcessingError\nfunction extractLogSafeMessageProperties(message) {\n    const safeProps = {\n        messageClientId: message.clientId,\n        sequenceNumber: message.sequenceNumber,\n        clientSequenceNumber: message.clientSequenceNumber,\n        referenceSequenceNumber: message.referenceSequenceNumber,\n        minimumSequenceNumber: message.minimumSequenceNumber,\n        messageTimestamp: message.timestamp,\n    };\n    return safeProps;\n}\n//# sourceMappingURL=deltaManager.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { EventForwarder } from \"@fluidframework/common-utils\";\n/**\n * Proxy to the real IDeltaQueue - used to restrict access\n */\nexport class DeltaQueueProxy extends EventForwarder {\n    constructor(queue) {\n        super(queue);\n        this.queue = queue;\n    }\n    get paused() {\n        return this.queue.paused;\n    }\n    get length() {\n        return this.queue.length;\n    }\n    get idle() {\n        return this.queue.idle;\n    }\n    peek() {\n        return this.queue.peek();\n    }\n    toArray() {\n        return this.queue.toArray();\n    }\n    // back-compat: usage removed in 0.33, remove in future versions\n    async systemPause() {\n        return this.pause();\n    }\n    async pause() {\n        return this.queue.pause();\n    }\n    // back-compat: usage removed in 0.33, remove in future versions\n    async systemResume() {\n        return this.resume();\n    }\n    async resume() {\n        this.queue.resume();\n    }\n}\n/**\n * Proxy to the real IDeltaManager - used to restrict access\n */\nexport class DeltaManagerProxy extends EventForwarder {\n    constructor(deltaManager) {\n        super(deltaManager);\n        this.deltaManager = deltaManager;\n        this.inbound = new DeltaQueueProxy(deltaManager.inbound);\n        this.outbound = new DeltaQueueProxy(deltaManager.outbound);\n        this.inboundSignal = new DeltaQueueProxy(deltaManager.inboundSignal);\n    }\n    get IDeltaSender() {\n        return this;\n    }\n    get minimumSequenceNumber() {\n        return this.deltaManager.minimumSequenceNumber;\n    }\n    get lastSequenceNumber() {\n        return this.deltaManager.lastSequenceNumber;\n    }\n    get lastMessage() {\n        return this.deltaManager.lastMessage;\n    }\n    get lastKnownSeqNumber() {\n        return this.deltaManager.lastKnownSeqNumber;\n    }\n    get initialSequenceNumber() {\n        return this.deltaManager.initialSequenceNumber;\n    }\n    get hasCheckpointSequenceNumber() {\n        return this.deltaManager.hasCheckpointSequenceNumber;\n    }\n    get clientDetails() {\n        return this.deltaManager.clientDetails;\n    }\n    get version() {\n        return this.deltaManager.version;\n    }\n    get maxMessageSize() {\n        return this.deltaManager.maxMessageSize;\n    }\n    get serviceConfiguration() {\n        return this.deltaManager.serviceConfiguration;\n    }\n    get active() {\n        return this.deltaManager.active;\n    }\n    get readonly() {\n        return this.deltaManager.readonly;\n    }\n    get readOnlyInfo() {\n        return this.deltaManager.readOnlyInfo;\n    }\n    dispose() {\n        this.inbound.dispose();\n        this.outbound.dispose();\n        this.inboundSignal.dispose();\n        super.dispose();\n    }\n    close() {\n        return this.deltaManager.close();\n    }\n    submitSignal(content) {\n        return this.deltaManager.submitSignal(content);\n    }\n    flush() {\n        return this.deltaManager.flush();\n    }\n}\n//# sourceMappingURL=deltaManagerProxy.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, performance, Deferred, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport Deque from \"double-ended-queue\";\nexport class DeltaQueue extends TypedEventEmitter {\n    /**\n     * @param worker - A callback to process a delta.\n     * @param logger - For logging telemetry.\n     */\n    constructor(worker) {\n        super();\n        this.worker = worker;\n        this.isDisposed = false;\n        this.q = new Deque();\n        /**\n         * Tracks the number of pause requests for the queue\n         * The DeltaQueue is create initially paused.\n         */\n        this.pauseCount = 1;\n    }\n    get disposed() {\n        return this.isDisposed;\n    }\n    /**\n     * @returns True if the queue is paused, false if not.\n     */\n    get paused() {\n        return this.pauseCount !== 0;\n    }\n    get length() {\n        return this.q.length;\n    }\n    get idle() {\n        return this.processingDeferred === undefined && this.q.length === 0;\n    }\n    dispose() {\n        throw new Error(\"Not implemented.\");\n        this.isDisposed = true;\n    }\n    clear() {\n        this.q.clear();\n    }\n    peek() {\n        return this.q.peekFront();\n    }\n    toArray() {\n        return this.q.toArray();\n    }\n    push(task) {\n        this.q.push(task);\n        this.emit(\"push\", task);\n        this.ensureProcessing();\n    }\n    async pause() {\n        this.pauseCount++;\n        // If called from within the processing loop, we are in the middle of processing an op. Return a promise\n        // that will resolve when processing has actually stopped.\n        if (this.processingDeferred !== undefined) {\n            return this.processingDeferred.promise;\n        }\n    }\n    resume() {\n        assert(this.pauseCount > 0, 0x0f4 /* \"Nonzero pause-count on resume()\" */);\n        this.pauseCount--;\n        if (!this.paused) {\n            this.ensureProcessing();\n        }\n    }\n    /**\n     * There are several actions that may need to kick off delta processing, so we want to guard against\n     * accidental reentrancy. ensureProcessing can be called safely to start the processing loop if it is\n     * not already started.\n     */\n    ensureProcessing() {\n        if (this.processingDeferred === undefined) {\n            this.processingDeferred = new Deferred();\n            // Use a resolved promise to start the processing on a separate stack.\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            Promise.resolve().then(() => {\n                this.processDeltas();\n                if (this.processingDeferred !== undefined) {\n                    this.processingDeferred.resolve();\n                    this.processingDeferred = undefined;\n                }\n            });\n        }\n    }\n    /**\n     * Executes the delta processing loop until a stop condition is reached.\n     */\n    processDeltas() {\n        const start = performance.now();\n        let count = 0;\n        // For grouping to work we must process all local messages immediately and in the single turn.\n        // So loop over them until no messages to process, we have become paused, or hit an error.\n        while (!(this.q.length === 0 || this.paused || this.error !== undefined)) {\n            // Get the next message in the queue\n            const next = this.q.shift();\n            count++;\n            // Process the message.\n            try {\n                // We know next is defined since we did a length check just prior to shifting.\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this.worker(next);\n                this.emit(\"op\", next);\n            }\n            catch (error) {\n                this.error = error;\n                this.emit(\"error\", error);\n            }\n        }\n        if (this.q.length === 0) {\n            this.emit(\"idle\", count, performance.now() - start);\n        }\n    }\n}\n//# sourceMappingURL=deltaQueue.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { EventEmitter } from \"events\";\nimport { v4 as uuid } from \"uuid\";\nimport { LoaderHeader, } from \"@fluidframework/container-definitions\";\nimport { Deferred, performance } from \"@fluidframework/common-utils\";\nimport { ChildLogger, DebugLogger, PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nimport { ensureFluidResolvedUrl, MultiUrlResolver, MultiDocumentServiceFactory, } from \"@fluidframework/driver-utils\";\nimport { Container } from \"./container\";\nimport { debug } from \"./debug\";\nimport { parseUrl } from \"./utils\";\nfunction canUseCache(request) {\n    if (request.headers === undefined) {\n        return true;\n    }\n    return request.headers[LoaderHeader.cache] !== false;\n}\nexport class RelativeLoader extends EventEmitter {\n    /**\n     * BaseRequest is the original request that triggered the load. This URL is used in case credentials need\n     * to be fetched again.\n     */\n    constructor(loader, containerUrl) {\n        super();\n        this.loader = loader;\n        this.containerUrl = containerUrl;\n        // Because the loader is passed to the container during construction we need to resolve the target container\n        // after construction.\n        this.containerDeferred = new Deferred();\n    }\n    get IFluidRouter() { return this; }\n    async resolve(request) {\n        if (request.url.startsWith(\"/\")) {\n            // If no headers are set that require a reload make use of the same object\n            const container = await this.containerDeferred.promise;\n            return container;\n        }\n        return this.loader.resolve(request);\n    }\n    async request(request) {\n        const containerUrl = this.containerUrl();\n        if (request.url.startsWith(\"/\")) {\n            let container;\n            if (canUseCache(request)) {\n                container = await this.containerDeferred.promise;\n            }\n            else if (containerUrl === undefined) {\n                throw new Error(\"Container url is not provided\");\n            }\n            else {\n                container = await this.loader.resolve({ url: containerUrl, headers: request.headers });\n            }\n            return container.request(request);\n        }\n        return this.loader.request(request);\n    }\n    resolveContainer(container) {\n        this.containerDeferred.resolve(container);\n    }\n}\nfunction createCachedResolver(resolver) {\n    const cacheResolver = Object.create(resolver);\n    const resolveCache = new Map();\n    cacheResolver.resolve = async (request) => {\n        if (!canUseCache(request)) {\n            return resolver.resolve(request);\n        }\n        if (!resolveCache.has(request.url)) {\n            resolveCache.set(request.url, resolver.resolve(request));\n        }\n        return resolveCache.get(request.url);\n    };\n    return cacheResolver;\n}\n/**\n * Manages Fluid resource loading\n */\nexport class Loader extends EventEmitter {\n    constructor(loaderProps) {\n        var _a, _b, _c;\n        super();\n        this.containers = new Map();\n        const scope = Object.assign({}, loaderProps.scope);\n        if (((_a = loaderProps.options) === null || _a === void 0 ? void 0 : _a.provideScopeLoader) === true) {\n            scope.ILoader = this;\n        }\n        this.services = {\n            urlResolver: createCachedResolver(MultiUrlResolver.create(loaderProps.urlResolver)),\n            documentServiceFactory: MultiDocumentServiceFactory.create(loaderProps.documentServiceFactory),\n            codeLoader: loaderProps.codeLoader,\n            options: (_b = loaderProps.options) !== null && _b !== void 0 ? _b : {},\n            scope,\n            subLogger: DebugLogger.mixinDebugLogger(\"fluid:telemetry\", loaderProps.logger, { all: { loaderId: uuid() } }),\n            proxyLoaderFactories: (_c = loaderProps.proxyLoaderFactories) !== null && _c !== void 0 ? _c : new Map(),\n        };\n        this.logger = ChildLogger.create(this.services.subLogger, \"Loader\");\n    }\n    /**\n     * @deprecated use constructor with loader props\n     */\n    static _create(resolver, documentServiceFactory, codeLoader, options, scope, proxyLoaderFactories, logger) {\n        return new Loader({\n            urlResolver: MultiUrlResolver.create(resolver),\n            documentServiceFactory: MultiDocumentServiceFactory.create(documentServiceFactory),\n            codeLoader,\n            options,\n            scope,\n            proxyLoaderFactories,\n            logger,\n        });\n    }\n    get IFluidRouter() { return this; }\n    async createDetachedContainer(codeDetails) {\n        debug(`Container creating in detached state: ${performance.now()} `);\n        const container = await Container.createDetached(this, codeDetails);\n        if (this.cachingEnabled) {\n            container.once(\"attached\", () => {\n                ensureFluidResolvedUrl(container.resolvedUrl);\n                const parsedUrl = parseUrl(container.resolvedUrl.url);\n                if (parsedUrl !== undefined) {\n                    this.addToContainerCache(parsedUrl.id, Promise.resolve(container));\n                }\n            });\n        }\n        return container;\n    }\n    async rehydrateDetachedContainerFromSnapshot(snapshot) {\n        debug(`Container creating in detached state: ${performance.now()} `);\n        return Container.rehydrateDetachedFromSnapshot(this, JSON.parse(snapshot));\n    }\n    async resolve(request, pendingLocalState) {\n        const eventName = pendingLocalState === undefined ? \"Resolve\" : \"ResolveWithPendingState\";\n        return PerformanceEvent.timedExecAsync(this.logger, { eventName }, async () => {\n            const resolved = await this.resolveCore(request, pendingLocalState !== undefined ? JSON.parse(pendingLocalState) : undefined);\n            return resolved.container;\n        });\n    }\n    async request(request) {\n        return PerformanceEvent.timedExecAsync(this.logger, { eventName: \"Request\" }, async () => {\n            const resolved = await this.resolveCore(request);\n            return resolved.container.request({ url: `${resolved.parsed.path}${resolved.parsed.query}` });\n        });\n    }\n    getKeyForContainerCache(request, parsedUrl) {\n        var _a;\n        const key = ((_a = request.headers) === null || _a === void 0 ? void 0 : _a[LoaderHeader.version]) !== undefined\n            ? `${parsedUrl.id}@${request.headers[LoaderHeader.version]}`\n            : parsedUrl.id;\n        return key;\n    }\n    addToContainerCache(key, containerP) {\n        this.containers.set(key, containerP);\n        containerP.then((container) => {\n            // If the container is closed or becomes closed after we resolve it, remove it from the cache.\n            if (container.closed) {\n                this.containers.delete(key);\n            }\n            else {\n                container.once(\"closed\", () => {\n                    this.containers.delete(key);\n                });\n            }\n        }).catch((error) => { console.error(\"Error during caching Container on the Loader\", error); });\n    }\n    async resolveCore(request, pendingLocalState) {\n        const resolvedAsFluid = await this.services.urlResolver.resolve(request);\n        ensureFluidResolvedUrl(resolvedAsFluid);\n        // Parse URL into data stores\n        const parsed = parseUrl(resolvedAsFluid.url);\n        if (parsed === undefined) {\n            throw new Error(`Invalid URL ${resolvedAsFluid.url}`);\n        }\n        if (pendingLocalState !== undefined) {\n            const parsedPendingUrl = parseUrl(pendingLocalState.url);\n            if ((parsedPendingUrl === null || parsedPendingUrl === void 0 ? void 0 : parsedPendingUrl.id) !== parsed.id ||\n                (parsedPendingUrl === null || parsedPendingUrl === void 0 ? void 0 : parsedPendingUrl.path.replace(/\\/$/, \"\")) !== parsed.path.replace(/\\/$/, \"\")) {\n                const message = `URL ${resolvedAsFluid.url} does not match pending state URL ${pendingLocalState.url}`;\n                throw new Error(message);\n            }\n        }\n        // parseUrl's id is expected to be of format \"tenantId/docId\"\n        const [, docId] = parsed.id.split(\"/\");\n        const { canCache, fromSequenceNumber } = this.parseHeader(parsed, request);\n        const shouldCache = pendingLocalState !== undefined ? false : canCache;\n        let container;\n        if (shouldCache) {\n            const key = this.getKeyForContainerCache(request, parsed);\n            const maybeContainer = await this.containers.get(key);\n            if (maybeContainer !== undefined) {\n                container = maybeContainer;\n            }\n            else {\n                const containerP = this.loadContainer(docId, request, resolvedAsFluid);\n                this.addToContainerCache(key, containerP);\n                container = await containerP;\n            }\n        }\n        else {\n            container =\n                await this.loadContainer(docId, request, resolvedAsFluid, pendingLocalState === null || pendingLocalState === void 0 ? void 0 : pendingLocalState.pendingRuntimeState);\n        }\n        if (container.deltaManager.lastSequenceNumber <= fromSequenceNumber) {\n            await new Promise((resolve, reject) => {\n                function opHandler(message) {\n                    if (message.sequenceNumber > fromSequenceNumber) {\n                        resolve();\n                        container.removeListener(\"op\", opHandler);\n                    }\n                }\n                container.on(\"op\", opHandler);\n            });\n        }\n        return { container, parsed };\n    }\n    get cachingEnabled() {\n        return this.services.options.cache !== false;\n    }\n    canCacheForRequest(headers) {\n        return this.cachingEnabled && headers[LoaderHeader.cache] !== false;\n    }\n    parseHeader(parsed, request) {\n        var _a, _b;\n        let fromSequenceNumber = -1;\n        request.headers = (_a = request.headers) !== null && _a !== void 0 ? _a : {};\n        const headerSeqNum = request.headers[LoaderHeader.sequenceNumber];\n        if (headerSeqNum !== undefined) {\n            fromSequenceNumber = headerSeqNum;\n        }\n        // If set in both query string and headers, use query string\n        request.headers[LoaderHeader.version] = (_b = parsed.version) !== null && _b !== void 0 ? _b : request.headers[LoaderHeader.version];\n        // Version === null means not use any snapshot.\n        if (request.headers[LoaderHeader.version] === \"null\") {\n            request.headers[LoaderHeader.version] = null;\n        }\n        const canCache = this.canCacheForRequest(request.headers);\n        debug(`${canCache} ${request.headers[LoaderHeader.version]}`);\n        return {\n            canCache,\n            fromSequenceNumber,\n        };\n    }\n    async loadContainer(encodedDocId, request, resolved, pendingLocalState) {\n        var _a, _b, _c, _d;\n        const docId = decodeURI(encodedDocId);\n        return Container.load(this, {\n            canReconnect: (_a = request.headers) === null || _a === void 0 ? void 0 : _a[LoaderHeader.reconnect],\n            clientDetailsOverride: (_b = request.headers) === null || _b === void 0 ? void 0 : _b[LoaderHeader.clientDetails],\n            containerUrl: request.url,\n            docId,\n            resolvedUrl: resolved,\n            version: (_c = request.headers) === null || _c === void 0 ? void 0 : _c[LoaderHeader.version],\n            pause: (_d = request.headers) === null || _d === void 0 ? void 0 : _d[LoaderHeader.pause],\n        }, pendingLocalState);\n    }\n}\n//# sourceMappingURL=loader.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { isOnline, OnlineStatus } from \"@fluidframework/driver-utils\";\nexport function logNetworkFailure(logger, event, error) {\n    var _a, _b;\n    const newEvent = Object.assign({}, event);\n    newEvent.online = isOnline();\n    if ((error === null || error === void 0 ? void 0 : error.online) !== undefined) {\n        newEvent.online = error.online;\n    }\n    if (typeof navigator === \"object\" && navigator !== null) {\n        const nav = navigator;\n        const connection = (_b = (_a = nav.connection) !== null && _a !== void 0 ? _a : nav.mozConnection) !== null && _b !== void 0 ? _b : nav.webkitConnection;\n        if (connection !== null && typeof connection === \"object\") {\n            newEvent.connectionType = connection.type;\n        }\n    }\n    // If we are online, log it as an error, such that we look at it ASAP.\n    // But if we  are offline, log non-error event - we will remove\n    // it in the future once confident it's right thing to do.\n    // Note: Unfortunately false positives happen in here (i.e. cable disconnected, but it reports true)!\n    newEvent.category = newEvent.online === OnlineStatus.Online ? \"error\" : \"generic\";\n    logger.sendTelemetryEvent(newEvent, error);\n}\n/**\n * Wait for browser to get to connected state.\n * If connected, waits minimum of minDelay anyway (between network retries)\n * If disconnected, polls every 30 seconds anyway, to make sure we are not getting stuck because of wrong signal\n * Note that browsers will have false positives (like having Hyper-V adapter on machine,\n * or machine connected to router that is not connected to internet)\n * But there should be no false negatives.\n * The only exception - Opera returns false when user enters \"Work Offline\" mode, regardless of actual connectivity.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async\nexport function waitForConnectedState(minDelay) {\n    // Use this frequency to poll even when we are offline and able to setup online/offline listener\n    // This is mostly safety net\n    const offlinePollFrequency = 30000;\n    return new Promise((resolve) => {\n        let listener = resolve;\n        let delay = minDelay;\n        if (isOnline() === OnlineStatus.Offline) {\n            if ((window === null || window === void 0 ? void 0 : window.addEventListener) !== undefined) {\n                listener = () => {\n                    resolve();\n                    window.removeEventListener(\"online\", listener);\n                };\n                window.addEventListener(\"online\", listener, false);\n                delay = Math.max(minDelay, offlinePollFrequency);\n            }\n        }\n        setTimeout(listener, delay);\n    });\n}\n//# sourceMappingURL=networkUtils.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { EventEmitter } from \"events\";\nexport class NullRuntime extends EventEmitter {\n    constructor() {\n        super();\n        this._disposed = false;\n    }\n    get IFluidSerializer() {\n        throw new Error(\"Not implemented\");\n    }\n    get IFluidHandleContext() {\n        throw new Error(\"Not implemented\");\n    }\n    get disposed() { return this._disposed; }\n    dispose() {\n        this._disposed = true;\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\n    snapshot(tagMessage) {\n        return Promise.resolve(null);\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\n    summarize(fullTree = false) {\n        return Promise.resolve({\n            tree: {},\n            type: 1 /* Tree */,\n        });\n    }\n    setConnectionState(connected, clientId) {\n        return;\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\n    stop() {\n        return Promise.resolve({});\n    }\n    createSummary() {\n        return {\n            tree: {},\n            type: 1 /* Tree */,\n        };\n    }\n    setAttachState(attachState) {\n        throw new Error(\"Null Runtime should not be attached\");\n    }\n    async request(request) {\n        return { status: 404, mimeType: \"text/plain\", value: \"NullRuntime can't resolve\" };\n    }\n    process(message, local, context) {\n        throw new Error(\"Null runtime should not receive messages\");\n    }\n    processSignal(message, local) {\n        // Null runtime can receive signals but it's okay to miss those.\n        return;\n    }\n    getPendingLocalState() {\n        throw new Error(\"Null runtime should not be asked for pending state\");\n    }\n}\nexport class NullChaincode {\n    async instantiateRuntime(context) {\n        return new NullRuntime();\n    }\n    get IRuntimeFactory() { return this; }\n}\n//# sourceMappingURL=nullRuntime.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n *\n * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n */\nexport const pkgName = \"@fluidframework/container-loader\";\nexport const pkgVersion = \"0.37.4\";\n//# sourceMappingURL=packageVersion.js.map","import { DocumentStorageServiceProxy } from \"@fluidframework/driver-utils\";\nimport { LoaderCachingPolicy, } from \"@fluidframework/driver-definitions\";\nimport { debug } from \"./debug\";\nexport class PrefetchDocumentStorageService extends DocumentStorageServiceProxy {\n    constructor() {\n        super(...arguments);\n        // BlobId -> blob prefetchCache cache\n        this.prefetchCache = new Map();\n        this.prefetchEnabled = true;\n    }\n    get policies() {\n        const policies = this.internalStorageService.policies;\n        if (policies) {\n            return Object.assign(Object.assign({}, policies), { caching: LoaderCachingPolicy.NoCaching });\n        }\n    }\n    async getSnapshotTree(version) {\n        const p = this.internalStorageService.getSnapshotTree(version);\n        if (this.prefetchEnabled) {\n            // We don't care if the prefetch succeed\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            p.then((tree) => {\n                if (tree === null || tree === undefined) {\n                    return;\n                }\n                this.prefetchTree(tree);\n            });\n        }\n        return p;\n    }\n    async readBlob(blobId) {\n        return this.cachedRead(blobId);\n    }\n    stopPrefetch() {\n        this.prefetchEnabled = false;\n        this.prefetchCache.clear();\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\n    cachedRead(blobId) {\n        if (this.prefetchEnabled) {\n            const prefetchedBlobP = this.prefetchCache.get(blobId);\n            if (prefetchedBlobP !== undefined) {\n                return prefetchedBlobP;\n            }\n            const prefetchedBlobPFromStorage = this.internalStorageService.readBlob(blobId);\n            this.prefetchCache.set(blobId, prefetchedBlobPFromStorage);\n            return prefetchedBlobPFromStorage;\n        }\n        return this.internalStorageService.readBlob(blobId);\n    }\n    prefetchTree(tree) {\n        const secondary = [];\n        this.prefetchTreeCore(tree, secondary);\n        for (const blob of secondary) {\n            // We don't care if the prefetch succeed\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.cachedRead(blob);\n        }\n    }\n    prefetchTreeCore(tree, secondary) {\n        for (const blobKey of Object.keys(tree.blobs)) {\n            const blob = tree.blobs[blobKey];\n            if (blobKey.startsWith(\".\") || blobKey === \"header\" || blobKey.startsWith(\"quorum\")) {\n                if (blob !== null) {\n                    // We don't care if the prefetch succeed\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                    this.cachedRead(blob);\n                }\n            }\n            else if (!blobKey.startsWith(\"deltas\")) {\n                if (blob !== null) {\n                    secondary.push(blob);\n                }\n            }\n        }\n        for (const commit of Object.keys(tree.commits)) {\n            this.getVersions(tree.commits[commit], 1)\n                // eslint-disable-next-line @typescript-eslint/promise-function-async\n                .then((moduleCommit) => this.getSnapshotTree(moduleCommit[0]))\n                .catch((error) => debug(\"Ignored cached read error\", error));\n        }\n        for (const subTree of Object.keys(tree.trees)) {\n            this.prefetchTreeCore(tree.trees[subTree], secondary);\n        }\n    }\n}\n//# sourceMappingURL=prefetchDocumentStorageService.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { CreateContainerError } from \"@fluidframework/container-utils\";\nimport { canRetryOnError, getRetryDelayFromError } from \"@fluidframework/driver-utils\";\nimport { performance, bufferToString } from \"@fluidframework/common-utils\";\nimport { v4 as uuid } from \"uuid\";\nexport class RetriableDocumentStorageService {\n    constructor(internalStorageService, deltaManager, logger) {\n        this.internalStorageService = internalStorageService;\n        this.deltaManager = deltaManager;\n        this.logger = logger;\n        this.disposed = false;\n    }\n    get policies() {\n        return this.internalStorageService.policies;\n    }\n    dispose() {\n        this.disposed = true;\n    }\n    get repositoryUrl() {\n        return this.internalStorageService.repositoryUrl;\n    }\n    async getSnapshotTree(version) {\n        return this.readWithRetry(async () => this.internalStorageService.getSnapshotTree(version), \"getSnapshotTree\");\n    }\n    async read(blobId) {\n        return this.readWithRetry(async () => bufferToString(await this.internalStorageService.readBlob(blobId), \"base64\"), \"read\");\n    }\n    async readBlob(id) {\n        return this.readWithRetry(async () => this.internalStorageService.readBlob(id), \"readBlob\");\n    }\n    async getVersions(versionId, count) {\n        return this.readWithRetry(async () => this.internalStorageService.getVersions(versionId, count), \"getVersions\");\n    }\n    async write(tree, parents, message, ref) {\n        return this.readWithRetry(async () => this.internalStorageService.write(tree, parents, message, ref), \"write\");\n    }\n    async uploadSummaryWithContext(summary, context) {\n        return this.readWithRetry(async () => this.internalStorageService.uploadSummaryWithContext(summary, context), \"uploadSummaryWithContext\");\n    }\n    async downloadSummary(handle) {\n        return this.readWithRetry(async () => this.internalStorageService.downloadSummary(handle), \"downloadSummary\");\n    }\n    async createBlob(file) {\n        return this.readWithRetry(async () => this.internalStorageService.createBlob(file), \"createBlob\");\n    }\n    async delay(timeMs) {\n        return new Promise((resolve) => setTimeout(() => resolve(), timeMs));\n    }\n    async readWithRetry(api, fetchCallName) {\n        var _a;\n        let result;\n        let success = false;\n        let retryAfter = 1; // has to be positive!\n        let numRetries = 0;\n        const startTime = performance.now();\n        let lastError;\n        let id;\n        do {\n            try {\n                result = await api();\n                if (id !== undefined) {\n                    this.deltaManager.refreshDelayInfo(id);\n                }\n                success = true;\n            }\n            catch (err) {\n                if (this.disposed) {\n                    // eslint-disable-next-line @typescript-eslint/no-throw-literal\n                    throw CreateContainerError(\"Storage service disposed!!\");\n                }\n                // If it is not retriable, then just throw the error.\n                if (!canRetryOnError(err)) {\n                    this.logger.sendErrorEvent({\n                        eventName: `Storage_${fetchCallName}`,\n                        retry: numRetries,\n                        duration: performance.now() - startTime,\n                    }, err);\n                    throw err;\n                }\n                numRetries++;\n                lastError = err;\n                // If the error is throttling error, then wait for the specified time before retrying.\n                // If the waitTime is not specified, then we start with retrying immediately to max of 8s.\n                retryAfter = (_a = getRetryDelayFromError(err)) !== null && _a !== void 0 ? _a : Math.min(retryAfter * 2, 8000);\n                if (id === undefined) {\n                    id = uuid();\n                }\n                this.deltaManager.emitDelayInfo(id, retryAfter, CreateContainerError(err));\n                await this.delay(retryAfter);\n            }\n        } while (!success);\n        if (numRetries > 0) {\n            this.logger.sendTelemetryEvent({\n                eventName: `Storage_${fetchCallName}`,\n                retry: numRetries,\n                duration: performance.now() - startTime,\n            }, lastError);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return result;\n    }\n}\n//# sourceMappingURL=retriableDocumentStorageService.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { parse } from \"url\";\nimport { fromUtf8ToBase64, bufferToString } from \"@fluidframework/common-utils\";\nimport { v4 as uuid } from \"uuid\";\nexport function parseUrl(url) {\n    var _a;\n    const parsed = parse(url, true);\n    if (typeof parsed.pathname !== \"string\") {\n        throw new Error(\"Failed to parse pathname\");\n    }\n    const query = (_a = parsed.search) !== null && _a !== void 0 ? _a : \"\";\n    const regex = /^\\/([^/]*\\/[^/]*)(\\/?.*)$/;\n    const match = regex.exec(parsed.pathname);\n    return ((match === null || match === void 0 ? void 0 : match.length) === 3)\n        ? { id: match[1], path: match[2], query, version: parsed.query.version }\n        : undefined;\n}\n/**\n * Converts summary tree (for upload) to snapshot tree (for download).\n * Summary tree blobs contain contents, but snapshot tree blobs normally\n * contain IDs pointing to storage. This will create 2 blob entries in the\n * snapshot tree for each blob in the summary tree. One will be the regular\n * path pointing to a uniquely generated ID. Then there will be another\n * entry with the path as that uniquely generated ID, and value as the\n * blob contents as a base-64 string.\n * @param summary - summary to convert\n */\nfunction convertSummaryToSnapshotWithEmbeddedBlobContents(summary) {\n    const treeNode = {\n        blobs: {},\n        trees: {},\n        commits: {},\n        id: uuid(),\n    };\n    const keys = Object.keys(summary.tree);\n    for (const key of keys) {\n        const summaryObject = summary.tree[key];\n        switch (summaryObject.type) {\n            case 1 /* Tree */: {\n                treeNode.trees[key] = convertSummaryToSnapshotWithEmbeddedBlobContents(summaryObject);\n                break;\n            }\n            case 2 /* Blob */: {\n                const blobId = uuid();\n                treeNode.blobs[key] = blobId;\n                treeNode.blobs[blobId] = typeof summaryObject.content === \"string\" ?\n                    fromUtf8ToBase64(summaryObject.content) :\n                    bufferToString(summaryObject.content, \"base64\");\n                break;\n            }\n            case 3 /* Handle */:\n                throw new Error(\"No handles should be there in summary in detached container!!\");\n                break;\n            default: {\n                throw new Error(`Unknown tree type ${summaryObject.type}`);\n            }\n        }\n    }\n    return treeNode;\n}\n/**\n * Combine and convert protocol and app summary tree to format which is readable by container while rehydrating.\n * @param protocolSummaryTree - Protocol Summary Tree\n * @param appSummaryTree - App Summary Tree\n */\nexport function convertProtocolAndAppSummaryToSnapshotTree(protocolSummaryTree, appSummaryTree) {\n    // Shallow copy is fine, since we are doing a deep clone below.\n    const combinedSummary = {\n        type: 1 /* Tree */,\n        tree: Object.assign({}, appSummaryTree.tree),\n    };\n    combinedSummary.tree[\".protocol\"] = protocolSummaryTree;\n    const snapshotTree = convertSummaryToSnapshotWithEmbeddedBlobContents(combinedSummary);\n    return snapshotTree;\n}\n//# sourceMappingURL=utils.js.map","\"use strict\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IContainerRuntime = void 0;\nexports.IContainerRuntime = \"IContainerRuntime\";\n//# sourceMappingURL=containerRuntime.js.map","\"use strict\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IContainerRuntimeDirtyable = void 0;\nexports.IContainerRuntimeDirtyable = \"IContainerRuntimeDirtyable\";\n//# sourceMappingURL=containerRuntimeDirtyable.js.map","\"use strict\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./containerRuntime\"), exports);\n__exportStar(require(\"./containerRuntimeDirtyable\"), exports);\n//# sourceMappingURL=index.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { AttachmentTreeEntry } from \"@fluidframework/protocol-base\";\nimport { generateHandleContextPath } from \"@fluidframework/runtime-utils\";\nimport { assert } from \"@fluidframework/common-utils\";\n/**\n * This class represents blob (long string)\n * This object is used only when creating (writing) new blob and serialization purposes.\n * De-serialization process goes through FluidObjectHandle and request flow:\n * DataObject.request() recognizes requests in the form of `/blobs/<id>`\n * and loads blob.\n */\nexport class BlobHandle {\n    constructor(path, routeContext, get, attachGraphCallback) {\n        this.path = path;\n        this.routeContext = routeContext;\n        this.get = get;\n        this.attachGraphCallback = attachGraphCallback;\n        this.absolutePath = generateHandleContextPath(path, this.routeContext);\n    }\n    get IFluidHandle() { return this; }\n    get isAttached() {\n        return this.attachGraphCallback === undefined;\n    }\n    attachGraph() {\n        if (this.attachGraphCallback) {\n            this.attachGraphCallback();\n            this.attachGraphCallback = undefined;\n        }\n    }\n    bind(handle) {\n        throw new Error(\"Cannot bind to blob handle\");\n    }\n}\nexport class BlobManager {\n    constructor(routeContext, getStorage, attachBlobCallback, logger) {\n        this.routeContext = routeContext;\n        this.getStorage = getStorage;\n        this.attachBlobCallback = attachBlobCallback;\n        this.logger = logger;\n        this.pendingBlobIds = new Set();\n        this.blobIds = new Set();\n    }\n    async getBlob(blobId) {\n        assert(this.blobIds.has(blobId) || this.pendingBlobIds.has(blobId), 0x11f /* \"requesting unknown blobs\" */);\n        return new BlobHandle(`${BlobManager.basePath}/${blobId}`, this.routeContext, async () => this.getStorage().readBlob(blobId), undefined);\n    }\n    async createBlob(blob) {\n        const response = await this.getStorage().createBlob(blob);\n        const handle = new BlobHandle(`${BlobManager.basePath}/${response.id}`, this.routeContext, async () => this.getStorage().readBlob(response.id), () => this.attachBlobCallback(response.id));\n        // Note - server will de-dup blobs, so we might get existing blobId!\n        if (!this.blobIds.has(response.id)) {\n            this.pendingBlobIds.add(response.id);\n        }\n        return handle;\n    }\n    addBlobId(blobId) {\n        this.blobIds.add(blobId);\n        this.pendingBlobIds.delete(blobId);\n    }\n    /**\n     * Load a set of previously attached blob IDs from a previous snapshot. Note\n     * that BlobManager tracking and reporting attached blobs is a temporary\n     * solution since storage expects attached blobs to be reported and any that\n     * are not reported as attached may be GCed. In the future attached blob\n     * IDs will be collected at summarization time, and runtime will not care\n     * about the existence or specific formatting of this tree in returned\n     * snapshots.\n     *\n     * @param blobsTree - Tree containing IDs of previously attached blobs. This\n     * corresponds to snapshot() below. We look for the IDs in the blob entries\n     * of the tree since the both the r11s and SPO drivers replace the\n     * attachment types returned in snapshot() with blobs.\n     */\n    load(blobsTree) {\n        let count = 0;\n        if (blobsTree) {\n            const values = Object.values(blobsTree.blobs);\n            count = values.length;\n            values.map((entry) => this.addBlobId(entry));\n        }\n        this.logger.sendTelemetryEvent({ eventName: \"ExternalBlobsInSnapshot\", count });\n    }\n    snapshot() {\n        const entries = [...this.blobIds].map((id) => new AttachmentTreeEntry(id, id));\n        return { entries };\n    }\n}\nBlobManager.basePath = \"_blobs\";\n//# sourceMappingURL=blobManager.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { ChildLogger, TelemetryLogger } from \"@fluidframework/telemetry-utils\";\nimport { assert, performance } from \"@fluidframework/common-utils\";\nclass OpPerfTelemetry {\n    constructor(clientId, deltaManager, logger) {\n        this.clientId = clientId;\n        this.deltaManager = deltaManager;\n        this.pongCount = 0;\n        this.socketLatency = 0;\n        this.firstConnection = true;\n        this.bootTime = performance.now();\n        this.connectionStartTime = 0;\n        this.gap = 0;\n        this.logger = ChildLogger.create(logger, \"OpPerf\");\n        this.deltaManager.on(\"pong\", (latency) => this.recordPingTime(latency));\n        this.deltaManager.on(\"submitOp\", (message) => this.beforeOpSubmit(message));\n        this.deltaManager.on(\"op\", (message) => this.afterProcessingOp(message));\n        this.deltaManager.on(\"connect\", (details, opsBehind) => {\n            this.clientId = details.clientId;\n            if (opsBehind !== undefined) {\n                this.connectionOpSeqNumber = this.deltaManager.lastKnownSeqNumber;\n                this.gap = opsBehind;\n                this.connectionStartTime = performance.now();\n                // We might be already up-today. If so, report it right away.\n                if (this.gap <= 0) {\n                    this.reportGettingUpToDate();\n                }\n            }\n        });\n        this.deltaManager.on(\"disconnect\", () => {\n            this.clientSequenceNumberForLatencyStatistics = undefined;\n            this.connectionOpSeqNumber = undefined;\n            this.firstConnection = false;\n        });\n        this.deltaManager.inbound.on(\"idle\", (count, duration) => {\n            // Do not want to log zero for sure.\n            // We are more interested in aggregates, so logging only if we are processing some number of ops\n            // Cut-off is arbitrary - can be increased or decreased based on amount of data collected and questions we\n            // want to get answered\n            // back-compat: Once 0.36 loader version saturates (count & duration args were added there),\n            // we can remove typeof check.\n            if (typeof count === \"number\" && count >= 100) {\n                this.logger.sendPerformanceEvent({\n                    eventName: \"GetDeltas_OpProcessing\",\n                    count,\n                    duration,\n                });\n            }\n        });\n    }\n    reportGettingUpToDate() {\n        this.connectionOpSeqNumber = undefined;\n        this.logger.sendPerformanceEvent({\n            eventName: \"ConnectionSpeed\",\n            duration: performance.now() - this.connectionStartTime,\n            ops: this.gap,\n            // track time to connect only for first connection.\n            timeToConnect: this.firstConnection ?\n                TelemetryLogger.formatTick(this.connectionStartTime - this.bootTime) :\n                undefined,\n            firstConnection: this.firstConnection,\n        });\n    }\n    recordPingTime(latency) {\n        this.pongCount++;\n        this.socketLatency += latency;\n        const aggregateCount = 100;\n        if (this.pongCount === aggregateCount) {\n            this.logger.sendTelemetryEvent({ eventName: \"DeltaLatency\", value: this.socketLatency / aggregateCount });\n            this.pongCount = 0;\n            this.socketLatency = 0;\n        }\n    }\n    beforeOpSubmit(message) {\n        // start with first client op and measure latency every 500 client ops\n        if (this.clientSequenceNumberForLatencyStatistics === undefined && message.clientSequenceNumber % 500 === 1) {\n            this.opSendTimeForLatencyStatistics = Date.now();\n            this.clientSequenceNumberForLatencyStatistics = message.clientSequenceNumber;\n        }\n    }\n    afterProcessingOp(message) {\n        const sequenceNumber = message.sequenceNumber;\n        if (sequenceNumber === this.connectionOpSeqNumber) {\n            this.reportGettingUpToDate();\n        }\n        // Record collab window max size after every 1000th op.\n        if (sequenceNumber % 1000 === 0) {\n            if (this.opSendTimeForLatencyStatisticsForMsnStatistics !== undefined) {\n                this.logger.sendPerformanceEvent({\n                    eventName: \"MsnStatistics\",\n                    sequenceNumber,\n                    msnDistance: this.deltaManager.lastSequenceNumber - this.deltaManager.minimumSequenceNumber,\n                    duration: message.timestamp - this.opSendTimeForLatencyStatisticsForMsnStatistics,\n                });\n            }\n            this.opSendTimeForLatencyStatisticsForMsnStatistics = message.timestamp;\n        }\n        if (this.clientId === message.clientId &&\n            this.clientSequenceNumberForLatencyStatistics === message.clientSequenceNumber) {\n            assert(this.opSendTimeForLatencyStatistics !== undefined, 0x120 /* \"Undefined latency statistics (op send time)\" */);\n            this.logger.sendPerformanceEvent({\n                eventName: \"OpRoundtripTime\",\n                sequenceNumber,\n                duration: Date.now() - this.opSendTimeForLatencyStatistics,\n            });\n            this.clientSequenceNumberForLatencyStatistics = undefined;\n        }\n    }\n}\nexport function ReportOpPerfTelemetry(clientId, deltaManager, logger) {\n    new OpPerfTelemetry(clientId, deltaManager, logger);\n}\n//# sourceMappingURL=connectionTelemetry.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { generateHandleContextPath } from \"@fluidframework/runtime-utils\";\nexport class ContainerFluidHandleContext {\n    /**\n     * Creates a new ContainerFluidHandleContext.\n     * @param path - The path to this handle relative to the routeContext.\n     * @param runtime - The IRuntime object this context represents.\n     * @param routeContext - The parent IFluidHandleContext that has a route to this handle.\n     */\n    constructor(path, runtime, routeContext) {\n        this.path = path;\n        this.runtime = runtime;\n        this.routeContext = routeContext;\n        this.absolutePath = generateHandleContextPath(path, this.routeContext);\n    }\n    get IFluidRouter() { return this; }\n    get IFluidHandleContext() { return this; }\n    attachGraph() {\n        throw new Error(\"can't attach container runtime form within container!\");\n    }\n    get isAttached() {\n        return this.runtime.attachState !== AttachState.Detached;\n    }\n    async resolveHandle(request) {\n        return this.runtime.resolveHandle(request);\n    }\n}\n//# sourceMappingURL=containerHandleContext.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { AgentSchedulerFactory, } from \"@fluidframework/agent-scheduler\";\nimport { AttachState, } from \"@fluidframework/container-definitions\";\nimport { assert, Trace, TypedEventEmitter, unreachableCase, } from \"@fluidframework/common-utils\";\nimport { ChildLogger, raiseConnectedEvent, PerformanceEvent, } from \"@fluidframework/telemetry-utils\";\nimport { readAndParse, readAndParseFromBlobs, BlobAggregationStorage, } from \"@fluidframework/driver-utils\";\nimport { CreateContainerError } from \"@fluidframework/container-utils\";\nimport { runGarbageCollection } from \"@fluidframework/garbage-collector\";\nimport { BlobTreeEntry, TreeTreeEntry, } from \"@fluidframework/protocol-base\";\nimport { MessageType, } from \"@fluidframework/protocol-definitions\";\nimport { FlushMode, channelsTreeName, } from \"@fluidframework/runtime-definitions\";\nimport { addBlobToSummary, addTreeToSummary, convertToSummaryTree, createRootSummarizerNodeWithGC, FluidSerializer, requestFluidObject, RequestParser, create404Response, exceptionToResponse, responseToException, } from \"@fluidframework/runtime-utils\";\nimport { v4 as uuid } from \"uuid\";\nimport { ContainerFluidHandleContext } from \"./containerHandleContext\";\nimport { FluidDataStoreRegistry } from \"./dataStoreRegistry\";\nimport { debug } from \"./debug\";\nimport { Summarizer } from \"./summarizer\";\nimport { SummaryManager } from \"./summaryManager\";\nimport { DeltaScheduler } from \"./deltaScheduler\";\nimport { ReportOpPerfTelemetry } from \"./connectionTelemetry\";\nimport { PendingStateManager } from \"./pendingStateManager\";\nimport { pkgVersion } from \"./packageVersion\";\nimport { BlobManager } from \"./blobManager\";\nimport { DataStores, getSummaryForDatastores } from \"./dataStores\";\nimport { blobsTreeName, chunksBlobName, metadataBlobName, wrapSummaryInChannelsTree, } from \"./summaryFormat\";\nexport var ContainerMessageType;\n(function (ContainerMessageType) {\n    // An op to be delivered to store\n    ContainerMessageType[\"FluidDataStoreOp\"] = \"component\";\n    // Creates a new store\n    ContainerMessageType[\"Attach\"] = \"attach\";\n    // Chunked operation.\n    ContainerMessageType[\"ChunkedOp\"] = \"chunkedOp\";\n    ContainerMessageType[\"BlobAttach\"] = \"blobAttach\";\n})(ContainerMessageType || (ContainerMessageType = {}));\n// Consider idle 5s of no activity. And snapshot if a minute has gone by with no snapshot.\nconst IdleDetectionTime = 5000;\nconst DefaultSummaryConfiguration = {\n    idleTime: IdleDetectionTime,\n    maxTime: IdleDetectionTime * 12,\n    // Snapshot if 1000 ops received since last snapshot.\n    maxOps: 1000,\n    // Wait 2 minutes for summary ack\n    maxAckWaitTime: 120000,\n};\nexport function isRuntimeMessage(message) {\n    switch (message.type) {\n        case ContainerMessageType.FluidDataStoreOp:\n        case ContainerMessageType.ChunkedOp:\n        case ContainerMessageType.Attach:\n        case ContainerMessageType.BlobAttach:\n        case MessageType.Operation:\n            return true;\n        default:\n            return false;\n    }\n}\nexport function unpackRuntimeMessage(message) {\n    if (message.type === MessageType.Operation) {\n        // legacy op format?\n        if (message.contents.address !== undefined && message.contents.type === undefined) {\n            message.type = ContainerMessageType.FluidDataStoreOp;\n        }\n        else {\n            // new format\n            const innerContents = message.contents;\n            assert(innerContents.type !== undefined, 0x121 /* \"Undefined inner contents type!\" */);\n            message.type = innerContents.type;\n            message.contents = innerContents.contents;\n        }\n        assert(isRuntimeMessage(message), 0x122 /* \"Message to unpack is not proper runtime message\" */);\n    }\n    else {\n        // Legacy format, but it's already \"unpacked\",\n        // i.e. message.type is actually ContainerMessageType.\n        // Nothing to do in such case.\n    }\n    return message;\n}\nexport class ScheduleManager {\n    constructor(deltaManager, emitter, logger) {\n        this.deltaManager = deltaManager;\n        this.emitter = emitter;\n        this.logger = logger;\n        this.localPaused = false;\n        this.deltaScheduler = new DeltaScheduler(this.deltaManager, ChildLogger.create(this.logger, \"DeltaScheduler\"));\n        // Listen for delta manager sends and add batch metadata to messages\n        this.deltaManager.on(\"prepareSend\", (messages) => {\n            if (messages.length === 0) {\n                return;\n            }\n            // First message will have the batch flag set to true if doing a batched send\n            const firstMessageMetadata = messages[0].metadata;\n            if (!firstMessageMetadata || !firstMessageMetadata.batch) {\n                return;\n            }\n            // If the batch contains only a single op, clear the batch flag.\n            if (messages.length === 1) {\n                delete firstMessageMetadata.batch;\n                return;\n            }\n            // Set the batch flag to false on the last message to indicate the end of the send batch\n            const lastMessage = messages[messages.length - 1];\n            lastMessage.metadata = Object.assign(Object.assign({}, lastMessage.metadata), { batch: false });\n        });\n        // Listen for updates and peek at the inbound\n        this.deltaManager.inbound.on(\"push\", (message) => {\n            this.trackPending(message);\n            this.updatePauseState(message.sequenceNumber);\n        });\n        const allPending = this.deltaManager.inbound.toArray();\n        for (const pending of allPending) {\n            this.trackPending(pending);\n        }\n        // Based on track pending update the pause state\n        this.updatePauseState(this.deltaManager.lastSequenceNumber);\n    }\n    beginOperation(message) {\n        var _a;\n        if (this.batchClientId !== message.clientId) {\n            // As a back stop for any bugs marking the end of a batch - if the client ID flipped, we\n            // consider the previous batch over.\n            if (this.batchClientId) {\n                this.emitter.emit(\"batchEnd\", \"Did not receive real batchEnd message\", undefined);\n                this.deltaScheduler.batchEnd();\n                this.logger.sendTelemetryEvent({\n                    eventName: \"BatchEndNotReceived\",\n                    clientId: this.batchClientId,\n                    sequenceNumber: message.sequenceNumber,\n                });\n            }\n            // This could be the beginning of a new batch or an individual message.\n            this.emitter.emit(\"batchBegin\", message);\n            this.deltaScheduler.batchBegin();\n            const batch = (_a = message === null || message === void 0 ? void 0 : message.metadata) === null || _a === void 0 ? void 0 : _a.batch;\n            if (batch) {\n                this.batchClientId = message.clientId;\n            }\n            else {\n                this.batchClientId = undefined;\n            }\n        }\n    }\n    endOperation(error, message) {\n        var _a;\n        if (error) {\n            this.batchClientId = undefined;\n            this.emitter.emit(\"batchEnd\", error, message);\n            this.deltaScheduler.batchEnd();\n            return;\n        }\n        this.updatePauseState(message.sequenceNumber);\n        const batch = (_a = message === null || message === void 0 ? void 0 : message.metadata) === null || _a === void 0 ? void 0 : _a.batch;\n        // If no batchClientId has been set then we're in an individual batch. Else, if we get\n        // batch end metadata, this is end of the current batch.\n        if (!this.batchClientId || batch === false) {\n            this.batchClientId = undefined;\n            this.emitter.emit(\"batchEnd\", undefined, message);\n            this.deltaScheduler.batchEnd();\n            return;\n        }\n    }\n    setPaused(localPaused) {\n        // Return early if no change in value\n        if (this.localPaused === localPaused) {\n            return;\n        }\n        this.localPaused = localPaused;\n        if (localPaused) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.deltaManager.inbound.pause();\n        }\n        else {\n            this.deltaManager.inbound.resume();\n        }\n    }\n    updatePauseState(sequenceNumber) {\n        // If the inbound queue is ever empty we pause it and wait for new events\n        if (this.deltaManager.inbound.length === 0) {\n            this.setPaused(true);\n            return;\n        }\n        // If no message has caused the pause flag to be set, or the next message up is not the one we need to pause at\n        // then we simply continue processing\n        if (!this.pauseSequenceNumber || sequenceNumber + 1 < this.pauseSequenceNumber) {\n            this.setPaused(false);\n        }\n        else {\n            // Otherwise the next message requires us to pause\n            this.setPaused(true);\n        }\n    }\n    trackPending(message) {\n        const metadata = message.metadata;\n        // Protocol messages are never part of a runtime batch of messages\n        if (!isRuntimeMessage(message)) {\n            this.pauseSequenceNumber = undefined;\n            this.pauseClientId = undefined;\n            return;\n        }\n        const batchMetadata = metadata ? metadata.batch : undefined;\n        // If the client ID changes then we can move the pause point. If it stayed the same then we need to check.\n        if (this.pauseClientId === message.clientId) {\n            if (batchMetadata !== undefined) {\n                // If batchMetadata is not undefined then if it's true we've begun a new batch - if false we've ended\n                // the previous one\n                this.pauseSequenceNumber = batchMetadata ? message.sequenceNumber : undefined;\n                this.pauseClientId = batchMetadata ? this.pauseClientId : undefined;\n            }\n        }\n        else {\n            // We check the batch flag for the new clientID - if true we pause otherwise we reset the tracking data\n            this.pauseSequenceNumber = batchMetadata ? message.sequenceNumber : undefined;\n            this.pauseClientId = batchMetadata ? message.clientId : undefined;\n        }\n    }\n}\nexport const agentSchedulerId = \"_scheduler\";\n// Wraps the provided list of packages and augments with some system level services.\nclass ContainerRuntimeDataStoreRegistry extends FluidDataStoreRegistry {\n    constructor(namedEntries) {\n        super([\n            ...namedEntries,\n            AgentSchedulerFactory.registryEntry,\n        ]);\n    }\n}\n/**\n * Represents the runtime of the container. Contains helper functions/state of the container.\n * It will define the store level mappings.\n */\nexport class ContainerRuntime extends TypedEventEmitter {\n    constructor(context, registry, metadata, chunks, runtimeOptions = {\n        generateSummaries: true,\n    }, containerScope, logger, requestHandler, _storage) {\n        var _a, _b;\n        super();\n        this.context = context;\n        this.registry = registry;\n        this.containerScope = containerScope;\n        this.logger = logger;\n        this.requestHandler = requestHandler;\n        this._storage = _storage;\n        // back-compat: Used by loader in <= 0.35\n        this.runtimeVersion = pkgVersion;\n        this._flushMode = FlushMode.Automatic;\n        this.needsFlush = false;\n        this.flushTrigger = false;\n        // Always matched IAgentScheduler.leader property\n        this._leader = false;\n        this.paused = false;\n        this._disposed = false;\n        this.dirtyContainer = false;\n        this.emitDirtyDocumentEvent = true;\n        /**\n         * Used to apply stashed ops at their reference sequence number.\n         * Normal op processing is synchronous, but rebasing is async since the\n         * data store may not be loaded yet, so we pause DeltaManager between ops.\n         * It's also important that we see each op so we know all stashed ops have\n         * been applied by \"connected\" event, but process() doesn't see system ops,\n         * so we listen directly from DeltaManager instead.\n         */\n        this.onOp = (op) => {\n            assert(!this.paused, 0x128 /* \"Container should not already be paused before applying stashed ops\" */);\n            this.paused = true;\n            this.scheduleManager.setPaused(true);\n            const stashP = this.pendingStateManager.applyStashedOpsAt(op.sequenceNumber);\n            stashP.then(() => {\n                this.paused = false;\n                this.scheduleManager.setPaused(false);\n            }, (error) => {\n                this.closeFn(CreateContainerError(error));\n            });\n        };\n        this.runtimeOptions = Object.assign({ disableIsolatedChannels: true }, runtimeOptions);\n        this._connected = this.context.connected;\n        this.chunkMap = new Map(chunks);\n        this.IFluidHandleContext = new ContainerFluidHandleContext(\"\", this);\n        this.IFluidSerializer = new FluidSerializer(this.IFluidHandleContext);\n        this._logger = ChildLogger.create(this.logger, \"ContainerRuntime\");\n        this.latestSummaryAck = {\n            proposalHandle: undefined,\n            ackHandle: (_a = this.context.getLoadedFromVersion()) === null || _a === void 0 ? void 0 : _a.id,\n        };\n        const loadedFromSequenceNumber = this.deltaManager.initialSequenceNumber;\n        this.summarizerNode = createRootSummarizerNodeWithGC(this.logger, \n        // Summarize function to call when summarize is called. Summarizer node always tracks summary state.\n        async (fullTree, trackState) => this.summarizeInternal(fullTree, trackState), \n        // Latest change sequence number, no changes since summary applied yet\n        loadedFromSequenceNumber, \n        // Summary reference sequence number, undefined if no summary yet\n        context.baseSnapshot ? loadedFromSequenceNumber : undefined, {\n            // Must set to false to prevent sending summary handle which would be pointing to\n            // a summary with an older protocol state.\n            canReuseHandle: false,\n            // Must set to true to throw on any data stores failure that was too severe to be handled.\n            // We also are not decoding the base summaries at the root.\n            throwOnFailure: true,\n            // If GC is disabled, let the summarizer node know so that it does not track GC state.\n            gcDisabled: this.runtimeOptions.disableGC,\n        });\n        if (this.context.baseSnapshot) {\n            this.summarizerNode.loadBaseSummaryWithoutDifferential(this.context.baseSnapshot);\n        }\n        this.dataStores = new DataStores(getSummaryForDatastores(context.baseSnapshot, metadata), this, (attachMsg) => this.submit(ContainerMessageType.Attach, attachMsg), (id, createParam) => (summarizeInternal, getGCDataFn, getInitialGCSummaryDetailsFn) => this.summarizerNode.createChild(summarizeInternal, id, createParam, undefined, getGCDataFn, getInitialGCSummaryDetailsFn), this._logger);\n        this.blobManager = new BlobManager(this.IFluidHandleContext, () => {\n            assert(this.attachState !== AttachState.Detached, 0x123 /* \"Blobs NYI in detached container mode\" */);\n            return this.storage;\n        }, (blobId) => this.submit(ContainerMessageType.BlobAttach, undefined, undefined, { blobId }), this.logger);\n        this.blobManager.load((_b = context.baseSnapshot) === null || _b === void 0 ? void 0 : _b.trees[blobsTreeName]);\n        this.scheduleManager = new ScheduleManager(context.deltaManager, this, ChildLogger.create(this.logger, \"ScheduleManager\"));\n        this.deltaSender = this.deltaManager;\n        this.pendingStateManager = new PendingStateManager(this, async (type, content) => this.applyStashedOp(type, content), context.pendingLocalState);\n        this.context.quorum.on(\"removeMember\", (clientId) => {\n            this.clearPartialChunks(clientId);\n        });\n        this.context.quorum.on(\"addProposal\", (proposal) => {\n            if (proposal.key === \"code\" || proposal.key === \"code2\") {\n                this.emit(\"codeDetailsProposed\", proposal.value, proposal);\n            }\n        });\n        if (this.context.previousRuntimeState === undefined || this.context.previousRuntimeState.state === undefined) {\n            this.previousState = {};\n        }\n        else {\n            this.previousState = this.context.previousRuntimeState.state;\n        }\n        // We always create the summarizer in the case that we are asked to generate summaries. But this may\n        // want to be on demand instead.\n        // Don't use optimizations when generating summaries with a document loaded using snapshots.\n        // This will ensure we correctly convert old documents.\n        this.summarizer = new Summarizer(\"/_summarizer\", this /* ISummarizerRuntime */, () => this.summaryConfiguration, this /* ISummarizerInternalsProvider */, this.IFluidHandleContext, this.previousState.summaryCollection);\n        // Create the SummaryManager and mark the initial state\n        this.summaryManager = new SummaryManager(context, this.runtimeOptions.generateSummaries !== false, this.logger, (summarizer) => { this.nextSummarizerP = summarizer; }, this.previousState.nextSummarizerP, !!this.previousState.reload, this.runtimeOptions.initialSummarizerDelayMs);\n        if (this.connected) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.summaryManager.setConnected(this.context.clientId);\n        }\n        this.deltaManager.on(\"readonly\", (readonly) => {\n            // we accumulate ops while being in read-only state.\n            // once user gets write permissions and we have active connection, flush all pending ops.\n            assert(readonly === this.deltaManager.readonly, 0x124 /* \"inconsistent readonly property/event state\" */);\n            // We need to be very careful with when we (re)send pending ops, to ensure that we only send ops\n            // when we either never send an op, or attempted to send it but we know for sure it was not\n            // sequenced by server and will never be sequenced (i.e. was lost)\n            // For loss of connection, we wait for our own \"join\" op and use it a a barrier to know all the\n            // ops that made it from previous connection, before switching clientId and raising \"connected\" event\n            // But with read-only permissions, if we transition between read-only and r/w states while on same\n            // connection, then we have no good signal to tell us when it's safe to send ops we accumulated while\n            // being in read-only state.\n            // For that reason, we support getting to read-only state only when disconnected. This ensures that we\n            // can rely on same safety mechanism and resend ops only when we establish new connection.\n            // This is applicable for read-only permissions (event is raised before connection is properly registered),\n            // but it's an extra requirement for Container.forceReadonly() API\n            assert(!readonly || !this.connected, 0x125 /* \"Unsafe to transition to read-only state!\" */);\n            this.replayPendingStates();\n        });\n        if (context.pendingLocalState !== undefined) {\n            this.deltaManager.on(\"op\", this.onOp);\n        }\n        ReportOpPerfTelemetry(this.context.clientId, this.deltaManager, this.logger);\n    }\n    get IContainerRuntime() { return this; }\n    get IContainerRuntimeDirtyable() { return this; }\n    get IFluidRouter() { return this; }\n    /**\n     * Load the stores from a snapshot and returns the runtime.\n     * @param context - Context of the container.\n     * @param registry - Mapping to the stores.\n     * @param requestHandlers - Request handlers for the container runtime\n     * @param runtimeOptions - Additional options to be passed to the runtime\n     */\n    static async load(context, registryEntries, requestHandler, runtimeOptions, containerScope = context.scope) {\n        var _a;\n        const logger = ChildLogger.create(context.logger, undefined, {\n            all: {\n                runtimeVersion: pkgVersion,\n            },\n        });\n        let storage = context.storage;\n        if (context.baseSnapshot) {\n            // This will patch snapshot in place!\n            // If storage is provided, it will wrap storage with BlobAggregationStorage that can\n            // pack & unpack aggregated blobs.\n            // Note that if storage is provided later by loader layer, we will wrap storage in this.storage getter.\n            // BlobAggregationStorage is smart enough for double-wrapping to be no-op\n            if (context.storage) {\n                const aggrStorage = BlobAggregationStorage.wrap(context.storage, logger);\n                await aggrStorage.unpackSnapshot(context.baseSnapshot);\n                storage = aggrStorage;\n            }\n            else {\n                await BlobAggregationStorage.unpackSnapshot(context.baseSnapshot);\n            }\n        }\n        const registry = new ContainerRuntimeDataStoreRegistry(registryEntries);\n        const tryFetchBlob = async (blobName) => {\n            var _a;\n            const blobId = (_a = context.baseSnapshot) === null || _a === void 0 ? void 0 : _a.blobs[blobName];\n            if (context.baseSnapshot && blobId) {\n                return storage ?\n                    readAndParse(storage, blobId) :\n                    readAndParseFromBlobs(context.baseSnapshot.blobs, blobId);\n            }\n        };\n        const chunks = (_a = await tryFetchBlob(chunksBlobName)) !== null && _a !== void 0 ? _a : [];\n        const metadata = await tryFetchBlob(metadataBlobName);\n        const runtime = new ContainerRuntime(context, registry, metadata, chunks, runtimeOptions, containerScope, logger, requestHandler, storage);\n        // Create all internal data stores if not already existing on storage or loaded a detached\n        // container from snapshot(ex. draft mode).\n        if (!context.existing) {\n            await runtime.createRootDataStore(AgentSchedulerFactory.type, agentSchedulerId);\n        }\n        runtime.subscribeToLeadership();\n        return runtime;\n    }\n    get id() {\n        return this.context.id;\n    }\n    get existing() {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.context.existing;\n    }\n    get options() {\n        return this.context.options;\n    }\n    get clientId() {\n        return this.context.clientId;\n    }\n    get clientDetails() {\n        return this.context.clientDetails;\n    }\n    get deltaManager() {\n        return this.context.deltaManager;\n    }\n    get storage() {\n        // This code is plain wrong. It lies that it never returns undefined!!!\n        // All callers should be fixed, as this API is called in detached state of container when we have\n        // no storage and it's passed down the stack without right typing.\n        if (!this._storage && this.context.storage) {\n            // Note: BlobAggregationStorage is smart enough for double-wrapping to be no-op\n            this._storage = BlobAggregationStorage.wrap(this.context.storage, this.logger);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this._storage;\n    }\n    get reSubmitFn() {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        return this.reSubmit;\n    }\n    get closeFn() {\n        return this.context.closeFn;\n    }\n    get loader() {\n        return this.context.loader;\n    }\n    get flushMode() {\n        return this._flushMode;\n    }\n    get scope() {\n        return this.containerScope;\n    }\n    get IFluidDataStoreRegistry() {\n        return this.registry;\n    }\n    get attachState() {\n        return this.context.attachState;\n    }\n    /**\n     * Returns true if generating summaries with isolated channels is\n     * explicitly disabled. This only affects how summaries are written.\n     */\n    get disableIsolatedChannels() {\n        return !!this.runtimeOptions.disableIsolatedChannels;\n    }\n    get connected() {\n        return this._connected;\n    }\n    get leader() {\n        return this._leader;\n    }\n    get summarizerClientId() {\n        return this.summaryManager.summarizer;\n    }\n    get summaryConfiguration() {\n        var _a, _b;\n        return Object.assign(Object.assign(Object.assign({}, DefaultSummaryConfiguration), (_b = (_a = this.context) === null || _a === void 0 ? void 0 : _a.serviceConfiguration) === null || _b === void 0 ? void 0 : _b.summary), this.runtimeOptions.summaryConfigOverrides);\n    }\n    get disposed() { return this._disposed; }\n    dispose(error) {\n        if (this._disposed) {\n            return;\n        }\n        this._disposed = true;\n        this.logger.sendTelemetryEvent({\n            eventName: \"ContainerRuntimeDisposed\",\n            category: \"generic\",\n            isDirty: this.isDirty,\n            lastSequenceNumber: this.deltaManager.lastSequenceNumber,\n            attachState: this.attachState,\n            message: error === null || error === void 0 ? void 0 : error.message,\n        });\n        this.summaryManager.dispose();\n        this.summarizer.dispose();\n        this.dataStores.dispose();\n        this.emit(\"dispose\");\n        this.removeAllListeners();\n    }\n    get IFluidTokenProvider() {\n        if (this.options && this.options.intelligence) {\n            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n            return {\n                intelligence: this.options.intelligence,\n            };\n        }\n        return undefined;\n    }\n    get IFluidConfiguration() {\n        return this.context.configuration;\n    }\n    /**\n     * Notifies this object about the request made to the container.\n     * @param request - Request made to the handler.\n     */\n    async request(request) {\n        try {\n            const parser = RequestParser.create(request);\n            const id = parser.pathParts[0];\n            if (id === \"_summarizer\" && parser.pathParts.length === 1) {\n                return {\n                    status: 200,\n                    mimeType: \"fluid/object\",\n                    value: this.summarizer,\n                };\n            }\n            if (this.requestHandler !== undefined) {\n                return this.requestHandler(parser, this);\n            }\n            return create404Response(request);\n        }\n        catch (error) {\n            return exceptionToResponse(error);\n        }\n    }\n    /**\n     * Resolves URI representing handle\n     * @param request - Request made to the handler.\n     */\n    async resolveHandle(request) {\n        var _a, _b;\n        try {\n            const requestParser = RequestParser.create(request);\n            const id = requestParser.pathParts[0];\n            if (id === \"_channels\") {\n                return this.resolveHandle(requestParser.createSubRequest(1));\n            }\n            if (id === BlobManager.basePath && requestParser.isLeaf(2)) {\n                const handle = await this.blobManager.getBlob(requestParser.pathParts[1]);\n                if (handle) {\n                    return {\n                        status: 200,\n                        mimeType: \"fluid/object\",\n                        value: handle.get(),\n                    };\n                }\n                else {\n                    return create404Response(request);\n                }\n            }\n            else if (requestParser.pathParts.length > 0) {\n                /**\n                 * If this an external app request with \"externalRequest\" header, we need to return an error if the\n                 * data store being requested is marked as unreferenced as per the data store's initial summary.\n                 *\n                 * This is a workaround to handle scenarios where a data store shared with an external app is deleted\n                 * and marked as unreferenced by GC. Returning an error will fail to load the data store for the app.\n                 */\n                const wait = typeof ((_a = request.headers) === null || _a === void 0 ? void 0 : _a.wait) === \"boolean\" ? request.headers.wait : undefined;\n                const dataStore = ((_b = request.headers) === null || _b === void 0 ? void 0 : _b.externalRequest) ? await this.getDataStoreIfInitiallyReferenced(id, wait)\n                    : await this.getDataStore(id, wait);\n                const subRequest = requestParser.createSubRequest(1);\n                // We always expect createSubRequest to include a leading slash, but asserting here to protect against\n                // unintentionally modifying the url if that changes.\n                assert(subRequest.url.startsWith(\"/\"), 0x126 /* \"Expected createSubRequest url to include a leading slash\" */);\n                return dataStore.IFluidRouter.request(subRequest);\n            }\n            return create404Response(request);\n        }\n        catch (error) {\n            return exceptionToResponse(error);\n        }\n    }\n    formMetadata() {\n        return {\n            summaryFormatVersion: 1,\n            disableIsolatedChannels: this.disableIsolatedChannels || undefined,\n        };\n    }\n    /**\n     * Retrieves the runtime for a data store if it's referenced as per the initially summary that it is loaded with.\n     * This is a workaround to handle scenarios where a data store shared with an external app is deleted and marked\n     * as unreferenced by GC.\n     * @param id - Id supplied during creating the data store.\n     * @param wait - True if you want to wait for it.\n     * @returns the data store runtime if the data store exists and is initially referenced; undefined otherwise.\n     */\n    async getDataStoreIfInitiallyReferenced(id, wait = true) {\n        const dataStoreContext = await this.dataStores.getDataStore(id, wait);\n        // The data store is referenced if used routes in the initial summary has a route to self.\n        // Older documents may not have used routes in the summary. They are considered referenced.\n        const usedRoutes = (await dataStoreContext.getInitialGCSummaryDetails()).usedRoutes;\n        if (usedRoutes === undefined || usedRoutes.includes(\"\") || usedRoutes.includes(\"/\")) {\n            return dataStoreContext.realize();\n        }\n        // The data store is unreferenced. Throw a 404 response exception.\n        const request = { url: id };\n        throw responseToException(create404Response(request), request);\n    }\n    /**\n     * Notifies this object to take the snapshot of the container.\n     * @deprecated - Use summarize to get summary of the container runtime.\n     */\n    async snapshot() {\n        const root = { entries: [] };\n        const entries = await this.dataStores.snapshot();\n        if (this.disableIsolatedChannels) {\n            root.entries = root.entries.concat(entries);\n        }\n        else {\n            root.entries.push(new TreeTreeEntry(channelsTreeName, { entries }));\n            root.entries.push(new BlobTreeEntry(metadataBlobName, JSON.stringify(this.formMetadata())));\n        }\n        if (this.chunkMap.size > 0) {\n            root.entries.push(new BlobTreeEntry(chunksBlobName, JSON.stringify([...this.chunkMap])));\n        }\n        return root;\n    }\n    addContainerBlobsToSummary(summaryTree) {\n        if (!this.disableIsolatedChannels) {\n            addBlobToSummary(summaryTree, metadataBlobName, JSON.stringify(this.formMetadata()));\n        }\n        if (this.chunkMap.size > 0) {\n            const content = JSON.stringify([...this.chunkMap]);\n            addBlobToSummary(summaryTree, chunksBlobName, content);\n        }\n        const blobsTree = convertToSummaryTree(this.blobManager.snapshot(), false);\n        addTreeToSummary(summaryTree, blobsTreeName, blobsTree);\n    }\n    async stop() {\n        this.verifyNotClosed();\n        // Reload would not work properly with local changes.\n        // First, summarizing code likely does not work (i.e. read - produced unknown result)\n        // in presence of local changes.\n        // On top of that newly reloaded runtime likely would not be dirty, while it has some changes.\n        // And container would assume it's dirty (as there was no notification changing state)\n        if (this.dirtyContainer) {\n            this.logger.sendErrorEvent({ eventName: \"DirtyContainerReloadRuntime\" });\n        }\n        const snapshot = await this.snapshot();\n        const state = {\n            reload: true,\n            summaryCollection: this.summarizer.summaryCollection,\n            nextSummarizerP: this.nextSummarizerP,\n            nextSummarizerD: this.nextSummarizerD,\n        };\n        this.dispose(new Error(\"ContainerRuntimeStopped\"));\n        return { snapshot, state };\n    }\n    replayPendingStates() {\n        // We need to be able to send ops to replay states\n        if (!this.canSendOps()) {\n            return;\n        }\n        // We need to temporary clear the dirty flags and disable\n        // dirty state change events to detect whether replaying ops\n        // has any effect.\n        // Save the old state, reset to false, disable event emit\n        const oldState = this.dirtyContainer;\n        this.dirtyContainer = false;\n        assert(this.emitDirtyDocumentEvent, 0x127 /* \"dirty document event not set on replay\" */);\n        this.emitDirtyDocumentEvent = false;\n        let newState;\n        try {\n            // replay the ops\n            this.pendingStateManager.replayPendingStates();\n        }\n        finally {\n            // Save the new start and restore the old state, re-enable event emit\n            newState = this.dirtyContainer;\n            this.dirtyContainer = oldState;\n            this.emitDirtyDocumentEvent = true;\n        }\n        // Officially transition from the old state to the new state.\n        this.updateDocumentDirtyState(newState);\n    }\n    async applyStashedOp(type, op) {\n        switch (type) {\n            case ContainerMessageType.FluidDataStoreOp:\n                return this.dataStores.applyStashedOp(op);\n            case ContainerMessageType.Attach:\n                return this.dataStores.applyStashedAttachOp(op);\n            case ContainerMessageType.BlobAttach:\n                return;\n            case ContainerMessageType.ChunkedOp:\n                throw new Error(`chunkedOp not expected here`);\n            default:\n                unreachableCase(type, `Unknown ContainerMessageType: ${type}`);\n        }\n    }\n    setConnectionState(connected, clientId) {\n        this.verifyNotClosed();\n        // There might be no change of state due to Container calling this API after loading runtime.\n        const changeOfState = this._connected !== connected;\n        this._connected = connected;\n        if (changeOfState) {\n            this.deltaManager.off(\"op\", this.onOp);\n            this.context.pendingLocalState = undefined;\n            this.replayPendingStates();\n        }\n        this.dataStores.setConnectionState(connected, clientId);\n        raiseConnectedEvent(this._logger, this, connected, clientId);\n        if (connected) {\n            assert(!!clientId, 0x129 /* \"Missing clientId\" */);\n            this.summaryManager.setConnected(clientId);\n        }\n        else {\n            this.summaryManager.setDisconnected();\n        }\n    }\n    process(messageArg, local) {\n        var _a;\n        this.verifyNotClosed();\n        // If it's not message for runtime, bail out right away.\n        if (!isRuntimeMessage(messageArg)) {\n            return;\n        }\n        // Do shallow copy of message, as methods below will modify it.\n        // There might be multiple container instances receiving same message\n        // We do not need to make deep copy, as each layer will just replace message.content itself,\n        // but would not modify contents details\n        let message = Object.assign({}, messageArg);\n        let error;\n        // Surround the actual processing of the operation with messages to the schedule manager indicating\n        // the beginning and end. This allows it to emit appropriate events and/or pause the processing of new\n        // messages once a batch has been fully processed.\n        this.scheduleManager.beginOperation(message);\n        try {\n            message = unpackRuntimeMessage(message);\n            // Chunk processing must come first given that we will transform the message to the unchunked version\n            // once all pieces are available\n            message = this.processRemoteChunkedMessage(message);\n            // Call the PendingStateManager to process messages.\n            const { localAck, localOpMetadata } = this.pendingStateManager.processMessage(message, local);\n            // If there are no more pending messages after processing a local message,\n            // the document is no longer dirty.\n            if (!this.pendingStateManager.hasPendingMessages()) {\n                this.updateDocumentDirtyState(false);\n            }\n            switch (message.type) {\n                case ContainerMessageType.Attach:\n                    this.dataStores.processAttachMessage(message, local || localAck);\n                    break;\n                case ContainerMessageType.FluidDataStoreOp:\n                    // if localAck === true, treat this as a local op because it's one we sent on a previous container\n                    this.dataStores.processFluidDataStoreOp(message, local || localAck, localOpMetadata);\n                    break;\n                case ContainerMessageType.BlobAttach:\n                    assert((_a = message === null || message === void 0 ? void 0 : message.metadata) === null || _a === void 0 ? void 0 : _a.blobId, 0x12a /* \"Missing blob id on metadata\" */);\n                    this.blobManager.addBlobId(message.metadata.blobId);\n                    break;\n                default:\n            }\n            this.emit(\"op\", message);\n        }\n        catch (e) {\n            error = e;\n            throw e;\n        }\n        finally {\n            this.scheduleManager.endOperation(error, message);\n        }\n    }\n    processSignal(message, local) {\n        const envelope = message.content;\n        const transformed = {\n            clientId: message.clientId,\n            content: envelope.contents.content,\n            type: envelope.contents.type,\n        };\n        if (envelope.address === undefined) {\n            // No address indicates a container signal message.\n            this.emit(\"signal\", transformed, local);\n            return;\n        }\n        this.dataStores.processSignal(envelope.address, transformed, local);\n    }\n    async getRootDataStore(id, wait = true) {\n        const context = await this.dataStores.getDataStore(id, wait);\n        assert(await context.isRoot(), 0x12b /* \"did not get root data store\" */);\n        return context.realize();\n    }\n    async getDataStore(id, wait = true) {\n        return (await this.dataStores.getDataStore(id, wait)).realize();\n    }\n    notifyDataStoreInstantiated(context) {\n        const fluidDataStorePkgName = context.packagePath[context.packagePath.length - 1];\n        const registryPath = `/${context.packagePath.slice(0, context.packagePath.length - 1).join(\"/\")}`;\n        this.emit(\"fluidDataStoreInstantiated\", fluidDataStorePkgName, registryPath, !context.existing);\n    }\n    setFlushMode(mode) {\n        if (mode === this._flushMode) {\n            return;\n        }\n        // If switching to manual mode add a warning trace indicating the underlying loader does not support\n        // this feature yet. Can remove in 0.9.\n        if (!this.deltaSender && mode === FlushMode.Manual) {\n            debug(\"DeltaManager does not yet support flush modes\");\n            return;\n        }\n        // Flush any pending batches if switching back to automatic\n        if (mode === FlushMode.Automatic) {\n            this.flush();\n        }\n        this._flushMode = mode;\n        // Let the PendingStateManager know that FlushMode has been updated.\n        this.pendingStateManager.onFlushModeUpdated(mode);\n    }\n    flush() {\n        if (!this.deltaSender) {\n            debug(\"DeltaManager does not yet support flush modes\");\n            return;\n        }\n        // Let the PendingStateManager know that there was an attempt to flush messages.\n        // Note that this should happen before the `this.needsFlush` check below because in the scenario where we are\n        // not connected, `this.needsFlush` will be false but the PendingStateManager might have pending messages and\n        // hence needs to track this.\n        this.pendingStateManager.onFlush();\n        // If flush has already been called then exit early\n        if (!this.needsFlush) {\n            return;\n        }\n        this.needsFlush = false;\n        return this.deltaSender.flush();\n    }\n    orderSequentially(callback) {\n        // If flush mode is already manual we are either\n        // nested in another orderSequentially, or\n        // the app is flushing manually, in which\n        // case this invocation doesn't own\n        // flushing.\n        if (this.flushMode === FlushMode.Manual) {\n            callback();\n        }\n        else {\n            const savedFlushMode = this.flushMode;\n            this.setFlushMode(FlushMode.Manual);\n            try {\n                callback();\n            }\n            finally {\n                this.flush();\n                this.setFlushMode(savedFlushMode);\n            }\n        }\n    }\n    async createDataStore(pkg) {\n        return this._createDataStore(pkg, false /* isRoot */);\n    }\n    async createRootDataStore(pkg, rootDataStoreId) {\n        const fluidDataStore = await this._createDataStore(pkg, true /* isRoot */, rootDataStoreId);\n        fluidDataStore.bindToContext();\n        return fluidDataStore;\n    }\n    createDetachedRootDataStore(pkg, rootDataStoreId) {\n        return this.dataStores.createDetachedDataStoreCore(pkg, true, rootDataStoreId);\n    }\n    createDetachedDataStore(pkg) {\n        return this.dataStores.createDetachedDataStoreCore(pkg, false);\n    }\n    async _createDataStoreWithProps(pkg, props, id = uuid(), isRoot = false) {\n        return this.dataStores._createFluidDataStoreContext(Array.isArray(pkg) ? pkg : [pkg], id, isRoot, props).realize();\n    }\n    async _createDataStore(pkg, isRoot, id = uuid()) {\n        return this.dataStores._createFluidDataStoreContext(Array.isArray(pkg) ? pkg : [pkg], id, isRoot).realize();\n    }\n    canSendOps() {\n        return this.connected && !this.deltaManager.readonly;\n    }\n    getQuorum() {\n        return this.context.quorum;\n    }\n    getAudience() {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.context.audience;\n    }\n    raiseContainerWarning(warning) {\n        this.context.raiseContainerWarning(warning);\n    }\n    /**\n     * @deprecated - // back-compat: marked deprecated in 0.35\n     * Returns true of document is dirty, i.e. there are some pending local changes that\n     * either were not sent out to delta stream or were not yet acknowledged.\n     */\n    isDocumentDirty() {\n        return this.dirtyContainer;\n    }\n    /**\n     * Returns true of container is dirty, i.e. there are some pending local changes that\n     * either were not sent out to delta stream or were not yet acknowledged.\n     */\n    get isDirty() {\n        return this.dirtyContainer;\n    }\n    /**\n     * Will return true for any message that affect the dirty state of this document\n     * This function can be used to filter out any runtime operations that should not be affecting whether or not\n     * the IFluidDataStoreRuntime.isDirty call returns true/false\n     * @param type - The type of ContainerRuntime message that is being checked\n     * @param contents - The contents of the message that is being verified\n     */\n    isMessageDirtyable(message) {\n        assert(isRuntimeMessage(message) === true, 0x12c /* \"Message passed for dirtyable check should be a container runtime message\" */);\n        return this.isContainerMessageDirtyable(message.type, message.contents);\n    }\n    isContainerMessageDirtyable(type, contents) {\n        if (type === ContainerMessageType.Attach) {\n            const attachMessage = contents;\n            if (attachMessage.id === agentSchedulerId) {\n                return false;\n            }\n        }\n        else if (type === ContainerMessageType.FluidDataStoreOp) {\n            const envelope = contents;\n            if (envelope.address === agentSchedulerId) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Submits the signal to be sent to other clients.\n     * @param type - Type of the signal.\n     * @param content - Content of the signal.\n     */\n    submitSignal(type, content) {\n        this.verifyNotClosed();\n        const envelope = { address: undefined, contents: { type, content } };\n        return this.context.submitSignalFn(envelope);\n    }\n    submitDataStoreSignal(address, type, content) {\n        const envelope = { address, contents: { type, content } };\n        return this.context.submitSignalFn(envelope);\n    }\n    setAttachState(attachState) {\n        if (attachState === AttachState.Attaching) {\n            assert(this.attachState === AttachState.Attaching, 0x12d /* \"Container Context should already be in attaching state\" */);\n        }\n        else {\n            assert(this.attachState === AttachState.Attached, 0x12e /* \"Container Context should already be in attached state\" */);\n        }\n        this.dataStores.setAttachState(attachState);\n    }\n    createSummary() {\n        const summarizeResult = this.dataStores.createSummary();\n        if (!this.disableIsolatedChannels) {\n            // Wrap data store summaries in .channels subtree.\n            wrapSummaryInChannelsTree(summarizeResult);\n        }\n        this.addContainerBlobsToSummary(summarizeResult);\n        return summarizeResult.summary;\n    }\n    async getAbsoluteUrl(relativeUrl) {\n        if (this.context.getAbsoluteUrl === undefined) {\n            throw new Error(\"Driver does not implement getAbsoluteUrl\");\n        }\n        if (this.attachState !== AttachState.Attached) {\n            return undefined;\n        }\n        return this.context.getAbsoluteUrl(relativeUrl);\n    }\n    async collectGarbage(logger) {\n        await PerformanceEvent.timedExecAsync(logger, { eventName: \"GarbageCollection\" }, async (event) => {\n            const gcStats = {};\n            try {\n                // Get the container's GC data and run GC on the reference graph in it.\n                const gcData = await this.dataStores.getGCData(this.runtimeOptions.runFullGC === true);\n                const { referencedNodeIds, deletedNodeIds } = runGarbageCollection(gcData.gcNodes, [\"/\"], this.logger);\n                // Update stats to be reported in the peformance event.\n                gcStats.deletedGCNodes = deletedNodeIds.length;\n                gcStats.totalGCNodes = referencedNodeIds.length + gcStats.deletedGCNodes;\n                // Update our summarizer node's used routes. Updating used routes in summarizer node before\n                // summarizing is required and asserted by the the summarizer node. We are the root and are\n                // always referenced, so the used routes is only self-route (empty string).\n                this.summarizerNode.updateUsedRoutes([\"\"]);\n                // Remove this node's route (\"/\") and notify data stores of routes that are used in it.\n                const usedRoutes = referencedNodeIds.filter((id) => { return id !== \"/\"; });\n                this.dataStores.updateUsedRoutes(usedRoutes);\n            }\n            catch (error) {\n                event.cancel(gcStats, error);\n                throw error;\n            }\n            event.end(gcStats);\n        });\n    }\n    async summarizeInternal(fullTree, trackState) {\n        const summarizeResult = await this.dataStores.summarize(fullTree, trackState);\n        let pathPartsForChildren;\n        if (!this.disableIsolatedChannels) {\n            // Wrap data store summaries in .channels subtree.\n            wrapSummaryInChannelsTree(summarizeResult);\n            pathPartsForChildren = [channelsTreeName];\n        }\n        this.addContainerBlobsToSummary(summarizeResult);\n        return Object.assign(Object.assign({}, summarizeResult), { id: \"\", pathPartsForChildren });\n    }\n    /**\n     * Returns a summary of the runtime at the current sequence number.\n     */\n    async summarize(options) {\n        const { runGC, fullTree = false, trackState, summaryLogger } = options;\n        if (runGC) {\n            await this.collectGarbage(summaryLogger);\n        }\n        const summarizeResult = await this.summarizerNode.summarize(fullTree, trackState);\n        assert(summarizeResult.summary.type === 1 /* Tree */, 0x12f /* \"Container Runtime's summarize should always return a tree\" */);\n        return summarizeResult;\n    }\n    /** Implementation of ISummarizerInternalsProvider.generateSummary */\n    async generateSummary(options) {\n        const { fullTree, refreshLatestAck, summaryLogger } = options;\n        const summaryRefSeqNum = this.deltaManager.lastSequenceNumber;\n        const message = `Summary @${summaryRefSeqNum}:${this.deltaManager.minimumSequenceNumber}`;\n        this.summarizerNode.startSummary(summaryRefSeqNum, summaryLogger);\n        try {\n            await this.deltaManager.inbound.pause();\n            const attemptData = {\n                referenceSequenceNumber: summaryRefSeqNum,\n                submitted: false,\n            };\n            if (!this.connected) {\n                // If summarizer loses connection it will never reconnect\n                return Object.assign(Object.assign({}, attemptData), { reason: \"disconnected\" });\n            }\n            const trace = Trace.start();\n            const summarizeResult = await this.summarize({\n                runGC: !this.runtimeOptions.disableGC,\n                fullTree,\n                trackState: true,\n                summaryLogger,\n            });\n            const generateData = {\n                summaryStats: summarizeResult.stats,\n                generateDuration: trace.trace().duration,\n            };\n            if (!this.connected) {\n                return Object.assign(Object.assign(Object.assign({}, attemptData), generateData), { reason: \"disconnected\" });\n            }\n            // Ensure that lastSequenceNumber has not changed after pausing\n            const lastSequenceNumber = this.deltaManager.lastSequenceNumber;\n            assert(lastSequenceNumber === summaryRefSeqNum, 0x130 /* `lastSequenceNumber changed while paused. ${lastSequenceNumber} !== ${summaryRefSeqNum}` */);\n            const handle = await this.storage.uploadSummaryWithContext(summarizeResult.summary, Object.assign(Object.assign({}, this.latestSummaryAck), { referenceSequenceNumber: summaryRefSeqNum }));\n            if (refreshLatestAck) {\n                const version = await this.getVersionFromStorage(this.id);\n                await this.refreshLatestSummaryAck(undefined, version.id, ChildLogger.create(summaryLogger, undefined, { all: { safeSummary: true } }), version);\n            }\n            const parent = this.latestSummaryAck.ackHandle;\n            const summaryMessage = {\n                handle,\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                head: parent,\n                message,\n                parents: parent ? [parent] : [],\n            };\n            const uploadData = {\n                handle,\n                uploadDuration: trace.trace().duration,\n            };\n            if (!this.connected) {\n                return Object.assign(Object.assign(Object.assign(Object.assign({}, attemptData), generateData), uploadData), { reason: \"disconnected\" });\n            }\n            // We need the summary op's reference sequence number to match our summary sequence number\n            // Otherwise we'll get the wrong sequence number stamped on the summary's .protocol attributes\n            assert(this.deltaManager.lastSequenceNumber === summaryRefSeqNum, `lastSequenceNumber changed before the summary op could be submitted. `\n                + `${this.deltaManager.lastSequenceNumber} !== ${summaryRefSeqNum}`);\n            const clientSequenceNumber = this.submitSystemMessage(MessageType.Summarize, summaryMessage);\n            this.summarizerNode.completeSummary(handle);\n            return Object.assign(Object.assign(Object.assign(Object.assign({}, attemptData), generateData), uploadData), { submitted: true, clientSequenceNumber, submitOpDuration: trace.trace().duration });\n        }\n        finally {\n            // Cleanup wip summary in case of failure\n            this.summarizerNode.clearSummary();\n            // Restart the delta manager\n            this.deltaManager.inbound.resume();\n        }\n    }\n    processRemoteChunkedMessage(message) {\n        if (message.type !== ContainerMessageType.ChunkedOp) {\n            return message;\n        }\n        const clientId = message.clientId;\n        const chunkedContent = message.contents;\n        this.addChunk(clientId, chunkedContent);\n        if (chunkedContent.chunkId === chunkedContent.totalChunks) {\n            const newMessage = Object.assign({}, message);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const serializedContent = this.chunkMap.get(clientId).join(\"\");\n            newMessage.contents = JSON.parse(serializedContent);\n            newMessage.type = chunkedContent.originalType;\n            this.clearPartialChunks(clientId);\n            return newMessage;\n        }\n        return message;\n    }\n    addChunk(clientId, chunkedContent) {\n        let map = this.chunkMap.get(clientId);\n        if (map === undefined) {\n            map = [];\n            this.chunkMap.set(clientId, map);\n        }\n        assert(chunkedContent.chunkId === map.length + 1, 0x131 /* \"Mismatch between new chunkId and expected chunkMap\" */); // 1-based indexing\n        map.push(chunkedContent.contents);\n    }\n    clearPartialChunks(clientId) {\n        if (this.chunkMap.has(clientId)) {\n            this.chunkMap.delete(clientId);\n        }\n    }\n    updateDocumentDirtyState(dirty) {\n        if (this.dirtyContainer === dirty) {\n            return;\n        }\n        this.dirtyContainer = dirty;\n        if (this.emitDirtyDocumentEvent) {\n            // back-compat: dirtyDocument & savedDocument deprecated in 0.35.\n            this.emit(dirty ? \"dirtyDocument\" : \"savedDocument\");\n            this.emit(dirty ? \"dirty\" : \"saved\");\n            // back-compat: Loader API added in 0.35 only\n            if (this.context.updateDirtyContainerState !== undefined) {\n                this.context.updateDirtyContainerState(dirty);\n            }\n        }\n    }\n    submitDataStoreOp(id, contents, localOpMetadata = undefined) {\n        const envelope = {\n            address: id,\n            contents,\n        };\n        this.submit(ContainerMessageType.FluidDataStoreOp, envelope, localOpMetadata);\n    }\n    async uploadBlob(blob) {\n        return this.blobManager.createBlob(blob);\n    }\n    submit(type, content, localOpMetadata = undefined, opMetadata = undefined) {\n        this.verifyNotClosed();\n        if (this.context.pendingLocalState !== undefined) {\n            this.closeFn(CreateContainerError(\"op submitted while processing pending initial state\"));\n        }\n        // There should be no ops in detached container state!\n        assert(this.attachState !== AttachState.Detached, 0x132 /* \"sending ops in detached container\" */);\n        let clientSequenceNumber = -1;\n        let opMetadataInternal = opMetadata;\n        if (this.canSendOps()) {\n            const serializedContent = JSON.stringify(content);\n            const maxOpSize = this.context.deltaManager.maxMessageSize;\n            // If in manual flush mode we will trigger a flush at the next turn break\n            if (this.flushMode === FlushMode.Manual && !this.needsFlush) {\n                opMetadataInternal = Object.assign(Object.assign({}, opMetadata), { batch: true });\n                this.needsFlush = true;\n                // Use Promise.resolve().then() to queue a microtask to detect the end of the turn and force a flush.\n                if (!this.flushTrigger) {\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                    Promise.resolve().then(() => {\n                        this.flushTrigger = false;\n                        this.flush();\n                    });\n                }\n            }\n            // Note: Chunking will increase content beyond maxOpSize because we JSON'ing JSON payload -\n            // there will be a lot of escape characters that can make it up to 2x bigger!\n            // This is Ok, because DeltaManager.shouldSplit() will have 2 * maxMessageSize limit\n            if (!serializedContent || serializedContent.length <= maxOpSize) {\n                clientSequenceNumber = this.submitRuntimeMessage(type, content, \n                /* batch: */ this._flushMode === FlushMode.Manual, opMetadataInternal);\n            }\n            else {\n                clientSequenceNumber = this.submitChunkedMessage(type, serializedContent, maxOpSize);\n            }\n        }\n        // Let the PendingStateManager know that a message was submitted.\n        this.pendingStateManager.onSubmitMessage(type, clientSequenceNumber, this.deltaManager.lastSequenceNumber, content, localOpMetadata, opMetadataInternal);\n        if (this.isContainerMessageDirtyable(type, content)) {\n            this.updateDocumentDirtyState(true);\n        }\n    }\n    submitChunkedMessage(type, content, maxOpSize) {\n        const contentLength = content.length;\n        const chunkN = Math.floor((contentLength - 1) / maxOpSize) + 1;\n        let offset = 0;\n        let clientSequenceNumber = 0;\n        for (let i = 1; i <= chunkN; i = i + 1) {\n            const chunkedOp = {\n                chunkId: i,\n                contents: content.substr(offset, maxOpSize),\n                originalType: type,\n                totalChunks: chunkN,\n            };\n            offset += maxOpSize;\n            clientSequenceNumber = this.submitRuntimeMessage(ContainerMessageType.ChunkedOp, chunkedOp, false);\n        }\n        return clientSequenceNumber;\n    }\n    submitSystemMessage(type, contents) {\n        this.verifyNotClosed();\n        assert(this.connected, 0x133 /* \"Container disconnected when trying to submit system message\" */);\n        // System message should not be sent in the middle of the batch.\n        // That said, we can preserve existing behavior by not flushing existing buffer.\n        // That might be not what caller hopes to get, but we can look deeper if telemetry tells us it's a problem.\n        const middleOfBatch = this.flushMode === FlushMode.Manual && this.needsFlush;\n        if (middleOfBatch) {\n            this._logger.sendErrorEvent({ eventName: \"submitSystemMessageError\", type });\n        }\n        return this.context.submitFn(type, contents, middleOfBatch);\n    }\n    submitRuntimeMessage(type, contents, batch, appData) {\n        const payload = { type, contents };\n        return this.context.submitFn(MessageType.Operation, payload, batch, appData);\n    }\n    /**\n     * Throw an error if the runtime is closed.  Methods that are expected to potentially\n     * be called after dispose due to asynchrony should not call this.\n     */\n    verifyNotClosed() {\n        if (this._disposed) {\n            throw new Error(\"Runtime is closed\");\n        }\n    }\n    /**\n     * Finds the right store and asks it to resubmit the message. This typically happens when we\n     * reconnect and there are pending messages.\n     * @param content - The content of the original message.\n     * @param localOpMetadata - The local metadata associated with the original message.\n     */\n    reSubmit(type, content, localOpMetadata, opMetadata) {\n        switch (type) {\n            case ContainerMessageType.FluidDataStoreOp:\n                // For Operations, call resubmitDataStoreOp which will find the right store\n                // and trigger resubmission on it.\n                this.dataStores.resubmitDataStoreOp(content, localOpMetadata);\n                break;\n            case ContainerMessageType.Attach:\n                this.submit(type, content, localOpMetadata);\n                break;\n            case ContainerMessageType.ChunkedOp:\n                throw new Error(`chunkedOp not expected here`);\n            case ContainerMessageType.BlobAttach:\n                this.submit(type, content, localOpMetadata, opMetadata);\n                break;\n            default:\n                unreachableCase(type, `Unknown ContainerMessageType: ${type}`);\n        }\n    }\n    subscribeToLeadership() {\n        if (this.context.clientDetails.capabilities.interactive) {\n            this.getScheduler().then((scheduler) => {\n                const LeaderTaskId = \"leader\";\n                // Each client expresses interest to be a leader.\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                scheduler.pick(LeaderTaskId, async () => {\n                    assert(!this._leader, 0x134 /* \"Client is already leader\" */);\n                    this.updateLeader(true);\n                });\n                scheduler.on(\"lost\", (key) => {\n                    if (key === LeaderTaskId) {\n                        assert(this._leader, 0x135 /* \"Got leader key but client is not leader\" */);\n                        this._leader = false;\n                        this.updateLeader(false);\n                    }\n                });\n            }).catch((err) => {\n                this.closeFn(CreateContainerError(err));\n            });\n        }\n    }\n    /**\n     * @deprecated starting in 0.36. The AgentScheduler can be requested directly, though this will also be removed in\n     * a future release when an alternative is available: containerRuntime.request(\\{ url: \"/_scheduler\" \\}).\n     * getTaskManager should be removed in 0.38.\n     */\n    async getTaskManager() {\n        console.error(\"getTaskManager is deprecated.\");\n        const agentScheduler = await this.getScheduler();\n        // Prior versions would return a TaskManager, which was an IProvideAgentScheduler -- returning this for back\n        // compat.  Wrapping the agentScheduler in an IProvideAgentScheduler will help catch any cases where customers\n        // try to call other TaskManager functionality.\n        return { IAgentScheduler: agentScheduler };\n    }\n    async getScheduler() {\n        return requestFluidObject(await this.getDataStore(agentSchedulerId, true), \"\");\n    }\n    updateLeader(leadership) {\n        this._leader = leadership;\n        if (this.leader) {\n            assert(this.clientId === undefined || this.connected && this.deltaManager && this.deltaManager.active, 0x136 /* \"Leader must either have undefined clientId or be connected with active delta manager!\" */);\n            this.emit(\"leader\");\n        }\n        else {\n            this.emit(\"notleader\");\n        }\n        this.dataStores.updateLeader();\n    }\n    /** Implementation of ISummarizerInternalsProvider.refreshLatestSummaryAck */\n    async refreshLatestSummaryAck(proposalHandle, ackHandle, summaryLogger, version) {\n        this.latestSummaryAck = { proposalHandle, ackHandle };\n        const getSnapshot = async () => {\n            const perfEvent = PerformanceEvent.start(summaryLogger, {\n                eventName: \"RefreshLatestSummaryGetSnapshot\",\n                hasVersion: !!version,\n            });\n            const stats = {};\n            let snapshot;\n            try {\n                const trace = Trace.start();\n                const versionToUse = version !== null && version !== void 0 ? version : await this.getVersionFromStorage(ackHandle);\n                stats.getVersionDuration = trace.trace().duration;\n                snapshot = await this.getSnapshotFromStorage(versionToUse);\n                stats.getSnapshotDuration = trace.trace().duration;\n            }\n            catch (error) {\n                perfEvent.cancel(stats, error);\n                throw error;\n            }\n            perfEvent.end(stats);\n            return snapshot;\n        };\n        await this.summarizerNode.refreshLatestSummary(proposalHandle, getSnapshot, async (id) => readAndParse(this.storage, id), summaryLogger);\n    }\n    async getVersionFromStorage(versionId) {\n        const versions = await this.storage.getVersions(versionId, 1);\n        assert(!!versions && !!versions[0], 0x137 /* \"Failed to get version from storage\" */);\n        return versions[0];\n    }\n    async getSnapshotFromStorage(version) {\n        const snapshot = await this.storage.getSnapshotTree(version);\n        assert(!!snapshot, 0x138 /* \"Failed to get snapshot from storage\" */);\n        return snapshot;\n    }\n    getPendingLocalState() {\n        return this.pendingStateManager.getLocalState();\n    }\n}\n//# sourceMappingURL=containerRuntime.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { BindState, AttachState, } from \"@fluidframework/container-definitions\";\nimport { assert, Deferred, LazyPromise, TypedEventEmitter, } from \"@fluidframework/common-utils\";\nimport { readAndParse } from \"@fluidframework/driver-utils\";\nimport { BlobTreeEntry } from \"@fluidframework/protocol-base\";\nimport { channelsTreeName, gcBlobKey, } from \"@fluidframework/runtime-definitions\";\nimport { addBlobToSummary, convertSummaryTreeToITree } from \"@fluidframework/runtime-utils\";\nimport { LoggingError, TelemetryDataTag } from \"@fluidframework/telemetry-utils\";\nimport { dataStoreAttributesBlobName, hasIsolatedChannels, wrapSummaryInChannelsTree, getAttributesFormatVersion, } from \"./summaryFormat\";\nfunction createAttributes(pkg, isRootDataStore, disableIsolatedChannels) {\n    const stringifiedPkg = JSON.stringify(pkg);\n    return disableIsolatedChannels ? {\n        pkg: stringifiedPkg,\n        snapshotFormatVersion: \"0.1\",\n        isRootDataStore,\n    } : {\n        pkg: stringifiedPkg,\n        summaryFormatVersion: 2,\n        isRootDataStore,\n    };\n}\nexport function createAttributesBlob(pkg, isRootDataStore, disableIsolatedChannels) {\n    const attributes = createAttributes(pkg, isRootDataStore, disableIsolatedChannels);\n    return new BlobTreeEntry(dataStoreAttributesBlobName, JSON.stringify(attributes));\n}\n/**\n * Represents the context for the store. This context is passed to the store runtime.\n */\nexport class FluidDataStoreContext extends TypedEventEmitter {\n    constructor(_containerRuntime, id, existing, storage, scope, createSummarizerNode, bindState, isLocalDataStore, bindChannel, pkg) {\n        super();\n        this._containerRuntime = _containerRuntime;\n        this.id = id;\n        this.existing = existing;\n        this.storage = storage;\n        this.scope = scope;\n        this.bindState = bindState;\n        this.isLocalDataStore = isLocalDataStore;\n        this.pkg = pkg;\n        this._disposed = false;\n        this.detachedRuntimeCreation = false;\n        this.loaded = false;\n        this.pending = [];\n        // URIs use slashes as delimiters. Handles use URIs.\n        // Thus having slashes in types almost guarantees trouble down the road!\n        assert(id.indexOf(\"/\") === -1, 0x13a /* `Data store ID contains slash: ${id}` */);\n        this._attachState = this.containerRuntime.attachState !== AttachState.Detached && existing ?\n            this.containerRuntime.attachState : AttachState.Detached;\n        this.bindToContext = () => {\n            assert(this.bindState === BindState.NotBound, 0x13b /* \"datastore context is already in bound state\" */);\n            this.bindState = BindState.Binding;\n            assert(this.channel !== undefined, 0x13c /* \"undefined channel on datastore context\" */);\n            bindChannel(this.channel);\n            this.bindState = BindState.Bound;\n        };\n        const thisSummarizeInternal = async (fullTree, trackState) => this.summarizeInternal(fullTree, trackState);\n        this.summarizerNode = createSummarizerNode(thisSummarizeInternal, async (fullGC) => this.getGCDataInternal(fullGC), async () => this.getInitialGCSummaryDetails());\n    }\n    get documentId() {\n        return this._containerRuntime.id;\n    }\n    get packagePath() {\n        assert(this.pkg !== undefined, 0x139 /* \"Undefined package path\" */);\n        return this.pkg;\n    }\n    get options() {\n        return this._containerRuntime.options;\n    }\n    get clientId() {\n        return this._containerRuntime.clientId;\n    }\n    get deltaManager() {\n        return this._containerRuntime.deltaManager;\n    }\n    get connected() {\n        return this._containerRuntime.connected;\n    }\n    get leader() {\n        return this._containerRuntime.leader;\n    }\n    get loader() {\n        return this._containerRuntime.loader;\n    }\n    get containerRuntime() {\n        return this._containerRuntime;\n    }\n    get isLoaded() {\n        return this.loaded;\n    }\n    get baseSnapshot() {\n        return this._baseSnapshot;\n    }\n    get disposed() { return this._disposed; }\n    get attachState() {\n        return this._attachState;\n    }\n    get IFluidDataStoreRegistry() {\n        return this.registry;\n    }\n    async isRoot() {\n        return (await this.getInitialSnapshotDetails()).isRootDataStore;\n    }\n    get disableIsolatedChannels() {\n        return this._containerRuntime.disableIsolatedChannels;\n    }\n    dispose() {\n        if (this._disposed) {\n            return;\n        }\n        this._disposed = true;\n        // Dispose any pending runtime after it gets fulfilled\n        if (this.channelDeferred) {\n            this.channelDeferred.promise.then((runtime) => {\n                runtime.dispose();\n            }).catch((error) => {\n                this._containerRuntime.logger.sendErrorEvent({ eventName: \"ChannelDisposeError\", fluidDataStoreId: this.id }, error);\n            });\n        }\n    }\n    rejectDeferredRealize(reason, packageName) {\n        throw new LoggingError(reason, { packageName: { value: packageName, tag: TelemetryDataTag.PackageData } });\n    }\n    async realize() {\n        assert(!this.detachedRuntimeCreation, 0x13d /* \"Detached runtime creation on realize()\" */);\n        if (!this.channelDeferred) {\n            this.channelDeferred = new Deferred();\n            this.realizeCore().catch((error) => {\n                var _a;\n                (_a = this.channelDeferred) === null || _a === void 0 ? void 0 : _a.reject(error);\n            });\n        }\n        return this.channelDeferred.promise;\n    }\n    async factoryFromPackagePath(packages) {\n        assert(this.pkg === packages, 0x13e /* \"Unexpected package path\" */);\n        if (packages === undefined) {\n            this.rejectDeferredRealize(\"packages is undefined\");\n        }\n        let entry;\n        let registry = this._containerRuntime.IFluidDataStoreRegistry;\n        let lastPkg;\n        for (const pkg of packages) {\n            if (!registry) {\n                this.rejectDeferredRealize(\"No registry for package\", lastPkg);\n            }\n            lastPkg = pkg;\n            entry = await registry.get(pkg);\n            if (!entry) {\n                this.rejectDeferredRealize(\"Registry does not contain entry for the package\", pkg);\n            }\n            registry = entry.IFluidDataStoreRegistry;\n        }\n        const factory = entry === null || entry === void 0 ? void 0 : entry.IFluidDataStoreFactory;\n        if (factory === undefined) {\n            this.rejectDeferredRealize(\"Can't find factory for package\", lastPkg);\n        }\n        return { factory, registry };\n    }\n    async realizeCore() {\n        const details = await this.getInitialSnapshotDetails();\n        // Base snapshot is the baseline where pending ops are applied to.\n        // It is important that this be in sync with the pending ops, and also\n        // that it is set here, before bindRuntime is called.\n        this._baseSnapshot = details.snapshot;\n        const packages = details.pkg;\n        const { factory, registry } = await this.factoryFromPackagePath(packages);\n        assert(this.registry === undefined, 0x13f /* \"datastore context registry is already set\" */);\n        this.registry = registry;\n        const channel = await factory.instantiateDataStore(this);\n        assert(channel !== undefined, 0x140 /* \"undefined channel on datastore context\" */);\n        this.bindRuntime(channel);\n    }\n    /**\n     * Notifies this object about changes in the connection state.\n     * @param value - New connection state.\n     * @param clientId - ID of the client. It's old ID when in disconnected state and\n     * it's new client ID when we are connecting or connected.\n     */\n    setConnectionState(connected, clientId) {\n        this.verifyNotClosed();\n        // Connection events are ignored if the store is not yet loaded\n        if (!this.loaded) {\n            return;\n        }\n        assert(this.connected === connected, 0x141 /* \"Unexpected connected state\" */);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.channel.setConnectionState(connected, clientId);\n    }\n    process(messageArg, local, localOpMetadata) {\n        var _a, _b;\n        this.verifyNotClosed();\n        const innerContents = messageArg.contents;\n        const message = Object.assign(Object.assign({}, messageArg), { type: innerContents.type, contents: innerContents.content });\n        this.summarizerNode.recordChange(message);\n        if (this.loaded) {\n            return (_a = this.channel) === null || _a === void 0 ? void 0 : _a.process(message, local, localOpMetadata);\n        }\n        else {\n            assert(!local, 0x142 /* \"local store channel is not loaded\" */);\n            (_b = this.pending) === null || _b === void 0 ? void 0 : _b.push(message);\n        }\n    }\n    processSignal(message, local) {\n        var _a;\n        this.verifyNotClosed();\n        // Signals are ignored if the store is not yet loaded\n        if (!this.loaded) {\n            return;\n        }\n        (_a = this.channel) === null || _a === void 0 ? void 0 : _a.processSignal(message, local);\n    }\n    getQuorum() {\n        return this._containerRuntime.getQuorum();\n    }\n    getAudience() {\n        return this._containerRuntime.getAudience();\n    }\n    /**\n     * Returns a summary at the current sequence number.\n     * @param fullTree - true to bypass optimizations and force a full summary tree\n     * @param trackState - This tells whether we should track state from this summary.\n     */\n    async summarize(fullTree = false, trackState = true) {\n        return this.summarizerNode.summarize(fullTree, trackState);\n    }\n    async summarizeInternal(fullTree, trackState) {\n        await this.realize();\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const summarizeResult = await this.channel.summarize(fullTree, trackState);\n        let pathPartsForChildren;\n        if (!this.disableIsolatedChannels) {\n            // Wrap dds summaries in .channels subtree.\n            wrapSummaryInChannelsTree(summarizeResult);\n            pathPartsForChildren = [channelsTreeName];\n        }\n        // Add data store's attributes to the summary.\n        const { pkg, isRootDataStore } = await this.getInitialSnapshotDetails();\n        const attributes = createAttributes(pkg, isRootDataStore, this.disableIsolatedChannels);\n        addBlobToSummary(summarizeResult, dataStoreAttributesBlobName, JSON.stringify(attributes));\n        // Add GC details to the summary.\n        const gcDetails = {\n            usedRoutes: this.summarizerNode.usedRoutes,\n            gcData: summarizeResult.gcData,\n        };\n        addBlobToSummary(summarizeResult, gcBlobKey, JSON.stringify(gcDetails));\n        // If we are not referenced, update the summary tree to indicate that.\n        if (!this.summarizerNode.isReferenced()) {\n            summarizeResult.summary.unreferenced = true;\n        }\n        return Object.assign(Object.assign({}, summarizeResult), { id: this.id, pathPartsForChildren });\n    }\n    /**\n     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this data store\n     * including any of its child channel contexts. Each node has a set of outbound routes to other GC nodes in the\n     * document.\n     * If there is no new data in this data store since the last summary, previous GC data is used.\n     * If there is new data, the GC data is generated again (by calling getGCDataInternal).\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCData(fullGC = false) {\n        return this.summarizerNode.getGCData(fullGC);\n    }\n    /**\n     * Generates data used for garbage collection. This is called when there is new data since last summary. It\n     * realizes the data store and calls into each channel context to get its GC data.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCDataInternal(fullGC = false) {\n        await this.realize();\n        assert(this.channel !== undefined, 0x143 /* \"Channel should not be undefined when running GC\" */);\n        return this.channel.getGCData(fullGC);\n    }\n    /**\n     * After GC has run, called to notify the data store of routes used in it. These are used for the following:\n     * 1. To identify if this data store is being referenced in the document or not.\n     * 2. To determine if it needs to re-summarize in case used routes changed since last summary.\n     * 3. These are added to the summary generated by the data store.\n     * 4. To notify child contexts of their used routes. This is done immediately if the data store is loaded. Else,\n     *    it is done when realizing the data store.\n     * @param usedRoutes - The routes that are used in this data store.\n     */\n    updateUsedRoutes(usedRoutes) {\n        // Currently, only data stores can be collected. Once we have GC at DDS layer, the DDS' in the data store will\n        // also be notified of their used routes. See - https://github.com/microsoft/FluidFramework/issues/4611\n        // Update the used routes in this data store's summarizer node.\n        this.summarizerNode.updateUsedRoutes(usedRoutes);\n        // If we are loaded, call the channel so it can update the used routes of the child contexts.\n        // If we are not loaded, we will update this when we are realized.\n        if (this.loaded) {\n            this.updateChannelUsedRoutes();\n        }\n    }\n    /**\n     * Updates the used routes of the channel and its child contexts. The channel must be loaded before calling this.\n     * It is called in these two scenarions:\n     * 1. When the used routes of the data store is updated and the data store is loaded.\n     * 2. When the data store is realized. This updates the channel's used routes as per last GC run.\n     */\n    updateChannelUsedRoutes() {\n        assert(this.loaded, 0x144 /* \"Channel should be loaded when updating used routes\" */);\n        assert(this.channel !== undefined, 0x145 /* \"Channel should be present when data store is loaded\" */);\n        // Remove the route to this data store, if it exists.\n        const usedChannelRoutes = this.summarizerNode.usedRoutes.filter((id) => { return id !== \"/\" && id !== \"\"; });\n        this.channel.updateUsedRoutes(usedChannelRoutes);\n    }\n    /**\n     * @deprecated 0.18.Should call request on the runtime directly\n     */\n    async request(request) {\n        const runtime = await this.realize();\n        return runtime.request(request);\n    }\n    submitMessage(type, content, localOpMetadata) {\n        this.verifyNotClosed();\n        assert(!!this.channel, 0x146 /* \"Channel must exist when submitting message\" */);\n        const fluidDataStoreContent = {\n            content,\n            type,\n        };\n        this._containerRuntime.submitDataStoreOp(this.id, fluidDataStoreContent, localOpMetadata);\n    }\n    /**\n     * This is called from a SharedSummaryBlock that does not generate ops but only wants to be part of the summary.\n     * It indicates that there is data in the object that needs to be summarized.\n     * We will update the latestSequenceNumber of the summary tracker of this\n     * store and of the object's channel.\n     *\n     * @param address - The address of the channel that is dirty.\n     *\n     */\n    setChannelDirty(address) {\n        this.verifyNotClosed();\n        // Get the latest sequence number.\n        const latestSequenceNumber = this.deltaManager.lastSequenceNumber;\n        this.summarizerNode.invalidate(latestSequenceNumber);\n        const channelSummarizerNode = this.summarizerNode.getChild(address);\n        if (channelSummarizerNode) {\n            channelSummarizerNode.invalidate(latestSequenceNumber); // TODO: lazy load problem?\n        }\n    }\n    submitSignal(type, content) {\n        this.verifyNotClosed();\n        assert(!!this.channel, 0x147 /* \"Channel must exist on submitting signal\" */);\n        return this._containerRuntime.submitDataStoreSignal(this.id, type, content);\n    }\n    raiseContainerWarning(warning) {\n        this.containerRuntime.raiseContainerWarning(warning);\n    }\n    /**\n     * Updates the leader.\n     * @param leadership - Whether this client is the new leader or not.\n     */\n    updateLeader(leadership) {\n        // Leader events are ignored if the store is not yet loaded\n        if (!this.loaded) {\n            return;\n        }\n        if (leadership) {\n            this.emit(\"leader\");\n        }\n        else {\n            this.emit(\"notleader\");\n        }\n    }\n    bindRuntime(channel) {\n        var _a;\n        if (this.channel) {\n            throw new Error(\"Runtime already bound\");\n        }\n        try {\n            assert(!this.detachedRuntimeCreation, 0x148 /* \"Detached runtime creation on runtime bind\" */);\n            assert(this.channelDeferred !== undefined, 0x149 /* \"Undefined channel defferal\" */);\n            assert(this.pkg !== undefined, 0x14a /* \"Undefined package path\" */);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const pending = this.pending;\n            if (pending.length > 0) {\n                // Apply all pending ops\n                for (const op of pending) {\n                    channel.process(op, false, undefined /* localOpMetadata */);\n                }\n            }\n            this.pending = undefined;\n            // And now mark the runtime active\n            this.loaded = true;\n            this.channel = channel;\n            // Freeze the package path to ensure that someone doesn't modify it when it is\n            // returned in packagePath().\n            Object.freeze(this.pkg);\n            /**\n             * Update the used routes of the channel. If GC has run before this data store was realized, we will have\n             * the used routes saved. So, this will ensure that all the child contexts have up-to-date used routes as\n             * per the last time GC was run.\n             * Also, this data store may have been realized during summarize. In that case, the child contexts need to\n             * have their used routes updated to determine if its needs to summarize again and to add it to the summary.\n             */\n            this.updateChannelUsedRoutes();\n            // And notify the pending promise it is now available\n            this.channelDeferred.resolve(this.channel);\n        }\n        catch (error) {\n            (_a = this.channelDeferred) === null || _a === void 0 ? void 0 : _a.reject(error);\n        }\n        // notify the runtime if they want to propagate up. Used for logging.\n        this._containerRuntime.notifyDataStoreInstantiated(this);\n    }\n    async getAbsoluteUrl(relativeUrl) {\n        if (this.attachState !== AttachState.Attached) {\n            return undefined;\n        }\n        return this._containerRuntime.getAbsoluteUrl(relativeUrl);\n    }\n    reSubmit(contents, localOpMetadata) {\n        assert(!!this.channel, 0x14b /* \"Channel must exist when resubmitting ops\" */);\n        const innerContents = contents;\n        this.channel.reSubmit(innerContents.type, innerContents.content, localOpMetadata);\n    }\n    async applyStashedOp(contents) {\n        if (!this.channel) {\n            await this.realize();\n        }\n        assert(!!this.channel, 0x14c /* \"Channel must exist when rebasing ops\" */);\n        const innerContents = contents;\n        return this.channel.applyStashedOp(innerContents.content);\n    }\n    verifyNotClosed() {\n        if (this._disposed) {\n            throw new Error(\"Context is closed\");\n        }\n    }\n    getCreateChildSummarizerNodeFn(id, createParam) {\n        return (summarizeInternal, getGCDataFn, getInitialGCSummaryDetailsFn) => this.summarizerNode.createChild(summarizeInternal, id, createParam, \n        // DDS will not create failure summaries\n        { throwOnFailure: true }, getGCDataFn, getInitialGCSummaryDetailsFn);\n    }\n    async uploadBlob(blob) {\n        return this.containerRuntime.uploadBlob(blob);\n    }\n}\nexport class RemotedFluidDataStoreContext extends FluidDataStoreContext {\n    constructor(id, initSnapshotValue, runtime, storage, scope, createSummarizerNode, pkg) {\n        super(runtime, id, true, storage, scope, createSummarizerNode, BindState.Bound, false, () => {\n            throw new Error(\"Already attached\");\n        }, pkg);\n        this.initSnapshotValue = initSnapshotValue;\n        this.initialSnapshotDetailsP = new LazyPromise(async () => {\n            var _a, _b;\n            let tree;\n            let isRootDataStore = true;\n            if (typeof this.initSnapshotValue === \"string\") {\n                const commit = (await this.storage.getVersions(this.initSnapshotValue, 1))[0];\n                tree = (_a = await this.storage.getSnapshotTree(commit)) !== null && _a !== void 0 ? _a : undefined;\n            }\n            else {\n                tree = this.initSnapshotValue;\n            }\n            const localReadAndParse = async (id) => readAndParse(this.storage, id);\n            if (tree) {\n                const loadedSummary = await this.summarizerNode.loadBaseSummary(tree, localReadAndParse);\n                tree = loadedSummary.baseSummary;\n                // Prepend outstanding ops to pending queue of ops to process.\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this.pending = loadedSummary.outstandingOps.concat(this.pending);\n            }\n            if (!!tree && tree.blobs[dataStoreAttributesBlobName] !== undefined) {\n                // Need to rip through snapshot and use that to populate extraBlobs\n                const attributes = await localReadAndParse(tree.blobs[dataStoreAttributesBlobName]);\n                let pkgFromSnapshot;\n                // Use the snapshotFormatVersion to determine how the pkg is encoded in the snapshot.\n                // For snapshotFormatVersion = \"0.1\" (1) or above, pkg is jsonified, otherwise it is just a string.\n                const formatVersion = getAttributesFormatVersion(attributes);\n                if (formatVersion < 1) {\n                    if (attributes.pkg.startsWith(\"[\\\"\") && attributes.pkg.endsWith(\"\\\"]\")) {\n                        pkgFromSnapshot = JSON.parse(attributes.pkg);\n                    }\n                    else {\n                        pkgFromSnapshot = [attributes.pkg];\n                    }\n                }\n                else {\n                    pkgFromSnapshot = JSON.parse(attributes.pkg);\n                }\n                this.pkg = pkgFromSnapshot;\n                /**\n                 * If there is no isRootDataStore in the attributes blob, set it to true. This will ensure that\n                 * data stores in older documents are not garbage collected incorrectly. This may lead to additional\n                 * roots in the document but they won't break.\n                 */\n                isRootDataStore = (_b = attributes.isRootDataStore) !== null && _b !== void 0 ? _b : true;\n                if (hasIsolatedChannels(attributes)) {\n                    tree = tree.trees[channelsTreeName];\n                }\n            }\n            return {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                pkg: this.pkg,\n                snapshot: tree,\n                isRootDataStore,\n            };\n        });\n        this.gcDetailsInInitialSummaryP = new LazyPromise(async () => {\n            // If the initial snapshot is undefined or string, the snapshot is in old format and won't have GC details.\n            if (!(!this.initSnapshotValue || typeof this.initSnapshotValue === \"string\")\n                && this.initSnapshotValue.blobs[gcBlobKey] !== undefined) {\n                return readAndParse(this.storage, this.initSnapshotValue.blobs[gcBlobKey]);\n            }\n            else {\n                return {};\n            }\n        });\n    }\n    async getInitialSnapshotDetails() {\n        return this.initialSnapshotDetailsP;\n    }\n    async getInitialGCSummaryDetails() {\n        return this.gcDetailsInInitialSummaryP;\n    }\n    generateAttachMessage() {\n        throw new Error(\"Cannot attach remote store\");\n    }\n}\n/**\n * Base class for detached & attached context classes\n */\nexport class LocalFluidDataStoreContextBase extends FluidDataStoreContext {\n    constructor(id, pkg, runtime, storage, scope, createSummarizerNode, bindChannel, snapshotTree, isRootDataStore, \n    /**\n     * @deprecated 0.16 Issue #1635, #3631\n     */\n    createProps) {\n        super(runtime, id, snapshotTree !== undefined ? true : false, storage, scope, createSummarizerNode, snapshotTree ? BindState.Bound : BindState.NotBound, true, bindChannel, pkg);\n        this.snapshotTree = snapshotTree;\n        this.isRootDataStore = isRootDataStore;\n        this.createProps = createProps;\n        this.attachListeners();\n    }\n    attachListeners() {\n        this.once(\"attaching\", () => {\n            assert(this.attachState === AttachState.Detached, 0x14d /* \"Should move from detached to attaching\" */);\n            this._attachState = AttachState.Attaching;\n        });\n        this.once(\"attached\", () => {\n            assert(this.attachState === AttachState.Attaching, 0x14e /* \"Should move from attaching to attached\" */);\n            this._attachState = AttachState.Attached;\n        });\n    }\n    generateAttachMessage() {\n        assert(this.channel !== undefined, 0x14f /* \"There should be a channel when generating attach message\" */);\n        assert(this.pkg !== undefined, 0x150 /* \"pkg should be available in local data store context\" */);\n        assert(this.isRootDataStore !== undefined, 0x151 /* \"isRootDataStore should be available in local data store context\" */);\n        const summarizeResult = this.channel.getAttachSummary();\n        if (!this.disableIsolatedChannels) {\n            // Wrap dds summaries in .channels subtree.\n            wrapSummaryInChannelsTree(summarizeResult);\n        }\n        // Add data store's attributes to the summary.\n        const attributes = createAttributes(this.pkg, this.isRootDataStore, this.disableIsolatedChannels);\n        addBlobToSummary(summarizeResult, dataStoreAttributesBlobName, JSON.stringify(attributes));\n        // Add GC details to the summary.\n        const gcDetails = {\n            usedRoutes: this.summarizerNode.usedRoutes,\n            gcData: summarizeResult.gcData,\n        };\n        addBlobToSummary(summarizeResult, gcBlobKey, JSON.stringify(gcDetails));\n        // Attach message needs the summary in ITree format. Convert the ISummaryTree into an ITree.\n        const snapshot = convertSummaryTreeToITree(summarizeResult.summary);\n        const message = {\n            id: this.id,\n            snapshot,\n            type: this.pkg[this.pkg.length - 1],\n        };\n        return message;\n    }\n    async getInitialSnapshotDetails() {\n        var _a;\n        assert(this.pkg !== undefined, 0x152 /* \"pkg should be available in local data store\" */);\n        assert(this.isRootDataStore !== undefined, 0x153 /* \"isRootDataStore should be available in local data store\" */);\n        const snapshot = this.disableIsolatedChannels\n            ? this.snapshotTree\n            : (_a = this.snapshotTree) === null || _a === void 0 ? void 0 : _a.trees[channelsTreeName];\n        return {\n            pkg: this.pkg,\n            snapshot,\n            isRootDataStore: this.isRootDataStore,\n        };\n    }\n    async getInitialGCSummaryDetails() {\n        // Local data store does not have initial summary.\n        return {};\n    }\n}\n/**\n * context implementation for \"attached\" data store runtime.\n * Various workflows (snapshot creation, requests) result in .realize() being called\n * on context, resulting in instantiation and attachment of runtime.\n * Runtime is created using data store factory that is associated with this context.\n */\nexport class LocalFluidDataStoreContext extends LocalFluidDataStoreContextBase {\n    constructor(id, pkg, runtime, storage, scope, createSummarizerNode, bindChannel, snapshotTree, isRootDataStore, \n    /**\n     * @deprecated 0.16 Issue #1635, #3631\n     */\n    createProps) {\n        super(id, pkg, runtime, storage, scope, createSummarizerNode, bindChannel, snapshotTree, isRootDataStore, createProps);\n    }\n}\n/**\n * Detached context. Data Store runtime will be attached to it by attachRuntime() call\n * Before attachment happens, this context is not associated with particular type of runtime\n * or factory, i.e. it's package path is undefined.\n * Attachment process provides all missing parts - package path, data store runtime, and data store factory\n */\nexport class LocalDetachedFluidDataStoreContext extends LocalFluidDataStoreContextBase {\n    constructor(id, pkg, runtime, storage, scope, createSummarizerNode, bindChannel, snapshotTree, isRootDataStore) {\n        super(id, pkg, runtime, storage, scope, createSummarizerNode, bindChannel, snapshotTree, isRootDataStore);\n        this.detachedRuntimeCreation = true;\n    }\n    async attachRuntime(registry, dataStoreRuntime) {\n        assert(this.detachedRuntimeCreation, 0x154 /* \"runtime creation is already attached\" */);\n        assert(this.channelDeferred === undefined, 0x155 /* \"channel deferral is already set\" */);\n        const factory = registry.IFluidDataStoreFactory;\n        const entry = await this.factoryFromPackagePath(this.pkg);\n        assert(entry.factory === factory, 0x156 /* \"Unexpected factory for package path\" */);\n        assert(this.registry === undefined, 0x157 /* \"datastore registry already attached\" */);\n        this.registry = entry.registry;\n        this.detachedRuntimeCreation = false;\n        this.channelDeferred = new Deferred();\n        super.bindRuntime(dataStoreRuntime);\n        if (this.isRootDataStore) {\n            dataStoreRuntime.bindToContext();\n        }\n    }\n    async getInitialSnapshotDetails() {\n        if (this.detachedRuntimeCreation) {\n            throw new Error(\"Detached Fluid Data Store context can't be realized! Please attach runtime first!\");\n        }\n        return super.getInitialSnapshotDetails();\n    }\n}\n//# sourceMappingURL=dataStoreContext.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, Deferred, Lazy } from \"@fluidframework/common-utils\";\nimport { ChildLogger } from \"@fluidframework/telemetry-utils\";\nexport class DataStoreContexts {\n    constructor(baseLogger) {\n        this.notBoundContexts = new Set();\n        /** Attached and loaded context proxies */\n        this._contexts = new Map();\n        /**\n         * List of pending context waiting either to be bound or to arrive from another client.\n         * This covers the case where a local context has been created but not yet bound,\n         * or the case where a client knows a store will exist and is waiting on its creation,\n         * so that a caller may await the deferred's promise until such a time as the context is fully ready.\n         * This is a superset of _contexts, since contexts remain here once the Deferred resolves.\n         */\n        this.deferredContexts = new Map();\n        this.disposeOnce = new Lazy(() => {\n            // close/stop all store contexts\n            for (const [fluidDataStoreId, contextD] of this.deferredContexts) {\n                contextD.promise.then((context) => {\n                    context.dispose();\n                }).catch((contextError) => {\n                    this._logger.sendErrorEvent({\n                        eventName: \"FluidDataStoreContextDisposeError\",\n                        fluidDataStoreId,\n                    }, contextError);\n                });\n            }\n        });\n        this.dispose = () => this.disposeOnce.value;\n        this._logger = ChildLogger.create(baseLogger);\n    }\n    [Symbol.iterator]() {\n        return this._contexts.entries();\n    }\n    get disposed() { return this.disposeOnce.evaluated; }\n    notBoundLength() {\n        return this.notBoundContexts.size;\n    }\n    isNotBound(id) {\n        return this.notBoundContexts.has(id);\n    }\n    has(id) {\n        return this._contexts.has(id);\n    }\n    get(id) {\n        return this._contexts.get(id);\n    }\n    /**\n     * Return the unbound local context with the given id,\n     * or undefined if it's not found or not unbound.\n     */\n    getUnbound(id) {\n        const context = this._contexts.get(id);\n        if (context === undefined || !this.notBoundContexts.has(id)) {\n            return undefined;\n        }\n        return this._contexts.get(id);\n    }\n    /**\n     * Add the given context, marking it as to-be-bound\n     */\n    addUnbound(context) {\n        const id = context.id;\n        assert(!this._contexts.has(id), 0x158 /* \"Creating store with existing ID\" */);\n        this._contexts.set(id, context);\n        this.notBoundContexts.add(id);\n        this.ensureDeferred(id);\n    }\n    /**\n     * Get the context with the given id, once it exists locally and is attached.\n     * e.g. If created locally, it must be bound, or if created remotely then it's fine as soon as it's sync'd in.\n     * @param id The id of the context to get\n     * @param wait If false, return undefined if the context isn't present and ready now. Otherwise, wait for it.\n     */\n    async getBoundOrRemoted(id, wait) {\n        const deferredContext = this.ensureDeferred(id);\n        if (!wait && !deferredContext.isCompleted) {\n            return undefined;\n        }\n        return deferredContext.promise;\n    }\n    ensureDeferred(id) {\n        const deferred = this.deferredContexts.get(id);\n        if (deferred) {\n            return deferred;\n        }\n        const newDeferred = new Deferred();\n        this.deferredContexts.set(id, newDeferred);\n        return newDeferred;\n    }\n    /**\n     * Update this context as bound\n     */\n    bind(id) {\n        const removed = this.notBoundContexts.delete(id);\n        assert(removed, 0x159 /* \"The given id was not found in notBoundContexts to delete\" */);\n        this.resolveDeferred(id);\n    }\n    /**\n     * Triggers the deferred to resolve, indicating the context is not local-only\n     * @param id - The id of the context to resolve to\n     */\n    resolveDeferred(id) {\n        const context = this._contexts.get(id);\n        assert(!!context, 0x15a /* \"Cannot find context to resolve to\" */);\n        assert(!this.notBoundContexts.has(id), 0x15b /* \"Expected this id to already be removed from notBoundContexts\" */);\n        const deferred = this.deferredContexts.get(id);\n        assert(!!deferred, 0x15c /* \"Cannot find deferred to resolve\" */);\n        deferred.resolve(context);\n    }\n    /**\n     * Add the given context, marking it as not local-only.\n     * This could be because it's a local context that's been bound, or because it's a remote context.\n     * @param context - The context to add\n     */\n    addBoundOrRemoted(context) {\n        const id = context.id;\n        assert(!this._contexts.has(id), 0x15d /* \"Creating store with existing ID\" */);\n        this._contexts.set(id, context);\n        // Resolve the deferred immediately since this context is not unbound\n        this.ensureDeferred(id);\n        this.resolveDeferred(id);\n    }\n}\n//# sourceMappingURL=dataStoreContexts.js.map","export class FluidDataStoreRegistry {\n    constructor(namedEntries) {\n        this.map = new Map(namedEntries);\n    }\n    get IFluidDataStoreRegistry() { return this; }\n    async get(name) {\n        if (this.map.has(name)) {\n            return this.map.get(name);\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=dataStoreRegistry.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { DataCorruptionError } from \"@fluidframework/container-utils\";\nimport { channelsTreeName, CreateSummarizerNodeSource, } from \"@fluidframework/runtime-definitions\";\nimport { convertSnapshotTreeToSummaryTree, convertSummaryTreeToITree, convertToSummaryTree, create404Response, responseToException, SummaryTreeBuilder, } from \"@fluidframework/runtime-utils\";\nimport { ChildLogger } from \"@fluidframework/telemetry-utils\";\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { BlobCacheStorageService, buildSnapshotTree, readAndParseFromBlobs } from \"@fluidframework/driver-utils\";\nimport { assert, Lazy } from \"@fluidframework/common-utils\";\nimport { v4 as uuid } from \"uuid\";\nimport { TreeTreeEntry } from \"@fluidframework/protocol-base\";\nimport { GCDataBuilder, getChildNodesUsedRoutes } from \"@fluidframework/garbage-collector\";\nimport { DataStoreContexts } from \"./dataStoreContexts\";\nimport { RemotedFluidDataStoreContext, LocalFluidDataStoreContext, createAttributesBlob, LocalDetachedFluidDataStoreContext, } from \"./dataStoreContext\";\nimport { dataStoreAttributesBlobName, nonDataStorePaths, rootHasIsolatedChannels, getAttributesFormatVersion, } from \"./summaryFormat\";\n/**\n * This class encapsulates data store handling. Currently it is only used by the container runtime,\n * but eventually could be hosted on any channel once we formalize the channel api boundary.\n */\nexport class DataStores {\n    constructor(baseSnapshot, runtime, submitAttachFn, getCreateChildSummarizerNodeFn, baseLogger, contexts = new DataStoreContexts(baseLogger)) {\n        var _a;\n        this.baseSnapshot = baseSnapshot;\n        this.runtime = runtime;\n        this.submitAttachFn = submitAttachFn;\n        this.getCreateChildSummarizerNodeFn = getCreateChildSummarizerNodeFn;\n        this.contexts = contexts;\n        // Stores tracked by the Domain\n        this.pendingAttach = new Map();\n        // 0.24 back-compat attachingBeforeSummary\n        this.attachOpFiredForDataStore = new Set();\n        this.disposeOnce = new Lazy(() => this.contexts.dispose());\n        this.dispose = () => this.disposeOnce.value;\n        this.logger = ChildLogger.create(baseLogger);\n        // Extract stores stored inside the snapshot\n        const fluidDataStores = new Map();\n        if (baseSnapshot) {\n            for (const [key, value] of Object.entries(baseSnapshot.trees)) {\n                fluidDataStores.set(key, value);\n            }\n        }\n        // Create a context for each of them\n        for (const [key, value] of fluidDataStores) {\n            let dataStoreContext;\n            // If we have a detached container, then create local data store contexts.\n            if (this.runtime.attachState !== AttachState.Detached) {\n                dataStoreContext = new RemotedFluidDataStoreContext(key, value, this.runtime, this.runtime.storage, this.runtime.scope, this.getCreateChildSummarizerNodeFn(key, { type: CreateSummarizerNodeSource.FromSummary }));\n            }\n            else {\n                if (typeof value !== \"object\") {\n                    throw new Error(\"Snapshot should be there to load from!!\");\n                }\n                const snapshotTree = value;\n                // Need to rip through snapshot.\n                const attributes = readAndParseFromBlobs(snapshotTree.blobs, snapshotTree.blobs[dataStoreAttributesBlobName]);\n                // Use the snapshotFormatVersion to determine how the pkg is encoded in the snapshot.\n                // For snapshotFormatVersion = \"0.1\" (1) or above, pkg is jsonified, otherwise it is just a string.\n                // However the feature of loading a detached container from snapshot, is added when the\n                // snapshotFormatVersion is at least \"0.1\" (1), so we don't expect it to be anything else.\n                const formatVersion = getAttributesFormatVersion(attributes);\n                assert(formatVersion > 0, 0x1d5 /* `Invalid snapshot format version ${attributes.snapshotFormatVersion}` */);\n                const pkgFromSnapshot = JSON.parse(attributes.pkg);\n                dataStoreContext = new LocalFluidDataStoreContext(key, pkgFromSnapshot, this.runtime, this.runtime.storage, this.runtime.scope, this.getCreateChildSummarizerNodeFn(key, { type: CreateSummarizerNodeSource.FromSummary }), (cr) => this.bindFluidDataStore(cr), snapshotTree, (_a = \n                // If there is no isRootDataStore in the attributes blob, set it to true. This ensures that data\n                // stores in older documents are not garbage collected incorrectly. This may lead to additional\n                // roots in the document but they won't break.\n                attributes.isRootDataStore) !== null && _a !== void 0 ? _a : true);\n            }\n            this.contexts.addBoundOrRemoted(dataStoreContext);\n        }\n    }\n    processAttachMessage(message, local) {\n        var _a, _b;\n        const attachMessage = message.contents;\n        // The local object has already been attached\n        if (local) {\n            assert(this.pendingAttach.has(attachMessage.id), 0x15e /* \"Local object does not have matching attach message id\" */);\n            (_a = this.contexts.get(attachMessage.id)) === null || _a === void 0 ? void 0 : _a.emit(\"attached\");\n            this.pendingAttach.delete(attachMessage.id);\n            return;\n        }\n        // If a non-local operation then go and create the object, otherwise mark it as officially attached.\n        if (this.contexts.has(attachMessage.id)) {\n            const error = new DataCorruptionError(\"Duplicate data store created with existing ID\", {\n                sequenceNumber: message.sequenceNumber,\n                clientId: message.clientId,\n                referenceSequenceNumber: message.referenceSequenceNumber,\n            });\n            this.logger.sendErrorEvent({ eventName: \"DuplicateDataStoreId\" }, error);\n            throw error;\n        }\n        const flatBlobs = new Map();\n        let snapshotTree;\n        if (attachMessage.snapshot) {\n            snapshotTree = buildSnapshotTree(attachMessage.snapshot.entries, flatBlobs);\n        }\n        // Include the type of attach message which is the pkg of the store to be\n        // used by RemotedFluidDataStoreContext in case it is not in the snapshot.\n        const pkg = [attachMessage.type];\n        const remotedFluidDataStoreContext = new RemotedFluidDataStoreContext(attachMessage.id, snapshotTree, this.runtime, new BlobCacheStorageService(this.runtime.storage, flatBlobs), this.runtime.scope, this.getCreateChildSummarizerNodeFn(attachMessage.id, {\n            type: CreateSummarizerNodeSource.FromAttach,\n            sequenceNumber: message.sequenceNumber,\n            snapshot: (_b = attachMessage.snapshot) !== null && _b !== void 0 ? _b : {\n                entries: [createAttributesBlob(pkg, true /* isRootDataStore */, this.runtime.disableIsolatedChannels)],\n            },\n        }), pkg);\n        // Resolve pending gets and store off any new ones\n        this.contexts.addBoundOrRemoted(remotedFluidDataStoreContext);\n        // Equivalent of nextTick() - Prefetch once all current ops have completed\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Promise.resolve().then(async () => remotedFluidDataStoreContext.realize());\n    }\n    bindFluidDataStore(fluidDataStoreRuntime) {\n        const id = fluidDataStoreRuntime.id;\n        const localContext = this.contexts.getUnbound(id);\n        assert(!!localContext, 0x15f /* \"Could not find unbound context to bind\" */);\n        // If the container is detached, we don't need to send OP or add to pending attach because\n        // we will summarize it while uploading the create new summary and make it known to other\n        // clients.\n        if (this.runtime.attachState !== AttachState.Detached) {\n            localContext.emit(\"attaching\");\n            const message = localContext.generateAttachMessage();\n            this.pendingAttach.set(id, message);\n            this.submitAttachFn(message);\n            this.attachOpFiredForDataStore.add(id);\n        }\n        this.contexts.bind(fluidDataStoreRuntime.id);\n    }\n    createDetachedDataStoreCore(pkg, isRoot, id = uuid()) {\n        const context = new LocalDetachedFluidDataStoreContext(id, pkg, this.runtime, this.runtime.storage, this.runtime.scope, this.getCreateChildSummarizerNodeFn(id, { type: CreateSummarizerNodeSource.Local }), (cr) => this.bindFluidDataStore(cr), undefined, isRoot);\n        this.contexts.addUnbound(context);\n        return context;\n    }\n    _createFluidDataStoreContext(pkg, id, isRoot, props) {\n        const context = new LocalFluidDataStoreContext(id, pkg, this.runtime, this.runtime.storage, this.runtime.scope, this.getCreateChildSummarizerNodeFn(id, { type: CreateSummarizerNodeSource.Local }), (cr) => this.bindFluidDataStore(cr), undefined, isRoot, props);\n        this.contexts.addUnbound(context);\n        return context;\n    }\n    get disposed() { return this.disposeOnce.evaluated; }\n    updateLeader() {\n        for (const [, context] of this.contexts) {\n            context.updateLeader(this.runtime.leader);\n        }\n    }\n    resubmitDataStoreOp(content, localOpMetadata) {\n        const envelope = content;\n        const context = this.contexts.get(envelope.address);\n        assert(!!context, 0x160 /* \"There should be a store context for the op\" */);\n        context.reSubmit(envelope.contents, localOpMetadata);\n    }\n    async applyStashedOp(content) {\n        const envelope = content;\n        const context = this.contexts.get(envelope.address);\n        assert(!!context, 0x161 /* \"There should be a store context for the op\" */);\n        return context.applyStashedOp(envelope.contents);\n    }\n    async applyStashedAttachOp(message) {\n        this.pendingAttach.set(message.id, message);\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        this.processAttachMessage({ contents: message }, false);\n    }\n    processFluidDataStoreOp(message, local, localMessageMetadata) {\n        const envelope = message.contents;\n        const transformed = Object.assign(Object.assign({}, message), { contents: envelope.contents });\n        const context = this.contexts.get(envelope.address);\n        assert(!!context, 0x162 /* \"There should be a store context for the op\" */);\n        context.process(transformed, local, localMessageMetadata);\n    }\n    async getDataStore(id, wait) {\n        const context = await this.contexts.getBoundOrRemoted(id, wait);\n        if (context === undefined) {\n            // The requested data store does not exits. Throw a 404 response exception.\n            const request = { url: id };\n            throw responseToException(create404Response(request), request);\n        }\n        return context;\n    }\n    processSignal(address, message, local) {\n        const context = this.contexts.get(address);\n        if (!context) {\n            // Attach message may not have been processed yet\n            assert(!local, 0x163 /* \"Missing datastore for local signal\" */);\n            this.logger.sendTelemetryEvent({\n                eventName: \"SignalFluidDataStoreNotFound\",\n                fluidDataStoreId: address,\n            });\n            return;\n        }\n        context.processSignal(message, local);\n    }\n    setConnectionState(connected, clientId) {\n        for (const [fluidDataStore, context] of this.contexts) {\n            try {\n                context.setConnectionState(connected, clientId);\n            }\n            catch (error) {\n                this.logger.sendErrorEvent({\n                    eventName: \"SetConnectionStateError\",\n                    clientId,\n                    fluidDataStore,\n                }, error);\n            }\n        }\n    }\n    setAttachState(attachState) {\n        let eventName;\n        if (attachState === AttachState.Attaching) {\n            eventName = \"attaching\";\n        }\n        else {\n            eventName = \"attached\";\n        }\n        for (const [, context] of this.contexts) {\n            // Fire only for bounded stores.\n            if (!this.contexts.isNotBound(context.id)) {\n                context.emit(eventName);\n            }\n        }\n    }\n    /**\n     * Notifies this object to take the snapshot of the container.\n     * @deprecated - Use summarize to get summary of the container runtime.\n     */\n    async snapshot() {\n        // Iterate over each store and ask it to snapshot\n        const fluidDataStoreSnapshotsP = Array.from(this.contexts).map(async ([fluidDataStoreId, value]) => {\n            const summaryTree = await value.summarize(true /* fullTree */, false /* trackState */);\n            assert(summaryTree.summary.type === 1 /* Tree */, 0x164 /* \"summarize should always return a tree when fullTree is true\" */);\n            // back-compat summary - Remove this once snapshot is removed.\n            const snapshot = convertSummaryTreeToITree(summaryTree.summary);\n            // If ID exists then previous commit is still valid\n            return {\n                fluidDataStoreId,\n                snapshot,\n            };\n        });\n        const entries = [];\n        // Add in module references to the store snapshots\n        const fluidDataStoreSnapshots = await Promise.all(fluidDataStoreSnapshotsP);\n        // Sort for better diffing of snapshots (in replay tool, used to find bugs in snapshotting logic)\n        fluidDataStoreSnapshots.sort((a, b) => a === null || a === void 0 ? void 0 : a.fluidDataStoreId.localeCompare(b.fluidDataStoreId));\n        for (const fluidDataStoreSnapshot of fluidDataStoreSnapshots) {\n            entries.push(new TreeTreeEntry(fluidDataStoreSnapshot.fluidDataStoreId, fluidDataStoreSnapshot.snapshot));\n        }\n        return entries;\n    }\n    async summarize(fullTree, trackState) {\n        const gcDataBuilder = new GCDataBuilder();\n        const summaryBuilder = new SummaryTreeBuilder();\n        // Iterate over each store and ask it to snapshot\n        await Promise.all(Array.from(this.contexts)\n            .filter(([_, context]) => {\n            // Summarizer works only with clients with no local changes!\n            assert(context.attachState !== AttachState.Attaching, 0x165 /* \"Summarizer cannot work if client has local changes\" */);\n            return context.attachState === AttachState.Attached;\n        }).map(async ([contextId, context]) => {\n            const contextSummary = await context.summarize(fullTree, trackState);\n            summaryBuilder.addWithStats(contextId, contextSummary);\n            // Prefix the child's id to the ids of its GC nodest. This gradually builds the id of each node to\n            // be a path from the root.\n            gcDataBuilder.prefixAndAddNodes(contextId, contextSummary.gcData.gcNodes);\n        }));\n        // Get the outbound routes and add a GC node for this channel.\n        gcDataBuilder.addNode(\"/\", await this.getOutboundRoutes());\n        return Object.assign(Object.assign({}, summaryBuilder.getSummaryTree()), { gcData: gcDataBuilder.getGCData() });\n    }\n    createSummary() {\n        const builder = new SummaryTreeBuilder();\n        // Attaching graph of some stores can cause other stores to get bound too.\n        // So keep taking summary until no new stores get bound.\n        let notBoundContextsLength;\n        do {\n            const builderTree = builder.summary.tree;\n            notBoundContextsLength = this.contexts.notBoundLength();\n            // Iterate over each data store and ask it to snapshot\n            Array.from(this.contexts)\n                .filter(([key, _]) => \n            // Take summary of bounded data stores only, make sure we haven't summarized them already\n            // and no attach op has been fired for that data store because for loader versions <= 0.24\n            // we set attach state as \"attaching\" before taking createNew summary.\n            !(this.contexts.isNotBound(key)\n                || builderTree[key]\n                || this.attachOpFiredForDataStore.has(key)))\n                .map(([key, value]) => {\n                let dataStoreSummary;\n                if (value.isLoaded) {\n                    const snapshot = value.generateAttachMessage().snapshot;\n                    dataStoreSummary = convertToSummaryTree(snapshot, true);\n                }\n                else {\n                    // If this data store is not yet loaded, then there should be no changes in the snapshot from\n                    // which it was created as it is detached container. So just use the previous snapshot.\n                    assert(!!this.baseSnapshot, 0x166 /* \"BaseSnapshot should be there as detached container loaded from snapshot\" */);\n                    dataStoreSummary = convertSnapshotTreeToSummaryTree(this.baseSnapshot.trees[key]);\n                }\n                builder.addWithStats(key, dataStoreSummary);\n            });\n        } while (notBoundContextsLength !== this.contexts.notBoundLength());\n        return builder.getSummaryTree();\n    }\n    /**\n     * Generates data used for garbage collection. It does the following:\n     * 1. Calls into each child data store context to get its GC data.\n     * 2. Prefixs the child context's id to the GC nodes in the child's GC data. This makes sure that the node can be\n     *    idenfied as belonging to the child.\n     * 3. Adds a GC node for this channel to the nodes received from the children. All these nodes together represent\n     *    the GC data of this channel.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCData(fullGC = false) {\n        const builder = new GCDataBuilder();\n        // Iterate over each store and get their GC data.\n        await Promise.all(Array.from(this.contexts)\n            .filter(([_, context]) => {\n            // Get GC data only for attached contexts. Detached contexts are not connected in the GC reference\n            // graph so any references they might have won't be connected as well.\n            return context.attachState === AttachState.Attached;\n        }).map(async ([contextId, context]) => {\n            const contextGCData = await context.getGCData(fullGC);\n            // Prefix the child's id to the ids of its GC nodes so they can be identified as belonging to the child.\n            // This also gradually builds the id of each node to be a path from the root.\n            builder.prefixAndAddNodes(contextId, contextGCData.gcNodes);\n        }));\n        // Get the outbound routes and add a GC node for this channel.\n        builder.addNode(\"/\", await this.getOutboundRoutes());\n        return builder.getGCData();\n    }\n    /**\n     * After GC has run, called to notify this Container's data stores of routes that are used in it.\n     * @param usedRoutes - The routes that are used in all data stores in this Container.\n     */\n    updateUsedRoutes(usedRoutes) {\n        var _a;\n        // Get a map of data store ids to routes used in it.\n        const usedDataStoreRoutes = getChildNodesUsedRoutes(usedRoutes);\n        // Verify that the used routes are correct.\n        for (const [id] of usedDataStoreRoutes) {\n            assert(this.contexts.has(id), 0x167 /* \"Used route does not belong to any known data store\" */);\n        }\n        // Update the used routes in each data store. Used routes is empty for unused data stores.\n        for (const [contextId, context] of this.contexts) {\n            context.updateUsedRoutes((_a = usedDataStoreRoutes.get(contextId)) !== null && _a !== void 0 ? _a : []);\n        }\n    }\n    /**\n     * Returns the outbound routes of this channel. Only root data stores are considered referenced and their paths are\n     * part of outbound routes.\n     */\n    async getOutboundRoutes() {\n        const outboundRoutes = [];\n        for (const [contextId, context] of this.contexts) {\n            const isRootDataStore = await context.isRoot();\n            if (isRootDataStore) {\n                outboundRoutes.push(`/${contextId}`);\n            }\n        }\n        return outboundRoutes;\n    }\n}\nexport function getSummaryForDatastores(snapshot, metadata) {\n    if (!snapshot) {\n        return undefined;\n    }\n    if (rootHasIsolatedChannels(metadata)) {\n        const datastoresSnapshot = snapshot.trees[channelsTreeName];\n        assert(!!datastoresSnapshot, 0x168 /* `expected ${channelsTreeName} tree in snapshot` */);\n        return datastoresSnapshot;\n    }\n    else {\n        // back-compat: strip out all non-datastore paths before giving to DataStores object.\n        const datastoresTrees = {};\n        for (const [key, value] of Object.entries(snapshot.trees)) {\n            if (!nonDataStorePaths.includes(key)) {\n                datastoresTrees[key] = value;\n            }\n        }\n        return Object.assign(Object.assign({}, snapshot), { trees: datastoresTrees });\n    }\n}\n//# sourceMappingURL=dataStores.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport registerDebug from \"debug\";\nimport { pkgName, pkgVersion } from \"./packageVersion\";\nexport const debug = registerDebug(\"fluid:process-loader\");\ndebug(`Package: ${pkgName} - Version: ${pkgVersion}`);\n//# sourceMappingURL=debug.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { performance } from \"@fluidframework/common-utils\";\n/**\n * DeltaScheduler is responsible for the scheduling of inbound delta queue in cases where there\n * is more than one op a particular run of the queue. It does not schedule if there is just one\n * op or just one batch in the run. It does the following two things:\n * 1. If the ops have been processed for more than a specific amount of time, it pauses the queue\n *    and calls setTimeout to schedule a resume of the queue. This ensures that we don't block\n *    the JS thread for a long time processing ops synchronously (for example, when catching up\n *    ops right after boot or catching up ops / delayed realizing data stores by summarizer).\n * 2. If we scheduled a particular run of the queue, it logs telemetry for the number of ops\n *    processed, the time and number of turns it took to process the ops.\n */\nexport class DeltaScheduler {\n    constructor(deltaManager, logger) {\n        this.logger = logger;\n        // The increase in time for processing ops after each turn.\n        this.processingTimeIncrement = 10;\n        this.totalProcessingTime = DeltaScheduler.processingTime;\n        // This keeps track of whether the delta scheduler is scheduling a particular run of the\n        // the inbound delta queue. Basically, every time the delta queue starts processing with\n        // more than one op, this will be set to true until the run completes.\n        this.isScheduling = false;\n        // This keeps track of the number of times inbound queue has been scheduled. After a particular\n        // count, we log telemetry for the number of ops processed, the time and number of turns it took\n        // to process the ops.\n        this.schedulingCount = 0;\n        this.deltaManager = deltaManager;\n        this.deltaManager.inbound.on(\"idle\", () => { this.inboundQueueIdle(); });\n    }\n    batchBegin() {\n        if (!this.processingStartTime) {\n            this.processingStartTime = performance.now();\n        }\n    }\n    batchEnd() {\n        if (this.shouldRunScheduler()) {\n            if (!this.isScheduling) {\n                this.isScheduling = true;\n                // Every 2000th time we are scheduling the inbound queue, we log telemetry for the\n                // number of ops processed, the time and number of turns it took to process the ops.\n                if (this.schedulingCount % 2000 === 0) {\n                    this.schedulingLog = {\n                        numberOfOps: this.deltaManager.inbound.length,\n                        numberOfTurns: 1,\n                        totalProcessingTime: 0,\n                    };\n                }\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const elapsedTime = performance.now() - this.processingStartTime;\n            if (elapsedTime > this.totalProcessingTime) {\n                // We have processed ops for more than the total processing time. So, pause the\n                // queue, yield the thread and schedule a resume.\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                this.deltaManager.inbound.pause();\n                setTimeout(() => {\n                    this.deltaManager.inbound.resume();\n                });\n                this.processingStartTime = undefined;\n                // Increase the total processing time. Keep doing this after each turn until all the ops have\n                // been processed. This way we keep the responsiveness at the beginning while also making sure\n                // that all the ops process fairly quickly.\n                this.totalProcessingTime += this.processingTimeIncrement;\n                // If we are logging the telemetry this time, update the telemetry log object.\n                if (this.schedulingLog) {\n                    this.schedulingLog.numberOfTurns++;\n                    this.schedulingLog.totalProcessingTime += elapsedTime;\n                }\n            }\n        }\n    }\n    inboundQueueIdle() {\n        if (this.schedulingLog) {\n            // Add the time taken for processing the final ops to the total processing time in the\n            // telemetry log object.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.schedulingLog.totalProcessingTime += performance.now() - this.processingStartTime;\n            this.logger.sendTelemetryEvent({\n                eventName: \"InboundOpsProcessingTime\",\n                numberOfOps: this.schedulingLog.numberOfOps,\n                numberOfTurns: this.schedulingLog.numberOfTurns,\n                processingTime: this.schedulingLog.totalProcessingTime,\n            });\n            this.schedulingLog = undefined;\n        }\n        // If we scheduled this batch of the inbound queue, increment the counter that tracks the\n        // number of times we have done this.\n        if (this.isScheduling) {\n            this.isScheduling = false;\n            this.schedulingCount++;\n        }\n        // Reset the processing times.\n        this.processingStartTime = undefined;\n        this.totalProcessingTime = DeltaScheduler.processingTime;\n    }\n    /**\n     * This function tells whether we should run the scheduler.\n     */\n    shouldRunScheduler() {\n        // If there are still ops in the queue after the one we are processing now, we should\n        // run the scheduler.\n        return this.deltaManager.inbound.length > 0;\n    }\n}\n// The time for processing ops in a single turn.\nDeltaScheduler.processingTime = 20;\n//# sourceMappingURL=deltaScheduler.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n *\n * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n */\nexport const pkgName = \"@fluidframework/container-runtime\";\nexport const pkgVersion = \"0.37.4\";\n//# sourceMappingURL=packageVersion.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { DataCorruptionError } from \"@fluidframework/container-utils\";\nimport { FlushMode } from \"@fluidframework/runtime-definitions\";\nimport Deque from \"double-ended-queue\";\nimport { ContainerMessageType } from \"./containerRuntime\";\n/**\n * PendingStateManager is responsible for maintaining the messages that have not been sent or have not yet been\n * acknowledged by the server. It also maintains the batch information for both automatically and manually flushed\n * batches along with the messages.\n * When the Container reconnects, it replays the pending states, which includes setting the FlushMode, manual flushing\n * of messages and triggering resubmission of unacked ops.\n *\n * It verifies that all the ops are acked, are received in the right order and batch information is correct.\n */\nexport class PendingStateManager {\n    constructor(containerRuntime, applyStashedOp, initialState) {\n        var _a;\n        this.containerRuntime = containerRuntime;\n        this.applyStashedOp = applyStashedOp;\n        this.pendingStates = new Deque();\n        // Maintains the count of messages that are currently unacked.\n        this.pendingMessagesCount = 0;\n        // Indicates whether we are processing a batch.\n        this.isProcessingBatch = false;\n        this.initialStates = new Deque((_a = initialState === null || initialState === void 0 ? void 0 : initialState.pendingStates) !== null && _a !== void 0 ? _a : []);\n        this.initialClientId = initialState === null || initialState === void 0 ? void 0 : initialState.clientId;\n        // get client sequence number of first actual message\n        this.initialClientSeqNum = -1;\n        for (let i = 0; i < this.initialStates.length; ++i) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const state = this.initialStates.get(i);\n            if (state.type === \"message\") {\n                this.initialClientSeqNum = state.clientSequenceNumber;\n                break;\n            }\n        }\n    }\n    get connected() {\n        return this.containerRuntime.connected;\n    }\n    /**\n     * Called to check if there are any pending messages in the pending state queue.\n     * @returns A boolean indicating whether there are messages or not.\n     */\n    hasPendingMessages() {\n        return this.pendingMessagesCount !== 0;\n    }\n    getLocalState() {\n        if (this.hasPendingMessages()) {\n            return {\n                clientId: this.clientId,\n                pendingStates: this.pendingStates.toArray().map(\n                // delete localOpMetadata since it may not be serializable\n                // and will be regenerated by applyStashedOp()\n                (state) => state.type === \"message\" ? Object.assign(Object.assign({}, state), { localOpMetadata: undefined }) : state),\n            };\n        }\n    }\n    /**\n     * Called when a message is submitted locally. Adds the message and the associated details to the pending state\n     * queue.\n     * @param type - The container message type.\n     * @param clientSequenceNumber - The clientSequenceNumber associated with the message.\n     * @param content - The message content.\n     * @param localOpMetadata - The local metadata associated with the message.\n     */\n    onSubmitMessage(type, clientSequenceNumber, referenceSequenceNumber, content, localOpMetadata, opMetadata) {\n        const pendingMessage = {\n            type: \"message\",\n            messageType: type,\n            clientSequenceNumber,\n            referenceSequenceNumber,\n            content,\n            localOpMetadata,\n            opMetadata,\n        };\n        this.pendingStates.push(pendingMessage);\n        this.pendingMessagesCount++;\n    }\n    /**\n     * Called when the FlushMode is updated. Adds the FlushMode to the pending state queue.\n     * @param flushMode - The flushMode that was updated.\n     */\n    onFlushModeUpdated(flushMode) {\n        if (flushMode === FlushMode.Automatic) {\n            const previousState = this.pendingStates.peekBack();\n            // We don't have to track a previous \"flush\" state because FlushMode.Automatic flushes the messages. So,\n            // just tracking this FlushMode.Automatic is enough.\n            if ((previousState === null || previousState === void 0 ? void 0 : previousState.type) === \"flush\") {\n                this.pendingStates.removeBack();\n            }\n            // If no messages were sent between FlushMode.Manual and FlushMode.Automatic, then we do not have to track\n            // both these states. Remove FlushMode.Manual from the pending queue and return.\n            if ((previousState === null || previousState === void 0 ? void 0 : previousState.type) === \"flushMode\" && previousState.flushMode === FlushMode.Manual) {\n                this.pendingStates.removeBack();\n                return;\n            }\n        }\n        const pendingFlushMode = {\n            type: \"flushMode\",\n            flushMode,\n        };\n        this.pendingStates.push(pendingFlushMode);\n    }\n    /**\n     * Called when flush() is called on the ContainerRuntime to manually flush messages.\n     */\n    onFlush() {\n        // If the FlushMode is Automatic, we should not track this flush call as it is only applicable when FlushMode\n        // is Manual.\n        if (this.containerRuntime.flushMode === FlushMode.Automatic) {\n            return;\n        }\n        // If the previous state is not a message, we don't have to track this flush call as there is nothing to flush.\n        const previousState = this.pendingStates.peekBack();\n        if ((previousState === null || previousState === void 0 ? void 0 : previousState.type) !== \"message\") {\n            return;\n        }\n        // Note that because of the checks above and the checks in onFlushModeUpdated(), we can be sure that a \"flush\"\n        // state always has a \"message\" before and after it. So, it marks the end of a batch and the beginning of a\n        // new one.\n        const pendingFlush = {\n            type: \"flush\",\n        };\n        this.pendingStates.push(pendingFlush);\n    }\n    /**\n     * Applies stashed ops at their reference sequence number so they are ready to be ACKed or resubmitted\n     */\n    async applyStashedOpsAt(seqNum) {\n        // apply stashed ops at sequence number\n        while (!this.initialStates.isEmpty()) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const nextState = this.initialStates.peekFront();\n            if (nextState.type === \"message\") {\n                if (nextState.referenceSequenceNumber > seqNum) {\n                    break; // nothing left to do at this sequence number\n                }\n                else if (nextState.referenceSequenceNumber > 0 && nextState.referenceSequenceNumber < seqNum) {\n                    throw new Error(\"loaded from snapshot too recent to apply stashed ops\");\n                }\n                // applyStashedOp will cause the DDS to behave as if it has sent the op but not actually send it\n                const localOpMetadata = await this.applyStashedOp(nextState.messageType, nextState.content);\n                nextState.localOpMetadata = localOpMetadata;\n            }\n            // then we push onto pendingStates which will cause PendingStateManager to resubmit when we connect\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.pendingStates.push(this.initialStates.shift());\n        }\n    }\n    /**\n     * Processes a local message once it's ack'd by the server to verify that there was no data corruption and that\n     * the batch information was preserved for batch messages. Also process remote messages that might have been\n     * sent from a previous container.\n     * @param message - The messsage that got ack'd and needs to be processed.\n     */\n    processMessage(message, local) {\n        // Do not process chunked ops until all pieces are available.\n        if (message.type === ContainerMessageType.ChunkedOp) {\n            return { localAck: false, localOpMetadata: undefined };\n        }\n        if (local) {\n            return { localAck: false, localOpMetadata: this.processPendingLocalMessage(message) };\n        }\n        else {\n            return this.processRemoteMessage(message);\n        }\n    }\n    /**\n     * Listens for ACKs of stashed ops\n     */\n    processRemoteMessage(message) {\n        // if this is an ack for a stashed op, dequeue one message.\n        // we should have seen its ref seq num by now and the DDS should be ready for it to be ACKed\n        if (message.clientId === this.initialClientId && message.clientSequenceNumber >= this.initialClientSeqNum) {\n            while (!this.pendingStates.isEmpty()) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const nextState = this.pendingStates.shift();\n                // if it's not a message just drop it and keep looking\n                if (nextState.type === \"message\") {\n                    return { localAck: true, localOpMetadata: nextState.localOpMetadata };\n                }\n            }\n        }\n        return { localAck: false, localOpMetadata: undefined };\n    }\n    /**\n     * Processes a local message once its ack'd by the server. It verifies that there was no data corruption and that\n     * the batch information was preserved for batch messages.\n     * @param message - The messsage that got ack'd and needs to be processed.\n     */\n    processPendingLocalMessage(message) {\n        // Pre-processing part - This may be the start of a batch.\n        this.maybeProcessBatchBegin(message);\n        // Get the next state from the pending queue and verify that it is of type \"message\".\n        const pendingState = this.peekNextPendingState();\n        assert(pendingState.type === \"message\", 0x169 /* \"No pending message found for this remote message\" */);\n        this.pendingStates.shift();\n        // Processing part - Verify that there has been no data corruption.\n        // The clientSequenceNumber of the incoming message must match that of the pending message.\n        if (pendingState.clientSequenceNumber !== message.clientSequenceNumber) {\n            // Close the container because this indicates data corruption.\n            const error = new DataCorruptionError(\"Unexpected ack received\", {\n                clientId: message.clientId,\n                sequenceNumber: message.sequenceNumber,\n                clientSequenceNumber: message.clientSequenceNumber,\n                expectedClientSequenceNumber: pendingState.clientSequenceNumber,\n            });\n            this.containerRuntime.closeFn(error);\n            return;\n        }\n        this.pendingMessagesCount--;\n        // Post-processing part - If we are processing a batch then this could be the last message in the batch.\n        if (this.isProcessingBatch) {\n            this.maybeProcessBatchEnd(message);\n        }\n        return pendingState.localOpMetadata;\n    }\n    /**\n     * This message could be the first message in batch. If so, set batch state marking the beginning of a batch.\n     * @param message - The message that is being processed.\n     */\n    maybeProcessBatchBegin(message) {\n        const pendingState = this.peekNextPendingState();\n        if (pendingState.type !== \"flush\" && pendingState.type !== \"flushMode\") {\n            return;\n        }\n        // If the pending state is of type \"flushMode\", it must be Manual since Automatic flush mode is processed\n        // after a message is processed and not before.\n        if (pendingState.type === \"flushMode\") {\n            assert(pendingState.flushMode === FlushMode.Manual, 0x16a /* \"Flush mode should be manual when processing batch begin\" */);\n        }\n        // We should not already be processing a batch and there should be no pending batch begin message.\n        assert(!this.isProcessingBatch && this.pendingBatchBeginMessage === undefined, 0x16b /* \"The pending batch state indicates we are already processing a batch\" */);\n        // Set the pending batch state indicating we have started processing a batch.\n        this.pendingBatchBeginMessage = message;\n        this.isProcessingBatch = true;\n        // Remove this pending state from the queue as we have processed it.\n        this.pendingStates.shift();\n    }\n    maybeProcessBatchEnd(message) {\n        var _a, _b;\n        const nextPendingState = this.peekNextPendingState();\n        if (nextPendingState.type !== \"flush\" && nextPendingState.type !== \"flushMode\") {\n            return;\n        }\n        // If the next pending state is of type \"flushMode\", it must be Automatic and if so, we need to remove it from\n        // the queue.\n        // Note that we do not remove the type \"flush\" from the queue because it indicates the end of one batch and the\n        // beginning of a new one. So, it will removed when the next batch begin is processed.\n        if (nextPendingState.type === \"flushMode\") {\n            assert(nextPendingState.flushMode === FlushMode.Automatic, 0x16c /* \"Flush mode is set to Manual in the middle of processing a batch\" */);\n            this.pendingStates.shift();\n        }\n        // There should be a pending batch begin message.\n        assert(this.pendingBatchBeginMessage !== undefined, 0x16d /* \"There is no pending batch begin message\" */);\n        // Get the batch begin metadata from the first message in the batch.\n        const batchBeginMetadata = (_a = this.pendingBatchBeginMessage.metadata) === null || _a === void 0 ? void 0 : _a.batch;\n        // There could be just a single message in the batch. If so, it should not have any batch metadata. If there\n        // are multiple messages in the batch, verify that we got the correct batch begin and end metadata.\n        if (this.pendingBatchBeginMessage === message) {\n            assert(batchBeginMetadata === undefined, 0x16e /* \"Batch with single message should not have batch metadata\" */);\n        }\n        else {\n            // Get the batch metadata from the last message in the batch.\n            const batchEndMetadata = (_b = message.metadata) === null || _b === void 0 ? void 0 : _b.batch;\n            assert(batchBeginMetadata === true, 0x16f /* \"Did not receive batch begin metadata\" */);\n            assert(batchEndMetadata === false, 0x170 /* \"Did not receive batch end metadata\" */);\n        }\n        // Clear the pending batch state now that we have processed the entire batch.\n        this.pendingBatchBeginMessage = undefined;\n        this.isProcessingBatch = false;\n    }\n    /**\n     * Returns the next pending state from the pending state queue.\n     */\n    peekNextPendingState() {\n        const nextPendingState = this.pendingStates.peekFront();\n        assert(!!nextPendingState, 0x171 /* \"No pending state found for the remote message\" */);\n        return nextPendingState;\n    }\n    /**\n     * Called when the Container's connection state changes. If the Container gets connected, it replays all the pending\n     * states in its queue. This includes setting the FlushMode and triggering resubmission of unacked ops.\n     */\n    replayPendingStates() {\n        assert(this.connected, 0x172 /* \"The connection state is not consistent with the runtime\" */);\n        // This assert suggests we are about to send same ops twice, which will result in data loss.\n        assert(this.clientId !== this.containerRuntime.clientId, 0x173 /* \"replayPendingStates called twice for same clientId!\" */);\n        this.clientId = this.containerRuntime.clientId;\n        assert(this.initialStates.isEmpty(), 0x174 /* \"initial states should be empty before replaying pending\" */);\n        let pendingStatesCount = this.pendingStates.length;\n        if (pendingStatesCount === 0) {\n            return;\n        }\n        // Reset the pending message count because all these messages will be removed from the queue.\n        this.pendingMessagesCount = 0;\n        // Save the current FlushMode so that we can revert it back after replaying the states.\n        const savedFlushMode = this.containerRuntime.flushMode;\n        // Process exactly `pendingStatesCount` items in the queue as it represents the number of states that were\n        // pending when we connected. This is important because the `reSubmitFn` might add more items in the queue\n        // which must not be replayed.\n        while (pendingStatesCount > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const pendingState = this.pendingStates.shift();\n            switch (pendingState.type) {\n                case \"message\":\n                    {\n                        this.containerRuntime.reSubmitFn(pendingState.messageType, pendingState.content, pendingState.localOpMetadata, pendingState.opMetadata);\n                    }\n                    break;\n                case \"flushMode\":\n                    {\n                        this.containerRuntime.setFlushMode(pendingState.flushMode);\n                    }\n                    break;\n                case \"flush\":\n                    {\n                        this.containerRuntime.flush();\n                    }\n                    break;\n                default:\n                    break;\n            }\n            pendingStatesCount--;\n        }\n        // Revert the FlushMode.\n        this.containerRuntime.setFlushMode(savedFlushMode);\n    }\n}\n//# sourceMappingURL=pendingStateManager.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { Deferred } from \"@fluidframework/common-utils\";\n/**\n * Helper class to coordinate something that needs to run only while connected.\n * This provides promises that resolve as it starts or stops.  Stopping happens\n * when disconnected or if stop() is called.\n */\nexport class RunWhileConnectedCoordinator {\n    constructor(runtime) {\n        this.runtime = runtime;\n        this.everConnected = false;\n        this.stopDeferred = new Deferred();\n        // Try to determine if the runtime has ever been connected\n        if (this.runtime.connected) {\n            this.everConnected = true;\n        }\n        else {\n            this.runtime.once(\"connected\", () => this.everConnected = true);\n        }\n        this.runtime.on(\"disconnected\", () => {\n            // Sometimes the initial connection state is raised as disconnected\n            if (!this.everConnected) {\n                return;\n            }\n            this.stop();\n        });\n    }\n    /**\n     * Starts and waits for a promise which resolves when connected.\n     * The promise will also resolve if stopped either externally or by disconnect.\n     * The return value indicates whether the start is successful or not.\n     */\n    async waitStart() {\n        if (!this.runtime.connected) {\n            if (this.everConnected) {\n                // We will not try to reconnect, so we are done running\n                return { started: false, message: \"DisconnectedBeforeRun\" };\n            }\n            const waitConnected = new Promise((resolve) => this.runtime.once(\"connected\", resolve));\n            await Promise.race([waitConnected, this.stopDeferred.promise]);\n            if (!this.runtime.connected) {\n                // If still not connected, no need to start running\n                return { started: false, message: \"NeverConnectedBeforeRun\" };\n            }\n        }\n        if (this.runtime.clientId === undefined) {\n            throw Error(\"clientId should be defined if connected.\");\n        }\n        return { started: true, clientId: this.runtime.clientId };\n    }\n    /**\n     * Returns a promise that resolves once stopped either externally or by disconnect.\n     */\n    async waitStopped() {\n        return this.stopDeferred.promise;\n    }\n    /**\n     * Stops running.\n     */\n    stop() {\n        this.stopDeferred.resolve();\n    }\n}\n//# sourceMappingURL=runWhileConnectedCoordinator.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { EventEmitter } from \"events\";\nimport { Deferred, PromiseTimer, Timer, } from \"@fluidframework/common-utils\";\nimport { ChildLogger, LoggingError, PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nimport { CreateContainerError } from \"@fluidframework/container-utils\";\nimport { MessageType, } from \"@fluidframework/protocol-definitions\";\nimport { create404Response } from \"@fluidframework/runtime-utils\";\nimport { RunWhileConnectedCoordinator } from \"./runWhileConnectedCoordinator\";\nimport { SummaryCollection } from \"./summaryCollection\";\nimport { SummarizerHandle } from \"./summarizerHandle\";\n// Send some telemetry if generate summary takes too long\nconst maxSummarizeTimeoutTime = 20000; // 20 sec\nconst maxSummarizeTimeoutCount = 5; // Double and resend 5 times\nconst maxSummarizeAckWaitTime = 120000; // 2 minutes\nconst minOpsForLastSummary = 50;\nexport const ISummarizer = \"ISummarizer\";\nconst summarizingError = \"summarizingError\";\nexport class SummarizingWarning extends LoggingError {\n    constructor(errorMessage, logged = false) {\n        super(errorMessage);\n        this.logged = logged;\n        this.errorType = summarizingError;\n        this.canRetry = true;\n    }\n}\nexport const createSummarizingWarning = (details, logged) => new SummarizingWarning(details, logged);\nconst checkNotTimeout = (something) => {\n    if (something === undefined) {\n        return false;\n    }\n    return something.timerResult === undefined;\n};\n/**\n * This class contains the heuristics for when to summarize.\n */\nclass SummarizerHeuristics {\n    constructor(configuration, trySummarize, \n    /**\n     * Last received op sequence number\n     */\n    lastOpSeqNumber, firstAck) {\n        this.configuration = configuration;\n        this.trySummarize = trySummarize;\n        this.lastOpSeqNumber = lastOpSeqNumber;\n        this._lastAttempted = firstAck;\n        this._lastAcked = firstAck;\n        this.idleTimer = new Timer(this.configuration.idleTime, () => this.trySummarize(\"idle\"));\n    }\n    /**\n     * Last sent summary attempt\n     */\n    get lastAttempted() {\n        return this._lastAttempted;\n    }\n    /**\n     * Last acked summary attempt\n     */\n    get lastAcked() {\n        return this._lastAcked;\n    }\n    /**\n     * Sets the last attempted summary and last acked summary.\n     * @param lastSummary - last acked summary\n     */\n    initialize(lastSummary) {\n        this._lastAttempted = lastSummary;\n        this._lastAcked = lastSummary;\n    }\n    /**\n     * Records a summary attempt. If the attempt was successfully sent,\n     * provide the reference sequence number, otherwise it will be set\n     * to the last seen op sequence number.\n     * @param refSequenceNumber - reference sequence number of sent summary\n     */\n    recordAttempt(refSequenceNumber) {\n        this._lastAttempted = {\n            refSequenceNumber: refSequenceNumber !== null && refSequenceNumber !== void 0 ? refSequenceNumber : this.lastOpSeqNumber,\n            summaryTime: Date.now(),\n        };\n    }\n    /**\n     * Mark the last sent summary attempt as acked.\n     */\n    ackLastSent() {\n        this._lastAcked = this.lastAttempted;\n    }\n    /**\n     * Runs the heuristic to determine if it should try to summarize.\n     */\n    run() {\n        this.idleTimer.clear();\n        const timeSinceLastSummary = Date.now() - this.lastAcked.summaryTime;\n        const opCountSinceLastSummary = this.lastOpSeqNumber - this.lastAcked.refSequenceNumber;\n        if (timeSinceLastSummary > this.configuration.maxTime) {\n            this.trySummarize(\"maxTime\");\n        }\n        else if (opCountSinceLastSummary > this.configuration.maxOps) {\n            this.trySummarize(\"maxOps\");\n        }\n        else {\n            this.idleTimer.restart();\n        }\n    }\n    /**\n     * Disposes of resources.\n     */\n    dispose() {\n        this.idleTimer.clear();\n    }\n}\n/**\n * An instance of RunningSummarizer manages the heuristics for summarizing.\n * Until disposed, the instance of RunningSummarizer can assume that it is\n * in a state of running, meaning it is connected and initialized.  It keeps\n * track of summaries that it is generating as they are broadcast and acked/nacked.\n */\nexport class RunningSummarizer {\n    constructor(clientId, onBehalfOfClientId, baseLogger, summaryWatcher, configuration, internalsProvider, lastOpSeqNumber, firstAck, immediateSummary = false, raiseSummarizingError, summaryCollection) {\n        var _a;\n        this.clientId = clientId;\n        this.onBehalfOfClientId = onBehalfOfClientId;\n        this.summaryWatcher = summaryWatcher;\n        this.configuration = configuration;\n        this.internalsProvider = internalsProvider;\n        this.immediateSummary = immediateSummary;\n        this.raiseSummarizingError = raiseSummarizingError;\n        this.stopping = false;\n        this._disposed = false;\n        this.summarizeCount = 0;\n        this.tryWhileSummarizing = false;\n        /**\n         * RunningSummarizer's logger includes the sequenced index of the current summary on each event.\n         * If some other Summarizer code wants that event on their logs they can get it here,\n         * but only if they're logging about that same summary.\n         * @param summaryOpRefSeq - RefSeq number of the summary op, to ensure the log correlation will be correct\n         */\n        this.tryGetCorrelatedLogger = (summaryOpRefSeq) => this.heuristics.lastAttempted.refSequenceNumber === summaryOpRefSeq\n            ? this.logger\n            : undefined;\n        this.logger = ChildLogger.create(baseLogger, \"Running\", { all: { summaryGenTag: () => this.summarizeCount } });\n        this.heuristics = new SummarizerHeuristics(configuration, (reason) => this.trySummarize(reason), lastOpSeqNumber, firstAck);\n        this.summarizeTimer = new Timer(maxSummarizeTimeoutTime, () => this.summarizeTimerHandler(maxSummarizeTimeoutTime, 1));\n        // Cap the maximum amount of time client will wait for a summarize op ack to maxSummarizeAckWaitTime\n        const maxAckWaitTime = Math.min(this.configuration.maxAckWaitTime, maxSummarizeAckWaitTime);\n        this.pendingAckTimer = new PromiseTimer(maxAckWaitTime, () => {\n            this.raiseSummarizingError(\"SummaryAckWaitTimeout\");\n            // Note: summaryGenTag (from ChildLogger definition) may be 0,\n            // since this code path is hit when RunningSummarizer first starts up,\n            // before this instance has kicked off a new summarize run.\n            this.logger.sendErrorEvent({\n                eventName: \"SummaryAckWaitTimeout\",\n                maxAckWaitTime,\n                refSequenceNumber: this.heuristics.lastAttempted.refSequenceNumber,\n                summarySequenceNumber: this.heuristics.lastAttempted.summarySequenceNumber,\n                timePending: Date.now() - this.heuristics.lastAttempted.summaryTime,\n            });\n        });\n        // back-compat 0.34 noSetPendingAckTimerTimeoutCallback\n        (_a = summaryCollection.setPendingAckTimerTimeoutCallback) === null || _a === void 0 ? void 0 : _a.call(summaryCollection, maxAckWaitTime, () => {\n            if (this.pendingAckTimer.hasTimer) {\n                this.logger.sendTelemetryEvent({\n                    eventName: \"MissingSummaryAckFoundByOps\",\n                    refSequenceNumber: this.heuristics.lastAttempted.refSequenceNumber,\n                    summarySequenceNumber: this.heuristics.lastAttempted.summarySequenceNumber,\n                });\n                this.pendingAckTimer.clear();\n            }\n        });\n    }\n    static async start(clientId, onBehalfOfClientId, logger, summaryWatcher, configuration, internalsProvider, lastOpSeqNumber, firstAck, immediateSummary, raiseSummarizingError, summaryCollection) {\n        const summarizer = new RunningSummarizer(clientId, onBehalfOfClientId, logger, summaryWatcher, configuration, internalsProvider, lastOpSeqNumber, firstAck, immediateSummary, raiseSummarizingError, summaryCollection);\n        await summarizer.waitStart();\n        // Run the heuristics after starting\n        if (immediateSummary) {\n            summarizer.trySummarize(\"immediate\");\n        }\n        else {\n            summarizer.heuristics.run();\n        }\n        return summarizer;\n    }\n    get disposed() { return this._disposed; }\n    dispose() {\n        this.summaryWatcher.dispose();\n        this.heuristics.dispose();\n        this.summarizeTimer.clear();\n        this.pendingAckTimer.clear();\n        this._disposed = true;\n    }\n    handleSystemOp(op) {\n        switch (op.type) {\n            case MessageType.ClientLeave: {\n                const leavingClientId = JSON.parse(op.data);\n                if (leavingClientId === this.clientId || leavingClientId === this.onBehalfOfClientId) {\n                    // Ignore summarizer leave messages, to make sure not to start generating\n                    // a summary as the summarizer is leaving\n                    return;\n                }\n                // Leave ops for any other client fall through to handle normally\n            }\n            // Intentional fallthrough\n            case MessageType.ClientJoin:\n            case MessageType.Propose:\n            case MessageType.Reject: {\n                // Synchronously handle quorum ops like regular ops\n                this.handleOp(undefined, op);\n                return;\n            }\n            default: {\n                return;\n            }\n        }\n    }\n    handleOp(error, op) {\n        if (error !== undefined) {\n            return;\n        }\n        this.heuristics.lastOpSeqNumber = op.sequenceNumber;\n        // Check for ops requesting summary\n        if (op.type === MessageType.Save) {\n            this.trySummarize(`;${op.clientId}: ${op.contents}`);\n        }\n        else {\n            this.heuristics.run();\n        }\n    }\n    async waitStop() {\n        var _a, _b;\n        if (this.disposed) {\n            return;\n        }\n        if (this.stopping) {\n            await ((_a = this.summarizing) === null || _a === void 0 ? void 0 : _a.promise);\n            return;\n        }\n        this.stopping = true;\n        const outstandingOps = this.heuristics.lastOpSeqNumber - this.heuristics.lastAcked.refSequenceNumber;\n        if (outstandingOps > minOpsForLastSummary) {\n            this.trySummarize(\"lastSummary\");\n            // This resolves when the current pending summary is acked or fails.\n            // We wait for the result in case a safe summary is needed, and to get\n            // better telemetry.\n            await ((_b = this.summarizing) === null || _b === void 0 ? void 0 : _b.promise);\n        }\n    }\n    async waitStart() {\n        // Wait no longer than ack timeout for all pending\n        const maybeLastAck = await Promise.race([\n            this.summaryWatcher.waitFlushed(),\n            this.pendingAckTimer.start(),\n        ]);\n        this.pendingAckTimer.clear();\n        if (checkNotTimeout(maybeLastAck)) {\n            this.heuristics.initialize({\n                refSequenceNumber: maybeLastAck.summaryOp.referenceSequenceNumber,\n                summaryTime: maybeLastAck.summaryOp.timestamp,\n                summarySequenceNumber: maybeLastAck.summaryOp.sequenceNumber,\n            });\n        }\n    }\n    trySummarize(reason) {\n        if (this.summarizing !== undefined) {\n            // We can't summarize if we are already\n            this.tryWhileSummarizing = true;\n            return;\n        }\n        // GenerateSummary could take some time\n        // mark that we are currently summarizing to prevent concurrent summarizing\n        this.summarizing = new Deferred();\n        (async () => {\n            const result = await this.summarize(reason, false);\n            if (result !== true) {\n                // On nack or error, try again in safe mode\n                await this.summarize(reason, true);\n            }\n        })().finally(() => {\n            var _a;\n            (_a = this.summarizing) === null || _a === void 0 ? void 0 : _a.resolve();\n            this.summarizing = undefined;\n            if (this.tryWhileSummarizing && !this.stopping && !this.disposed) {\n                this.tryWhileSummarizing = false;\n                this.heuristics.run();\n            }\n        }).catch((error) => {\n            this.logger.sendErrorEvent({ eventName: \"UnexpectedSummarizeError\" }, error);\n        });\n    }\n    /**\n     * Generates summary and listens for broadcast and ack/nack.\n     * Returns true for ack, false for nack, and undefined for failure or timeout.\n     * @param reason - reason for summarizing\n     * @param safe - true to generate summary in safe mode\n     */\n    async summarize(reason, safe) {\n        this.summarizeTimer.start();\n        try {\n            return await this.summarizeCore(reason, safe);\n        }\n        finally {\n            this.summarizeTimer.clear();\n            this.pendingAckTimer.clear();\n        }\n    }\n    async summarizeCore(reason, safe) {\n        ++this.summarizeCount;\n        // Wait to generate and send summary\n        const summaryData = await this.generateSummaryWithLogging(reason, safe);\n        this.heuristics.recordAttempt(summaryData === null || summaryData === void 0 ? void 0 : summaryData.referenceSequenceNumber);\n        if (!summaryData || !summaryData.submitted) {\n            // Did not send the summary op\n            this.raiseSummarizingError(\"Error while generating or submitting summary\");\n            return undefined;\n        }\n        const pendingTimeoutP = this.pendingAckTimer.start().catch(() => undefined);\n        const summary = this.summaryWatcher.watchSummary(summaryData.clientSequenceNumber);\n        // Wait for broadcast\n        const summaryOp = await Promise.race([summary.waitBroadcast(), pendingTimeoutP]);\n        if (!checkNotTimeout(summaryOp)) {\n            return undefined;\n        }\n        this.heuristics.lastAttempted.summarySequenceNumber = summaryOp.sequenceNumber;\n        this.logger.sendTelemetryEvent({\n            eventName: \"SummaryOp\",\n            timeWaiting: Date.now() - this.heuristics.lastAttempted.summaryTime,\n            refSequenceNumber: summaryOp.referenceSequenceNumber,\n            summarySequenceNumber: summaryOp.sequenceNumber,\n            handle: summaryOp.contents.handle,\n        });\n        // Wait for ack/nack\n        const ackNack = await Promise.race([summary.waitAckNack(), pendingTimeoutP]);\n        if (!checkNotTimeout(ackNack)) {\n            return undefined;\n        }\n        this.logger.sendTelemetryEvent({\n            eventName: ackNack.type === MessageType.SummaryAck ? \"SummaryAck\" : \"SummaryNack\",\n            category: ackNack.type === MessageType.SummaryAck ? \"generic\" : \"error\",\n            timeWaiting: Date.now() - this.heuristics.lastAttempted.summaryTime,\n            summarySequenceNumber: ackNack.contents.summaryProposal.summarySequenceNumber,\n            error: ackNack.type === MessageType.SummaryNack ? ackNack.contents.errorMessage : undefined,\n            handle: ackNack.type === MessageType.SummaryAck ? ackNack.contents.handle : undefined,\n        });\n        this.pendingAckTimer.clear();\n        // Update for success\n        if (ackNack.type === MessageType.SummaryAck) {\n            this.heuristics.ackLastSent();\n            // since we need a full summary after context reload, we only clear this on ack\n            this.immediateSummary = false;\n            return true;\n        }\n        else {\n            this.raiseSummarizingError(\"SummaryNack\");\n            return false;\n        }\n    }\n    async generateSummaryWithLogging(message, safe) {\n        const summarizingEvent = PerformanceEvent.start(this.logger, {\n            eventName: \"GenerateSummary\",\n            message,\n            timeSinceLastAttempt: Date.now() - this.heuristics.lastAttempted.summaryTime,\n            timeSinceLastSummary: Date.now() - this.heuristics.lastAcked.summaryTime,\n            safe: safe || undefined,\n        });\n        // Wait for generate/send summary\n        let summaryData;\n        try {\n            summaryData = await this.internalsProvider.generateSummary({\n                fullTree: this.immediateSummary || safe,\n                refreshLatestAck: safe,\n                summaryLogger: this.logger,\n            });\n        }\n        catch (error) {\n            summarizingEvent.cancel({ category: \"error\" }, error);\n            return;\n        }\n        this.summarizeTimer.clear();\n        if (!summaryData) {\n            summarizingEvent.cancel();\n            return;\n        }\n        const telemetryProps = Object.assign(Object.assign(Object.assign({}, summaryData), summaryData.summaryStats), { refSequenceNumber: summaryData.referenceSequenceNumber, opsSinceLastAttempt: summaryData.referenceSequenceNumber - this.heuristics.lastAttempted.refSequenceNumber, opsSinceLastSummary: summaryData.referenceSequenceNumber - this.heuristics.lastAcked.refSequenceNumber });\n        telemetryProps.summaryStats = undefined;\n        telemetryProps.referenceSequenceNumber = undefined;\n        if (summaryData.submitted) {\n            summarizingEvent.end(telemetryProps);\n        }\n        else {\n            summarizingEvent.cancel(telemetryProps);\n        }\n        return summaryData;\n    }\n    summarizeTimerHandler(time, count) {\n        this.logger.sendPerformanceEvent({\n            eventName: \"SummarizeTimeout\",\n            timeoutTime: time,\n            timeoutCount: count,\n        });\n        if (count < maxSummarizeTimeoutCount) {\n            // Double and start a new timer\n            const nextTime = time * 2;\n            this.summarizeTimer.start(nextTime, () => this.summarizeTimerHandler(nextTime, count + 1));\n        }\n    }\n}\n/**\n * Summarizer is responsible for coordinating when to send generate and send summaries.\n * It is the main entry point for summary work.\n */\nexport class Summarizer extends EventEmitter {\n    constructor(url, runtime, configurationGetter, internalsProvider, handleContext, summaryCollection) {\n        var _a;\n        super();\n        this.runtime = runtime;\n        this.configurationGetter = configurationGetter;\n        this.internalsProvider = internalsProvider;\n        this.immediateSummary = false;\n        this.stopped = false;\n        this.stopDeferred = new Deferred();\n        this._disposed = false;\n        this.logger = ChildLogger.create(this.runtime.logger, \"Summarizer\");\n        this.runCoordinator = new RunWhileConnectedCoordinator(runtime);\n        if (summaryCollection) {\n            // summarize immediately because we just went through context reload\n            this.immediateSummary = true;\n            this.summaryCollection = summaryCollection;\n        }\n        else {\n            this.summaryCollection = new SummaryCollection(this.runtime.deltaManager.initialSequenceNumber, this.logger);\n        }\n        this.runtime.deltaManager.inbound.on(\"op\", (op) => this.summaryCollection.handleOp(op));\n        (_a = this.runtime.previousState.nextSummarizerD) === null || _a === void 0 ? void 0 : _a.resolve(this);\n        this.innerHandle = new SummarizerHandle(this, url, handleContext);\n    }\n    get IFluidLoadable() { return this; }\n    get IFluidRouter() { return this; }\n    get IFluidRunnable() { return this; }\n    get ISummarizer() { return this; }\n    get handle() { return this.innerHandle; }\n    async run(onBehalfOf) {\n        try {\n            await this.runCore(onBehalfOf);\n        }\n        catch (error) {\n            const err2 = Object.assign(Object.assign({ logged: false }, CreateContainerError(error)), { errorType: summarizingError });\n            this.emit(\"summarizingError\", err2);\n            throw error;\n        }\n        finally {\n            // Cleanup after running\n            if (this.runtime.connected) {\n                if (this.runningSummarizer) {\n                    await this.runningSummarizer.waitStop();\n                }\n                this.runtime.closeFn();\n            }\n            this.dispose();\n        }\n    }\n    /**\n     * Stops the summarizer from running.  This will complete\n     * the run promise, and also close the container.\n     * @param reason - reason code for stopping\n     */\n    stop(reason) {\n        if (this.stopped) {\n            // already stopping\n            return;\n        }\n        this.stopped = true;\n        this.logger.sendTelemetryEvent({\n            eventName: \"StoppingSummarizer\",\n            onBehalfOf: this.onBehalfOfClientId,\n            reason,\n        });\n        this.stopDeferred.resolve();\n    }\n    updateOnBehalfOf(onBehalfOf) {\n        this.onBehalfOfClientId = onBehalfOf;\n    }\n    async request(request) {\n        if (request.url === \"/\" || request.url === \"\") {\n            return {\n                mimeType: \"fluid/object\",\n                status: 200,\n                value: this,\n            };\n        }\n        return create404Response(request);\n    }\n    async runCore(onBehalfOf) {\n        this.onBehalfOfClientId = onBehalfOf;\n        const startResult = await this.runCoordinator.waitStart();\n        if (startResult.started === false) {\n            this.logger.sendTelemetryEvent({\n                eventName: \"NotStarted\",\n                reason: startResult.message,\n                onBehalfOf,\n            });\n            return;\n        }\n        if (this.runtime.deltaManager.active === false) {\n            this.logger.sendTelemetryEvent({\n                eventName: \"NotStarted\",\n                reason: \"CannotWrite\",\n                onBehalfOf,\n            });\n            return;\n        }\n        if (this.runtime.summarizerClientId !== this.onBehalfOfClientId\n            && this.runtime.summarizerClientId !== this.runtime.clientId) {\n            // Verify that this client's computed summarizer matches the client this was spawned\n            // on behalf of.  If not, fallback on the following logic before stopping:\n            // If we are not oldest client in quorum, another client will take over as summarizer.\n            // We want to make sure we at least try to summarize in case server is rejecting ops,\n            // so if we are the oldest client, we will still go through and try to summarize at least once.\n            // We also don't want to end up with two summarizer clients running at the same time,\n            // so we bypass running altogether if this client isn't the oldest.\n            this.logger.sendTelemetryEvent({\n                eventName: \"NotStarted\",\n                reason: \"DifferentComputedSummarizer\",\n                computedSummarizer: this.runtime.summarizerClientId,\n                onBehalfOf,\n                clientId: this.runtime.clientId,\n            });\n            return;\n        }\n        // Initialize values and first ack (time is not exact)\n        this.logger.sendTelemetryEvent({\n            eventName: \"RunningSummarizer\",\n            onBehalfOf,\n            initSummarySeqNumber: this.summaryCollection.initialSequenceNumber,\n        });\n        const initialAttempt = {\n            refSequenceNumber: this.summaryCollection.initialSequenceNumber,\n            summaryTime: Date.now(),\n        };\n        const runningSummarizer = await RunningSummarizer.start(startResult.clientId, onBehalfOf, this.logger, this.summaryCollection.createWatcher(startResult.clientId), this.configurationGetter(), this /* Pick<ISummarizerInternalsProvider, \"generateSummary\"> */, this.runtime.deltaManager.lastSequenceNumber, initialAttempt, this.immediateSummary, (description) => {\n            if (!this._disposed) {\n                this.emit(\"summarizingError\", createSummarizingWarning(`Summarizer: ${description}`, true));\n            }\n        }, this.summaryCollection);\n        this.runningSummarizer = runningSummarizer;\n        this.immediateSummary = false;\n        // Handle summary acks\n        this.handleSummaryAcks().catch((error) => {\n            this.logger.sendErrorEvent({ eventName: \"HandleSummaryAckFatalError\" }, error);\n            // Raise error to parent container.\n            this.emit(\"summarizingError\", createSummarizingWarning(\"Summarizer: HandleSummaryAckFatalError\", true));\n            this.stop(\"HandleSummaryAckFatalError\");\n        });\n        // Listen for ops\n        this.systemOpListener = (op) => runningSummarizer.handleSystemOp(op);\n        this.runtime.deltaManager.inbound.on(\"op\", this.systemOpListener);\n        this.opListener = (error, op) => runningSummarizer.handleOp(error, op);\n        this.runtime.on(\"batchEnd\", this.opListener);\n        await Promise.race([\n            this.runCoordinator.waitStopped(),\n            this.stopDeferred.promise,\n        ]);\n    }\n    /**\n     * Disposes of resources after running.  This cleanup will\n     * clear any outstanding timers and reset some of the state\n     * properties.\n     */\n    dispose() {\n        this._disposed = true;\n        if (this.runningSummarizer) {\n            this.runningSummarizer.dispose();\n            this.runningSummarizer = undefined;\n        }\n        if (this.systemOpListener) {\n            this.runtime.deltaManager.inbound.off(\"op\", this.systemOpListener);\n        }\n        if (this.opListener) {\n            this.runtime.removeListener(\"batchEnd\", this.opListener);\n        }\n    }\n    async setSummarizer() {\n        this.runtime.nextSummarizerD = new Deferred();\n        return this.runtime.nextSummarizerD.promise;\n    }\n    /** Implementation of SummarizerInternalsProvider.generateSummary */\n    async generateSummary(options) {\n        if (this.onBehalfOfClientId !== this.runtime.summarizerClientId\n            && this.runtime.clientId !== this.runtime.summarizerClientId) {\n            // We are no longer the summarizer; a different client is, so we should stop ourself\n            this.stop(\"parentNoLongerSummarizer\");\n            return undefined;\n        }\n        return this.internalsProvider.generateSummary(options);\n    }\n    async handleSummaryAcks() {\n        var _a;\n        let refSequenceNumber = this.summaryCollection.initialSequenceNumber;\n        while (this.runningSummarizer) {\n            const summaryLogger = (_a = this.runningSummarizer.tryGetCorrelatedLogger(refSequenceNumber)) !== null && _a !== void 0 ? _a : this.logger;\n            try {\n                const ack = await this.summaryCollection.waitSummaryAck(refSequenceNumber);\n                refSequenceNumber = ack.summaryOp.referenceSequenceNumber;\n                await this.internalsProvider.refreshLatestSummaryAck(ack.summaryOp.contents.handle, ack.summaryAckNack.contents.handle, summaryLogger);\n            }\n            catch (error) {\n                summaryLogger.sendErrorEvent({ eventName: \"HandleSummaryAckError\", refSequenceNumber }, error);\n            }\n            refSequenceNumber++;\n        }\n    }\n}\n//# sourceMappingURL=summarizer.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { FluidObjectHandle } from \"@fluidframework/datastore\";\n// TODO #2425 Expose Summarizer handle as FluidObjectHandle w/ tests\nexport class SummarizerHandle extends FluidObjectHandle {\n    async get() {\n        throw Error(\"Do not try to get a summarizer object from the handle. Reference it directly.\");\n    }\n    attach() {\n        return;\n    }\n    bind(handle) {\n        return;\n    }\n}\n//# sourceMappingURL=summarizerHandle.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { Deferred, assert } from \"@fluidframework/common-utils\";\nimport { MessageType, } from \"@fluidframework/protocol-definitions\";\nvar SummaryState;\n(function (SummaryState) {\n    SummaryState[SummaryState[\"Local\"] = 0] = \"Local\";\n    SummaryState[SummaryState[\"Broadcast\"] = 1] = \"Broadcast\";\n    SummaryState[SummaryState[\"Acked\"] = 2] = \"Acked\";\n    SummaryState[SummaryState[\"Nacked\"] = -1] = \"Nacked\";\n})(SummaryState || (SummaryState = {}));\nclass Summary {\n    constructor(clientId, clientSequenceNumber) {\n        this.clientId = clientId;\n        this.clientSequenceNumber = clientSequenceNumber;\n        this.state = SummaryState.Local;\n        this.defSummaryOp = new Deferred();\n        this.defSummaryAck = new Deferred();\n    }\n    static createLocal(clientId, clientSequenceNumber) {\n        return new Summary(clientId, clientSequenceNumber);\n    }\n    static createFromOp(op) {\n        const summary = new Summary(op.clientId, op.clientSequenceNumber);\n        summary.broadcast(op);\n        return summary;\n    }\n    get summaryOp() { return this._summaryOp; }\n    get summaryAckNack() { return this._summaryAckNack; }\n    hasBeenAcked() {\n        return this.state === SummaryState.Acked;\n    }\n    broadcast(op) {\n        assert(this.state === SummaryState.Local, 0x175 /* \"Can only broadcast if summarizer starts in local state\" */);\n        this._summaryOp = op;\n        this.defSummaryOp.resolve();\n        this.state = SummaryState.Broadcast;\n        return true;\n    }\n    ackNack(op) {\n        assert(this.state === SummaryState.Broadcast, 0x176 /* \"Can only ack/nack if summarizer is in broadcasting state\" */);\n        this._summaryAckNack = op;\n        this.defSummaryAck.resolve();\n        this.state = op.type === MessageType.SummaryAck ? SummaryState.Acked : SummaryState.Nacked;\n        return true;\n    }\n    async waitBroadcast() {\n        await this.defSummaryOp.promise;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this._summaryOp;\n    }\n    async waitAckNack() {\n        await this.defSummaryAck.promise;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this._summaryAckNack;\n    }\n}\n/**\n * This class watches summaries created by a specific client.\n * It should be created and managed from a SummaryCollection.\n */\nclass ClientSummaryWatcher {\n    constructor(clientId, summaryCollection) {\n        this.clientId = clientId;\n        this.summaryCollection = summaryCollection;\n        // key: clientSeqNum\n        this.localSummaries = new Map();\n        this._disposed = false;\n    }\n    get disposed() { return this._disposed; }\n    /**\n     * Watches for a specific sent summary op.\n     * @param clientSequenceNumber - client sequence number of sent summary op\n     */\n    watchSummary(clientSequenceNumber) {\n        let summary = this.localSummaries.get(clientSequenceNumber);\n        if (!summary) {\n            summary = Summary.createLocal(this.clientId, clientSequenceNumber);\n            this.localSummaries.set(summary.clientSequenceNumber, summary);\n        }\n        return summary;\n    }\n    /**\n     * Waits until all of the pending summaries in the underlying SummaryCollection\n     * are acked/nacked.\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\n    waitFlushed() {\n        return this.summaryCollection.waitFlushed();\n    }\n    /**\n     * Gets a watched summary or returns undefined if not watched.\n     * @param clientSequenceNumber - client sequence number of sent summary op\n     */\n    tryGetSummary(clientSequenceNumber) {\n        return this.localSummaries.get(clientSequenceNumber);\n    }\n    /**\n     * Starts watching a summary made by this client.\n     * @param summary - summary to start watching\n     */\n    setSummary(summary) {\n        this.localSummaries.set(summary.clientSequenceNumber, summary);\n    }\n    dispose() {\n        this.summaryCollection.removeWatcher(this.clientId);\n        this._disposed = true;\n    }\n}\n/**\n * Data structure that looks at the op stream to track summaries as they\n * are broadcast, acked and nacked.\n * It provides functionality for watching specific summaries.\n */\nexport class SummaryCollection {\n    constructor(initialSequenceNumber, logger) {\n        this.initialSequenceNumber = initialSequenceNumber;\n        this.logger = logger;\n        // key: clientId\n        this.summaryWatchers = new Map();\n        // key: summarySeqNum\n        this.pendingSummaries = new Map();\n        this.refreshWaitNextAck = new Deferred();\n    }\n    get latestAck() { return this.lastAck; }\n    /**\n     * Creates and returns a summary watcher for a specific client.\n     * This will allow for local sent summaries to be better tracked.\n     * @param clientId - client id for watcher\n     */\n    createWatcher(clientId) {\n        const watcher = new ClientSummaryWatcher(clientId, this);\n        this.summaryWatchers.set(clientId, watcher);\n        return watcher;\n    }\n    removeWatcher(clientId) {\n        this.summaryWatchers.delete(clientId);\n    }\n    setPendingAckTimerTimeoutCallback(maxAckWaitTime, timeoutCallback) {\n        this.maxAckWaitTime = maxAckWaitTime;\n        this.pendingAckTimerTimeoutCallback = timeoutCallback;\n    }\n    /**\n     * Returns a promise that resolves once all pending summary ops\n     * have been acked or nacked.\n     */\n    async waitFlushed() {\n        while (this.pendingSummaries.size > 0) {\n            // eslint-disable-next-line @typescript-eslint/promise-function-async\n            const promises = Array.from(this.pendingSummaries, ([, summary]) => summary.waitAckNack());\n            await Promise.all(promises);\n        }\n        return this.lastAck;\n    }\n    /**\n     * Returns a promise that resolves once a summary is acked that has a reference\n     * sequence number greater than or equal to the passed in sequence number.\n     * @param referenceSequenceNumber - reference sequence number to wait for\n     * @returns The latest acked summary\n     */\n    async waitSummaryAck(referenceSequenceNumber) {\n        while (!this.lastAck || this.lastAck.summaryOp.referenceSequenceNumber < referenceSequenceNumber) {\n            await this.refreshWaitNextAck.promise;\n        }\n        return this.lastAck;\n    }\n    /**\n     * Handler for ops; only handles ops relating to summaries.\n     * @param op - op message to handle\n     */\n    handleOp(op) {\n        var _a;\n        switch (op.type) {\n            case MessageType.Summarize: {\n                this.handleSummaryOp(op);\n                return;\n            }\n            case MessageType.SummaryAck: {\n                this.handleSummaryAck(op);\n                return;\n            }\n            case MessageType.SummaryNack: {\n                this.handleSummaryNack(op);\n                return;\n            }\n            default: {\n                // If the difference between timestamp of current op and last summary op is greater than\n                // the maxAckWaitTime, then we need to inform summarizer to not wait and summarize\n                // immediately as we have already waited for maxAckWaitTime.\n                const lastOpTimestamp = op.timestamp;\n                if (this.lastSummaryTimestamp !== undefined &&\n                    this.maxAckWaitTime !== undefined &&\n                    lastOpTimestamp - this.lastSummaryTimestamp >= this.maxAckWaitTime) {\n                    (_a = this.pendingAckTimerTimeoutCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n                }\n                return;\n            }\n        }\n    }\n    handleSummaryOp(op) {\n        let summary;\n        // Check if summary already being watched, broadcast if so\n        const watcher = this.summaryWatchers.get(op.clientId);\n        if (watcher) {\n            summary = watcher.tryGetSummary(op.clientSequenceNumber);\n            if (summary) {\n                summary.broadcast(op);\n            }\n        }\n        // If not watched, create from op\n        if (!summary) {\n            summary = Summary.createFromOp(op);\n            if (watcher) {\n                watcher.setSummary(summary);\n            }\n        }\n        this.pendingSummaries.set(op.sequenceNumber, summary);\n        this.lastSummaryTimestamp = op.timestamp;\n    }\n    handleSummaryAck(op) {\n        const seq = op.contents.summaryProposal.summarySequenceNumber;\n        const summary = this.pendingSummaries.get(seq);\n        if (!summary) {\n            // Summary ack without an op should be rare. We could fetch the\n            // reference sequence number from the snapshot, but instead we\n            // will not emit this ack. It should be the case that the summary\n            // op that this ack is for is earlier than this file was loaded\n            // from. i.e. initialSequenceNumber > summarySequenceNumber.\n            // We really don't care about it for now, since it is older than\n            // the one we loaded from.\n            if (seq >= this.initialSequenceNumber) {\n                // Potential causes for it to be later than our initialSequenceNumber\n                // are that the summaryOp was nacked then acked, double-acked, or\n                // the summarySequenceNumber is incorrect.\n                this.logger.sendErrorEvent({\n                    eventName: \"SummaryAckWithoutOp\",\n                    sequenceNumber: op.sequenceNumber,\n                    summarySequenceNumber: seq,\n                    initialSequenceNumber: this.initialSequenceNumber,\n                });\n            }\n            return;\n        }\n        summary.ackNack(op);\n        this.pendingSummaries.delete(seq);\n        // Track latest ack\n        if (!this.lastAck || seq > this.lastAck.summaryAckNack.contents.summaryProposal.summarySequenceNumber) {\n            this.lastAck = summary;\n            this.refreshWaitNextAck.resolve();\n            this.refreshWaitNextAck = new Deferred();\n        }\n    }\n    handleSummaryNack(op) {\n        const seq = op.contents.summaryProposal.summarySequenceNumber;\n        const summary = this.pendingSummaries.get(seq);\n        if (summary) {\n            summary.ackNack(op);\n            this.pendingSummaries.delete(seq);\n        }\n    }\n}\n//# sourceMappingURL=summaryCollection.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { channelsTreeName } from \"@fluidframework/runtime-definitions\";\nexport function getAttributesFormatVersion(attributes) {\n    if (attributes.summaryFormatVersion) {\n        /**\n         * Version 2+: Introduces .channels trees for isolation of\n         * channel trees from data store objects.\n         */\n        return attributes.summaryFormatVersion;\n    }\n    else if (attributes.snapshotFormatVersion === \"0.1\") {\n        /**\n         * Version 1: from this version the pkg within the data store\n         * attributes blob is a JSON array rather than a string.\n         */\n        return 1;\n    }\n    /**\n     * Version 0: format version is missing from summary.\n     * This indicates it is an older version.\n     */\n    return 0;\n}\n// eslint-disable-next-line prefer-arrow/prefer-arrow-functions\nexport function hasIsolatedChannels(attributes) {\n    return !!attributes.summaryFormatVersion && !attributes.disableIsolatedChannels;\n}\n// eslint-disable-next-line prefer-arrow/prefer-arrow-functions\nexport function getMetadataFormatVersion(metadata) {\n    var _a;\n    /**\n     * Version 1+: Introduces .metadata blob and .channels trees for isolation of\n     * data store trees from container-level objects.\n     *\n     * Version 0: metadata blob missing; format version is missing from summary.\n     * This indicates it is an older version.\n     */\n    return (_a = metadata === null || metadata === void 0 ? void 0 : metadata.summaryFormatVersion) !== null && _a !== void 0 ? _a : 0;\n}\nexport const metadataBlobName = \".metadata\";\nexport const chunksBlobName = \".chunks\";\nexport const blobsTreeName = \".blobs\";\n// eslint-disable-next-line prefer-arrow/prefer-arrow-functions\nexport function rootHasIsolatedChannels(metadata) {\n    return !!metadata && !metadata.disableIsolatedChannels;\n}\nexport const protocolTreeName = \".protocol\";\n/**\n * List of tree IDs at the container level which are reserved.\n * This is for older versions of summaries that do not yet have an\n * isolated data stores namespace. Without the namespace, this must\n * be used to prevent name collisions with data store IDs.\n */\nexport const nonDataStorePaths = [protocolTreeName, \".logTail\", \".serviceProtocol\", blobsTreeName];\nexport const dataStoreAttributesBlobName = \".component\";\n/**\n * Modifies summary tree and stats to put tree under .channels tree.\n * Converts from: {\n *     type: SummaryType.Tree,\n *     tree: { a: {...}, b: {...}, c: {...} },\n * }\n * to: {\n *     type: SummaryType.Tree,\n *     tree: {\n *         \".channels\": {\n *             type: SummaryType.Tree,\n *             tree: { a: {...}, b: {...}, c: {...} }\n *         },\n *     },\n * }\n * And adds +1 to treeNodeCount in stats.\n * @param summarizeResult - summary tree and stats to modify\n */\nexport function wrapSummaryInChannelsTree(summarizeResult) {\n    summarizeResult.summary = {\n        type: 1 /* Tree */,\n        tree: { [channelsTreeName]: summarizeResult.summary },\n    };\n    summarizeResult.stats.treeNodeCount++;\n}\n//# sourceMappingURL=summaryFormat.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { EventEmitter } from \"events\";\nimport { Heap, PromiseTimer, } from \"@fluidframework/common-utils\";\nimport { ChildLogger, PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nimport { LoaderHeader, } from \"@fluidframework/container-definitions\";\nimport { DriverHeader } from \"@fluidframework/driver-definitions\";\nimport { createSummarizingWarning } from \"./summarizer\";\nexport const summarizerClientType = \"summarizer\";\nclass ClientComparer {\n    constructor() {\n        this.min = {\n            clientId: \"\",\n            sequenceNumber: -1,\n            isSummarizer: false,\n        };\n    }\n    compare(a, b) {\n        return a.sequenceNumber - b.sequenceNumber;\n    }\n}\nclass QuorumHeap {\n    constructor() {\n        this.heap = new Heap((new ClientComparer()));\n        this.heapMembers = new Map();\n        this.summarizerCount = 0;\n    }\n    addClient(clientId, client) {\n        var _a;\n        // Have to undefined-check client.details for backwards compatibility\n        const isSummarizer = ((_a = client.client.details) === null || _a === void 0 ? void 0 : _a.type) === summarizerClientType;\n        const heapNode = this.heap.add({ clientId, sequenceNumber: client.sequenceNumber, isSummarizer });\n        this.heapMembers.set(clientId, heapNode);\n        if (isSummarizer) {\n            this.summarizerCount++;\n        }\n    }\n    removeClient(clientId) {\n        const member = this.heapMembers.get(clientId);\n        if (member) {\n            this.heap.remove(member);\n            this.heapMembers.delete(clientId);\n            if (member.value.isSummarizer) {\n                this.summarizerCount--;\n            }\n        }\n    }\n    getFirstClientId() {\n        return this.heap.count() > 0 ? this.heap.peek().value.clientId : undefined;\n    }\n    getSummarizerCount() {\n        return this.summarizerCount;\n    }\n}\nvar SummaryManagerState;\n(function (SummaryManagerState) {\n    SummaryManagerState[SummaryManagerState[\"Off\"] = 0] = \"Off\";\n    SummaryManagerState[SummaryManagerState[\"Starting\"] = 1] = \"Starting\";\n    SummaryManagerState[SummaryManagerState[\"Running\"] = 2] = \"Running\";\n    SummaryManagerState[SummaryManagerState[\"Stopping\"] = 3] = \"Stopping\";\n    SummaryManagerState[SummaryManagerState[\"Disabled\"] = -1] = \"Disabled\";\n})(SummaryManagerState || (SummaryManagerState = {}));\nconst defaultInitialDelayMs = 5000;\nconst opsToBypassInitialDelay = 4000;\nconst defaultThrottleDelayWindowMs = 60 * 1000;\nconst defaultThrottleMaxDelayMs = 30 * 1000;\n// default throttling function increases exponentially (0ms, 20ms, 60ms, 140ms, etc)\nconst defaultThrottleDelayFunction = (n) => 20 * (Math.pow(2, n) - 1);\n/**\n * Used to give increasing delay times for throttling a single functionality.\n * Delay is based on previous attempts within specified time window, ignoring actual delay time.\n */\nclass Throttler {\n    constructor(delayWindowMs, maxDelayMs, delayFunction) {\n        this.delayWindowMs = delayWindowMs;\n        this.maxDelayMs = maxDelayMs;\n        this.delayFunction = delayFunction;\n        this.startTimes = [];\n    }\n    get attempts() {\n        return this.startTimes.length;\n    }\n    getDelay() {\n        const now = Date.now();\n        this.startTimes = this.startTimes.filter((t) => now - t < this.delayWindowMs);\n        const delayMs = Math.min(this.delayFunction(this.startTimes.length), this.maxDelayMs);\n        this.startTimes.push(now);\n        this.startTimes = this.startTimes.map((t) => t + delayMs); // account for delay time\n        if (delayMs === this.maxDelayMs) {\n            // we hit max delay so adding more won't affect anything\n            // shift off oldest time to stop this array from growing forever\n            this.startTimes.shift();\n        }\n        return delayMs;\n    }\n}\nexport class SummaryManager extends EventEmitter {\n    constructor(context, summariesEnabled, parentLogger, setNextSummarizer, nextSummarizerP, immediateSummary = false, initialDelayMs = defaultInitialDelayMs) {\n        var _a, _b;\n        super();\n        this.context = context;\n        this.summariesEnabled = summariesEnabled;\n        this.setNextSummarizer = setNextSummarizer;\n        this.nextSummarizerP = nextSummarizerP;\n        this.quorumHeap = new QuorumHeap();\n        this.connected = false;\n        this.state = SummaryManagerState.Off;\n        this._disposed = false;\n        this.startThrottler = new Throttler(defaultThrottleDelayWindowMs, defaultThrottleMaxDelayMs, defaultThrottleDelayFunction);\n        this.opsUntilFirstConnect = -1;\n        this.logger = ChildLogger.create(parentLogger, \"SummaryManager\", { all: { clientId: () => this.latestClientId } });\n        this.connected = context.connected;\n        if (this.connected) {\n            this.setClientId(context.clientId);\n        }\n        const members = context.quorum.getMembers();\n        for (const [clientId, client] of members) {\n            this.quorumHeap.addClient(clientId, client);\n        }\n        context.quorum.on(\"addMember\", (clientId, details) => {\n            if (this.opsUntilFirstConnect === -1 && clientId === this.clientId) {\n                this.opsUntilFirstConnect = details.sequenceNumber - this.context.deltaManager.initialSequenceNumber;\n            }\n            this.quorumHeap.addClient(clientId, details);\n            this.refreshSummarizer();\n        });\n        context.quorum.on(\"removeMember\", (clientId) => {\n            this.quorumHeap.removeClient(clientId);\n            this.refreshSummarizer();\n        });\n        this.initialDelayTimer = immediateSummary ? undefined : new PromiseTimer(initialDelayMs, () => { });\n        this.initialDelayP = (_b = (_a = this.initialDelayTimer) === null || _a === void 0 ? void 0 : _a.start()) !== null && _b !== void 0 ? _b : Promise.resolve();\n        this.refreshSummarizer();\n    }\n    get summarizer() {\n        return this.summarizerClientId;\n    }\n    get disposed() {\n        return this._disposed;\n    }\n    setConnected(clientId) {\n        this.updateConnected(true, clientId);\n    }\n    setDisconnected() {\n        this.updateConnected(false);\n    }\n    setClientId(clientId) {\n        this.clientId = clientId;\n        if (clientId !== undefined) {\n            this.latestClientId = clientId;\n            if (this.runningSummarizer !== undefined) {\n                this.runningSummarizer.updateOnBehalfOf(clientId);\n            }\n        }\n    }\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    updateConnected(connected, clientId) {\n        if (this.connected === connected) {\n            return;\n        }\n        this.connected = connected;\n        this.setClientId(clientId);\n        this.refreshSummarizer();\n    }\n    getShouldSummarizeState() {\n        if (!this.connected) {\n            return { shouldSummarize: false, stopReason: \"parentNotConnected\" };\n        }\n        else if (this.clientId !== this.summarizer) {\n            return { shouldSummarize: false, stopReason: \"parentShouldNotSummarize\" };\n        }\n        else if (this.disposed) {\n            return { shouldSummarize: false, stopReason: \"disposed\" };\n        }\n        else if (this.nextSummarizerP !== undefined) {\n            // This client has just come from a context reload, which means its\n            // summarizer client did as well.  We need to call start to rebind them.\n            return { shouldSummarize: true, shouldStart: true };\n        }\n        else if (this.quorumHeap.getSummarizerCount() > 0) {\n            // Need to wait for any other existing summarizer clients to close,\n            // because they can live longer than their parent container.\n            return { shouldSummarize: true, shouldStart: false };\n        }\n        else {\n            return { shouldSummarize: true, shouldStart: true };\n        }\n    }\n    refreshSummarizer() {\n        // Compute summarizer\n        const newSummarizerClientId = this.quorumHeap.getFirstClientId();\n        if (newSummarizerClientId !== this.summarizerClientId) {\n            this.summarizerClientId = newSummarizerClientId;\n            this.emit(\"summarizer\", newSummarizerClientId);\n        }\n        // Transition states depending on shouldSummarize, which is a calculated\n        // property that is only true if this client is connected and has the\n        // computed summarizer client id\n        const shouldSummarizeState = this.getShouldSummarizeState();\n        switch (this.state) {\n            case SummaryManagerState.Off: {\n                if (shouldSummarizeState.shouldSummarize && shouldSummarizeState.shouldStart) {\n                    this.start();\n                }\n                return;\n            }\n            case SummaryManagerState.Starting: {\n                // Cannot take any action until summarizer is created\n                // state transition will occur after creation\n                return;\n            }\n            case SummaryManagerState.Running: {\n                if (shouldSummarizeState.shouldSummarize === false) {\n                    this.stop(shouldSummarizeState.stopReason);\n                }\n                return;\n            }\n            case SummaryManagerState.Stopping: {\n                // Cannot take any action until running summarizer finishes\n                // state transition will occur after it stops\n                return;\n            }\n            case SummaryManagerState.Disabled: {\n                // Never switch away from disabled state\n                return;\n            }\n            default: {\n                return;\n            }\n        }\n    }\n    raiseContainerWarning(warning) {\n        this.context.raiseContainerWarning(warning);\n    }\n    start() {\n        if (!this.summariesEnabled) {\n            // If we should never summarize, lock in disabled state\n            this.logger.sendTelemetryEvent({ eventName: \"SummariesDisabled\" });\n            this.state = SummaryManagerState.Disabled;\n            return;\n        }\n        if (this.context.clientDetails.type === summarizerClientType) {\n            // Make sure that the summarizer client does not load another summarizer.\n            this.state = SummaryManagerState.Disabled;\n            return;\n        }\n        this.state = SummaryManagerState.Starting;\n        // throttle creation of new summarizer containers to prevent spamming the server with websocket connections\n        const delayMs = this.startThrottler.getDelay();\n        if (delayMs >= defaultThrottleMaxDelayMs) {\n            // we can't create a summarizer for some reason; raise error on container\n            this.raiseContainerWarning(createSummarizingWarning(\"SummaryManager: CreateSummarizer Max Throttle Delay\", false));\n        }\n        this.createSummarizer(delayMs).then((summarizer) => {\n            this.setNextSummarizer(summarizer.setSummarizer());\n            summarizer.on(\"summarizingError\", (warning) => this.raiseContainerWarning(warning));\n            this.run(summarizer);\n        }, (error) => {\n            this.logger.sendErrorEvent({\n                eventName: \"CreateSummarizerError\",\n                attempt: this.startThrottler.attempts,\n            }, error);\n            this.tryRestart();\n        });\n    }\n    run(summarizer) {\n        this.state = SummaryManagerState.Running;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const clientId = this.latestClientId;\n        this.runningSummarizer = summarizer;\n        PerformanceEvent.timedExecAsync(this.logger, { eventName: \"RunningSummarizer\", attempt: this.startThrottler.attempts }, async () => summarizer.run(clientId)).finally(() => {\n            this.runningSummarizer = undefined;\n            this.nextSummarizerP = undefined;\n            this.tryRestart();\n        });\n        const shouldSummarizeState = this.getShouldSummarizeState();\n        if (shouldSummarizeState.shouldSummarize === false) {\n            this.stop(shouldSummarizeState.stopReason);\n        }\n    }\n    tryRestart() {\n        const shouldSummarizeState = this.getShouldSummarizeState();\n        if (shouldSummarizeState.shouldSummarize && shouldSummarizeState.shouldStart) {\n            this.start();\n        }\n        else {\n            this.state = SummaryManagerState.Off;\n        }\n    }\n    stop(reason) {\n        this.state = SummaryManagerState.Stopping;\n        if (this.runningSummarizer) {\n            // Stopping the running summarizer client should trigger a change\n            // in states when the running summarizer closes\n            this.runningSummarizer.stop(reason);\n        }\n        else {\n            // Should not be possible to hit this case\n            this.logger.sendErrorEvent({ eventName: \"StopCalledWithoutRunningSummarizer\", reason });\n            this.state = SummaryManagerState.Off;\n        }\n    }\n    async createSummarizer(delayMs) {\n        // We have been elected the summarizer. Some day we may be able to summarize with a live document but for\n        // now we play it safe and launch a second copy.\n        this.logger.sendTelemetryEvent({\n            eventName: \"CreatingSummarizer\",\n            delayMs,\n            opsUntilFirstConnect: this.opsUntilFirstConnect,\n        });\n        const shouldDelay = delayMs > 0;\n        const shouldInitialDelay = this.opsUntilFirstConnect < opsToBypassInitialDelay;\n        if (shouldDelay || shouldInitialDelay) {\n            await Promise.all([\n                shouldInitialDelay ? this.initialDelayP : Promise.resolve(),\n                shouldDelay ? new Promise((resolve) => setTimeout(resolve, delayMs)) : Promise.resolve(),\n            ]);\n        }\n        if (this.nextSummarizerP) {\n            return this.nextSummarizerP;\n        }\n        const loader = this.context.loader;\n        // TODO eventually we may wish to spawn an execution context from which to run this\n        const request = {\n            headers: {\n                [LoaderHeader.cache]: false,\n                [LoaderHeader.clientDetails]: {\n                    capabilities: { interactive: false },\n                    type: summarizerClientType,\n                },\n                [DriverHeader.summarizingClient]: true,\n                [LoaderHeader.reconnect]: false,\n                [LoaderHeader.sequenceNumber]: this.context.deltaManager.lastSequenceNumber,\n            },\n            url: \"/_summarizer\",\n        };\n        const response = await loader.request(request);\n        if (response.status !== 200\n            || (response.mimeType !== \"fluid/object\" && response.mimeType !== \"fluid/component\")) {\n            return Promise.reject(new Error(\"Invalid summarizer route\"));\n        }\n        const rawFluidObject = response.value;\n        const summarizer = rawFluidObject.ISummarizer;\n        if (!summarizer) {\n            return Promise.reject(new Error(\"Fluid object does not implement ISummarizer\"));\n        }\n        return summarizer;\n    }\n    dispose() {\n        var _a;\n        (_a = this.initialDelayTimer) === null || _a === void 0 ? void 0 : _a.clear();\n        this._disposed = true;\n    }\n}\n//# sourceMappingURL=summaryManager.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { ContainerErrorType, } from \"@fluidframework/container-definitions\";\nimport { LoggingError } from \"@fluidframework/telemetry-utils\";\nfunction messageFromError(error) {\n    if (typeof (error === null || error === void 0 ? void 0 : error.message) === \"string\") {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return error.message;\n    }\n    return `${error}`;\n}\nconst isValidLoggingError = (error) => {\n    return typeof (error === null || error === void 0 ? void 0 : error.errorType) === \"string\" && error instanceof LoggingError;\n};\nconst isRegularObject = (value) => {\n    return value !== null && !Array.isArray(value) && typeof value === \"object\";\n};\n// TODO: move this elsewhere and use in TelemetryLogger.prepareErrorObject\nfunction extractLogSafeErrorProperties(error) {\n    // Only get properties we know about.\n    // Grabbing all properties will expose PII in telemetry!\n    const message = messageFromError(error);\n    const safeProps = {\n        message,\n    };\n    if (isRegularObject(error)) {\n        const { errorType, stack } = error;\n        if (typeof errorType === \"string\") {\n            safeProps.errorType = errorType;\n        }\n        if (typeof stack === \"string\") {\n            safeProps.stack = stack;\n        }\n    }\n    return safeProps;\n}\n/**\n * Generic error\n */\nexport class GenericError extends LoggingError {\n    constructor(errorMessage, error, props) {\n        super(errorMessage, props);\n        this.error = error;\n        this.errorType = ContainerErrorType.genericError;\n    }\n}\nexport class DataCorruptionError extends LoggingError {\n    constructor(errorMessage, props) {\n        super(errorMessage, props);\n        this.errorType = ContainerErrorType.dataCorruptionError;\n        this.canRetry = false;\n    }\n}\nexport class DataProcessingError extends LoggingError {\n    constructor(errorMessage, props) {\n        super(errorMessage, props);\n        this.errorType = ContainerErrorType.dataProcessingError;\n        this.canRetry = false;\n    }\n}\nexport const extractSafePropertiesFromMessage = (message) => ({\n    messageClientId: message.clientId,\n    messageSequenceNumber: message.sequenceNumber,\n    messageClientSequenceNumber: message.clientSequenceNumber,\n    messageReferenceSequenceNumber: message.referenceSequenceNumber,\n    messageMinimumSequenceNumber: message.minimumSequenceNumber,\n    messageTimestamp: message.timestamp,\n});\n/**\n * Conditionally coerce the throwable input into a DataProcessingError.\n * @param error - Throwable input to be converted.\n */\nexport function CreateProcessingError(error, message) {\n    const info = message !== undefined\n        ? extractSafePropertiesFromMessage(message)\n        : undefined;\n    if (typeof error === \"string\") {\n        return new DataProcessingError(error, info);\n    }\n    else if (!isRegularObject(error)) {\n        return new DataProcessingError(\"DataProcessingError without explicit message (needs review)\", Object.assign(Object.assign({}, info), { typeof: typeof error }));\n    }\n    else if (isValidLoggingError(error)) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return error;\n    }\n    else {\n        const safeProps = extractLogSafeErrorProperties(error);\n        return new DataProcessingError(safeProps.message, Object.assign(Object.assign(Object.assign({}, info), safeProps), { errorType: ContainerErrorType.dataProcessingError }));\n    }\n}\n/**\n * Convert the error into one of the error types.\n * @param error - Error to be converted.\n */\nexport function CreateContainerError(error) {\n    var _a;\n    assert(error !== undefined, 0x0f5 /* \"Missing error input\" */);\n    if (typeof error === \"object\" && error !== null) {\n        const err = error;\n        if (isValidLoggingError(error)) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return err;\n        }\n        const { message, stack, errorType = `${(_a = error.errorType) !== null && _a !== void 0 ? _a : ContainerErrorType.genericError}`, } = extractLogSafeErrorProperties(error);\n        return new LoggingError(message, {\n            errorType,\n            stack,\n        });\n    }\n    else if (typeof error === \"string\") {\n        return new GenericError(error, new Error(error));\n    }\n    else {\n        return new GenericError(messageFromError(error), error);\n    }\n}\n//# sourceMappingURL=error.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Check if the package.json defines a Fluid package\n * @param pkg - the package json data to check if it is a Fluid package.\n */\nexport const isFluidPackage = (pkg) => typeof pkg === \"object\"\n    && typeof (pkg === null || pkg === void 0 ? void 0 : pkg.name) === \"string\"\n    && typeof (pkg === null || pkg === void 0 ? void 0 : pkg.fluid) === \"object\";\nexport const isFluidCodeDetails = (details) => {\n    const maybeCodeDetails = details;\n    return typeof maybeCodeDetails === \"object\"\n        && (typeof (maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.package) === \"string\" || isFluidPackage(maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.package))\n        && ((maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.config) === undefined || typeof (maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.config) === \"object\");\n};\nexport const IFluidCodeDetailsComparer = \"IFluidCodeDetailsComparer\";\n//# sourceMappingURL=fluidPackage.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { addBlobToSummary } from \"@fluidframework/runtime-utils\";\nimport { ChannelDeltaConnection } from \"./channelDeltaConnection\";\nimport { ChannelStorageService } from \"./channelStorageService\";\nexport const attributesBlobKey = \".attributes\";\nexport function createServiceEndpoints(id, connected, submitFn, dirtyFn, storageService, tree, extraBlobs) {\n    const deltaConnection = new ChannelDeltaConnection(id, connected, (message, localOpMetadata) => submitFn(message, localOpMetadata), dirtyFn);\n    const objectStorage = new ChannelStorageService(tree, storageService, extraBlobs);\n    return {\n        deltaConnection,\n        objectStorage,\n    };\n}\nexport function summarizeChannel(channel, fullTree = false, trackState = false) {\n    const summarizeResult = channel.summarize(fullTree, trackState);\n    // Add the channel attributes to the returned result.\n    addBlobToSummary(summarizeResult, attributesBlobKey, JSON.stringify(channel.attributes));\n    return summarizeResult;\n}\n//# sourceMappingURL=channelContext.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { CreateProcessingError } from \"@fluidframework/container-utils\";\nexport class ChannelDeltaConnection {\n    constructor(objectId, _connected, submitFn, dirtyFn) {\n        this.objectId = objectId;\n        this._connected = _connected;\n        this.submitFn = submitFn;\n        this.dirtyFn = dirtyFn;\n    }\n    get handler() {\n        assert(!!this._handler, 0x177 /* \"Missing delta handler\" */);\n        return this._handler;\n    }\n    get connected() {\n        return this._connected;\n    }\n    attach(handler) {\n        assert(this._handler === undefined, 0x178 /* \"Missing delta handler on attach\" */);\n        this._handler = handler;\n    }\n    setConnectionState(connected) {\n        this._connected = connected;\n        this.handler.setConnectionState(connected);\n    }\n    process(message, local, localOpMetadata) {\n        try {\n            // catches as data processing error whether or not they come from async pending queues\n            this.handler.process(message, local, localOpMetadata);\n        }\n        catch (error) {\n            // eslint-disable-next-line @typescript-eslint/no-throw-literal\n            throw CreateProcessingError(error, message);\n        }\n    }\n    reSubmit(content, localOpMetadata) {\n        this.handler.reSubmit(content, localOpMetadata);\n    }\n    applyStashedOp(message) {\n        return this.handler.applyStashedOp(message);\n    }\n    /**\n     * Send new messages to the server\n     */\n    submit(message, localOpMetadata) {\n        this.submitFn(message, localOpMetadata);\n    }\n    /**\n     * Indicates that the channel is dirty and needs to be part of the summary. It is called by a SharedSummaryBlock\n     * that needs to be part of the summary but does not generate ops.\n     */\n    dirty() {\n        this.dirtyFn();\n    }\n}\n//# sourceMappingURL=channelDeltaConnection.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { getNormalizedObjectStoragePathParts } from \"@fluidframework/runtime-utils\";\nexport class ChannelStorageService {\n    constructor(tree, storage, extraBlobs) {\n        this.tree = tree;\n        this.storage = storage;\n        this.extraBlobs = extraBlobs;\n        this.flattenedTree = {};\n        // Create a map from paths to blobs\n        if (tree !== undefined) {\n            ChannelStorageService.flattenTree(\"\", tree, this.flattenedTree);\n        }\n    }\n    static flattenTree(base, tree, results) {\n        // eslint-disable-next-line guard-for-in, no-restricted-syntax\n        for (const path in tree.trees) {\n            ChannelStorageService.flattenTree(`${base}${path}/`, tree.trees[path], results);\n        }\n        // eslint-disable-next-line guard-for-in, no-restricted-syntax\n        for (const blob in tree.blobs) {\n            results[`${base}${blob}`] = tree.blobs[blob];\n        }\n    }\n    async contains(path) {\n        return this.flattenedTree[path] !== undefined;\n    }\n    async readBlob(path) {\n        const id = await this.getIdForPath(path);\n        const blob = this.extraBlobs !== undefined\n            ? this.extraBlobs.get(id)\n            : undefined;\n        if (blob !== undefined) {\n            return blob;\n        }\n        return this.storage.readBlob(id);\n    }\n    async list(path) {\n        var _a;\n        let tree = this.tree;\n        const pathParts = getNormalizedObjectStoragePathParts(path);\n        while (tree !== undefined && pathParts.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const part = pathParts.shift();\n            tree = tree.trees[part];\n        }\n        if (tree === undefined || pathParts.length !== 0) {\n            throw new Error(\"path does not exist\");\n        }\n        return Object.keys((_a = tree === null || tree === void 0 ? void 0 : tree.blobs) !== null && _a !== void 0 ? _a : {});\n    }\n    async getIdForPath(path) {\n        return this.flattenedTree[path];\n    }\n}\n//# sourceMappingURL=channelStorageService.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { BindState, AttachState, } from \"@fluidframework/container-definitions\";\nimport { CreateProcessingError } from \"@fluidframework/container-utils\";\nimport { assert, Deferred, LazyPromise, TypedEventEmitter, unreachableCase, } from \"@fluidframework/common-utils\";\nimport { ChildLogger, raiseConnectedEvent, } from \"@fluidframework/telemetry-utils\";\nimport { buildSnapshotTree, readAndParseFromBlobs } from \"@fluidframework/driver-utils\";\nimport { CreateSummarizerNodeSource, } from \"@fluidframework/runtime-definitions\";\nimport { convertSnapshotTreeToSummaryTree, convertSummaryTreeToITree, FluidSerializer, generateHandleContextPath, RequestParser, SummaryTreeBuilder, create404Response, createResponseError, exceptionToResponse, } from \"@fluidframework/runtime-utils\";\nimport { cloneGCData, GCDataBuilder, getChildNodesGCData, getChildNodesUsedRoutes, removeRouteFromAllNodes, } from \"@fluidframework/garbage-collector\";\nimport { v4 as uuid } from \"uuid\";\nimport { summarizeChannel } from \"./channelContext\";\nimport { LocalChannelContext } from \"./localChannelContext\";\nimport { RemoteChannelContext } from \"./remoteChannelContext\";\nexport var DataStoreMessageType;\n(function (DataStoreMessageType) {\n    // Creates a new channel\n    DataStoreMessageType[\"Attach\"] = \"attach\";\n    DataStoreMessageType[\"ChannelOp\"] = \"op\";\n})(DataStoreMessageType || (DataStoreMessageType = {}));\n/**\n * Base data store class\n */\nexport class FluidDataStoreRuntime extends TypedEventEmitter {\n    constructor(dataStoreContext, sharedObjectRegistry) {\n        super();\n        this.dataStoreContext = dataStoreContext;\n        this.sharedObjectRegistry = sharedObjectRegistry;\n        this.serializer = new FluidSerializer(this.IFluidHandleContext);\n        this._disposed = false;\n        this.contexts = new Map();\n        this.contextsDeferred = new Map();\n        this.pendingAttach = new Map();\n        // This is used to break the recursion while attaching the graph. Also tells the attach state of the graph.\n        this.graphAttachState = AttachState.Detached;\n        this.deferredAttached = new Deferred();\n        this.localChannelContextQueue = new Map();\n        this.notBoundedChannelContextSet = new Set();\n        this.logger = ChildLogger.create(dataStoreContext.containerRuntime.logger, undefined, { all: { dataStoreId: uuid() } });\n        this.documentId = dataStoreContext.documentId;\n        this.id = dataStoreContext.id;\n        this.existing = dataStoreContext.existing;\n        this.options = dataStoreContext.options;\n        this.deltaManager = dataStoreContext.deltaManager;\n        this.quorum = dataStoreContext.getQuorum();\n        this.audience = dataStoreContext.getAudience();\n        const tree = dataStoreContext.baseSnapshot;\n        this.initialChannelUsedRoutesP = new LazyPromise(async () => {\n            var _a, _b;\n            // back-compat: 0.35.0. getInitialGCSummaryDetails is added to IFluidDataStoreContext in 0.35.0. Remove\n            // undefined check when N > 0.36.0.\n            const gcDetailsInInitialSummary = await ((_b = (_a = this.dataStoreContext).getInitialGCSummaryDetails) === null || _b === void 0 ? void 0 : _b.call(_a));\n            if ((gcDetailsInInitialSummary === null || gcDetailsInInitialSummary === void 0 ? void 0 : gcDetailsInInitialSummary.usedRoutes) !== undefined) {\n                // Remove the route to this data store, if it exists.\n                const usedRoutes = gcDetailsInInitialSummary.usedRoutes.filter((id) => { return id !== \"/\" && id !== \"\"; });\n                return getChildNodesUsedRoutes(usedRoutes);\n            }\n            return new Map();\n        });\n        this.initialChannelGCDataP = new LazyPromise(async () => {\n            var _a, _b;\n            // back-compat: 0.35.0. getInitialGCSummaryDetails is added to IFluidDataStoreContext in 0.35.0. Remove\n            // undefined check when N > 0.36.0.\n            const gcDetailsInInitialSummary = await ((_b = (_a = this.dataStoreContext).getInitialGCSummaryDetails) === null || _b === void 0 ? void 0 : _b.call(_a));\n            if ((gcDetailsInInitialSummary === null || gcDetailsInInitialSummary === void 0 ? void 0 : gcDetailsInInitialSummary.gcData) !== undefined) {\n                const gcData = cloneGCData(gcDetailsInInitialSummary.gcData);\n                // Remove GC node for this data store, if any.\n                delete gcData.gcNodes[\"/\"];\n                // Remove the back route to this data store that was added when generating each child's GC nodes.\n                removeRouteFromAllNodes(gcData.gcNodes, this.absolutePath);\n                return getChildNodesGCData(gcData);\n            }\n            return new Map();\n        });\n        // Must always receive the data store type inside of the attributes\n        if ((tree === null || tree === void 0 ? void 0 : tree.trees) !== undefined) {\n            Object.keys(tree.trees).forEach((path) => {\n                // Issue #4414\n                if (path === \"_search\") {\n                    return;\n                }\n                let channelContext;\n                // If already exists on storage, then create a remote channel. However, if it is case of rehydrating a\n                // container from snapshot where we load detached container from a snapshot, isLocalDataStore would be\n                // true. In this case create a LocalChannelContext.\n                if (dataStoreContext.isLocalDataStore) {\n                    const channelAttributes = readAndParseFromBlobs(tree.trees[path].blobs, tree.trees[path].blobs[\".attributes\"]);\n                    channelContext = new LocalChannelContext(path, this.sharedObjectRegistry, channelAttributes.type, this, this.dataStoreContext, this.dataStoreContext.storage, (content, localOpMetadata) => this.submitChannelOp(path, content, localOpMetadata), (address) => this.setChannelDirty(address), tree.trees[path]);\n                    // This is the case of rehydrating a detached container from snapshot. Now due to delay loading of\n                    // data store, if the data store is loaded after the container is attached, then we missed marking\n                    // the channel as attached. So mark it now. Otherwise add it to local channel context queue, so\n                    // that it can be mark attached later with the data store.\n                    if (dataStoreContext.attachState !== AttachState.Detached) {\n                        channelContext.markAttached();\n                    }\n                    else {\n                        this.localChannelContextQueue.set(path, channelContext);\n                    }\n                }\n                else {\n                    channelContext = new RemoteChannelContext(this, dataStoreContext, dataStoreContext.storage, (content, localOpMetadata) => this.submitChannelOp(path, content, localOpMetadata), (address) => this.setChannelDirty(address), path, tree.trees[path], this.sharedObjectRegistry, undefined /* extraBlobs */, this.dataStoreContext.getCreateChildSummarizerNodeFn(path, { type: CreateSummarizerNodeSource.FromSummary }), async () => this.getChannelInitialGCDetails(path));\n                }\n                const deferred = new Deferred();\n                deferred.resolve(channelContext);\n                this.contexts.set(path, channelContext);\n                this.contextsDeferred.set(path, deferred);\n            });\n        }\n        this.attachListener();\n        // If exists on storage or loaded from a snapshot, it should already be binded.\n        this.bindState = this.existing ? BindState.Bound : BindState.NotBound;\n        this._attachState = dataStoreContext.attachState;\n        // If it's existing we know it has been attached.\n        if (this.existing) {\n            this.deferredAttached.resolve();\n        }\n    }\n    /**\n     * Loads the data store runtime\n     * @param context - The data store context\n     * @param sharedObjectRegistry - The registry of shared objects used by this data store\n     * @param activeCallback - The callback called when the data store runtime in active\n     * @param dataStoreRegistry - The registry of data store created and used by this data store\n     */\n    static load(context, sharedObjectRegistry) {\n        return new FluidDataStoreRuntime(context, sharedObjectRegistry);\n    }\n    get IFluidRouter() { return this; }\n    get connected() {\n        return this.dataStoreContext.connected;\n    }\n    get leader() {\n        return this.dataStoreContext.leader;\n    }\n    get clientId() {\n        return this.dataStoreContext.clientId;\n    }\n    get clientDetails() {\n        return this.dataStoreContext.containerRuntime.clientDetails;\n    }\n    get loader() {\n        return this.dataStoreContext.loader;\n    }\n    get isAttached() {\n        return this.attachState !== AttachState.Detached;\n    }\n    get attachState() {\n        return this._attachState;\n    }\n    get absolutePath() {\n        return generateHandleContextPath(this.id, this.routeContext);\n    }\n    get routeContext() {\n        return this.dataStoreContext.containerRuntime.IFluidHandleContext;\n    }\n    get IFluidSerializer() { return this.serializer; }\n    get IFluidHandleContext() { return this; }\n    get rootRoutingContext() { return this; }\n    get channelsRoutingContext() { return this; }\n    get objectsRoutingContext() { return this; }\n    get disposed() { return this._disposed; }\n    dispose() {\n        if (this._disposed) {\n            return;\n        }\n        this._disposed = true;\n        this.emit(\"dispose\");\n        this.removeAllListeners();\n    }\n    async resolveHandle(request) {\n        return this.request(request);\n    }\n    async request(request) {\n        try {\n            const parser = RequestParser.create(request);\n            const id = parser.pathParts[0];\n            if (id === \"_channels\" || id === \"_custom\") {\n                return this.request(parser.createSubRequest(1));\n            }\n            // Check for a data type reference first\n            if (this.contextsDeferred.has(id) && parser.isLeaf(1)) {\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    const value = await this.contextsDeferred.get(id).promise;\n                    const channel = await value.getChannel();\n                    return { mimeType: \"fluid/object\", status: 200, value: channel };\n                }\n                catch (error) {\n                    this.logger.sendErrorEvent({ eventName: \"GetChannelFailedInRequest\" }, error);\n                    return createResponseError(500, `Failed to get Channel: ${error}`, request);\n                }\n            }\n            // Otherwise defer to an attached request handler\n            return create404Response(request);\n        }\n        catch (error) {\n            return exceptionToResponse(error);\n        }\n    }\n    async getChannel(id) {\n        this.verifyNotClosed();\n        // TODO we don't assume any channels (even root) in the runtime. If you request a channel that doesn't exist\n        // we will never resolve the promise. May want a flag to getChannel that doesn't wait for the promise if\n        // it doesn't exist\n        if (!this.contextsDeferred.has(id)) {\n            this.contextsDeferred.set(id, new Deferred());\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const context = await this.contextsDeferred.get(id).promise;\n        const channel = await context.getChannel();\n        return channel;\n    }\n    createChannel(id = uuid(), type) {\n        this.verifyNotClosed();\n        assert(!this.contexts.has(id), 0x179 /* \"createChannel() with existing ID\" */);\n        this.notBoundedChannelContextSet.add(id);\n        const context = new LocalChannelContext(id, this.sharedObjectRegistry, type, this, this.dataStoreContext, this.dataStoreContext.storage, (content, localOpMetadata) => this.submitChannelOp(id, content, localOpMetadata), (address) => this.setChannelDirty(address), undefined);\n        this.contexts.set(id, context);\n        if (this.contextsDeferred.has(id)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.contextsDeferred.get(id).resolve(context);\n        }\n        else {\n            const deferred = new Deferred();\n            deferred.resolve(context);\n            this.contextsDeferred.set(id, deferred);\n        }\n        assert(!!context.channel, 0x17a /* \"Channel should be loaded when created!!\" */);\n        return context.channel;\n    }\n    /**\n     * Binds a channel with the runtime. If the runtime is attached we will attach the channel right away.\n     * If the runtime is not attached we will defer the attach until the runtime attaches.\n     * @param channel - channel to be registered.\n     */\n    bindChannel(channel) {\n        assert(this.notBoundedChannelContextSet.has(channel.id), 0x17b /* \"Channel to be binded should be in not bounded set\" */);\n        this.notBoundedChannelContextSet.delete(channel.id);\n        // If our data store is attached, then attach the channel.\n        if (this.isAttached) {\n            this.attachChannel(channel);\n            return;\n        }\n        else {\n            this.bind(channel.handle);\n            // If our data store is local then add the channel to the queue\n            if (!this.localChannelContextQueue.has(channel.id)) {\n                this.localChannelContextQueue.set(channel.id, this.contexts.get(channel.id));\n            }\n        }\n    }\n    attachGraph() {\n        if (this.graphAttachState !== AttachState.Detached) {\n            return;\n        }\n        this.graphAttachState = AttachState.Attaching;\n        if (this.boundhandles !== undefined) {\n            this.boundhandles.forEach((handle) => {\n                handle.attachGraph();\n            });\n            this.boundhandles = undefined;\n        }\n        // Flush the queue to set any pre-existing channels to local\n        this.localChannelContextQueue.forEach((channel) => {\n            // When we are attaching the data store we don't need to send attach for the registered services.\n            // This is because they will be captured as part of the Attach data store snapshot\n            channel.markAttached();\n        });\n        this.localChannelContextQueue.clear();\n        this.bindToContext();\n        this.graphAttachState = AttachState.Attached;\n    }\n    /**\n     * Binds this runtime to the container\n     * This includes the following:\n     * 1. Sending an Attach op that includes all existing state\n     * 2. Attaching the graph if the data store becomes attached.\n     */\n    bindToContext() {\n        if (this.bindState !== BindState.NotBound) {\n            return;\n        }\n        this.bindState = BindState.Binding;\n        this.dataStoreContext.bindToContext();\n        this.bindState = BindState.Bound;\n    }\n    bind(handle) {\n        // If the data store is already attached or its graph is already in attaching or attached state,\n        // then attach the incoming handle too.\n        if (this.isAttached || this.graphAttachState !== AttachState.Detached) {\n            handle.attachGraph();\n            return;\n        }\n        if (this.boundhandles === undefined) {\n            this.boundhandles = new Set();\n        }\n        this.boundhandles.add(handle);\n    }\n    setConnectionState(connected, clientId) {\n        this.verifyNotClosed();\n        for (const [, object] of this.contexts) {\n            object.setConnectionState(connected, clientId);\n        }\n        raiseConnectedEvent(this.logger, this, connected, clientId);\n    }\n    getQuorum() {\n        return this.quorum;\n    }\n    getAudience() {\n        return this.audience;\n    }\n    async uploadBlob(blob) {\n        this.verifyNotClosed();\n        return this.dataStoreContext.uploadBlob(blob);\n    }\n    process(message, local, localOpMetadata) {\n        this.verifyNotClosed();\n        try {\n            // catches as data processing error whether or not they come from async pending queues\n            switch (message.type) {\n                case DataStoreMessageType.Attach: {\n                    const attachMessage = message.contents;\n                    const id = attachMessage.id;\n                    // If a non-local operation then go and create the object\n                    // Otherwise mark it as officially attached.\n                    if (local) {\n                        assert(this.pendingAttach.has(id), 0x17c /* \"Unexpected attach (local) channel OP\" */);\n                        this.pendingAttach.delete(id);\n                    }\n                    else {\n                        assert(!this.contexts.has(id), 0x17d);\n                        const flatBlobs = new Map();\n                        const snapshotTree = buildSnapshotTree(attachMessage.snapshot.entries, flatBlobs);\n                        const remoteChannelContext = new RemoteChannelContext(this, this.dataStoreContext, this.dataStoreContext.storage, (content, localContentMetadata) => this.submitChannelOp(id, content, localContentMetadata), (address) => this.setChannelDirty(address), id, snapshotTree, this.sharedObjectRegistry, flatBlobs, this.dataStoreContext.getCreateChildSummarizerNodeFn(id, {\n                            type: CreateSummarizerNodeSource.FromAttach,\n                            sequenceNumber: message.sequenceNumber,\n                            snapshot: attachMessage.snapshot,\n                        }), async () => this.getChannelInitialGCDetails(id), attachMessage.type);\n                        this.contexts.set(id, remoteChannelContext);\n                        if (this.contextsDeferred.has(id)) {\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            this.contextsDeferred.get(id).resolve(remoteChannelContext);\n                        }\n                        else {\n                            const deferred = new Deferred();\n                            deferred.resolve(remoteChannelContext);\n                            this.contextsDeferred.set(id, deferred);\n                        }\n                    }\n                    break;\n                }\n                case DataStoreMessageType.ChannelOp:\n                    this.processChannelOp(message, local, localOpMetadata);\n                    break;\n                default:\n            }\n            this.emit(\"op\", message);\n        }\n        catch (error) {\n            // eslint-disable-next-line @typescript-eslint/no-throw-literal\n            throw CreateProcessingError(error, message);\n        }\n    }\n    processSignal(message, local) {\n        this.emit(\"signal\", message, local);\n    }\n    isChannelAttached(id) {\n        return (\n        // Added in createChannel\n        // Removed when bindChannel is called\n        !this.notBoundedChannelContextSet.has(id)\n            // Added in bindChannel only if this is not attached yet\n            // Removed when this is attached by calling attachGraph\n            && !this.localChannelContextQueue.has(id)\n            // Added in attachChannel called by bindChannel\n            // Removed when attach op is broadcast\n            && !this.pendingAttach.has(id));\n    }\n    /**\n     * Returns the outbound routes of this channel. Currently, all contexts in this channel are considered\n     * referenced and are hence outbound. This will change when we have root and non-root channel contexts.\n     * The only root contexts will be considered as referenced.\n     */\n    getOutboundRoutes() {\n        const outboundRoutes = [];\n        for (const [contextId] of this.contexts) {\n            outboundRoutes.push(`${this.absolutePath}/${contextId}`);\n        }\n        return outboundRoutes;\n    }\n    /**\n     * Updates the GC nodes of this channel. It does the following:\n     * - Adds a back route to self to all its child GC nodes.\n     * - Adds a node for this channel.\n     * @param builder - The builder that contains the GC nodes for this channel's children.\n     */\n    updateGCNodes(builder) {\n        // Add a back route to self in each child's GC nodes. If any child is referenced, then its parent should\n        // be considered referenced as well.\n        builder.addRouteToAllNodes(this.absolutePath);\n        // Get the outbound routes and add a GC node for this channel.\n        builder.addNode(\"/\", this.getOutboundRoutes());\n    }\n    /**\n     * Generates data used for garbage collection. This includes a list of GC nodes that represent this channel\n     * including any of its child channel contexts. Each node has a set of outbound routes to other GC nodes in the\n     * document. It does the following:\n     * 1. Calls into each child context to get its GC data.\n     * 2. Prefixs the child context's id to the GC nodes in the child's GC data. This makes sure that the node can be\n     *    idenfied as belonging to the child.\n     * 3. Adds a GC node for this channel to the nodes received from the children. All these nodes together represent\n     *    the GC data of this channel.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCData(fullGC = false) {\n        const builder = new GCDataBuilder();\n        // Iterate over each channel context and get their GC data.\n        await Promise.all(Array.from(this.contexts)\n            .filter(([contextId, _]) => {\n            // Get GC data only for attached contexts. Detached contexts are not connected in the GC reference\n            // graph so any references they might have won't be connected as well.\n            return this.isChannelAttached(contextId);\n        }).map(async ([contextId, context]) => {\n            const contextGCData = await context.getGCData(fullGC);\n            // Prefix the child's id to the ids of its GC nodes so they can be identified as belonging to the child.\n            // This also gradually builds the id of each node to be a path from the root.\n            builder.prefixAndAddNodes(contextId, contextGCData.gcNodes);\n        }));\n        this.updateGCNodes(builder);\n        return builder.getGCData();\n    }\n    /**\n     * After GC has run, called to notify this channel of routes that are used in it. It calls the child contexts to\n     * update their used routes.\n     * @param usedRoutes - The routes that are used in all contexts in this channel.\n     */\n    updateUsedRoutes(usedRoutes) {\n        var _a;\n        // Get a map of channel ids to routes used in it.\n        const usedContextRoutes = getChildNodesUsedRoutes(usedRoutes);\n        // Verify that the used routes are correct.\n        for (const [id] of usedContextRoutes) {\n            assert(this.contexts.has(id), 0x17e /* \"Used route does not belong to any known context\" */);\n        }\n        // Update the used routes in each context. Used routes is empty for unused context.\n        for (const [contextId, context] of this.contexts) {\n            context.updateUsedRoutes((_a = usedContextRoutes.get(contextId)) !== null && _a !== void 0 ? _a : []);\n        }\n    }\n    /**\n     * Returns the GC details in initial summary for the channel with the given id. The initial summary of the data\n     * store contains the GC details of all the child channel contexts that were created before the summary was taken.\n     * We find the GC details belonging to the given channel context and return it.\n     * @param channelId - The id of the channel context that is asked for the initial GC details.\n     * @returns the requested channel's GC details in the initial summary.\n     */\n    async getChannelInitialGCDetails(channelId) {\n        const channelInitialUsedRoutes = await this.initialChannelUsedRoutesP;\n        const channelInitialGCData = await this.initialChannelGCDataP;\n        let channelUsedRoutes = channelInitialUsedRoutes.get(channelId);\n        // Currently, channel context's are always considered used. So, it there is no used route for it, we still\n        // need to mark it as used. Add self-route (empty string) to the channel context's used routes.\n        if (channelUsedRoutes === undefined || channelUsedRoutes.length === 0) {\n            channelUsedRoutes = [\"\"];\n        }\n        return {\n            usedRoutes: channelUsedRoutes,\n            gcData: channelInitialGCData.get(channelId),\n        };\n    }\n    /**\n     * Returns a summary at the current sequence number.\n     * @param fullTree - true to bypass optimizations and force a full summary tree\n     * @param trackState - This tells whether we should track state from this summary.\n     */\n    async summarize(fullTree = false, trackState = true) {\n        const gcDataBuilder = new GCDataBuilder();\n        const summaryBuilder = new SummaryTreeBuilder();\n        // Iterate over each data store and ask it to summarize\n        await Promise.all(Array.from(this.contexts)\n            .filter(([contextId, _]) => {\n            const isAttached = this.isChannelAttached(contextId);\n            // We are not expecting local dds! Summary may not capture local state.\n            assert(isAttached, 0x17f /* \"Not expecting detached channels during summarize\" */);\n            // If the object is registered - and we have received the sequenced op creating the object\n            // (i.e. it has a base mapping) - then we go ahead and summarize\n            return isAttached;\n        }).map(async ([contextId, context]) => {\n            // If BlobAggregationStorage is engaged, we have to write full summary for data stores\n            // BlobAggregationStorage relies on this behavior, as it aggregates blobs across DDSs.\n            // Not generating full summary will mean data loss, as we will overwrite aggregate blob in new summary,\n            // and any virtual blobs that stayed (for unchanged DDSs) will need aggregate blob in previous summary\n            // that is no longer present in this summary.\n            // This is temporal limitation that can be lifted in future once BlobAggregationStorage becomes smarter.\n            const contextSummary = await context.summarize(true /* fullTree */, trackState);\n            summaryBuilder.addWithStats(contextId, contextSummary);\n            // Prefix the child's id to the ids of its GC nodes. This gradually builds the id of each node\n            // to be a path from the root.\n            gcDataBuilder.prefixAndAddNodes(contextId, contextSummary.gcData.gcNodes);\n        }));\n        this.updateGCNodes(gcDataBuilder);\n        return Object.assign(Object.assign({}, summaryBuilder.getSummaryTree()), { gcData: gcDataBuilder.getGCData() });\n    }\n    getAttachSummary() {\n        this.attachGraph();\n        const gcDataBuilder = new GCDataBuilder();\n        const summaryBuilder = new SummaryTreeBuilder();\n        // Craft the .attributes file for each shared object\n        for (const [contextId, context] of this.contexts) {\n            if (!(context instanceof LocalChannelContext)) {\n                throw new Error(\"Should only be called with local channel handles\");\n            }\n            if (!this.notBoundedChannelContextSet.has(contextId)) {\n                let summaryTree;\n                if (context.isLoaded) {\n                    const contextSummary = context.getAttachSummary();\n                    assert(contextSummary.summary.type === 1 /* Tree */, 0x180 /* \"getAttachSummary should always return a tree\" */);\n                    summaryTree = { stats: contextSummary.stats, summary: contextSummary.summary };\n                    // Prefix the child's id to the ids of its GC nodest. This gradually builds the id of each node\n                    // to be a path from the root.\n                    gcDataBuilder.prefixAndAddNodes(contextId, contextSummary.gcData.gcNodes);\n                }\n                else {\n                    // If this channel is not yet loaded, then there should be no changes in the snapshot from which\n                    // it was created as it is detached container. So just use the previous snapshot.\n                    assert(!!this.dataStoreContext.baseSnapshot, 0x181 /* \"BaseSnapshot should be there as detached container loaded from snapshot\" */);\n                    summaryTree = convertSnapshotTreeToSummaryTree(this.dataStoreContext.baseSnapshot.trees[contextId]);\n                }\n                summaryBuilder.addWithStats(contextId, summaryTree);\n            }\n        }\n        this.updateGCNodes(gcDataBuilder);\n        return Object.assign(Object.assign({}, summaryBuilder.getSummaryTree()), { gcData: gcDataBuilder.getGCData() });\n    }\n    submitMessage(type, content, localOpMetadata) {\n        this.submit(type, content, localOpMetadata);\n    }\n    submitSignal(type, content) {\n        this.verifyNotClosed();\n        return this.dataStoreContext.submitSignal(type, content);\n    }\n    /**\n     * Will return when the data store is attached.\n     */\n    async waitAttached() {\n        return this.deferredAttached.promise;\n    }\n    raiseContainerWarning(warning) {\n        this.dataStoreContext.raiseContainerWarning(warning);\n    }\n    /**\n     * Attach channel should only be called after the data store has been attached\n     */\n    attachChannel(channel) {\n        this.verifyNotClosed();\n        // If this handle is already attached no need to attach again.\n        if (channel.handle.isAttached) {\n            return;\n        }\n        channel.handle.attachGraph();\n        assert(this.isAttached, 0x182 /* \"Data store should be attached to attach the channel.\" */);\n        // Get the object snapshot only if the data store is Bound and its graph is attached too,\n        // because if the graph is attaching, then it would get included in the data store snapshot.\n        if (this.bindState === BindState.Bound && this.graphAttachState === AttachState.Attached) {\n            const summarizeResult = summarizeChannel(channel, true /* fullTree */, false /* trackState */);\n            // Attach message needs the summary in ITree format. Convert the ISummaryTree into an ITree.\n            const snapshot = convertSummaryTreeToITree(summarizeResult.summary);\n            const message = {\n                id: channel.id,\n                snapshot,\n                type: channel.attributes.type,\n            };\n            this.pendingAttach.set(channel.id, message);\n            this.submit(DataStoreMessageType.Attach, message);\n        }\n        const context = this.contexts.get(channel.id);\n        context.markAttached();\n    }\n    submitChannelOp(address, contents, localOpMetadata) {\n        const envelope = { address, contents };\n        this.submit(DataStoreMessageType.ChannelOp, envelope, localOpMetadata);\n    }\n    submit(type, content, localOpMetadata = undefined) {\n        this.verifyNotClosed();\n        this.dataStoreContext.submitMessage(type, content, localOpMetadata);\n    }\n    /**\n     * For messages of type MessageType.Operation, finds the right channel and asks it to resubmit the message.\n     * For all other messages, just submit it again.\n     * This typically happens when we reconnect and there are unacked messages.\n     * @param content - The content of the original message.\n     * @param localOpMetadata - The local metadata associated with the original message.\n     */\n    reSubmit(type, content, localOpMetadata) {\n        this.verifyNotClosed();\n        switch (type) {\n            case DataStoreMessageType.ChannelOp:\n                {\n                    // For Operations, find the right channel and trigger resubmission on it.\n                    const envelope = content;\n                    const channelContext = this.contexts.get(envelope.address);\n                    assert(!!channelContext, 0x183 /* \"There should be a channel context for the op\" */);\n                    channelContext.reSubmit(envelope.contents, localOpMetadata);\n                    break;\n                }\n            case DataStoreMessageType.Attach:\n                // For Attach messages, just submit them again.\n                this.submit(type, content, localOpMetadata);\n                break;\n            default:\n                unreachableCase(type);\n        }\n    }\n    async applyStashedOp(content) {\n        const envelope = content;\n        const channelContext = this.contexts.get(envelope.address);\n        assert(!!channelContext, 0x184 /* \"There should be a channel context for the op\" */);\n        await channelContext.getChannel();\n        return channelContext.applyStashedOp(envelope.contents);\n    }\n    setChannelDirty(address) {\n        this.verifyNotClosed();\n        this.dataStoreContext.setChannelDirty(address);\n    }\n    processChannelOp(message, local, localOpMetadata) {\n        this.verifyNotClosed();\n        const envelope = message.contents;\n        const transformed = Object.assign(Object.assign({}, message), { contents: envelope.contents });\n        const channelContext = this.contexts.get(envelope.address);\n        assert(!!channelContext, 0x185 /* \"Channel not found\" */);\n        channelContext.processOp(transformed, local, localOpMetadata);\n        return channelContext;\n    }\n    attachListener() {\n        this.setMaxListeners(Number.MAX_SAFE_INTEGER);\n        this.dataStoreContext.on(\"leader\", () => {\n            this.emit(\"leader\");\n        });\n        this.dataStoreContext.on(\"notleader\", () => {\n            this.emit(\"notleader\");\n        });\n        this.dataStoreContext.once(\"attaching\", () => {\n            assert(this.bindState !== BindState.NotBound, 0x186 /* \"Data store attaching should not occur if it is not bound\" */);\n            this._attachState = AttachState.Attaching;\n            // This promise resolution will be moved to attached event once we fix the scheduler.\n            this.deferredAttached.resolve();\n            this.emit(\"attaching\");\n        });\n        this.dataStoreContext.once(\"attached\", () => {\n            assert(this.bindState === BindState.Bound, 0x187 /* \"Data store should only be attached after it is bound\" */);\n            this._attachState = AttachState.Attached;\n            this.emit(\"attached\");\n        });\n    }\n    verifyNotClosed() {\n        if (this._disposed) {\n            throw new Error(\"Runtime is closed\");\n        }\n    }\n}\n/**\n * Mixin class that adds request handler to FluidDataStoreRuntime\n * Request handler is only called when data store can't resolve request, i.e. for custom requests.\n * @param Base - base class, inherits from FluidDataStoreRuntime\n * @param requestHandler - request handler to mix in\n */\nexport const mixinRequestHandler = (requestHandler, Base = FluidDataStoreRuntime) => class RuntimeWithRequestHandler extends Base {\n    async request(request) {\n        const response = await super.request(request);\n        if (response.status === 404) {\n            return requestHandler(request, this);\n        }\n        return response;\n    }\n};\n/**\n * Mixin class that adds await for DataObject to finish initialization before we proceed to summary.\n * @param Base - base class, inherits from FluidDataStoreRuntime\n */\nexport const mixinSummaryHandler = (handler, Base = FluidDataStoreRuntime) => class RuntimeWithSummarizerHandler extends Base {\n    addBlob(summary, path, content) {\n        const firstName = path.shift();\n        if (firstName === undefined) {\n            throw new Error(\"Path can't be empty\");\n        }\n        let blob = {\n            type: 2 /* Blob */,\n            content,\n        };\n        summary.stats.blobNodeCount++;\n        summary.stats.totalBlobSize += content.length;\n        for (const name of path.reverse()) {\n            blob = {\n                type: 1 /* Tree */,\n                tree: { [name]: blob },\n            };\n            summary.stats.treeNodeCount++;\n        }\n        summary.summary.tree[firstName] = blob;\n    }\n    async summarize(...args) {\n        const summary = await super.summarize(...args);\n        const content = await handler(this);\n        this.addBlob(summary, content.path, content.content);\n        return summary;\n    }\n};\n//# sourceMappingURL=dataStoreRuntime.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport registerDebug from \"debug\";\nimport { pkgName, pkgVersion } from \"./packageVersion\";\nexport const debug = registerDebug(\"fluid:process-loader\");\ndebug(`Package: ${pkgName} - Version: ${pkgVersion}`);\n//# sourceMappingURL=debug.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { generateHandleContextPath } from \"@fluidframework/runtime-utils\";\nexport class FluidObjectHandle {\n    /**\n     * Creates a new FluidObjectHandle.\n     * @param value - The IFluidObject object this handle is for.\n     * @param path - The path to this handle relative to the routeContext.\n     * @param routeContext - The parent IFluidHandleContext that has a route to this handle.\n     */\n    constructor(value, path, routeContext) {\n        this.value = value;\n        this.path = path;\n        this.routeContext = routeContext;\n        // This is used to break the recursion while attaching the graph. Also tells the attach state of the graph.\n        this.graphAttachState = AttachState.Detached;\n        this.absolutePath = generateHandleContextPath(path, this.routeContext);\n    }\n    get IFluidHandle() { return this; }\n    get isAttached() {\n        return this.routeContext.isAttached;\n    }\n    async get() {\n        return this.value;\n    }\n    attachGraph() {\n        // If this handle is already in attaching state in the graph or attached, no need to attach again.\n        if (this.graphAttachState !== AttachState.Detached) {\n            return;\n        }\n        this.graphAttachState = AttachState.Attaching;\n        if (this.bound !== undefined) {\n            for (const handle of this.bound) {\n                handle.attachGraph();\n            }\n            this.bound = undefined;\n        }\n        this.routeContext.attachGraph();\n        this.graphAttachState = AttachState.Attached;\n    }\n    bind(handle) {\n        // If the dds is already attached or its graph is already in attaching or attached state,\n        // then attach the incoming handle too.\n        if (this.isAttached || this.graphAttachState !== AttachState.Detached) {\n            handle.attachGraph();\n            return;\n        }\n        if (this.bound === undefined) {\n            this.bound = new Set();\n        }\n        this.bound.add(handle);\n    }\n}\n//# sourceMappingURL=fluidHandle.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n// eslint-disable-next-line import/no-internal-modules\nimport cloneDeep from \"lodash/cloneDeep\";\nimport { readAndParse } from \"@fluidframework/driver-utils\";\nimport { CreateContainerError } from \"@fluidframework/container-utils\";\nimport { assert, Lazy, stringToBuffer } from \"@fluidframework/common-utils\";\nimport { createServiceEndpoints, summarizeChannel, } from \"./channelContext\";\n/**\n * Channel context for a locally created channel\n */\nexport class LocalChannelContext {\n    constructor(id, registry, type, runtime, dataStoreContext, storageService, submitFn, dirtyFn, snapshotTree) {\n        this.id = id;\n        this.runtime = runtime;\n        this.dataStoreContext = dataStoreContext;\n        this.storageService = storageService;\n        this.submitFn = submitFn;\n        this.snapshotTree = snapshotTree;\n        this.attached = false;\n        this.pending = [];\n        let blobMap;\n        const clonedSnapshotTree = cloneDeep(this.snapshotTree);\n        if (clonedSnapshotTree !== undefined) {\n            blobMap = new Map();\n            this.collectExtraBlobsAndSanitizeSnapshot(clonedSnapshotTree, blobMap);\n        }\n        this.services = new Lazy(() => {\n            return createServiceEndpoints(this.id, this.dataStoreContext.connected, this.submitFn, this.dirtyFn, this.storageService, clonedSnapshotTree, blobMap);\n        });\n        this.factory = registry.get(type);\n        if (this.factory === undefined) {\n            throw new Error(`Channel Factory ${type} not registered`);\n        }\n        if (snapshotTree === undefined) {\n            this.channel = this.factory.create(runtime, id);\n        }\n        this.dirtyFn = () => { dirtyFn(id); };\n    }\n    async getChannel() {\n        if (this.channel === undefined) {\n            this.channel = await this.loadChannel();\n        }\n        return this.channel;\n    }\n    get isLoaded() {\n        return this.channel !== undefined;\n    }\n    setConnectionState(connected, clientId) {\n        // Connection events are ignored if the data store is not yet attached or loaded\n        if (this.attached && this.isLoaded) {\n            this.services.value.deltaConnection.setConnectionState(connected);\n        }\n    }\n    processOp(message, local, localOpMetadata) {\n        assert(this.attached, 0x188 /* \"Local channel must be attached when processing op\" */);\n        // A local channel may not be loaded in case where we rehydrate the container from a snapshot because of\n        // delay loading. So after the container is attached and some other client joins which start generating\n        // ops for this channel. So not loaded local channel can still receive ops and we store them to process later.\n        if (this.isLoaded) {\n            this.services.value.deltaConnection.process(message, local, localOpMetadata);\n        }\n        else {\n            assert(local === false, 0x189 /* \"Should always be remote because a local dds shouldn't generate ops before loading\" */);\n            this.pending.push(message);\n        }\n    }\n    reSubmit(content, localOpMetadata) {\n        assert(this.isLoaded, 0x18a /* \"Channel should be loaded to resubmit ops\" */);\n        assert(this.attached, 0x18b /* \"Local channel must be attached when resubmitting op\" */);\n        this.services.value.deltaConnection.reSubmit(content, localOpMetadata);\n    }\n    applyStashedOp() {\n        throw new Error(\"no stashed ops on local channel\");\n    }\n    /**\n     * Returns a summary at the current sequence number.\n     * @param fullTree - true to bypass optimizations and force a full summary tree\n     * @param trackState - This tells whether we should track state from this summary.\n     */\n    async summarize(fullTree = false, trackState = false) {\n        assert(this.isLoaded && this.channel !== undefined, 0x18c /* \"Channel should be loaded to summarize\" */);\n        return summarizeChannel(this.channel, fullTree, trackState);\n    }\n    getAttachSummary() {\n        assert(this.isLoaded && this.channel !== undefined, 0x18d /* \"Channel should be loaded to take snapshot\" */);\n        return summarizeChannel(this.channel, true /* fullTree */, false /* trackState */);\n    }\n    async loadChannel() {\n        assert(!this.isLoaded, 0x18e /* \"Channel must not already be loaded when loading\" */);\n        assert(!!this.snapshotTree, 0x18f /* \"Snapshot should be provided to load from!!\" */);\n        assert(await this.services.value.objectStorage.contains(\".attributes\"), 0x190 /* \".attributes blob should be present\" */);\n        const attributes = await readAndParse(this.services.value.objectStorage, \".attributes\");\n        assert(!!this.factory, 0x191 /* \"Factory should be there for local channel\" */);\n        // Services will be assigned during this load.\n        const channel = await this.factory.load(this.runtime, this.id, this.services.value, attributes);\n        // Commit changes.\n        this.channel = channel;\n        // Send all pending messages to the channel\n        for (const message of this.pending) {\n            try {\n                this.services.value.deltaConnection.process(message, false, undefined /* localOpMetadata */);\n            }\n            catch (err) {\n                // record sequence number for easier debugging\n                const error = CreateContainerError(err);\n                error.sequenceNumber = message.sequenceNumber;\n                // eslint-disable-next-line @typescript-eslint/no-throw-literal\n                throw error;\n            }\n        }\n        return this.channel;\n    }\n    markAttached() {\n        if (this.attached) {\n            throw new Error(\"Channel is already attached\");\n        }\n        if (this.isLoaded) {\n            assert(!!this.channel, 0x192 /* \"Channel should be there if loaded!!\" */);\n            this.channel.connect(this.services.value);\n        }\n        this.attached = true;\n    }\n    collectExtraBlobsAndSanitizeSnapshot(snapshotTree, blobMap) {\n        const blobMapInitial = new Map(Object.entries(snapshotTree.blobs));\n        for (const [blobName, blobId] of blobMapInitial.entries()) {\n            const blobValue = blobMapInitial.get(blobId);\n            if (blobValue !== undefined) {\n                blobMap.set(blobId, stringToBuffer(blobValue, \"base64\"));\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete snapshotTree.blobs[blobName];\n            }\n        }\n        for (const value of Object.values(snapshotTree.trees)) {\n            this.collectExtraBlobsAndSanitizeSnapshot(value, blobMap);\n        }\n    }\n    /**\n     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this context.\n     * Each node has a set of outbound routes to other GC nodes in the document. This should be called only after\n     * the context has loaded.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCData(fullGC = false) {\n        assert(this.isLoaded && this.channel !== undefined, 0x193 /* \"Channel should be loaded to run GC\" */);\n        return this.channel.getGCData(fullGC);\n    }\n    updateUsedRoutes(usedRoutes) {\n        /**\n         * Currently, DDSs are always considered referenced and are not garbage collected.\n         * Once we have GC at DDS level, this channel context's used routes will be updated as per the passed\n         * value. See - https://github.com/microsoft/FluidFramework/issues/4611\n         */\n    }\n}\n//# sourceMappingURL=localChannelContext.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n *\n * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n */\nexport const pkgName = \"@fluidframework/datastore\";\nexport const pkgVersion = \"0.37.4\";\n//# sourceMappingURL=packageVersion.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { CreateContainerError, DataCorruptionError } from \"@fluidframework/container-utils\";\nimport { readAndParse } from \"@fluidframework/driver-utils\";\nimport { attributesBlobKey, createServiceEndpoints, summarizeChannel, } from \"./channelContext\";\nimport { debug } from \"./debug\";\nexport class RemoteChannelContext {\n    constructor(runtime, dataStoreContext, storageService, submitFn, dirtyFn, id, baseSnapshot, registry, extraBlobs, createSummarizerNode, gcDetailsInInitialSummary, attachMessageType) {\n        this.runtime = runtime;\n        this.dataStoreContext = dataStoreContext;\n        this.id = id;\n        this.registry = registry;\n        this.attachMessageType = attachMessageType;\n        this.isLoaded = false;\n        this.pending = [];\n        this.services = createServiceEndpoints(this.id, this.dataStoreContext.connected, submitFn, () => dirtyFn(this.id), storageService, baseSnapshot, extraBlobs);\n        const thisSummarizeInternal = async (fullTree, trackState) => this.summarizeInternal(fullTree, trackState);\n        this.summarizerNode = createSummarizerNode(thisSummarizeInternal, async (fullGC) => this.getGCDataInternal(fullGC), async () => gcDetailsInInitialSummary());\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\n    getChannel() {\n        if (this.channelP === undefined) {\n            this.channelP = this.loadChannel();\n        }\n        return this.channelP;\n    }\n    setConnectionState(connected, clientId) {\n        // Connection events are ignored if the data store is not yet loaded\n        if (!this.isLoaded) {\n            return;\n        }\n        this.services.deltaConnection.setConnectionState(connected);\n    }\n    applyStashedOp(message) {\n        assert(this.isLoaded, 0x194 /* \"Remote channel must be loaded when rebasing op\" */);\n        return this.services.deltaConnection.applyStashedOp(message);\n    }\n    processOp(message, local, localOpMetadata) {\n        this.summarizerNode.invalidate(message.sequenceNumber);\n        if (this.isLoaded) {\n            this.services.deltaConnection.process(message, local, localOpMetadata);\n        }\n        else {\n            assert(!local, 0x195 /* \"Remote channel must not be local when processing op\" */);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.pending.push(message);\n        }\n    }\n    reSubmit(content, localOpMetadata) {\n        assert(this.isLoaded, 0x196 /* \"Remote channel must be loaded when resubmitting op\" */);\n        this.services.deltaConnection.reSubmit(content, localOpMetadata);\n    }\n    /**\n     * Returns a summary at the current sequence number.\n     * @param fullTree - true to bypass optimizations and force a full summary tree\n     * @param trackState - This tells whether we should track state from this summary.\n     */\n    async summarize(fullTree = false, trackState = true) {\n        return this.summarizerNode.summarize(fullTree, trackState);\n    }\n    async summarizeInternal(fullTree, trackState) {\n        const channel = await this.getChannel();\n        const summarizeResult = summarizeChannel(channel, fullTree, trackState);\n        return Object.assign(Object.assign({}, summarizeResult), { id: this.id });\n    }\n    async loadChannel() {\n        assert(!this.isLoaded, 0x197 /* \"Remote channel must not already be loaded when loading\" */);\n        let attributes;\n        if (await this.services.objectStorage.contains(attributesBlobKey)) {\n            attributes = await readAndParse(this.services.objectStorage, attributesBlobKey);\n        }\n        let factory;\n        // this is a backward compatibility case where\n        // the attach message doesn't include\n        // the attributes. Since old attach messages\n        // will not have attributes we need to keep\n        // this as long as we support old attach messages\n        if (attributes === undefined) {\n            if (this.attachMessageType === undefined) {\n                // TODO: Strip out potential PII content #1920\n                throw new DataCorruptionError(\"Channel type not available\", {\n                    channelId: this.id,\n                    dataStoreId: this.dataStoreContext.id,\n                    dataStorePackagePath: this.dataStoreContext.packagePath.join(\"/\"),\n                });\n            }\n            factory = this.registry.get(this.attachMessageType);\n            if (factory === undefined) {\n                // TODO: Strip out potential PII content #1920\n                throw new DataCorruptionError(`Channel Factory ${this.attachMessageType} for attach not registered`, {\n                    channelId: this.id,\n                    dataStoreId: this.dataStoreContext.id,\n                    dataStorePackagePath: this.dataStoreContext.packagePath.join(\"/\"),\n                    channelFactoryType: this.attachMessageType,\n                });\n            }\n            attributes = factory.attributes;\n        }\n        else {\n            factory = this.registry.get(attributes.type);\n            if (factory === undefined) {\n                // TODO: Strip out potential PII content #1920\n                throw new DataCorruptionError(`Channel Factory ${attributes.type} not registered`, {\n                    channelId: this.id,\n                    dataStoreId: this.dataStoreContext.id,\n                    dataStorePackagePath: this.dataStoreContext.packagePath.join(\"/\"),\n                    channelFactoryType: attributes.type,\n                });\n            }\n        }\n        // Compare snapshot version to collaborative object version\n        if (attributes.snapshotFormatVersion !== undefined\n            && attributes.snapshotFormatVersion !== factory.attributes.snapshotFormatVersion) {\n            debug(`Snapshot version mismatch. Type: ${attributes.type}, ` +\n                `Snapshot format@pkg version: ${attributes.snapshotFormatVersion}@${attributes.packageVersion}, ` +\n                // eslint-disable-next-line max-len\n                `client format@pkg version: ${factory.attributes.snapshotFormatVersion}@${factory.attributes.packageVersion}`);\n        }\n        const channel = await factory.load(this.runtime, this.id, this.services, attributes);\n        // Send all pending messages to the channel\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        for (const message of this.pending) {\n            try {\n                this.services.deltaConnection.process(message, false, undefined /* localOpMetadata */);\n            }\n            catch (err) {\n                // record sequence number for easier debugging\n                const error = CreateContainerError(err);\n                error.sequenceNumber = message.sequenceNumber;\n                // eslint-disable-next-line @typescript-eslint/no-throw-literal\n                throw error;\n            }\n        }\n        // Commit changes.\n        this.channel = channel;\n        this.pending = undefined;\n        this.isLoaded = true;\n        // Because have some await between we created the service and here, the connection state might have changed\n        // and we don't propagate the connection state when we are not loaded.  So we have to set it again here.\n        this.services.deltaConnection.setConnectionState(this.dataStoreContext.connected);\n        return this.channel;\n    }\n    /**\n     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this context.\n     * Each node has a set of outbound routes to other GC nodes in the document.\n     * If there is no new data in this context since the last summary, previous GC data is used.\n     * If there is new data, the GC data is generated again (by calling getGCDataInternal).\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCData(fullGC = false) {\n        return this.summarizerNode.getGCData(fullGC);\n    }\n    /**\n     * Generates the data used for garbage collection. This is called when there is new data since last summary. It\n     * loads the context and calls into the channel to get its GC data.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCDataInternal(fullGC = false) {\n        const channel = await this.getChannel();\n        return channel.getGCData(fullGC);\n    }\n    /**\n     * After GC has run, called to notify the context of routes used in it. These are used for the following:\n     * 1. To identify if this context is being referenced in the document or not.\n     * 2. To determine if it needs to re-summarize in case used routes changed since last summary.\n     * 3. These are added to the summary generated by the context.\n     * @param usedRoutes - The routes that are used in this context.\n     */\n    updateUsedRoutes(usedRoutes) {\n        /**\n         * Currently, DDSs are always considered referenced and are not garbage collected. Update the summarizer node's\n         * used routes to contain a route to this channel context.\n         * Once we have GC at DDS level, this will be updated to use the passed usedRoutes. See -\n         * https://github.com/microsoft/FluidFramework/issues/4611\n         */\n        this.summarizerNode.updateUsedRoutes([\"\"]);\n    }\n}\n//# sourceMappingURL=remoteChannelContext.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Driver Error types\n * Lists types that are likely to be used by all drivers\n */\nexport var DriverErrorType;\n(function (DriverErrorType) {\n    /**\n     * Some error, most likely an exception caught by runtime and propagated to container as critical error\n     */\n    DriverErrorType[\"genericError\"] = \"genericError\";\n    /**\n     * Some non-categorized (below) networking error\n     * Include errors like  fatal server error (usually 500).\n     */\n    DriverErrorType[\"genericNetworkError\"] = \"genericNetworkError\";\n    /**\n     * Access denied - user does not have enough privileges to open a file, or continue to operate on a file\n     */\n    DriverErrorType[\"authorizationError\"] = \"authorizationError\";\n    /**\n     * File not found, or file deleted during session\n     */\n    DriverErrorType[\"fileNotFoundOrAccessDeniedError\"] = \"fileNotFoundOrAccessDeniedError\";\n    /**\n     * Throttling error from server. Server is busy and is asking not to reconnect for some time\n     */\n    DriverErrorType[\"throttlingError\"] = \"throttlingError\";\n    /**\n     * We can not reach server due to computer being offline.\n     */\n    DriverErrorType[\"offlineError\"] = \"offlineError\";\n    /*\n     * Unsupported client protocol\n     */\n    DriverErrorType[\"unsupportedClientProtocolVersion\"] = \"unsupportedClientProtocolVersion\";\n    /**\n     * User does not have write permissions to a file, but is changing content of a file.\n     * That might be indication of some data store error - data stores should not generate ops in readonly mode.\n     */\n    DriverErrorType[\"writeError\"] = \"writeError\";\n    /**\n     * Generic fetch failure.\n     * Most of such failures are due to client being offline, or DNS is not reachable, such errors map to\n     * DriverErrorType.offlineError. Anything else that can't be diagnose as likely offline maps to this error.\n     * This can also indicate no response from server.\n     */\n    DriverErrorType[\"fetchFailure\"] = \"fetchFailure\";\n    /**\n     * Unexpected response from server. Either JSON is malformed, or some required properties are missing\n     */\n    DriverErrorType[\"incorrectServerResponse\"] = \"incorrectServerResponse\";\n})(DriverErrorType || (DriverErrorType = {}));\n//# sourceMappingURL=driverError.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nexport var LoaderCachingPolicy;\n(function (LoaderCachingPolicy) {\n    /**\n     * The loader should not implement any prefetching or caching policy.\n     */\n    LoaderCachingPolicy[LoaderCachingPolicy[\"NoCaching\"] = 0] = \"NoCaching\";\n    /**\n     * The loader should implement prefetching policy, i.e. it should prefetch resources from the latest snapshot.\n     */\n    LoaderCachingPolicy[LoaderCachingPolicy[\"Prefetch\"] = 1] = \"Prefetch\";\n})(LoaderCachingPolicy || (LoaderCachingPolicy = {}));\n//# sourceMappingURL=storage.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Additional key in the loader request header\n */\nexport var DriverHeader;\n(function (DriverHeader) {\n    // Key to indicate whether the request for summarizer\n    DriverHeader[\"summarizingClient\"] = \"fluid-client-summarizer\";\n    // createNew information, specific to each driver\n    DriverHeader[\"createNew\"] = \"createNew\";\n})(DriverHeader || (DriverHeader = {}));\n//# sourceMappingURL=urlResolver.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, bufferToString, stringToBuffer, unreachableCase, fromUtf8ToBase64, Uint8ArrayToString, } from \"@fluidframework/common-utils\";\n// Gate that when flipped, instructs to compress small blobs.\n// We have to first ship with this gate off, such that we can get to saturation bits\n// that can understand compressed format. And only after that flip it.\nfunction gatesAllowPacking() {\n    try {\n        // Leave override for testing purposes\n        // eslint-disable-next-line no-null/no-null\n        if (typeof localStorage === \"object\" && localStorage !== null) {\n            if (localStorage.FluidAggregateBlobs === \"1\") {\n                return true;\n            }\n            if (localStorage.FluidAggregateBlobs === \"0\") {\n                return false;\n            }\n        }\n    }\n    catch (e) { }\n    // We are starting disabled.\n    return false;\n}\n/*\n * Work around for bufferToString having a bug - it can't consume IsoBuffer!\n * To be removed once bufferToString is fixed!\n*/\nfunction bufferToString2(blob, encoding) {\n    if (blob instanceof Uint8Array) { // IsoBuffer does not have ctor, so it's not in proto chain :(\n        return Uint8ArrayToString(blob, encoding);\n    }\n    return bufferToString(blob, encoding);\n}\n/**\n * Class responsible for aggregating smaller blobs into one and unpacking it later on.\n */\nclass BlobAggregator {\n    constructor() {\n        this.content = [];\n    }\n    addBlob(key, content) {\n        this.content.push([key, content]);\n    }\n    getAggregatedBlobContent() {\n        if (this.content.length === 0) {\n            return undefined;\n        }\n        return JSON.stringify(this.content);\n    }\n    static load(input) {\n        const data = bufferToString2(input, \"utf-8\");\n        return JSON.parse(data);\n    }\n}\n/*\n * Base class that deals with unpacking snapshots (in place) containing aggregated blobs\n * It relies on abstract methods for reads and storing unpacked blobs.\n */\nexport class SnapshotExtractor {\n    constructor() {\n        this.aggregatedBlobName = \"__big\";\n        this.virtualIdPrefix = \"__\";\n        // counter for generation of virtual storage IDs\n        this.virtualIdCounter = 0;\n    }\n    getNextVirtualId() {\n        return `${this.virtualIdPrefix}${++this.virtualIdCounter}`;\n    }\n    async unpackSnapshotCore(snapshot, level = 0) {\n        // for now only working at data store level, i.e.\n        // .app/DataStore/...\n        if (level >= 2) {\n            return;\n        }\n        for (const key of Object.keys(snapshot.trees)) {\n            const obj = snapshot.trees[key];\n            await this.unpackSnapshotCore(obj, level + 1);\n        }\n        // For future proof, we will support multiple aggregated blobs with any name\n        // that starts with this.aggregatedBlobName\n        for (const key of Object.keys(snapshot.blobs)) {\n            if (!key.startsWith(this.aggregatedBlobName)) {\n                continue;\n            }\n            const blobId = snapshot.blobs[key];\n            if (blobId !== undefined) {\n                const blob = await this.getBlob(blobId, snapshot);\n                for (const [path, value] of BlobAggregator.load(blob)) {\n                    const id = this.getNextVirtualId();\n                    this.setBlob(id, snapshot, value);\n                    const pathSplit = path.split(\"/\");\n                    let subTree = snapshot;\n                    for (const subPath of pathSplit.slice(0, pathSplit.length - 1)) {\n                        if (subTree.trees[subPath] === undefined) {\n                            subTree.trees[subPath] = { blobs: {}, commits: {}, trees: {} };\n                        }\n                        subTree = subTree.trees[subPath];\n                    }\n                    const blobName = pathSplit[pathSplit.length - 1];\n                    assert(subTree.blobs[blobName] === undefined, 0x0f6 /* \"real blob ID exists\" */);\n                    subTree.blobs[blobName] = id;\n                }\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete snapshot.blobs[this.aggregatedBlobName];\n            }\n        }\n    }\n}\n/*\n * Snapshot extractor class that works in place, i.e. patches snapshot that has\n * blob content in ISnapshotTree.blobs itself, not in storage.\n * As result, it implements reading and writing of blobs to/from snapshot itself.\n * It follows existing pattern that mixes concerns - ISnapshotTree.blobs is used for two\n * purposes:\n * 1. map path name to blob ID\n * 2. map blob ID to blob content\n * #2 is what storage (IDocumentStorageService) is for, but in places where we do not have it\n * (like loading serialized earlier draft content), blob content is put directly into snapshot.\n * Ideally this should be fixed by using BlobCacheStorageService or something similar and\n * fixing existing flows to allow switching of storage.\n */\nclass SnapshotExtractorInPlace extends SnapshotExtractor {\n    async getBlob(id, tree) {\n        const blob = tree.blobs[id];\n        assert(blob !== undefined, 0x0f7 /* \"aggregate blob missing\" */);\n        return stringToBuffer(blob, \"base64\");\n    }\n    setBlob(id, tree, content) {\n        assert(tree.blobs[id] === undefined, 0x0f8 /* \"blob from aggregate blob exists on its own\" */);\n        tree.blobs[id] = fromUtf8ToBase64(content);\n    }\n}\n/*\n * Snapshot packer and extractor.\n * When summary is written it will find and aggregate small blobs into bigger blobs\n * When snapshot is read, it will unpack aggregated blobs and provide them transparently to caller.\n */\nexport class BlobAggregationStorage extends SnapshotExtractor {\n    constructor(storage, logger, allowPacking, blobCutOffSize) {\n        super();\n        this.storage = storage;\n        this.logger = logger;\n        this.allowPacking = allowPacking;\n        this.blobCutOffSize = blobCutOffSize;\n        this.loadedFromSummary = false;\n        this.virtualBlobs = new Map();\n    }\n    static wrap(storage, logger, allowPacking = gatesAllowPacking()) {\n        var _a;\n        if (storage instanceof BlobAggregationStorage) {\n            return storage;\n        }\n        // Always create BlobAggregationStorage even if storage is not asking for packing.\n        // This is mostly to avoid cases where future changes in policy would result in inability to\n        // load old files that were created with aggregation on.\n        const minBlobSize = (_a = storage.policies) === null || _a === void 0 ? void 0 : _a.minBlobSize;\n        return new BlobAggregationStorage(storage, logger, allowPacking, minBlobSize);\n    }\n    static async unpackSnapshot(snapshot) {\n        const converter = new SnapshotExtractorInPlace();\n        await converter.unpackSnapshotCore(snapshot);\n    }\n    get policies() {\n        const policies = this.storage.policies;\n        if (policies) {\n            return Object.assign(Object.assign({}, policies), { minBlobSize: undefined });\n        }\n    }\n    async unpackSnapshot(snapshot) {\n        // SummarizerNodeWithGC.refreshLatestSummary can call it when this.loadedFromSummary === false\n        // (I assumed after file was created)\n        // assert(!this.loadedFromSummary, \"unpack without summary\");\n        this.loadedFromSummary = true;\n        await this.unpackSnapshotCore(snapshot);\n    }\n    setBlob(id, tree, content) {\n        this.virtualBlobs.set(id, stringToBuffer(content, \"utf-8\"));\n    }\n    async getBlob(id, tree) {\n        return this.readBlob(id).catch((error) => {\n            this.logger.sendErrorEvent({ eventName: \"BlobDedupNoAggregateBlob\" }, error);\n            throw error;\n        });\n    }\n    get repositoryUrl() { return this.storage.repositoryUrl; }\n    async getVersions(versionId, count) {\n        return this.storage.getVersions(versionId, count);\n    }\n    async downloadSummary(handle) {\n        throw new Error(\"NYI\");\n    }\n    // This is only used through Container.snapshot() for testing purposes\n    async write(root, parents, message, ref) {\n        return this.storage.write(root, parents, message, ref);\n    }\n    // for now we are not optimizing these blobs, with assumption that this API is used only\n    // for big blobs (images)\n    async createBlob(file) {\n        return this.storage.createBlob(file);\n    }\n    async getSnapshotTree(version) {\n        const tree = await this.storage.getSnapshotTree(version);\n        if (tree) {\n            await this.unpackSnapshot(tree);\n        }\n        return tree;\n    }\n    async read(id) {\n        // optimize it a bit to avoid unneeded conversions while we transition to using readBlob everywhere.\n        if (this.isRealStorageId(id)) {\n            return bufferToString2(await this.storage.readBlob(id), \"base64\");\n        }\n        const blob = await this.readBlob(id);\n        return bufferToString2(blob, \"base64\");\n    }\n    async readBlob(id) {\n        if (this.isRealStorageId(id)) {\n            return this.storage.readBlob(id);\n        }\n        // We support only reading blobs from the summary we loaded from.\n        // This may need to be extended to any general summary in the future as runtime usage pattern\n        // of storage changes (for example, data stores start to load from recent summary, not from original\n        // summary whole container loaded from)\n        // are there other ways we can get here? createFile is one flow, but we should not be reading blobs\n        // in such flow\n        assert(this.loadedFromSummary, 0x0f9 /* \"never read summary\" */);\n        const blob = this.virtualBlobs.get(id);\n        assert(blob !== undefined, 0x0fa /* \"virtual blob not found\" */);\n        return blob;\n    }\n    async uploadSummaryWithContext(summary, context) {\n        const summaryNew = this.allowPacking ? await this.compressSmallBlobs(summary) : summary;\n        return this.storage.uploadSummaryWithContext(summaryNew, context);\n    }\n    // For simplification, we assume that\n    // - blob aggregation is done at data store level only for now\n    // - data store either reuses previous summary, or generates full summary, i.e. there is no partial (some DDS)\n    // summary produced by data stores.\n    // These simplifications allow us not to touch handles, as they are self-contained (either do not use aggregated\n    // blob Or contain aggregated blob that stays relevant for that sub-tree)\n    // Note:\n    // From perf perspective, it makes sense to place aggregated blobs one level up in the tree not to create extra\n    // tree nodes (i.e. have shallow tree with less edges). But that creates problems with reusability of trees at\n    // incremental summary time - we would need to understand handles and parse them. In current design we can skip\n    // that step because if data store is reused, the hole sub-tree is reused included aggregated blob embedded into it\n    // and that means we can do nothing and be correct!\n    async compressSmallBlobs(summary, path = \"\", level = 0, aggregatorArg) {\n        if (this.blobCutOffSize === undefined || this.blobCutOffSize < 0) {\n            return summary;\n        }\n        // Only pack at data store level.\n        const startingLevel = level === 1;\n        let aggregator = aggregatorArg;\n        if (startingLevel) {\n            assert(aggregator === undefined, 0x0fb /* \"logic err with aggregator\" */);\n            aggregator = new BlobAggregator();\n        }\n        const newSummary = Object.assign({}, summary);\n        newSummary.tree = Object.assign({}, newSummary.tree);\n        for (const key of Object.keys(summary.tree)) {\n            const obj = summary.tree[key];\n            // Get path relative to root of data store (where we do aggregation)\n            const newPath = startingLevel ? key : `${path}/${key}`;\n            switch (obj.type) {\n                case 1 /* Tree */:\n                    // If client created empty tree, keep it as is\n                    // Also do not package search blobs - they are part of storage contract\n                    if (obj.tree !== {} && key !== \"__search\") {\n                        const tree = await this.compressSmallBlobs(obj, newPath, level + 1, aggregator);\n                        newSummary.tree[key] = tree;\n                        if (tree.tree === {}) {\n                            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                            delete newSummary.tree[key];\n                        }\n                    }\n                    break;\n                case 2 /* Blob */:\n                    if (aggregator && typeof obj.content == \"string\" && obj.content.length < this.blobCutOffSize) {\n                        aggregator.addBlob(newPath, obj.content);\n                        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                        delete newSummary.tree[key];\n                    }\n                    break;\n                case 3 /* Handle */: {\n                    // Would be nice to:\n                    // Trees: expand the tree\n                    // Blobs: parse handle and ensure it points to real blob, not virtual blob.\n                    // We can avoid it for now given data store is the granularity of incremental summaries.\n                    let handlePath = obj.handle;\n                    if (handlePath.startsWith(\"/\")) {\n                        handlePath = handlePath.substr(1);\n                    }\n                    // Ensure only whole data stores can be reused, no reusing at deeper level!\n                    assert(level === 0, 0x0fc /* \"tree reuse at lower level\" */);\n                    assert(handlePath.indexOf(\"/\") === -1, 0x0fd /* \"data stores are writing incremental summaries!\" */);\n                    break;\n                }\n                case 4 /* Attachment */:\n                    assert(this.isRealStorageId(obj.id), 0x0fe /* \"attachment is aggregate blob\" */);\n                    break;\n                default:\n                    unreachableCase(obj, `Unknown type: ${obj.type}`);\n            }\n        }\n        assert(newSummary.tree[this.aggregatedBlobName] === undefined, 0x0ff /* \"duplicate aggregate blob\" */);\n        if (startingLevel) {\n            // Note: It would be great to add code here to unpack aggregate blob back to normal blobs\n            // If only one blob made it into aggregate. Currently that does not happen as we always have\n            // at least one .component blob and at least one DDS that has .attributes blob, so it's not an issue.\n            // But it's possible that in future that would be great addition!\n            // Good news - it's backward compatible change.\n            assert(aggregator !== undefined, 0x100 /* \"logic error\" */);\n            const content = aggregator.getAggregatedBlobContent();\n            if (content !== undefined) {\n                newSummary.tree[this.aggregatedBlobName] = {\n                    type: 2 /* Blob */,\n                    content,\n                };\n            }\n        }\n        return newSummary;\n    }\n    isRealStorageId(id) {\n        return !id.startsWith(this.virtualIdPrefix);\n    }\n}\n// Tells data store if it can use incremental summary (i.e. reuse DDSs from previous summary\n// when only one DDS changed).\n// The answer has to be know long before we enable actual packing. The reason for the is the following:\n// A the moment when we enable packing, we should assume that all clients out there wil already have bits\n// that can unpack properly (i.e. enough time passed since we deployed bits that can unpack)\n// But we can still have clients where some of them already pack, and some do not. If one summary was\n// using packing, then it relies on non-incremental summaries going forward, even if next client who\n// produced summary is not packing!\n// This can have slight improvement by enabling it per file (based on \"did summary we loaded from contain\n// aggregated blobs\"), but that's harder to make reliable, so going for simplicity.\nBlobAggregationStorage.fullDataStoreSummaries = true;\n//# sourceMappingURL=blobAggregationStorage.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { bufferToString } from \"@fluidframework/common-utils\";\nimport { DocumentStorageServiceProxy } from \"./documentStorageServiceProxy\";\n/**\n * IDocumentStorageService adapter with pre-cached blobs.\n */\nexport class BlobCacheStorageService extends DocumentStorageServiceProxy {\n    constructor(internalStorageService, blobs) {\n        super(internalStorageService);\n        this.blobs = blobs;\n    }\n    get policies() {\n        return this.internalStorageService.policies;\n    }\n    async read(id) {\n        const blob = this.blobs.get(id);\n        if (blob !== undefined) {\n            return bufferToString(blob, \"base64\");\n        }\n        return bufferToString(await this.internalStorageService.readBlob(id), \"base64\");\n    }\n    async readBlob(id) {\n        const blob = this.blobs.get(id);\n        if (blob !== undefined) {\n            return blob;\n        }\n        return this.internalStorageService.readBlob(id);\n    }\n}\n//# sourceMappingURL=blobCacheStorageService.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, stringToBuffer } from \"@fluidframework/common-utils\";\nimport { FileMode, TreeEntry, } from \"@fluidframework/protocol-definitions\";\nimport { buildHierarchy } from \"@fluidframework/protocol-base\";\nimport { v4 as uuid } from \"uuid\";\nfunction flattenCore(path, treeEntries, blobMap) {\n    const entries = [];\n    for (const treeEntry of treeEntries) {\n        const subPath = `${path}${treeEntry.path}`;\n        if (treeEntry.type === TreeEntry.Blob) {\n            const blob = treeEntry.value;\n            const buffer = stringToBuffer(blob.contents, blob.encoding);\n            const id = uuid();\n            blobMap.set(id, buffer);\n            const entry = {\n                mode: FileMode[treeEntry.mode],\n                path: subPath,\n                sha: id,\n                size: 0,\n                type: \"blob\",\n                url: \"\",\n            };\n            entries.push(entry);\n        }\n        else if (treeEntry.type === TreeEntry.Commit) {\n            const entry = {\n                mode: FileMode[treeEntry.mode],\n                path: subPath,\n                sha: treeEntry.value,\n                size: -1,\n                type: \"commit\",\n                url: \"\",\n            };\n            entries.push(entry);\n        }\n        else {\n            assert(treeEntry.type === TreeEntry.Tree, 0x101 /* \"Unexpected tree entry type on flatten!\" */);\n            const t = treeEntry.value;\n            const entry = {\n                mode: FileMode[treeEntry.mode],\n                path: subPath,\n                sha: \"\",\n                size: -1,\n                type: \"tree\",\n                url: \"\",\n            };\n            entries.push(entry);\n            const subTreeEntries = flattenCore(`${subPath}/`, t.entries, blobMap);\n            entries.push(...subTreeEntries);\n        }\n    }\n    return entries;\n}\n/**\n * Create a flatten view of an array of ITreeEntry\n *\n * @param tree - an array of ITreeEntry to flatten\n * @param blobMap - a map of blob's sha1 to content\n * @returns A flatten with of the ITreeEntry\n */\nfunction flatten(tree, blobMap) {\n    const entries = flattenCore(\"\", tree, blobMap);\n    return {\n        sha: \"\",\n        tree: entries,\n        url: \"\",\n    };\n}\n/**\n * Build a tree hierarchy base on an array of ITreeEntry\n *\n * @param entries - an array of ITreeEntry to flatten\n * @param blobMap - a map of blob's sha1 to content that gets filled with content from entries\n * NOTE: blobMap's validity is contingent on the returned promise's resolution\n * @returns the hierarchical tree\n */\nexport function buildSnapshotTree(entries, blobMap) {\n    const flattened = flatten(entries, blobMap);\n    return buildHierarchy(flattened);\n}\n//# sourceMappingURL=buildSnapshotTree.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nexport class DocumentStorageServiceProxy {\n    constructor(internalStorageService) {\n        this.internalStorageService = internalStorageService;\n    }\n    get repositoryUrl() {\n        return this.internalStorageService.repositoryUrl;\n    }\n    async getSnapshotTree(version) {\n        return this.internalStorageService.getSnapshotTree(version);\n    }\n    async getVersions(versionId, count) {\n        return this.internalStorageService.getVersions(versionId, count);\n    }\n    async write(tree, parents, message, ref) {\n        return this.internalStorageService.write(tree, parents, message, ref);\n    }\n    async uploadSummaryWithContext(summary, context) {\n        return this.internalStorageService.uploadSummaryWithContext(summary, context);\n    }\n    async downloadSummary(handle) {\n        return this.internalStorageService.downloadSummary(handle);\n    }\n    async createBlob(file) {\n        return this.internalStorageService.createBlob(file);\n    }\n    async readBlob(blobId) {\n        return this.internalStorageService.readBlob(blobId);\n    }\n}\n//# sourceMappingURL=documentStorageServiceProxy.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nexport const isFluidResolvedUrl = (resolved) => (resolved === null || resolved === void 0 ? void 0 : resolved.type) === \"fluid\";\nexport function ensureFluidResolvedUrl(resolved) {\n    if (!isFluidResolvedUrl(resolved)) {\n        throw new Error(`resolved is not a Fluid url. Type: ${resolved === null || resolved === void 0 ? void 0 : resolved.type}`);\n    }\n}\n//# sourceMappingURL=fluidResolvedUrl.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { parse } from \"url\";\nimport { ensureFluidResolvedUrl } from \"./fluidResolvedUrl\";\nexport class MultiDocumentServiceFactory {\n    constructor(documentServiceFactories) {\n        this.protocolName = \"none:\";\n        this.protocolToDocumentFactoryMap = new Map();\n        documentServiceFactories.forEach((factory) => {\n            this.protocolToDocumentFactoryMap.set(factory.protocolName, factory);\n        });\n    }\n    static create(documentServiceFactory) {\n        if (Array.isArray(documentServiceFactory)) {\n            const factories = [];\n            documentServiceFactory.forEach((factory) => {\n                const maybeMulti = factory;\n                if (maybeMulti.protocolToDocumentFactoryMap !== undefined) {\n                    factories.push(...maybeMulti.protocolToDocumentFactoryMap.values());\n                }\n                else {\n                    factories.push(factory);\n                }\n            });\n            if (factories.length === 1) {\n                return factories[0];\n            }\n            return new MultiDocumentServiceFactory(factories);\n        }\n        return documentServiceFactory;\n    }\n    async createDocumentService(resolvedUrl, logger) {\n        ensureFluidResolvedUrl(resolvedUrl);\n        const urlObj = parse(resolvedUrl.url);\n        if (urlObj.protocol === undefined) {\n            throw new Error(\"No protocol provided\");\n        }\n        const factory = this.protocolToDocumentFactoryMap.get(urlObj.protocol);\n        if (factory === undefined) {\n            throw new Error(\"Unknown Fluid protocol\");\n        }\n        return factory.createDocumentService(resolvedUrl, logger);\n    }\n    async createContainer(createNewSummary, createNewResolvedUrl, logger) {\n        ensureFluidResolvedUrl(createNewResolvedUrl);\n        const urlObj = parse(createNewResolvedUrl.url);\n        if (urlObj.protocol === undefined) {\n            throw new Error(\"No protocol provided\");\n        }\n        const factory = this.protocolToDocumentFactoryMap.get(urlObj.protocol);\n        if (factory === undefined) {\n            throw new Error(\"Unknown Fluid protocol\");\n        }\n        return factory.createContainer(createNewSummary, createNewResolvedUrl, logger);\n    }\n}\n//# sourceMappingURL=multiDocumentServiceFactory.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Resolver that takes a list of url resolvers and then try each of them to resolve the url.\n * @param resolversList - List of url resolvers to be used to resolve the request.\n * @param request - Request to be resolved.\n */\nexport async function configurableUrlResolver(resolversList, request) {\n    const url = request.url;\n    let resolved;\n    for (const resolver of resolversList) {\n        resolved = await resolver.resolve({ url });\n        if (resolved !== undefined) {\n            return resolved;\n        }\n    }\n    return undefined;\n}\nexport class MultiUrlResolver {\n    constructor(urlResolvers) {\n        this.urlResolvers = urlResolvers;\n    }\n    static create(urlResolver) {\n        if (Array.isArray(urlResolver)) {\n            if (urlResolver.length === 1) {\n                return urlResolver[0];\n            }\n            return new MultiUrlResolver(urlResolver);\n        }\n        return urlResolver;\n    }\n    async resolve(request) {\n        return configurableUrlResolver(this.urlResolvers, request);\n    }\n    async getAbsoluteUrl(resolvedUrl, relativeUrl) {\n        throw new Error(\"Not implmented\");\n    }\n}\n//# sourceMappingURL=multiUrlResolver.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { DriverErrorType, } from \"@fluidframework/driver-definitions\";\nimport { LoggingError } from \"@fluidframework/telemetry-utils\";\nexport var OnlineStatus;\n(function (OnlineStatus) {\n    OnlineStatus[OnlineStatus[\"Offline\"] = 0] = \"Offline\";\n    OnlineStatus[OnlineStatus[\"Online\"] = 1] = \"Online\";\n    OnlineStatus[OnlineStatus[\"Unknown\"] = 2] = \"Unknown\";\n})(OnlineStatus || (OnlineStatus = {}));\n// It tells if we have local connection only - we might not have connection to web.\n// No solution for node.js (other than resolve dns names / ping specific sites)\n// Can also use window.addEventListener(\"online\" / \"offline\")\nexport function isOnline() {\n    // eslint-disable-next-line no-null/no-null\n    if (typeof navigator === \"object\" && navigator !== null && typeof navigator.onLine === \"boolean\") {\n        return navigator.onLine ? OnlineStatus.Online : OnlineStatus.Offline;\n    }\n    return OnlineStatus.Unknown;\n}\n/**\n * Generic network error class.\n */\nexport class GenericNetworkError extends LoggingError {\n    constructor(errorMessage, canRetry, statusCode) {\n        super(errorMessage, { statusCode });\n        this.canRetry = canRetry;\n        this.errorType = DriverErrorType.genericNetworkError;\n    }\n}\nexport class AuthorizationError extends LoggingError {\n    constructor(errorMessage, claims, tenantId, statusCode) {\n        super(errorMessage, { statusCode });\n        this.claims = claims;\n        this.tenantId = tenantId;\n        this.errorType = DriverErrorType.authorizationError;\n        this.canRetry = false;\n    }\n}\nexport class NetworkErrorBasic extends LoggingError {\n    constructor(errorMessage, errorType, canRetry, statusCode) {\n        super(errorMessage, { statusCode });\n        this.errorType = errorType;\n        this.canRetry = canRetry;\n    }\n}\nexport class NonRetryableError extends NetworkErrorBasic {\n    constructor(errorMessage, errorType, statusCode) {\n        super(errorMessage, errorType, false, statusCode);\n        this.errorType = errorType;\n    }\n}\n/**\n * Throttling error class - used to communicate all throttling errors\n */\nexport class ThrottlingError extends LoggingError {\n    constructor(errorMessage, retryAfterSeconds, statusCode) {\n        super(errorMessage, { statusCode });\n        this.retryAfterSeconds = retryAfterSeconds;\n        this.errorType = DriverErrorType.throttlingError;\n        this.canRetry = true;\n    }\n}\nexport const createWriteError = (errorMessage) => new NonRetryableError(errorMessage, DriverErrorType.writeError, undefined /* statusCodes */);\nexport function createGenericNetworkError(errorMessage, canRetry, retryAfterSeconds, statusCode) {\n    if (retryAfterSeconds !== undefined && canRetry) {\n        return new ThrottlingError(errorMessage, retryAfterSeconds, statusCode);\n    }\n    return new GenericNetworkError(errorMessage, canRetry, statusCode);\n}\n/**\n * Check if a connection error can be retried.  Unless explicitly allowed, retry is disallowed.\n * I.e. asserts or unexpected exceptions in our code result in container failure.\n * @param error - The error to inspect for ability to retry\n */\nexport const canRetryOnError = (error) => (error === null || error === void 0 ? void 0 : error.canRetry) === true;\n// eslint-disable-next-line @typescript-eslint/no-unsafe-return\nexport const getRetryDelayFromError = (error) => error === null || error === void 0 ? void 0 : error.retryAfterSeconds;\n//# sourceMappingURL=network.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, Deferred } from \"@fluidframework/common-utils\";\n/**\n * Helper class to organize parallel fetching of data\n * It can be used to concurrently do many requests, while consuming\n * data in the right order. Take a look at UT for examples.\n * @param concurrency - level of concurrency\n * @param from - starting point of fetching data (inclusive)\n * @param to  - ending point of fetching data. exclusive, or undefined if unknown\n * @param payloadSize - batch size\n * @param logger - logger to use\n * @param requestCallback - callback to request batches\n * @returns - Queue that can be used to retrieve data\n */\nexport class ParallelRequests {\n    constructor(from, to, payloadSize, logger, requestCallback, responseCallback) {\n        this.to = to;\n        this.payloadSize = payloadSize;\n        this.logger = logger;\n        this.requestCallback = requestCallback;\n        this.responseCallback = responseCallback;\n        this.results = new Map();\n        this.working = true;\n        this.requestsInFlight = 0;\n        this.endEvent = new Deferred();\n        this.requests = 0;\n        this.latestRequested = from;\n        this.nextToDeliver = from;\n        this.knewTo = (to !== undefined);\n    }\n    cancel() {\n        this.working = false;\n        this.endEvent.resolve();\n    }\n    async run(concurrency) {\n        assert(concurrency > 0, 0x102 /* \"invalid level of concurrency\" */);\n        assert(this.working, 0x103 /* \"trying to parallel run while not working\" */);\n        let c = concurrency;\n        while (c > 0) {\n            c--;\n            this.addRequest();\n        }\n        this.dispatch(); // will recalculate and trigger this.endEvent if needed\n        return this.endEvent.promise;\n    }\n    done() {\n        // We should satisfy request fully.\n        assert(this.to !== undefined, 0x104 /* \"undefined end point for parallel fetch\" */);\n        assert(this.nextToDeliver >= this.to, 0x105 /* \"unexpected end point for parallel fetch\" */);\n        this.working = false;\n        this.endEvent.resolve();\n    }\n    fail(error) {\n        this.working = false;\n        this.endEvent.reject(error);\n    }\n    dispatch() {\n        while (this.working) {\n            const value = this.results.get(this.nextToDeliver);\n            if (value === undefined) {\n                break;\n            }\n            this.results.delete(this.nextToDeliver);\n            assert(value.length <= this.payloadSize, 0x1d9 /* \"addRequestCore() should break into smaller chunks\" */);\n            this.nextToDeliver += value.length;\n            this.responseCallback(value);\n        }\n        // Account for cancellation - state might be not in consistent state on cancelling operation\n        if (this.working) {\n            if (this.requestsInFlight === 0) {\n                // we should have dispatched everything, no matter whether we knew about the end or not.\n                // see comment in addRequestCore() around throwing away chunk if it's above this.to\n                assert(this.results.size === 0, 0x107 /* \"ending dispatch with remaining results to be sent\" */);\n                this.done();\n            }\n            else if (this.to !== undefined && this.nextToDeliver >= this.to) {\n                // Learned about the end and dispatched all the ops up to it.\n                // Ignore all the in-flight requests above boundary - unblock caller sooner.\n                assert(!this.knewTo, 0x108 /* \"ending results dispatch but knew in advance about more requests\" */);\n                this.done();\n            }\n        }\n    }\n    getNextChunk() {\n        if (!this.working) {\n            return undefined;\n        }\n        const from = this.latestRequested;\n        if (this.to !== undefined) {\n            if (this.to <= from) {\n                return undefined;\n            }\n        }\n        // this.latestRequested\n        // inclusive on the right side! Exclusive on the left.\n        this.latestRequested += this.payloadSize;\n        if (this.to !== undefined) {\n            this.latestRequested = Math.min(this.to, this.latestRequested);\n        }\n        assert(from < this.latestRequested, 0x109 /* \"unexpected next chunk position\" */);\n        return { from, to: this.latestRequested };\n    }\n    addRequest() {\n        const chunk = this.getNextChunk();\n        if (chunk === undefined) {\n            return;\n        }\n        this.addRequestCore(chunk.from, chunk.to).catch(this.fail.bind(this));\n    }\n    async addRequestCore(fromArg, toArg) {\n        assert(this.working, 0x10a /* \"cannot add parallel request while not working\" */);\n        let from = fromArg;\n        let to = toArg;\n        // to & from are exclusive\n        this.requestsInFlight++;\n        while (this.working) {\n            const requestedLength = to - from;\n            assert(requestedLength > 0, 0x10b /* \"invalid parallel request range\" */);\n            // We should not be wasting time asking for something useless.\n            if (this.to !== undefined) {\n                assert(from < this.to, 0x10c /* \"invalid parallel request start point\" */);\n                assert(to <= this.to, 0x10d /* \"invalid parallel request end point\" */);\n            }\n            this.requests++;\n            const promise = this.requestCallback(this.requests, from, to, this.to !== undefined);\n            // dispatch any prior received data\n            this.dispatch();\n            const { payload, cancel, partial } = await promise;\n            if (cancel) {\n                this.cancel();\n            }\n            if (this.to !== undefined && from >= this.to) {\n                // while we were waiting for response, we learned on what is the boundary\n                // We can get here (with actual result!) if situation changed while this request was in\n                // flight, i.e. the end was extended over what we learn in some other request\n                // While it's useful not to throw this result, this is very corner cases and makes logic\n                // (including consistency checks) much harder to write correctly.\n                // So for now, we are throwing this result out the window.\n                assert(!this.knewTo, 0x10e /* \"should not throw result if we knew about boundary in advance\" */);\n                // Learn how often it happens and if it's too wasteful to throw these chunks.\n                // If it pops into our view a lot, we would need to reconsider how we approach it.\n                // Note that this is not visible to user other than potentially not hitting 100% of\n                // what we can in perf domain.\n                if (payload.length !== 0) {\n                    this.logger.sendErrorEvent({\n                        eventName: \"ParallelRequests_GotExtra\",\n                        from,\n                        to,\n                        end: this.to,\n                        length: payload.length,\n                    });\n                }\n                break;\n            }\n            if (this.working) {\n                const fromOrig = from;\n                const length = payload.length;\n                let fullChunk = (requestedLength <= length); // we can possible get more than we asked.\n                if (length !== 0) {\n                    // We can get more than we asked for!\n                    // This can screw up logic in dispatch!\n                    // So push only batch size, and keep the rest for later - if conditions are favorable, we\n                    // will be able to use it. If not (parallel request overlapping these ops), it's easier to\n                    // discard them and wait for another (overlapping) request to come in later.\n                    if (requestedLength < length) {\n                        // This is error in a sense that it's not expected and likely points bug in other layer.\n                        // This layer copes with this situation just fine.\n                        this.logger.sendTelemetryEvent({\n                            eventName: \"ParallelRequests_Over\",\n                            from,\n                            to,\n                            length,\n                        });\n                    }\n                    const data = payload.splice(0, requestedLength);\n                    this.results.set(from, data);\n                    from += data.length;\n                }\n                else {\n                    // 1. empty (partial) chunks should not be returned by various caching / adapter layers -\n                    //    they should fall back to next layer. This might be important invariant to hold to ensure\n                    //    that we are less likely have bugs where such layer would keep returning empty partial\n                    //    result on each call.\n                    // 2. Current invariant is that callback does retries until it gets something,\n                    //    with the goal of failing if zero data is retrieved in given amount of time.\n                    //    This is very specific property of storage / ops, so this logic is not here, but given only\n                    //    one user of this class, we assert that to catch issues earlier.\n                    // These invariant can be relaxed if needed.\n                    assert(!partial, 0x10f /* \"empty/partial chunks should not be returned by caching\" */);\n                    assert(!this.knewTo, 0x110 /* \"callback should retry until valid fetch before it learns new boundary\" */);\n                }\n                if (!partial && !fullChunk) {\n                    if (!this.knewTo) {\n                        if (this.to === undefined || this.to > from) {\n                            // The END\n                            this.to = from;\n                        }\n                        break;\n                    }\n                    // We know that there are more items to be retrieved\n                    // Can we get partial chunk? Ideally storage indicates that's not a full chunk\n                    // Note that it's possible that not all ops hit storage yet.\n                    // We will come back to request more, and if we can't get any more ops soon, it's\n                    // catastrophic failure (see comment above on responsibility of callback to return something)\n                    // This layer will just keep trying until it gets full set.\n                    this.logger.sendPerformanceEvent({\n                        eventName: \"ParallelRequests_Partial\",\n                        from: fromOrig,\n                        to,\n                        length,\n                    });\n                }\n                if (to === this.latestRequested) {\n                    // we can go after full chunk at the end if we received partial chunk, or more than asked\n                    // Also if we got more than we asked to, we can actually use those ops!\n                    if (payload.length !== 0) {\n                        this.results.set(from, payload);\n                        from += payload.length;\n                    }\n                    this.latestRequested = from;\n                    fullChunk = true;\n                }\n                if (fullChunk) {\n                    const chunk = this.getNextChunk();\n                    if (chunk === undefined) {\n                        break;\n                    }\n                    from = chunk.from;\n                    to = chunk.to;\n                }\n            }\n        }\n        this.requestsInFlight--;\n        this.dispatch();\n    }\n}\n/**\n * Helper queue class to allow async push / pull\n * It's essentially a pipe allowing multiple writers, and single reader\n */\nexport class Queue {\n    constructor() {\n        this.queue = [];\n        this.done = false;\n    }\n    pushValue(value) {\n        this.pushCore(Promise.resolve(value));\n    }\n    pushError(error) {\n        this.pushCore(Promise.reject(error));\n        this.done = true;\n    }\n    pushDone() {\n        this.pushCore(Promise.resolve(undefined));\n        this.done = true;\n    }\n    pushCore(value) {\n        assert(!this.done, 0x112 /* \"cannot push onto queue if done\" */);\n        if (this.deferred) {\n            assert(this.queue.length === 0, 0x113 /* \"deferred queue should be empty\" */);\n            this.deferred.resolve(value);\n            this.deferred = undefined;\n        }\n        else {\n            this.queue.push(value);\n        }\n    }\n    async pop() {\n        assert(this.deferred === undefined, 0x114 /* \"cannot pop if deferred\" */);\n        const el = this.queue.shift();\n        if (el !== undefined) {\n            return el;\n        }\n        assert(!this.done, 0x115 /* \"queue should not be done during pop\" */);\n        this.deferred = new Deferred();\n        return this.deferred.promise;\n    }\n}\n/**\n * Helper function to expose ParallelRequests through IReadPipe interface\n * @param concurrency - level of concurrency\n * @param from - starting point of fetching data (inclusive)\n * @param to  - ending point of fetching data. exclusive, or undefined if unknown\n * @param payloadSize - batch size\n * @param logger - logger to use\n * @param requestCallback - callback to request batches\n * @returns - Queue that can be used to retrieve data\n */\nexport function parallel(concurrency, from, to, payloadSize, logger, requestCallback) {\n    const queue = new Queue();\n    const manager = new ParallelRequests(from, to, payloadSize, logger, requestCallback, (messages) => queue.pushValue(messages));\n    manager.run(concurrency)\n        .then(() => queue.pushDone())\n        .catch((error) => queue.pushError(error));\n    return queue;\n}\n//# sourceMappingURL=parallelRequests.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { bufferToString, fromBase64ToUtf8 } from \"@fluidframework/common-utils\";\n/**\n * Read a blob from IDocumentStorageService and JSON.parse it into object of type T\n *\n * @param storage - the IDocumentStorageService to read from\n * @param id - the id of the blob to read and parse\n * @returns the object that we decoded and JSON.parse\n */\nexport async function readAndParse(storage, id) {\n    const blob = await storage.readBlob(id);\n    const decoded = bufferToString(blob, \"utf8\");\n    return JSON.parse(decoded);\n}\n/**\n * Read a blob from map, decode it (from \"base64\") and JSON.parse it into object of type T\n *\n * @param blobs - the blob map to read from\n * @param id - the id of the blob to read and parse\n * @returns the object that we decoded and JSON.parse\n */\nexport function readAndParseFromBlobs(blobs, id) {\n    const encoded = blobs[id];\n    const decoded = fromBase64ToUtf8(encoded);\n    return JSON.parse(decoded);\n}\n//# sourceMappingURL=readAndParse.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Combine the app summary and protocol summary in 1 tree.\n * @param appSummary - Summary of the app.\n * @param protocolSummary - Summary of the protocol.\n */\nexport function combineAppAndProtocolSummary(appSummary, protocolSummary) {\n    const createNewSummary = {\n        type: 1 /* Tree */,\n        tree: {\n            \".protocol\": protocolSummary,\n            \".app\": appSummary,\n        },\n    };\n    return createNewSummary;\n}\n/**\n * Extract the attributes from the protocol summary.\n * @param protocolSummary - protocol summary from which the values are to be extracted.\n */\nexport function getDocAttributesFromProtocolSummary(protocolSummary) {\n    var _a;\n    const attributesBlob = protocolSummary.tree.attributes;\n    const documentAttributes = JSON.parse(attributesBlob.content);\n    documentAttributes.term = (_a = documentAttributes.term) !== null && _a !== void 0 ? _a : 1;\n    return documentAttributes;\n}\n/**\n * Extract quorum values from the protocol summary.\n * @param protocolSummary - protocol summary from which the values are to be extracted.\n */\nexport function getQuorumValuesFromProtocolSummary(protocolSummary) {\n    const quorumValuesBlob = protocolSummary.tree.quorumValues;\n    const quorumValues = JSON.parse(quorumValuesBlob.content);\n    return quorumValues;\n}\n//# sourceMappingURL=summaryForCreateNew.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Runs garbage collection on the given reference graph.\n * @param referenceGraph - The reference graph to run GC on. It's a list of nodes where each node has an id and set of\n * routes to other nodes in the graph.\n * @param rootIds - The ids of root nodes that are considered referenced.\n * @param logger - Used to log telelmetry.\n * @returns the ids of referenced nodes and the ids of deleted nodes in the referenced graph.\n */\nexport function runGarbageCollection(referenceGraph, rootIds, logger) {\n    // This set keeps track of nodes that we have visited. It is used to detect cycles in the graph.\n    const visited = new Set();\n    // This tracks the ids of referenced nodes. The nodes corresponding to rootIds are always considered\n    // referenced so we start with those.\n    const referencedIds = [...rootIds];\n    for (const id of referencedIds) {\n        // If we have already seen this node, ignore and continue. Else, add it to visited list.\n        if (visited.has(id)) {\n            continue;\n        }\n        visited.add(id);\n        // Get the node for the referenced id and add its outbound routes to referencedIds since they are\n        // also referenced.\n        const routes = referenceGraph[id];\n        if (routes !== undefined) {\n            referencedIds.push(...routes);\n        }\n        else {\n            // Log a telemetry event if there is a node missing for a referenced id. This should not happen but for now\n            // we don't assert. We can monitor telemetry for a while to figure out next steps.\n            /**\n             * This telemetry is currently too noisy. Start sending it GC is enabled end-to-end. See here for details -\n             * https://github.com/microsoft/FluidFramework/issues/4939\n             *\n             * logger.sendTelemetryEvent({\n             *    eventName: \"MissingGCNode\",\n             *    missingNodeId: id,\n             * });\n            */\n        }\n    }\n    const referencedNodeIds = [];\n    const deletedNodeIds = [];\n    for (const id of Object.keys(referenceGraph)) {\n        // The nodes from the reference graph whose ids are in the visited list are referenced.\n        // The rest of the nodes are deleted.\n        if (visited.has(id)) {\n            referencedNodeIds.push(id);\n        }\n        else {\n            deletedNodeIds.push(id);\n        }\n    }\n    return { referencedNodeIds, deletedNodeIds };\n}\n//# sourceMappingURL=garbageCollector.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\n/**\n * Helper function that clones the GC data.\n * @param gcData - The GC data to clone.\n * @returns a clone of the given GC data.\n */\nexport function cloneGCData(gcData) {\n    const clonedGCNodes = {};\n    for (const [id, outboundRoutes] of Object.entries(gcData.gcNodes)) {\n        clonedGCNodes[id] = Array.from(outboundRoutes);\n    }\n    return {\n        gcNodes: clonedGCNodes,\n    };\n}\n/**\n * Helper function that generates the used routes of children from a given node's used routes.\n * @param usedRoutes - The used routes of a node.\n * @returns A map of used routes of each children of the the given node.\n */\nexport function getChildNodesUsedRoutes(usedRoutes) {\n    const childUsedRoutesMap = new Map();\n    for (const route of usedRoutes) {\n        assert(route.startsWith(\"/\"), 0x198 /* \"Used route should always be an absolute route\" */);\n        const childId = route.split(\"/\")[1];\n        const childUsedRoute = route.slice(childId.length + 1);\n        const childUsedRoutes = childUsedRoutesMap.get(childId);\n        if (childUsedRoutes !== undefined) {\n            childUsedRoutes.push(childUsedRoute);\n        }\n        else {\n            childUsedRoutesMap.set(childId, [childUsedRoute]);\n        }\n    }\n    return childUsedRoutesMap;\n}\n/**\n * Helper function that generates the GC data of children from a given node's GC data.\n * @param gcData - The GC data of a node.\n * @returns A map of GC data of each children of the the given node.\n */\nexport function getChildNodesGCData(gcData) {\n    const childGCDataMap = new Map();\n    for (const [id, outboundRoutes] of Object.entries(gcData.gcNodes)) {\n        assert(id.startsWith(\"/\"), 0x199 /* \"id should always be an absolute route\" */);\n        const childId = id.split(\"/\")[1];\n        let childGCNodeId = id.slice(childId.length + 1);\n        // GC node id always begins with \"/\". Handle the special case where the id in parent's GC nodes is of the\n        // for `/root`. This would make `childId=root` and `childGCNodeId=\"\"`.\n        if (childGCNodeId === \"\") {\n            childGCNodeId = \"/\";\n        }\n        // Create a copy of the outbound routes array in the parents GC data.\n        const childOutboundRoutes = Array.from(outboundRoutes);\n        let childGCData = childGCDataMap.get(childId);\n        if (childGCData === undefined) {\n            childGCData = { gcNodes: {} };\n        }\n        childGCData.gcNodes[childGCNodeId] = childOutboundRoutes;\n        childGCDataMap.set(childId, childGCData);\n    }\n    return childGCDataMap;\n}\n/**\n * Removes the given route from the outbound routes of all the given GC nodes.\n * @param gcNodes - The nodes from which the route is to be removed.\n * @param outboundRoute - The route to be removed.\n */\nexport function removeRouteFromAllNodes(gcNodes, outboundRoute) {\n    for (const outboundRoutes of Object.values(gcNodes)) {\n        const index = outboundRoutes.indexOf(outboundRoute);\n        if (index > -1) {\n            outboundRoutes.splice(index, 1);\n        }\n    }\n}\nexport class GCDataBuilder {\n    constructor() {\n        this.gcNodes = {};\n    }\n    addNode(id, outboundRoutes) {\n        this.gcNodes[id] = outboundRoutes;\n    }\n    /**\n     * Adds the given GC nodes. It does the following:\n     * - Normalizes the ids of the given nodes.\n     * - Prefixes the given `prefixId` to the given nodes' ids.\n     * - Adds the outbound routes of the nodes against the normalized and prefixed id.\n     */\n    prefixAndAddNodes(prefixId, gcNodes) {\n        for (const [id, outboundRoutes] of Object.entries(gcNodes)) {\n            let normalizedId = id;\n            // Remove any starting slashes from the id.\n            while (normalizedId.startsWith(\"/\")) {\n                normalizedId = normalizedId.substr(1);\n            }\n            // Prefix the given id to the normalized id.\n            normalizedId = `/${prefixId}/${normalizedId}`;\n            // Remove any trailing slashes from the normalized id.\n            while (normalizedId.endsWith(\"/\")) {\n                normalizedId = normalizedId.substr(0, normalizedId.length - 1);\n            }\n            // Add the outbound routes against the normalized and prefixed id.\n            this.gcNodes[normalizedId] = outboundRoutes;\n        }\n    }\n    /**\n     * Adds the given outbound route to the outbound routes of all GC nodes.\n     */\n    addRouteToAllNodes(outboundRoute) {\n        for (const outboundRoutes of Object.values(this.gcNodes)) {\n            outboundRoutes.push(outboundRoute);\n        }\n    }\n    getGCData() {\n        return {\n            gcNodes: this.gcNodes,\n        };\n    }\n}\n//# sourceMappingURL=utils.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport registerDebug from \"debug\";\nimport { pkgName, pkgVersion } from \"./packageVersion\";\nexport const debug = registerDebug(\"fluid:map\");\ndebug(`Package: ${pkgName} - Version: ${pkgVersion}`);\n//# sourceMappingURL=debug.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { readAndParse } from \"@fluidframework/driver-utils\";\nimport { addBlobToTree } from \"@fluidframework/protocol-base\";\nimport { MessageType, } from \"@fluidframework/protocol-definitions\";\nimport { SharedObject, ValueType } from \"@fluidframework/shared-object-base\";\nimport * as path from \"path-browserify\";\nimport { debug } from \"./debug\";\nimport { LocalValueMaker, makeSerializable, } from \"./localValues\";\nimport { pkgVersion } from \"./packageVersion\";\n// We use path-browserify since this code can run safely on the server or the browser.\n// We standardize on using posix slashes everywhere.\nconst posix = path.posix;\nconst snapshotFileName = \"header\";\nfunction serializeDirectory(absolutePath, root, serializer) {\n    const MinValueSizeSeparateSnapshotBlob = 8 * 1024;\n    const tree = { entries: [] };\n    let counter = 0;\n    const blobs = [];\n    const stack = [];\n    const content = {};\n    stack.push([root, content]);\n    while (stack.length > 0) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const [currentSubDir, currentSubDirObject] = stack.pop();\n        for (const [key, value] of currentSubDir.getSerializedStorage(serializer)) {\n            if (!currentSubDirObject.storage) {\n                currentSubDirObject.storage = {};\n            }\n            const result = {\n                type: value.type,\n                // eslint-disable-next-line @typescript-eslint/ban-types\n                value: value.value && JSON.parse(value.value),\n            };\n            if (value.value && value.value.length >= MinValueSizeSeparateSnapshotBlob) {\n                const extraContent = {};\n                let largeContent = extraContent;\n                if (currentSubDir.absolutePath !== posix.sep) {\n                    for (const dir of currentSubDir.absolutePath.substr(1).split(posix.sep)) {\n                        const subDataObject = {};\n                        largeContent.subdirectories = { [dir]: subDataObject };\n                        largeContent = subDataObject;\n                    }\n                }\n                largeContent.storage = { [key]: result };\n                const blobName = `blob${counter}`;\n                counter++;\n                blobs.push(blobName);\n                addBlobToTree(tree, blobName, extraContent);\n            }\n            else {\n                currentSubDirObject.storage[key] = result;\n            }\n        }\n        for (const [subdirName, subdir] of currentSubDir.subdirectories()) {\n            if (!currentSubDirObject.subdirectories) {\n                currentSubDirObject.subdirectories = {};\n            }\n            const subDataObject = {};\n            currentSubDirObject.subdirectories[subdirName] = subDataObject;\n            stack.push([subdir, subDataObject]);\n        }\n    }\n    const newFormat = {\n        absolutePath,\n        blobs,\n        content,\n    };\n    addBlobToTree(tree, snapshotFileName, newFormat);\n    return tree;\n}\n/**\n * The factory that defines the directory.\n * @sealed\n */\nexport class DirectoryFactory {\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.\"type\"}\n     */\n    get type() {\n        return DirectoryFactory.Type;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}\n     */\n    get attributes() {\n        return DirectoryFactory.Attributes;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n     */\n    async load(runtime, id, services, attributes) {\n        const directory = new SharedDirectory(id, runtime, attributes);\n        await directory.load(services);\n        return directory;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.create}\n     */\n    create(runtime, id) {\n        const directory = new SharedDirectory(id, runtime, DirectoryFactory.Attributes);\n        directory.initializeLocal();\n        return directory;\n    }\n}\n/**\n * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.\"type\"}\n */\nDirectoryFactory.Type = \"https://graph.microsoft.com/types/directory\";\n/**\n * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}\n */\nDirectoryFactory.Attributes = {\n    type: DirectoryFactory.Type,\n    snapshotFormatVersion: \"0.1\",\n    packageVersion: pkgVersion,\n};\n/**\n * SharedDirectory provides a hierarchical organization of map-like data structures as SubDirectories.\n * The values stored within can be accessed like a map, and the hierarchy can be navigated using path syntax.\n * SubDirectories can be retrieved for use as working directories.\n *\n * @example\n * ```ts\n * mySharedDirectory.createSubDirectory(\"a\").createSubDirectory(\"b\").createSubDirectory(\"c\").set(\"foo\", val1);\n * const mySubDir = mySharedDirectory.getWorkingDirectory(\"/a/b/c\");\n * mySubDir.get(\"foo\"); // returns val1\n * ```\n *\n * @sealed\n */\nexport class SharedDirectory extends SharedObject {\n    /**\n     * Constructs a new shared directory. If the object is non-local an id and service interfaces will\n     * be provided.\n     * @param id - String identifier for the SharedDirectory\n     * @param runtime - Data store runtime\n     * @param type - Type identifier\n     */\n    constructor(id, runtime, attributes) {\n        super(id, runtime, attributes);\n        /**\n         * String representation for the class.\n         */\n        this[Symbol.toStringTag] = \"SharedDirectory\";\n        /**\n         * Root of the SharedDirectory, most operations on the SharedDirectory itself act on the root.\n         */\n        this.root = new SubDirectory(this, this.runtime, this.serializer, posix.sep);\n        /**\n         * Mapping of op types to message handlers.\n         */\n        this.messageHandlers = new Map();\n        this.localValueMaker = new LocalValueMaker(this.serializer);\n        this.setMessageHandlers();\n        // Mirror the containedValueChanged op on the SharedDirectory\n        this.root.on(\"containedValueChanged\", (changed, local) => {\n            this.emit(\"containedValueChanged\", changed, local, this);\n        });\n    }\n    /**\n     * Create a new shared directory\n     *\n     * @param runtime - Data store runtime the new shared directory belongs to\n     * @param id - Optional name of the shared directory\n     * @returns Newly create shared directory (but not attached yet)\n     */\n    static create(runtime, id) {\n        return runtime.createChannel(id, DirectoryFactory.Type);\n    }\n    /**\n     * Get a factory for SharedDirectory to register with the data store.\n     *\n     * @returns A factory that creates and load SharedDirectory\n     */\n    static getFactory() {\n        return new DirectoryFactory();\n    }\n    /**\n     * {@inheritDoc IDirectory.absolutePath}\n     */\n    get absolutePath() {\n        return this.root.absolutePath;\n    }\n    /**\n     * {@inheritDoc IDirectory.get}\n     */\n    get(key) {\n        return this.root.get(key);\n    }\n    /**\n     * {@inheritDoc IDirectory.wait}\n     */\n    async wait(key) {\n        return this.root.wait(key);\n    }\n    /**\n     * {@inheritDoc IDirectory.set}\n     */\n    set(key, value) {\n        this.root.set(key, value);\n        return this;\n    }\n    /**\n     * Deletes the given key from within this IDirectory.\n     * @param key - The key to delete\n     * @returns True if the key existed and was deleted, false if it did not exist\n     */\n    delete(key) {\n        return this.root.delete(key);\n    }\n    /**\n     * Deletes all keys from within this IDirectory.\n     */\n    clear() {\n        this.root.clear();\n    }\n    /**\n     * Checks whether the given key exists in this IDirectory.\n     * @param key - The key to check\n     * @returns True if the key exists, false otherwise\n     */\n    has(key) {\n        return this.root.has(key);\n    }\n    /**\n     * The number of entries under this IDirectory.\n     */\n    get size() {\n        return this.root.size;\n    }\n    /**\n     * Issue a callback on each entry under this IDirectory.\n     * @param callback - Callback to issue\n     */\n    forEach(callback) {\n        this.root.forEach(callback);\n    }\n    /**\n     * Get an iterator over the entries under this IDirectory.\n     * @returns The iterator\n     */\n    [Symbol.iterator]() {\n        return this.root[Symbol.iterator]();\n    }\n    /**\n     * Get an iterator over the entries under this IDirectory.\n     * @returns The iterator\n     */\n    entries() {\n        return this.root.entries();\n    }\n    /**\n     * Get an iterator over the keys under this IDirectory.\n     * @returns The iterator\n     */\n    keys() {\n        return this.root.keys();\n    }\n    /**\n     * Get an iterator over the values under this IDirectory.\n     * @returns The iterator\n     */\n    values() {\n        return this.root.values();\n    }\n    /**\n     * {@inheritDoc IDirectory.createSubDirectory}\n     */\n    createSubDirectory(subdirName) {\n        return this.root.createSubDirectory(subdirName);\n    }\n    /**\n     * {@inheritDoc IDirectory.getSubDirectory}\n     */\n    getSubDirectory(subdirName) {\n        return this.root.getSubDirectory(subdirName);\n    }\n    /**\n     * {@inheritDoc IDirectory.hasSubDirectory}\n     */\n    hasSubDirectory(subdirName) {\n        return this.root.hasSubDirectory(subdirName);\n    }\n    /**\n     * {@inheritDoc IDirectory.deleteSubDirectory}\n     */\n    deleteSubDirectory(subdirName) {\n        return this.root.deleteSubDirectory(subdirName);\n    }\n    /**\n     * {@inheritDoc IDirectory.subdirectories}\n     */\n    subdirectories() {\n        return this.root.subdirectories();\n    }\n    /**\n     * {@inheritDoc IDirectory.getWorkingDirectory}\n     */\n    getWorkingDirectory(relativePath) {\n        const absolutePath = this.makeAbsolute(relativePath);\n        if (absolutePath === posix.sep) {\n            return this.root;\n        }\n        let currentSubDir = this.root;\n        const subdirs = absolutePath.substr(1).split(posix.sep);\n        for (const subdir of subdirs) {\n            currentSubDir = currentSubDir.getSubDirectory(subdir);\n            if (!currentSubDir) {\n                return undefined;\n            }\n        }\n        return currentSubDir;\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.snapshotCore}\n     */\n    snapshotCore(serializer) {\n        return serializeDirectory(this.handle.absolutePath, this.root, serializer);\n    }\n    /**\n     * Submits an operation\n     * @param op - Op to submit\n     * @param localOpMetadata - The local metadata associated with the op. We send a unique id that is used to track\n     * this op while it has not been ack'd. This will be sent when we receive this op back from the server.\n     * @internal\n     */\n    submitDirectoryMessage(op, localOpMetadata) {\n        this.submitLocalMessage(op, localOpMetadata);\n    }\n    /**\n     * Create an emitter for a value type to emit ops from the given key and path.\n     * @param key - The key of the directory that the value type will be stored on\n     * @param absolutePath - The absolute path of the subdirectory storing the value type\n     * @returns A value op emitter for the given key and path\n     * @internal\n     */\n    makeDirectoryValueOpEmitter(key, absolutePath) {\n        const emit = (opName, previousValue, params) => {\n            const op = {\n                key,\n                path: absolutePath,\n                type: \"act\",\n                value: {\n                    opName,\n                    value: params,\n                },\n            };\n            // Send the localOpMetadata as undefined because we don't care about the ack.\n            this.submitDirectoryMessage(op, undefined /* localOpMetadata */);\n            const event = { key, path: absolutePath, previousValue };\n            this.emit(\"valueChanged\", event, true, null, this);\n        };\n        return { emit };\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.onDisconnect}\n     */\n    onDisconnect() {\n        debug(`Directory ${this.id} is now disconnected`);\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.reSubmitCore}\n     */\n    reSubmitCore(content, localOpMetadata) {\n        const message = content;\n        const handler = this.messageHandlers.get(message.type);\n        assert(handler !== undefined, 0x00d /* `Missing message handler for message type: ${message.type}` */);\n        handler.submit(message, localOpMetadata);\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n     */\n    async loadCore(storage) {\n        const data = await readAndParse(storage, snapshotFileName);\n        const newFormat = data;\n        if (Array.isArray(newFormat.blobs)) {\n            // New storage format\n            this.populate(newFormat.content);\n            await Promise.all(newFormat.blobs.map(async (value) => {\n                const dataExtra = await readAndParse(storage, value);\n                this.populate(dataExtra);\n            }));\n        }\n        else {\n            // Old storage format\n            this.populate(data);\n        }\n    }\n    /**\n     * Populate the directory with the given directory data.\n     * @param data - A JSON string containing serialized directory data\n     * @internal\n     */\n    populate(data) {\n        const stack = [];\n        stack.push([this.root, data]);\n        while (stack.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const [currentSubDir, currentSubDirObject] = stack.pop();\n            if (currentSubDirObject.subdirectories) {\n                for (const [subdirName, subdirObject] of Object.entries(currentSubDirObject.subdirectories)) {\n                    let newSubDir = currentSubDir.getSubDirectory(subdirName);\n                    if (!newSubDir) {\n                        newSubDir = new SubDirectory(this, this.runtime, this.serializer, posix.join(currentSubDir.absolutePath, subdirName));\n                        currentSubDir.populateSubDirectory(subdirName, newSubDir);\n                    }\n                    stack.push([newSubDir, subdirObject]);\n                }\n            }\n            if (currentSubDirObject.storage) {\n                for (const [key, serializable] of Object.entries(currentSubDirObject.storage)) {\n                    const localValue = this.makeLocal(key, currentSubDir.absolutePath, serializable);\n                    currentSubDir.populateStorage(key, localValue);\n                }\n            }\n        }\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.registerCore}\n     */\n    registerCore() {\n        const subdirsToRegisterFrom = new Array();\n        subdirsToRegisterFrom.push(this.root);\n        for (const currentSubDir of subdirsToRegisterFrom) {\n            for (const value of currentSubDir.values()) {\n                if (SharedObject.is(value)) {\n                    value.bindToContext();\n                }\n            }\n            for (const [, subdir] of currentSubDir.subdirectories()) {\n                subdirsToRegisterFrom.push(subdir);\n            }\n        }\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.processCore}\n     */\n    processCore(message, local, localOpMetadata) {\n        if (message.type === MessageType.Operation) {\n            const op = message.contents;\n            const handler = this.messageHandlers.get(op.type);\n            assert(handler !== undefined, 0x00e /* `Missing message handler for message type: ${message.type}` */);\n            handler.process(op, local, message, localOpMetadata);\n        }\n    }\n    /**\n     * Converts the given relative path to absolute against the root.\n     * @param relativePath - The path to convert\n     */\n    makeAbsolute(relativePath) {\n        return posix.resolve(posix.sep, relativePath);\n    }\n    /**\n     * The remote ISerializableValue we're receiving (either as a result of a snapshot load or an incoming set op)\n     * will have the information we need to create a real object, but will not be the real object yet.  For example,\n     * we might know it's a map and the ID but not have the actual map or its data yet.  makeLocal's job\n     * is to convert that information into a real object for local usage.\n     * @param key - Key of element being converted\n     * @param absolutePath - Path of element being converted\n     * @param serializable - The remote information that we can convert into a real object\n     * @returns The local value that was produced\n     */\n    makeLocal(key, absolutePath, serializable) {\n        if (serializable.type === ValueType[ValueType.Plain] || serializable.type === ValueType[ValueType.Shared]) {\n            return this.localValueMaker.fromSerializable(serializable);\n        }\n        else {\n            return this.localValueMaker.fromSerializableValueType(serializable, this.makeDirectoryValueOpEmitter(key, absolutePath));\n        }\n    }\n    /**\n     * Set the message handlers for the directory.\n     */\n    setMessageHandlers() {\n        this.messageHandlers.set(\"clear\", {\n            process: (op, local, message, localOpMetadata) => {\n                const subdir = this.getWorkingDirectory(op.path);\n                if (subdir) {\n                    subdir.processClearMessage(op, local, message, localOpMetadata);\n                }\n            },\n            submit: (op, localOpMetadata) => {\n                const subdir = this.getWorkingDirectory(op.path);\n                if (subdir) {\n                    // We don't reuse the metadata but send a new one on each submit.\n                    subdir.submitClearMessage(op);\n                }\n            },\n        });\n        this.messageHandlers.set(\"delete\", {\n            process: (op, local, message, localOpMetadata) => {\n                const subdir = this.getWorkingDirectory(op.path);\n                if (subdir) {\n                    subdir.processDeleteMessage(op, local, message, localOpMetadata);\n                }\n            },\n            submit: (op, localOpMetadata) => {\n                const subdir = this.getWorkingDirectory(op.path);\n                if (subdir) {\n                    // We don't reuse the metadata but send a new one on each submit.\n                    subdir.submitKeyMessage(op);\n                }\n            },\n        });\n        this.messageHandlers.set(\"set\", {\n            process: (op, local, message, localOpMetadata) => {\n                const subdir = this.getWorkingDirectory(op.path);\n                if (subdir) {\n                    const context = local ? undefined : this.makeLocal(op.key, op.path, op.value);\n                    subdir.processSetMessage(op, context, local, message, localOpMetadata);\n                }\n            },\n            submit: (op, localOpMetadata) => {\n                const subdir = this.getWorkingDirectory(op.path);\n                if (subdir) {\n                    // We don't reuse the metadata but send a new one on each submit.\n                    subdir.submitKeyMessage(op);\n                }\n            },\n        });\n        this.messageHandlers.set(\"createSubDirectory\", {\n            process: (op, local, message, localOpMetadata) => {\n                const parentSubdir = this.getWorkingDirectory(op.path);\n                if (parentSubdir) {\n                    parentSubdir.processCreateSubDirectoryMessage(op, local, message, localOpMetadata);\n                }\n            },\n            submit: (op, localOpMetadata) => {\n                const parentSubdir = this.getWorkingDirectory(op.path);\n                if (parentSubdir) {\n                    // We don't reuse the metadata but send a new one on each submit.\n                    parentSubdir.submitSubDirectoryMessage(op);\n                }\n            },\n        });\n        this.messageHandlers.set(\"deleteSubDirectory\", {\n            process: (op, local, message, localOpMetadata) => {\n                const parentSubdir = this.getWorkingDirectory(op.path);\n                if (parentSubdir) {\n                    parentSubdir.processDeleteSubDirectoryMessage(op, local, message, localOpMetadata);\n                }\n            },\n            submit: (op, localOpMetadata) => {\n                const parentSubdir = this.getWorkingDirectory(op.path);\n                if (parentSubdir) {\n                    // We don't reuse the metadata but send a new one on each submit.\n                    parentSubdir.submitSubDirectoryMessage(op);\n                }\n            },\n        });\n        // Ops with type \"act\" describe actions taken by custom value type handlers of whatever item is\n        // being addressed.  These custom handlers can be retrieved from the ValueTypeLocalValue which has\n        // stashed its valueType (and therefore its handlers).  We also emit a valueChanged for anyone\n        // watching for manipulations of that item.\n        this.messageHandlers.set(\"act\", {\n            process: (op, local, message, localOpMetadata) => {\n                const subdir = this.getWorkingDirectory(op.path);\n                // Subdir might not exist if we deleted it\n                if (!subdir) {\n                    return;\n                }\n                const localValue = subdir.getLocalValue(op.key);\n                // Local value might not exist if we deleted it\n                if (!localValue) {\n                    return;\n                }\n                const handler = localValue.getOpHandler(op.value.opName);\n                const previousValue = localValue.value;\n                const translatedValue = this.serializer.parse(JSON.stringify(op.value.value));\n                handler.process(previousValue, translatedValue, local, message);\n                const event = { key: op.key, path: op.path, previousValue };\n                this.emit(\"valueChanged\", event, local, message, this);\n            },\n            submit: (op, localOpMetadata) => {\n                this.submitDirectoryMessage(op, localOpMetadata);\n            },\n        });\n    }\n    applyStashedOp() {\n        throw new Error(\"not implemented\");\n    }\n}\n/**\n * Node of the directory tree.\n * @sealed\n */\nclass SubDirectory extends TypedEventEmitter {\n    /**\n     * Constructor.\n     * @param directory - Reference back to the SharedDirectory to perform operations\n     * @param runtime - The data store runtime this directory is associated with\n     * @param serializer - The serializer to serialize / parse handles\n     * @param absolutePath - The absolute path of this IDirectory\n     */\n    constructor(directory, runtime, serializer, absolutePath) {\n        super();\n        this.directory = directory;\n        this.runtime = runtime;\n        this.serializer = serializer;\n        this.absolutePath = absolutePath;\n        /**\n         * String representation for the class.\n         */\n        this[Symbol.toStringTag] = \"SubDirectory\";\n        /**\n         * The in-memory data the directory is storing.\n         */\n        this._storage = new Map();\n        /**\n         * The subdirectories the directory is holding.\n         */\n        this._subdirectories = new Map();\n        /**\n         * Keys that have been modified locally but not yet ack'd from the server.\n         */\n        this.pendingKeys = new Map();\n        /**\n         * Subdirectories that have been modified locally but not yet ack'd from the server.\n         */\n        this.pendingSubDirectories = new Map();\n        /**\n         * This is used to assign a unique id to every outgoing operation and helps in tracking unack'd ops.\n         */\n        this.pendingMessageId = -1;\n        /**\n         * If a clear has been performed locally but not yet ack'd from the server, then this stores the pending id\n         * of that clear operation. Otherwise, is -1.\n         */\n        this.pendingClearMessageId = -1;\n    }\n    /**\n     * Checks whether the given key exists in this IDirectory.\n     * @param key - The key to check\n     * @returns True if the key exists, false otherwise\n     */\n    has(key) {\n        return this._storage.has(key);\n    }\n    /**\n     * {@inheritDoc IDirectory.get}\n     */\n    get(key) {\n        var _a;\n        return (_a = this._storage.get(key)) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    /**\n     * {@inheritDoc IDirectory.wait}\n     */\n    async wait(key) {\n        // Return immediately if the value already exists\n        if (this._storage.has(key)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return this._storage.get(key).value;\n        }\n        // Otherwise subscribe to changes\n        return new Promise((resolve, reject) => {\n            const callback = (changed) => {\n                if (this.absolutePath === changed.path && key === changed.key) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    resolve(this._storage.get(key).value);\n                    this.directory.removeListener(\"valueChanged\", callback);\n                }\n            };\n            this.directory.on(\"valueChanged\", callback);\n        });\n    }\n    /**\n     * {@inheritDoc IDirectory.set}\n     */\n    set(key, value) {\n        // Undefined/null keys can't be serialized to JSON in the manner we currently snapshot.\n        if (key === undefined || key === null) {\n            throw new Error(\"Undefined and null keys are not supported\");\n        }\n        // Create a local value and serialize it.\n        const localValue = this.directory.localValueMaker.fromInMemory(value);\n        const serializableValue = makeSerializable(localValue, this.serializer, this.directory.handle);\n        // Set the value locally.\n        this.setCore(key, localValue, true, null);\n        // If we are not attached, don't submit the op.\n        if (!this.directory.isAttached()) {\n            return this;\n        }\n        const op = {\n            key,\n            path: this.absolutePath,\n            type: \"set\",\n            value: serializableValue,\n        };\n        this.submitKeyMessage(op);\n        return this;\n    }\n    /**\n     * {@inheritDoc IDirectory.createSubDirectory}\n     */\n    createSubDirectory(subdirName) {\n        // Undefined/null subdirectory names can't be serialized to JSON in the manner we currently snapshot.\n        if (subdirName === undefined || subdirName === null) {\n            throw new Error(\"SubDirectory name may not be undefined or null\");\n        }\n        if (subdirName.includes(posix.sep)) {\n            throw new Error(`SubDirectory name may not contain ${posix.sep}`);\n        }\n        // Create the sub directory locally first.\n        this.createSubDirectoryCore(subdirName, true, null);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const subDir = this._subdirectories.get(subdirName);\n        // If we are not attached, don't submit the op.\n        if (!this.directory.isAttached()) {\n            return subDir;\n        }\n        const op = {\n            path: this.absolutePath,\n            subdirName,\n            type: \"createSubDirectory\",\n        };\n        this.submitSubDirectoryMessage(op);\n        return subDir;\n    }\n    /**\n     * {@inheritDoc IDirectory.getSubDirectory}\n     */\n    getSubDirectory(subdirName) {\n        return this._subdirectories.get(subdirName);\n    }\n    /**\n     * {@inheritDoc IDirectory.hasSubDirectory}\n     */\n    hasSubDirectory(subdirName) {\n        return this._subdirectories.has(subdirName);\n    }\n    /**\n     * {@inheritDoc IDirectory.deleteSubDirectory}\n     */\n    deleteSubDirectory(subdirName) {\n        // Delete the sub directory locally first.\n        const successfullyRemoved = this.deleteSubDirectoryCore(subdirName, true, null);\n        // If we are not attached, don't submit the op.\n        if (!this.directory.isAttached()) {\n            return successfullyRemoved;\n        }\n        const op = {\n            path: this.absolutePath,\n            subdirName,\n            type: \"deleteSubDirectory\",\n        };\n        this.submitSubDirectoryMessage(op);\n        return successfullyRemoved;\n    }\n    /**\n     * {@inheritDoc IDirectory.subdirectories}\n     */\n    subdirectories() {\n        return this._subdirectories.entries();\n    }\n    /**\n     * {@inheritDoc IDirectory.getWorkingDirectory}\n     */\n    getWorkingDirectory(relativePath) {\n        return this.directory.getWorkingDirectory(this.makeAbsolute(relativePath));\n    }\n    /**\n     * Deletes the given key from within this IDirectory.\n     * @param key - The key to delete\n     * @returns True if the key existed and was deleted, false if it did not exist\n     */\n    delete(key) {\n        // Delete the key locally first.\n        const successfullyRemoved = this.deleteCore(key, true, null);\n        // If we are not attached, don't submit the op.\n        if (!this.directory.isAttached()) {\n            return successfullyRemoved;\n        }\n        const op = {\n            key,\n            path: this.absolutePath,\n            type: \"delete\",\n        };\n        this.submitKeyMessage(op);\n        return successfullyRemoved;\n    }\n    /**\n     * Deletes all keys from within this IDirectory.\n     */\n    clear() {\n        // Clear the data locally first.\n        this.clearCore(true, null);\n        // If we are not attached, don't submit the op.\n        if (!this.directory.isAttached()) {\n            return;\n        }\n        const op = {\n            path: this.absolutePath,\n            type: \"clear\",\n        };\n        this.submitClearMessage(op);\n    }\n    /**\n     * Issue a callback on each entry under this IDirectory.\n     * @param callback - Callback to issue\n     */\n    forEach(callback) {\n        this._storage.forEach((localValue, key, map) => {\n            callback(localValue.value, key, map);\n        });\n    }\n    /**\n     * The number of entries under this IDirectory.\n     */\n    get size() {\n        return this._storage.size;\n    }\n    /**\n     * Get an iterator over the entries under this IDirectory.\n     * @returns The iterator\n     */\n    entries() {\n        const localEntriesIterator = this._storage.entries();\n        const iterator = {\n            next() {\n                const nextVal = localEntriesIterator.next();\n                if (nextVal.done) {\n                    return { value: undefined, done: true };\n                }\n                else {\n                    // Unpack the stored value\n                    return { value: [nextVal.value[0], nextVal.value[1].value], done: false };\n                }\n            },\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n        return iterator;\n    }\n    /**\n     * Get an iterator over the keys under this IDirectory.\n     * @returns The iterator\n     */\n    keys() {\n        return this._storage.keys();\n    }\n    /**\n     * Get an iterator over the values under this IDirectory.\n     * @returns The iterator\n     */\n    values() {\n        const localValuesIterator = this._storage.values();\n        const iterator = {\n            next() {\n                const nextVal = localValuesIterator.next();\n                if (nextVal.done) {\n                    return { value: undefined, done: true };\n                }\n                else {\n                    // Unpack the stored value\n                    return { value: nextVal.value.value, done: false };\n                }\n            },\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n        return iterator;\n    }\n    /**\n     * Get an iterator over the entries under this IDirectory.\n     * @returns The iterator\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Process a clear operation.\n     * @param op - The op to process\n     * @param local - Whether the message originated from the local client\n     * @param message - The message\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @internal\n     */\n    processClearMessage(op, local, message, localOpMetadata) {\n        if (local) {\n            assert(localOpMetadata !== undefined, 0x00f /* `pendingMessageId is missing from the local client's ${op.type} operation` */);\n            const pendingMessageId = localOpMetadata;\n            if (this.pendingClearMessageId === pendingMessageId) {\n                this.pendingClearMessageId = -1;\n            }\n            return;\n        }\n        this.clearExceptPendingKeys();\n        this.directory.emit(\"clear\", local, op, this.directory);\n    }\n    /**\n     * Process a delete operation.\n     * @param op - The op to process\n     * @param local - Whether the message originated from the local client\n     * @param message - The message\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @internal\n     */\n    processDeleteMessage(op, local, message, localOpMetadata) {\n        if (!this.needProcessStorageOperation(op, local, message, localOpMetadata)) {\n            return;\n        }\n        this.deleteCore(op.key, local, message);\n    }\n    /**\n     * Process a set operation.\n     * @param op - The op to process\n     * @param local - Whether the message originated from the local client\n     * @param message - The message\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @internal\n     */\n    processSetMessage(op, context, local, message, localOpMetadata) {\n        if (!this.needProcessStorageOperation(op, local, message, localOpMetadata)) {\n            return;\n        }\n        // needProcessStorageOperation should have returned false if local is true\n        // so we can assume context is not undefined\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.setCore(op.key, context, local, message);\n    }\n    /**\n     * Process a create subdirectory operation.\n     * @param op - The op to process\n     * @param local - Whether the message originated from the local client\n     * @param message - The message\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @internal\n     */\n    processCreateSubDirectoryMessage(op, local, message, localOpMetadata) {\n        if (!this.needProcessSubDirectoryOperations(op, local, message, localOpMetadata)) {\n            return;\n        }\n        this.createSubDirectoryCore(op.subdirName, local, message);\n    }\n    /**\n     * Process a delete subdirectory operation.\n     * @param op - The op to process\n     * @param local - Whether the message originated from the local client\n     * @param message - The message\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @internal\n     */\n    processDeleteSubDirectoryMessage(op, local, message, localOpMetadata) {\n        if (!this.needProcessSubDirectoryOperations(op, local, message, localOpMetadata)) {\n            return;\n        }\n        this.deleteSubDirectoryCore(op.subdirName, local, message);\n    }\n    /**\n     * Submit a clear operation.\n     * @param op - The operation\n     * @internal\n     */\n    submitClearMessage(op) {\n        const pendingMessageId = ++this.pendingMessageId;\n        this.directory.submitDirectoryMessage(op, pendingMessageId);\n        this.pendingClearMessageId = pendingMessageId;\n    }\n    /**\n     * Submit a key operation.\n     * @param op - The operation\n     * @internal\n     */\n    submitKeyMessage(op) {\n        const pendingMessageId = ++this.pendingMessageId;\n        this.directory.submitDirectoryMessage(op, pendingMessageId);\n        this.pendingKeys.set(op.key, pendingMessageId);\n    }\n    /**\n     * Submit a subdirectory operation.\n     * @param op - The operation\n     * @internal\n     */\n    submitSubDirectoryMessage(op) {\n        const pendingMessageId = ++this.pendingMessageId;\n        this.directory.submitDirectoryMessage(op, pendingMessageId);\n        this.pendingSubDirectories.set(op.subdirName, pendingMessageId);\n    }\n    /**\n     * Get the storage of this subdirectory in a serializable format, to be used in snapshotting.\n     * @param serializer - The serializer to use to serialize handles in its values.\n     * @returns The JSONable string representing the storage of this subdirectory\n     * @internal\n     */\n    *getSerializedStorage(serializer) {\n        for (const [key, localValue] of this._storage) {\n            const value = localValue.makeSerialized(serializer, this.directory.handle);\n            const res = [key, value];\n            yield res;\n        }\n    }\n    /**\n     * Populate a key value in this subdirectory's storage, to be used when loading from snapshot.\n     * @param key - The key to populate\n     * @param localValue - The local value to populate into it\n     * @internal\n     */\n    populateStorage(key, localValue) {\n        this._storage.set(key, localValue);\n    }\n    /**\n     * Populate a subdirectory into this subdirectory, to be used when loading from snapshot.\n     * @param subdirName - The name of the subdirectory to add\n     * @param newSubDir - The new subdirectory to add\n     * @internal\n     */\n    populateSubDirectory(subdirName, newSubDir) {\n        this._subdirectories.set(subdirName, newSubDir);\n    }\n    /**\n     * Retrieve the local value at the given key.  This is used to get value type information stashed on the local\n     * value so op handlers can be retrieved\n     * @param key - The key to retrieve from\n     * @returns The local value\n     * @internal\n     */\n    getLocalValue(key) {\n        return this._storage.get(key);\n    }\n    /**\n     * Converts the given relative path into an absolute path.\n     * @param path - Relative path to convert\n     * @returns The equivalent absolute path\n     */\n    makeAbsolute(relativePath) {\n        return posix.resolve(this.absolutePath, relativePath);\n    }\n    /**\n     * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should\n     * not process the incoming operation.\n     * @param op - Operation to check\n     * @param local - Whether the message originated from the local client\n     * @param message - The message\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @returns True if the operation should be processed, false otherwise\n     */\n    needProcessStorageOperation(op, local, message, localOpMetadata) {\n        if (this.pendingClearMessageId !== -1) {\n            if (local) {\n                assert(localOpMetadata !== undefined && localOpMetadata < this.pendingClearMessageId, 0x010 /* \"Received out of order storage op when there is an unackd clear message\" */);\n            }\n            // If I have a NACK clear, we can ignore all ops.\n            return false;\n        }\n        if (this.pendingKeys.has(op.key)) {\n            // Found an NACK op, clear it from the directory if the latest sequence number in the directory\n            // match the message's and don't process the op.\n            if (local) {\n                assert(localOpMetadata !== undefined, 0x011 /* `pendingMessageId is missing from the local client's ${op.type} operation` */);\n                const pendingMessageId = localOpMetadata;\n                const pendingKeyMessageId = this.pendingKeys.get(op.key);\n                if (pendingKeyMessageId === pendingMessageId) {\n                    this.pendingKeys.delete(op.key);\n                }\n            }\n            return false;\n        }\n        // If we don't have a NACK op on the key, we need to process the remote ops.\n        return !local;\n    }\n    /**\n     * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should\n     * not process the incoming operation.\n     * @param op - Operation to check\n     * @param local - Whether the message originated from the local client\n     * @param message - The message\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @returns True if the operation should be processed, false otherwise\n     */\n    needProcessSubDirectoryOperations(op, local, message, localOpMetadata) {\n        if (this.pendingSubDirectories.has(op.subdirName)) {\n            if (local) {\n                assert(localOpMetadata !== undefined, 0x012 /* `pendingMessageId is missing from the local client's ${op.type} operation` */);\n                const pendingMessageId = localOpMetadata;\n                const pendingSubDirectoryMessageId = this.pendingSubDirectories.get(op.subdirName);\n                if (pendingSubDirectoryMessageId === pendingMessageId) {\n                    this.pendingSubDirectories.delete(op.subdirName);\n                }\n            }\n            return false;\n        }\n        return !local;\n    }\n    /**\n     * Clear all keys in memory in response to a remote clear, but retain keys we have modified but not yet been ack'd.\n     */\n    clearExceptPendingKeys() {\n        // Assuming the pendingKeys is small and the map is large\n        // we will get the value for the pendingKeys and clear the map\n        const temp = new Map();\n        this.pendingKeys.forEach((value, key, map) => {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            temp.set(key, this._storage.get(key));\n        });\n        this._storage.clear();\n        temp.forEach((value, key, map) => {\n            this._storage.set(key, value);\n        });\n    }\n    /**\n     * Clear implementation used for both locally sourced clears as well as incoming remote clears.\n     * @param local - Whether the message originated from the local client\n     * @param op - The message if from a remote clear, or null if from a local clear\n     */\n    clearCore(local, op) {\n        this._storage.clear();\n        this.directory.emit(\"clear\", local, op, this.directory);\n    }\n    /**\n     * Delete implementation used for both locally sourced deletes as well as incoming remote deletes.\n     * @param key - The key being deleted\n     * @param local - Whether the message originated from the local client\n     * @param op - The message if from a remote delete, or null if from a local delete\n     * @returns True if the key existed and was deleted, false if it did not exist\n     */\n    deleteCore(key, local, op) {\n        const previousValue = this.get(key);\n        const successfullyRemoved = this._storage.delete(key);\n        if (successfullyRemoved) {\n            const event = { key, path: this.absolutePath, previousValue };\n            this.directory.emit(\"valueChanged\", event, local, op, this.directory);\n            const containedEvent = { key, previousValue };\n            this.emit(\"containedValueChanged\", containedEvent, local, this);\n        }\n        return successfullyRemoved;\n    }\n    /**\n     * Set implementation used for both locally sourced sets as well as incoming remote sets.\n     * @param key - The key being set\n     * @param value - The value being set\n     * @param local - Whether the message originated from the local client\n     * @param op - The message if from a remote set, or null if from a local set\n     */\n    setCore(key, value, local, op) {\n        const previousValue = this.get(key);\n        this._storage.set(key, value);\n        const event = { key, path: this.absolutePath, previousValue };\n        this.directory.emit(\"valueChanged\", event, local, op, this.directory);\n        const containedEvent = { key, previousValue };\n        this.emit(\"containedValueChanged\", containedEvent, local, this);\n    }\n    /**\n     * Create subdirectory implementation used for both locally sourced creation as well as incoming remote creation.\n     * @param subdirName - The name of the subdirectory being created\n     * @param local - Whether the message originated from the local client\n     * @param op - The message if from a remote create, or null if from a local create\n     */\n    createSubDirectoryCore(subdirName, local, op) {\n        if (!this._subdirectories.has(subdirName)) {\n            this._subdirectories.set(subdirName, new SubDirectory(this.directory, this.runtime, this.serializer, posix.join(this.absolutePath, subdirName)));\n        }\n    }\n    /**\n     * Delete subdirectory implementation used for both locally sourced creation as well as incoming remote creation.\n     * @param subdirName - The name of the subdirectory being deleted\n     * @param local - Whether the message originated from the local client\n     * @param op - The message if from a remote delete, or null if from a local delete\n     */\n    deleteSubDirectoryCore(subdirName, local, op) {\n        // This should make the subdirectory structure unreachable so it can be GC'd and won't appear in snapshots\n        // Might want to consider cleaning out the structure more exhaustively though?\n        return this._subdirectories.delete(subdirName);\n    }\n}\n//# sourceMappingURL=directory.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { parseHandles, serializeHandles, SharedObject, ValueType, } from \"@fluidframework/shared-object-base\";\nexport function makeSerializable(localValue, serializer, bind) {\n    const value = localValue.makeSerialized(serializer, bind);\n    return {\n        type: value.type,\n        value: value.value && JSON.parse(value.value),\n    };\n}\n/**\n * Manages a contained plain value.  May also contain shared object handles.\n */\nexport class PlainLocalValue {\n    /**\n     * Create a new PlainLocalValue.\n     * @param value - The value to store, which may contain shared object handles\n     */\n    constructor(value) {\n        this.value = value;\n    }\n    /**\n     * {@inheritDoc ILocalValue.\"type\"}\n     */\n    get type() {\n        return ValueType[ValueType.Plain];\n    }\n    /**\n     * {@inheritDoc ILocalValue.makeSerialized}\n     */\n    makeSerialized(serializer, bind) {\n        // Stringify to convert to the serialized handle values - and then parse in order to create\n        // a POJO for the op\n        const value = serializeHandles(this.value, serializer, bind);\n        return {\n            type: this.type,\n            value,\n        };\n    }\n}\n/**\n * Manages a contained value type.\n *\n * @privateRemarks\n * TODO: Should maybe be a generic\n *\n * @alpha\n */\nexport class ValueTypeLocalValue {\n    /**\n     * Create a new ValueTypeLocalValue.\n     * @param value - The instance of the value type stored within\n     * @param valueType - The type object of the value type stored within\n     */\n    constructor(value, valueType) {\n        this.value = value;\n        this.valueType = valueType;\n    }\n    /**\n     * {@inheritDoc ILocalValue.\"type\"}\n     */\n    get type() {\n        return this.valueType.name;\n    }\n    /**\n     * {@inheritDoc ILocalValue.makeSerialized}\n     */\n    makeSerialized(serializer, bind) {\n        const storedValueType = this.valueType.factory.store(this.value);\n        const value = serializeHandles(storedValueType, serializer, bind);\n        return {\n            type: this.type,\n            value,\n        };\n    }\n    /**\n     * Get the handler for a given op of this value type.\n     * @param opName - The name of the operation that needs processing\n     * @returns The object which can process the given op\n     */\n    getOpHandler(opName) {\n        const handler = this.valueType.ops.get(opName);\n        if (!handler) {\n            throw new Error(\"Unknown type message\");\n        }\n        return handler;\n    }\n}\n/**\n * A LocalValueMaker enables a container type DDS to produce and store local values with minimal awareness of how\n * those objects are stored, serialized, and deserialized.\n */\nexport class LocalValueMaker {\n    /**\n     * Create a new LocalValueMaker.\n     * @param serializer - The serializer to serialize / parse handles.\n     */\n    constructor(serializer) {\n        this.serializer = serializer;\n        /**\n         * The value types this maker is able to produce.\n         */\n        this.valueTypes = new Map();\n    }\n    /**\n     * Register a value type this maker will be able to produce.\n     * @param type - The value type to register\n     * @alpha\n     */\n    registerValueType(type) {\n        this.valueTypes.set(type.name, type);\n    }\n    /**\n     * Create a new local value from an incoming serialized value.\n     * @param serializable - The serializable value to make local\n     */\n    fromSerializable(serializable) {\n        // Migrate from old shared value to handles\n        if (serializable.type === ValueType[ValueType.Shared]) {\n            serializable.type = ValueType[ValueType.Plain];\n            const handle = {\n                type: \"__fluid_handle__\",\n                url: serializable.value,\n            };\n            serializable.value = handle;\n        }\n        const translatedValue = parseHandles(serializable.value, this.serializer);\n        return new PlainLocalValue(translatedValue);\n    }\n    /**\n     * Create a new local value from an incoming serialized value for value type\n     * @param serializable - The serializable value to make local\n     * @param emitter - The value op emitter, if the serializable is a value type\n     */\n    fromSerializableValueType(serializable, emitter) {\n        if (this.valueTypes.has(serializable.type)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const valueType = this.valueTypes.get(serializable.type);\n            serializable.value = parseHandles(serializable.value, this.serializer);\n            const localValue = valueType.factory.load(emitter, serializable.value);\n            return new ValueTypeLocalValue(localValue, valueType);\n        }\n        else {\n            throw new Error(`Unknown value type \"${serializable.type}\"`);\n        }\n    }\n    /**\n     * Create a new local value containing a given plain object.\n     * @param value - The value to store\n     * @returns An ILocalValue containing the value\n     */\n    fromInMemory(value) {\n        if (SharedObject.is(value)) {\n            throw new Error(\"SharedObject sets are no longer supported. Instead set the SharedObject handle.\");\n        }\n        return new PlainLocalValue(value);\n    }\n    /**\n     * Create a new local value containing a value type.\n     * @param type - The type of the value type to create\n     * @param emitter - The IValueOpEmitter object that the new value type will use to emit ops\n     * @param params - The initialization arguments for the value type\n     * @returns An ILocalValue containing the new value type\n     * @alpha\n     */\n    makeValueType(type, emitter, params) {\n        const valueType = this.loadValueType(params, type, emitter);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return new ValueTypeLocalValue(valueType, this.valueTypes.get(type));\n    }\n    /**\n     * Create a new value type.\n     * @param params - The initialization arguments for the value type\n     * @param type - The type of value type to create\n     * @param emitter - The IValueOpEmitter object that the new value type will use to emit ops\n     * @returns The new value type\n     * @alpha\n     */\n    loadValueType(params, type, emitter) {\n        const valueType = this.valueTypes.get(type);\n        if (!valueType) {\n            throw new Error(`Unknown type '${type}' specified`);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return valueType.factory.load(emitter, params);\n    }\n}\n//# sourceMappingURL=localValues.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { addBlobToTree } from \"@fluidframework/protocol-base\";\nimport { MessageType, } from \"@fluidframework/protocol-definitions\";\nimport { readAndParse } from \"@fluidframework/driver-utils\";\nimport { SharedObject, } from \"@fluidframework/shared-object-base\";\nimport { debug } from \"./debug\";\nimport { MapKernel } from \"./mapKernel\";\nimport { pkgVersion } from \"./packageVersion\";\nconst snapshotFileName = \"header\";\n/**\n * The factory that defines the map.\n * @sealed\n */\nexport class MapFactory {\n    /**\n    * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.\"type\"}\n    */\n    get type() {\n        return MapFactory.Type;\n    }\n    /**\n    * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}\n    */\n    get attributes() {\n        return MapFactory.Attributes;\n    }\n    /**\n    * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n    */\n    async load(runtime, id, services, attributes) {\n        const map = new SharedMap(id, runtime, attributes);\n        await map.load(services);\n        return map;\n    }\n    /**\n    * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.create}\n    */\n    create(runtime, id) {\n        const map = new SharedMap(id, runtime, MapFactory.Attributes);\n        map.initializeLocal();\n        return map;\n    }\n}\n/**\n* {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.\"type\"}\n*/\nMapFactory.Type = \"https://graph.microsoft.com/types/map\";\n/**\n* {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}\n*/\nMapFactory.Attributes = {\n    type: MapFactory.Type,\n    snapshotFormatVersion: \"0.2\",\n    packageVersion: pkgVersion,\n};\n/**\n * The SharedMap distributed data structure can be used to store key-value pairs. It provides the same API for setting\n * and retrieving values that JavaScript developers are accustomed to with the\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map | Map} built-in object.\n * However, the keys of a SharedMap must be strings.\n */\nexport class SharedMap extends SharedObject {\n    /**\n    * Do not call the constructor. Instead, you should use the {@link SharedMap.create | create method}.\n    *\n    * @param id - String identifier.\n    * @param runtime - Data store runtime.\n    * @param attributes - The attributes for the map.\n    */\n    constructor(id, runtime, attributes) {\n        super(id, runtime, attributes);\n        /**\n        * String representation for the class.\n        */\n        this[Symbol.toStringTag] = \"SharedMap\";\n        this.kernel = new MapKernel(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), () => this.isAttached(), [], this);\n    }\n    /**\n     * Create a new shared map.\n     * @param runtime - The data store runtime that the new shared map belongs to.\n     * @param id - Optional name of the shared map.\n     * @returns Newly created shared map.\n     *\n     * @example\n     * To create a `SharedMap`, call the static create method:\n     *\n     * ```typescript\n     * const myMap = SharedMap.create(this.runtime, id);\n     * ```\n     *\n     */\n    static create(runtime, id) {\n        return runtime.createChannel(id, MapFactory.Type);\n    }\n    /**\n     * Get a factory for SharedMap to register with the data store.\n     * @returns A factory that creates SharedMaps and loads them from storage.\n     */\n    static getFactory() {\n        return new MapFactory();\n    }\n    /**\n    * {@inheritDoc MapKernel.keys}\n    */\n    keys() {\n        return this.kernel.keys();\n    }\n    /**\n    * {@inheritDoc MapKernel.entries}\n    */\n    entries() {\n        return this.kernel.entries();\n    }\n    /**\n    * {@inheritDoc MapKernel.values}\n    */\n    values() {\n        return this.kernel.values();\n    }\n    /**\n    * Get an iterator over the entries in this map.\n    * @returns The iterator\n    */\n    [Symbol.iterator]() {\n        return this.kernel.entries();\n    }\n    /**\n    * {@inheritDoc MapKernel.size}\n    */\n    get size() {\n        return this.kernel.size;\n    }\n    /**\n    * {@inheritDoc MapKernel.forEach}\n    */\n    forEach(callbackFn) {\n        this.kernel.forEach(callbackFn);\n    }\n    /**\n    * {@inheritDoc ISharedMap.get}\n    */\n    get(key) {\n        return this.kernel.get(key);\n    }\n    /**\n    * {@inheritDoc ISharedMap.wait}\n    */\n    async wait(key) {\n        return this.kernel.wait(key);\n    }\n    /**\n    * {@inheritDoc MapKernel.has}\n    */\n    has(key) {\n        return this.kernel.has(key);\n    }\n    /**\n    * {@inheritDoc ISharedMap.set}\n    */\n    set(key, value) {\n        this.kernel.set(key, value);\n        return this;\n    }\n    /**\n    * {@inheritDoc MapKernel.delete}\n    */\n    delete(key) {\n        return this.kernel.delete(key);\n    }\n    /**\n    * {@inheritDoc MapKernel.clear}\n    */\n    clear() {\n        this.kernel.clear();\n    }\n    /**\n    * {@inheritDoc @fluidframework/shared-object-base#SharedObject.snapshotCore}\n    */\n    snapshotCore(serializer) {\n        let currentSize = 0;\n        let counter = 0;\n        let headerBlob = {};\n        const blobs = [];\n        const tree = {\n            entries: [],\n        };\n        const data = this.kernel.getSerializedStorage(serializer);\n        // If single property exceeds this size, it goes into its own blob\n        const MinValueSizeSeparateSnapshotBlob = 8 * 1024;\n        // Maximum blob size for multiple map properties\n        // Should be bigger than MinValueSizeSeparateSnapshotBlob\n        const MaxSnapshotBlobSize = 16 * 1024;\n        // Partitioning algorithm:\n        // 1) Split large (over MinValueSizeSeparateSnapshotBlob = 8K) properties into their own blobs.\n        //    Naming (across snapshots) of such blob does not have to be stable across snapshots,\n        //    As de-duping process (in driver) should not care about paths, only content.\n        // 2) Split remaining properties into blobs of MaxSnapshotBlobSize (16K) size.\n        //    This process does not produce stable partitioning. This means\n        //    modification (including addition / deletion) of property can shift properties across blobs\n        //    and result in non-incremental snapshot.\n        //    This can be improved in the future, without being format breaking change, as loading sequence\n        //    loads all blobs at once and partitioning schema has no impact on that process.\n        for (const key of Object.keys(data)) {\n            const value = data[key];\n            if (value.value && value.value.length >= MinValueSizeSeparateSnapshotBlob) {\n                const blobName = `blob${counter}`;\n                counter++;\n                blobs.push(blobName);\n                const content = {\n                    [key]: {\n                        type: value.type,\n                        value: JSON.parse(value.value),\n                    },\n                };\n                addBlobToTree(tree, blobName, content);\n            }\n            else {\n                currentSize += value.type.length + 21; // Approximation cost of property header\n                if (value.value) {\n                    currentSize += value.value.length;\n                }\n                if (currentSize > MaxSnapshotBlobSize) {\n                    const blobName = `blob${counter}`;\n                    counter++;\n                    blobs.push(blobName);\n                    addBlobToTree(tree, blobName, headerBlob);\n                    headerBlob = {};\n                    currentSize = 0;\n                }\n                headerBlob[key] = {\n                    type: value.type,\n                    value: value.value === undefined ? undefined : JSON.parse(value.value),\n                };\n            }\n        }\n        const header = {\n            absolutePath: this.handle.absolutePath,\n            blobs,\n            content: headerBlob,\n        };\n        addBlobToTree(tree, snapshotFileName, header);\n        return tree;\n    }\n    getSerializableStorage() {\n        return this.kernel.getSerializableStorage(this.serializer);\n    }\n    /**\n    * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n    */\n    async loadCore(storage) {\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        const json = await readAndParse(storage, snapshotFileName);\n        const newFormat = json;\n        if (Array.isArray(newFormat.blobs)) {\n            this.kernel.populateFromSerializable(newFormat.content);\n            await Promise.all(newFormat.blobs.map(async (value) => {\n                const content = await readAndParse(storage, value);\n                this.kernel.populateFromSerializable(content);\n            }));\n        }\n        else {\n            this.kernel.populateFromSerializable(json);\n        }\n    }\n    /**\n    * {@inheritDoc @fluidframework/shared-object-base#SharedObject.onDisconnect}\n    */\n    onDisconnect() {\n        debug(`Map ${this.id} is now disconnected`);\n    }\n    /**\n      * {@inheritDoc @fluidframework/shared-object-base#SharedObject.reSubmitCore}\n      */\n    reSubmitCore(content, localOpMetadata) {\n        this.kernel.trySubmitMessage(content, localOpMetadata);\n    }\n    applyStashedOp(content) {\n        this.kernel.tryProcessMessage(content, false, undefined, undefined);\n        return this.kernel.tryGetStashedOpLocalMetadata(content);\n    }\n    /**\n    * {@inheritDoc @fluidframework/shared-object-base#SharedObject.processCore}\n    */\n    processCore(message, local, localOpMetadata) {\n        if (message.type === MessageType.Operation) {\n            this.kernel.tryProcessMessage(message.contents, local, message, localOpMetadata);\n        }\n    }\n    /**\n    * {@inheritDoc @fluidframework/shared-object-base#SharedObject.registerCore}\n    */\n    registerCore() {\n        for (const value of this.values()) {\n            if (SharedObject.is(value)) {\n                value.bindToContext();\n            }\n        }\n    }\n}\n//# sourceMappingURL=map.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { makeHandlesSerializable, parseHandles, ValueType } from \"@fluidframework/shared-object-base\";\nimport { assert, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { LocalValueMaker, makeSerializable, } from \"./localValues\";\n/**\n * A SharedMap is a map-like distributed data structure.\n */\nexport class MapKernel {\n    /**\n     * Create a new shared map kernel.\n     * @param serializer - The serializer to serialize / parse handles\n     * @param handle - The handle of the shared object using the kernel\n     * @param submitMessage - A callback to submit a message through the shared object\n     * @param isAttached - To query whether the shared object should generate ops\n     * @param valueTypes - The value types to register\n     * @param eventEmitter - The object that will emit map events\n     */\n    constructor(serializer, handle, submitMessage, isAttached, valueTypes, eventEmitter = new TypedEventEmitter()) {\n        this.serializer = serializer;\n        this.handle = handle;\n        this.submitMessage = submitMessage;\n        this.isAttached = isAttached;\n        this.eventEmitter = eventEmitter;\n        /**\n         * Mapping of op types to message handlers.\n         */\n        this.messageHandlers = new Map();\n        /**\n         * The in-memory data the map is storing.\n         */\n        this.data = new Map();\n        /**\n         * Keys that have been modified locally but not yet ack'd from the server.\n         */\n        this.pendingKeys = new Map();\n        /**\n         * This is used to assign a unique id to every outgoing operation and helps in tracking unack'd ops.\n         */\n        this.pendingMessageId = -1;\n        /**\n         * If a clear has been performed locally but not yet ack'd from the server, then this stores the pending id\n         * of that clear operation. Otherwise, is -1.\n         */\n        this.pendingClearMessageId = -1;\n        this.localValueMaker = new LocalValueMaker(serializer);\n        this.messageHandlers = this.getMessageHandlers();\n        for (const type of valueTypes) {\n            this.localValueMaker.registerValueType(type);\n        }\n    }\n    /**\n     * The number of key/value pairs stored in the map.\n     */\n    get size() {\n        return this.data.size;\n    }\n    /**\n     * Get an iterator over the keys in this map.\n     * @returns The iterator\n     */\n    keys() {\n        return this.data.keys();\n    }\n    /**\n     * Get an iterator over the entries in this map.\n     * @returns The iterator\n     */\n    entries() {\n        const localEntriesIterator = this.data.entries();\n        const iterator = {\n            next() {\n                const nextVal = localEntriesIterator.next();\n                if (nextVal.done) {\n                    return { value: undefined, done: true };\n                }\n                else {\n                    // Unpack the stored value\n                    return { value: [nextVal.value[0], nextVal.value[1].value], done: false };\n                }\n            },\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n        return iterator;\n    }\n    /**\n     * Get an iterator over the values in this map.\n     * @returns The iterator\n     */\n    values() {\n        const localValuesIterator = this.data.values();\n        const iterator = {\n            next() {\n                const nextVal = localValuesIterator.next();\n                if (nextVal.done) {\n                    return { value: undefined, done: true };\n                }\n                else {\n                    // Unpack the stored value\n                    return { value: nextVal.value.value, done: false };\n                }\n            },\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n        return iterator;\n    }\n    /**\n     * Get an iterator over the entries in this map.\n     * @returns The iterator\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Executes the given callback on each entry in the map.\n     * @param callbackFn - Callback function\n     */\n    forEach(callbackFn) {\n        this.data.forEach((localValue, key, m) => {\n            callbackFn(localValue.value, key, m);\n        });\n    }\n    /**\n     * {@inheritDoc ISharedMap.get}\n     */\n    get(key) {\n        if (!this.data.has(key)) {\n            return undefined;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const localValue = this.data.get(key);\n        return localValue.value;\n    }\n    /**\n     * {@inheritDoc ISharedMap.wait}\n     */\n    async wait(key) {\n        // Return immediately if the value already exists\n        if (this.has(key)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return this.get(key);\n        }\n        // Otherwise subscribe to changes\n        return new Promise((resolve) => {\n            const callback = (changed) => {\n                if (key === changed.key) {\n                    // eslint-disable-next-line max-len\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-unnecessary-type-assertion\n                    resolve(this.get(changed.key));\n                    this.eventEmitter.removeListener(\"valueChanged\", callback);\n                }\n            };\n            this.eventEmitter.on(\"valueChanged\", callback);\n        });\n    }\n    /**\n     * Check if a key exists in the map.\n     * @param key - The key to check\n     * @returns True if the key exists, false otherwise\n     */\n    has(key) {\n        return this.data.has(key);\n    }\n    /**\n     * {@inheritDoc ISharedMap.set}\n     */\n    set(key, value) {\n        // Undefined/null keys can't be serialized to JSON in the manner we currently snapshot.\n        if (key === undefined || key === null) {\n            throw new Error(\"Undefined and null keys are not supported\");\n        }\n        // Create a local value and serialize it.\n        const localValue = this.localValueMaker.fromInMemory(value);\n        const serializableValue = makeSerializable(localValue, this.serializer, this.handle);\n        // Set the value locally.\n        this.setCore(key, localValue, true, undefined);\n        // If we are not attached, don't submit the op.\n        if (!this.isAttached()) {\n            return;\n        }\n        const op = {\n            key,\n            type: \"set\",\n            value: serializableValue,\n        };\n        this.submitMapKeyMessage(op);\n    }\n    /**\n     * {@inheritDoc IValueTypeCreator.createValueType}\n     */\n    createValueType(key, type, params) {\n        // Create a local value and serialize it.\n        const localValue = this.localValueMaker.makeValueType(type, this.makeMapValueOpEmitter(key), params);\n        // TODO ideally we could use makeSerialized in this case as well. But the interval\n        // collection has assumptions of attach being called prior. Given the IFluidSerializer it\n        // may be possible to remove custom value type serialization entirely.\n        const transformedValue = makeHandlesSerializable(params, this.serializer, this.handle);\n        // Set the value locally.\n        this.setCore(key, localValue, true, undefined);\n        // If we are not attached, don't submit the op.\n        if (!this.isAttached()) {\n            return this;\n        }\n        // This is a special form of serialized valuetype only used for set, containing info for initialization.\n        // After initialization, the serialized form will need to come from the .store of the value type's factory.\n        const serializableValue = { type, value: transformedValue };\n        const op = {\n            key,\n            type: \"set\",\n            value: serializableValue,\n        };\n        this.submitMapKeyMessage(op);\n        return this;\n    }\n    /**\n     * Delete a key from the map.\n     * @param key - Key to delete\n     * @returns True if the key existed and was deleted, false if it did not exist\n     */\n    delete(key) {\n        // Delete the key locally first.\n        const successfullyRemoved = this.deleteCore(key, true, undefined);\n        // If we are not attached, don't submit the op.\n        if (!this.isAttached()) {\n            return successfullyRemoved;\n        }\n        const op = {\n            key,\n            type: \"delete\",\n        };\n        this.submitMapKeyMessage(op);\n        return successfullyRemoved;\n    }\n    /**\n     * Clear all data from the map.\n     */\n    clear() {\n        // Clear the data locally first.\n        this.clearCore(true, undefined);\n        // If we are not attached, don't submit the op.\n        if (!this.isAttached()) {\n            return;\n        }\n        const op = {\n            type: \"clear\",\n        };\n        this.submitMapClearMessage(op);\n    }\n    /**\n     * Serializes the data stored in the shared map to a JSON string\n     * @param serializer - The serializer to use to serialize handles in its values.\n     * @returns A JSON string containing serialized map data\n     */\n    getSerializedStorage(serializer) {\n        const serializableMapData = {};\n        this.data.forEach((localValue, key) => {\n            serializableMapData[key] = localValue.makeSerialized(serializer, this.handle);\n        });\n        return serializableMapData;\n    }\n    getSerializableStorage(serializer) {\n        const serializableMapData = {};\n        this.data.forEach((localValue, key) => {\n            serializableMapData[key] = makeSerializable(localValue, serializer, this.handle);\n        });\n        return serializableMapData;\n    }\n    serialize(serializer) {\n        return JSON.stringify(this.getSerializableStorage(serializer));\n    }\n    /**\n     * Populate the kernel with the given map data.\n     * @param data - A JSON string containing serialized map data\n     */\n    populateFromSerializable(json) {\n        for (const [key, serializable] of Object.entries(json)) {\n            const localValue = {\n                key,\n                value: this.makeLocal(key, serializable),\n            };\n            this.data.set(localValue.key, localValue.value);\n        }\n    }\n    populate(json) {\n        this.populateFromSerializable(JSON.parse(json));\n    }\n    /**\n     * Submit the given op if a handler is registered.\n     * @param op - The operation to attempt to submit\n     * @param localOpMetadata - The local metadata associated with the op. This is kept locally by the runtime\n     * and not sent to the server. This will be sent back when this message is received back from the server. This is\n     * also sent if we are asked to resubmit the message.\n     * @returns True if the operation was submitted, false otherwise.\n     */\n    trySubmitMessage(op, localOpMetadata) {\n        const type = op.type;\n        if (this.messageHandlers.has(type)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.messageHandlers.get(type).submit(op, localOpMetadata);\n            return true;\n        }\n        return false;\n    }\n    tryGetStashedOpLocalMetadata(op) {\n        const type = op.type;\n        if (this.messageHandlers.has(type)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return this.messageHandlers.get(type).getStashedOpLocalMetadata(op);\n        }\n        throw new Error(\"no apply stashed op handler\");\n    }\n    /**\n     * Process the given op if a handler is registered.\n     * @param message - The message to process\n     * @param local - Whether the message originated from the local client\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @returns True if the operation was processed, false otherwise.\n     */\n    tryProcessMessage(op, local, message, localOpMetadata) {\n        if (this.messageHandlers.has(op.type)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.messageHandlers\n                .get(op.type)\n                .process(op, local, message, localOpMetadata);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Set implementation used for both locally sourced sets as well as incoming remote sets.\n     * @param key - The key being set\n     * @param value - The value being set\n     * @param local - Whether the message originated from the local client\n     * @param op - The message if from a remote set, or null if from a local set\n     */\n    setCore(key, value, local, op) {\n        const previousValue = this.get(key);\n        this.data.set(key, value);\n        const event = { key, previousValue };\n        this.eventEmitter.emit(\"valueChanged\", event, local, op, this.eventEmitter);\n    }\n    /**\n     * Clear implementation used for both locally sourced clears as well as incoming remote clears.\n     * @param local - Whether the message originated from the local client\n     * @param op - The message if from a remote clear, or null if from a local clear\n     */\n    clearCore(local, op) {\n        this.data.clear();\n        this.eventEmitter.emit(\"clear\", local, op, this.eventEmitter);\n    }\n    /**\n     * Delete implementation used for both locally sourced deletes as well as incoming remote deletes.\n     * @param key - The key being deleted\n     * @param local - Whether the message originated from the local client\n     * @param op - The message if from a remote delete, or null if from a local delete\n     * @returns True if the key existed and was deleted, false if it did not exist\n     */\n    deleteCore(key, local, op) {\n        const previousValue = this.get(key);\n        const successfullyRemoved = this.data.delete(key);\n        if (successfullyRemoved) {\n            const event = { key, previousValue };\n            this.eventEmitter.emit(\"valueChanged\", event, local, op, this.eventEmitter);\n        }\n        return successfullyRemoved;\n    }\n    /**\n     * Clear all keys in memory in response to a remote clear, but retain keys we have modified but not yet been ack'd.\n     */\n    clearExceptPendingKeys() {\n        // Assuming the pendingKeys is small and the map is large\n        // we will get the value for the pendingKeys and clear the map\n        const temp = new Map();\n        this.pendingKeys.forEach((value, key) => {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            temp.set(key, this.data.get(key));\n        });\n        this.data.clear();\n        temp.forEach((value, key) => {\n            this.data.set(key, value);\n        });\n    }\n    /**\n     * The remote ISerializableValue we're receiving (either as a result of a load or an incoming set op) will\n     * have the information we need to create a real object, but will not be the real object yet.  For example,\n     * we might know it's a map and the map's ID but not have the actual map or its data yet.  makeLocal's\n     * job is to convert that information into a real object for local usage.\n     * @param key - The key that the caller intends to store the local value into (used for ops later).  But\n     * doesn't actually store the local value into that key.  So better not lie!\n     * @param serializable - The remote information that we can convert into a real object\n     * @returns The local value that was produced\n     */\n    makeLocal(key, serializable) {\n        if (serializable.type === ValueType[ValueType.Plain] || serializable.type === ValueType[ValueType.Shared]) {\n            return this.localValueMaker.fromSerializable(serializable);\n        }\n        else {\n            return this.localValueMaker.fromSerializableValueType(serializable, this.makeMapValueOpEmitter(key));\n        }\n    }\n    /**\n     * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should\n     * not process the incoming operation.\n     * @param op - Operation to check\n     * @param local - Whether the message originated from the local client\n     * @param message - The message\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @returns True if the operation should be processed, false otherwise\n     */\n    needProcessKeyOperation(op, local, localOpMetadata) {\n        if (this.pendingClearMessageId !== -1) {\n            if (local) {\n                assert(localOpMetadata !== undefined && localOpMetadata < this.pendingClearMessageId, 0x013 /* \"Received out of order op when there is an unackd clear message\" */);\n            }\n            // If we have an unack'd clear, we can ignore all ops.\n            return false;\n        }\n        if (this.pendingKeys.has(op.key)) {\n            // Found an unack'd op. Clear it from the map if the pendingMessageId in the map matches this message's\n            // and don't process the op.\n            if (local) {\n                assert(localOpMetadata !== undefined, 0x014 /* `pendingMessageId is missing from the local client's ${op.type} operation` */);\n                const pendingMessageId = localOpMetadata;\n                const pendingKeyMessageId = this.pendingKeys.get(op.key);\n                if (pendingKeyMessageId === pendingMessageId) {\n                    this.pendingKeys.delete(op.key);\n                }\n            }\n            return false;\n        }\n        // If we don't have a NACK op on the key, we need to process the remote ops.\n        return !local;\n    }\n    /**\n     * Get the message handlers for the map.\n     * @returns A map of string op names to IMapMessageHandlers for those ops\n     */\n    getMessageHandlers() {\n        const messageHandlers = new Map();\n        messageHandlers.set(\"clear\", {\n            process: (op, local, message, localOpMetadata) => {\n                if (local) {\n                    assert(localOpMetadata !== undefined, 0x015 /* \"pendingMessageId is missing from the local client's clear operation\" */);\n                    const pendingMessageId = localOpMetadata;\n                    if (this.pendingClearMessageId === pendingMessageId) {\n                        this.pendingClearMessageId = -1;\n                    }\n                    return;\n                }\n                if (this.pendingKeys.size !== 0) {\n                    this.clearExceptPendingKeys();\n                    return;\n                }\n                this.clearCore(local, message);\n            },\n            submit: (op, localOpMetadata) => {\n                // We don't reuse the metadata but send a new one on each submit.\n                this.submitMapClearMessage(op);\n            },\n            getStashedOpLocalMetadata: (op) => {\n                // We don't reuse the metadata but send a new one on each submit.\n                return this.getMapClearMessageLocalMetadata(op);\n            },\n        });\n        messageHandlers.set(\"delete\", {\n            process: (op, local, message, localOpMetadata) => {\n                if (!this.needProcessKeyOperation(op, local, localOpMetadata)) {\n                    return;\n                }\n                this.deleteCore(op.key, local, message);\n            },\n            submit: (op, localOpMetadata) => {\n                // We don't reuse the metadata but send a new one on each submit.\n                this.submitMapKeyMessage(op);\n            },\n            getStashedOpLocalMetadata: (op) => {\n                // We don't reuse the metadata but send a new one on each submit.\n                return this.getMapKeyMessageLocalMetadata(op);\n            },\n        });\n        messageHandlers.set(\"set\", {\n            process: (op, local, message, localOpMetadata) => {\n                if (!this.needProcessKeyOperation(op, local, localOpMetadata)) {\n                    return;\n                }\n                // needProcessKeyOperation should have returned false if local is true\n                const context = this.makeLocal(op.key, op.value);\n                this.setCore(op.key, context, local, message);\n            },\n            submit: (op, localOpMetadata) => {\n                // We don't reuse the metadata but send a new one on each submit.\n                this.submitMapKeyMessage(op);\n            },\n            getStashedOpLocalMetadata: (op) => {\n                // We don't reuse the metadata but send a new one on each submit.\n                return this.getMapKeyMessageLocalMetadata(op);\n            },\n        });\n        // Ops with type \"act\" describe actions taken by custom value type handlers of whatever item is\n        // being addressed.  These custom handlers can be retrieved from the ValueTypeLocalValue which has\n        // stashed its valueType (and therefore its handlers).  We also emit a valueChanged for anyone\n        // watching for manipulations of that item.\n        messageHandlers.set(\"act\", {\n            process: (op, local, message, localOpMetadata) => {\n                // Local value might not exist if we deleted it\n                const localValue = this.data.get(op.key);\n                if (!localValue) {\n                    return;\n                }\n                const handler = localValue.getOpHandler(op.value.opName);\n                const previousValue = localValue.value;\n                const translatedValue = parseHandles(op.value.value, this.serializer);\n                handler.process(previousValue, translatedValue, local, message);\n                const event = { key: op.key, previousValue };\n                this.eventEmitter.emit(\"valueChanged\", event, local, message, this.eventEmitter);\n            },\n            submit: (op, localOpMetadata) => {\n                this.submitMessage(op, localOpMetadata);\n            },\n            getStashedOpLocalMetadata: (op) => {\n                assert(false, 0x016 /* \"apply stashed op not implemented for custom value type ops\" */);\n            },\n        });\n        return messageHandlers;\n    }\n    getMapClearMessageLocalMetadata(op) {\n        const pendingMessageId = ++this.pendingMessageId;\n        this.pendingClearMessageId = pendingMessageId;\n        return pendingMessageId;\n    }\n    /**\n     * Submit a clear message to remote clients.\n     * @param op - The clear message\n     */\n    submitMapClearMessage(op) {\n        const pendingMessageId = this.getMapClearMessageLocalMetadata(op);\n        this.submitMessage(op, pendingMessageId);\n    }\n    getMapKeyMessageLocalMetadata(op) {\n        const pendingMessageId = ++this.pendingMessageId;\n        this.pendingKeys.set(op.key, pendingMessageId);\n        return pendingMessageId;\n    }\n    /**\n     * Submit a map key message to remote clients.\n     * @param op - The map key message\n     */\n    submitMapKeyMessage(op) {\n        const pendingMessageId = this.getMapKeyMessageLocalMetadata(op);\n        this.submitMessage(op, pendingMessageId);\n    }\n    /**\n     * Create an emitter for a value type to emit ops from the given key.\n     * @alpha\n     * @param key - The key of the map that the value type will be stored on\n     * @returns A value op emitter for the given key\n     */\n    makeMapValueOpEmitter(key) {\n        const emit = (opName, previousValue, params) => {\n            const translatedParams = makeHandlesSerializable(params, this.serializer, this.handle);\n            const op = {\n                key,\n                type: \"act\",\n                value: {\n                    opName,\n                    value: translatedParams,\n                },\n            };\n            // Send the localOpMetadata as undefined because we don't care about the ack.\n            this.submitMessage(op, undefined /* localOpMetadata */);\n            const event = { key, previousValue };\n            this.eventEmitter.emit(\"valueChanged\", event, true, null, this.eventEmitter);\n        };\n        return { emit };\n    }\n}\n//# sourceMappingURL=mapKernel.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n *\n * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n */\nexport const pkgName = \"@fluidframework/map\";\nexport const pkgVersion = \"0.37.4\";\n//# sourceMappingURL=packageVersion.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { assert, Trace } from \"@fluidframework/common-utils\";\nimport { LoggingError } from \"@fluidframework/telemetry-utils\";\nimport * as Collections from \"./collections\";\nimport { UnassignedSequenceNumber, UniversalSequenceNumber } from \"./constants\";\nimport { LocalReference } from \"./localReference\";\nimport { compareStrings, elapsedMicroseconds, MergeTree, RegisterCollection, } from \"./mergeTree\";\nimport * as OpBuilder from \"./opBuilder\";\nimport { SnapshotLegacy } from \"./snapshotlegacy\";\nimport { SnapshotLoader } from \"./snapshotLoader\";\nimport { MergeTreeTextHelper } from \"./textSegment\";\nimport { SnapshotV1 } from \"./snapshotV1\";\nexport class Client {\n    constructor(\n    // Passing this callback would be unnecessary if Client were merged with SharedSegmentSequence\n    specToSegment, logger, options) {\n        this.specToSegment = specToSegment;\n        this.logger = logger;\n        this.verboseOps = false;\n        this.noVerboseRemoteAnnotate = false;\n        this.measureOps = false;\n        this.registerCollection = new RegisterCollection();\n        this.accumTime = 0;\n        this.localTime = 0;\n        this.localOps = 0;\n        this.accumWindowTime = 0;\n        this.accumWindow = 0;\n        this.accumOps = 0;\n        this.maxWindowTime = 0;\n        this.clientNameToIds = new Collections.RedBlackTree(compareStrings);\n        this.shortClientIdMap = [];\n        this.pendingConsensus = new Map();\n        this.mergeTree = new MergeTree(options);\n        this.mergeTree.getLongClientId = (id) => this.getLongClientId(id);\n    }\n    get mergeTreeDeltaCallback() { return this.mergeTree.mergeTreeDeltaCallback; }\n    set mergeTreeDeltaCallback(callback) {\n        this.mergeTree.mergeTreeDeltaCallback = callback;\n    }\n    get mergeTreeMaintenanceCallback() {\n        return this.mergeTree.mergeTreeMaintenanceCallback;\n    }\n    set mergeTreeMaintenanceCallback(callback) {\n        this.mergeTree.mergeTreeMaintenanceCallback = callback;\n    }\n    /**\n     * The merge tree maintains a queue of segment groups for each local operation.\n     * These segment groups track segments modified by an operation.\n     * This method peeks the tail of that queue, and returns the segments groups there.\n     * It is used to get the segment group(s) for the previous operations.\n     * @param count - The number segment groups to get peek from the tail of the queue. Default 1.\n     */\n    peekPendingSegmentGroups(count = 1) {\n        var _a, _b;\n        if (count === 1) {\n            return (_a = this.mergeTree.pendingSegments) === null || _a === void 0 ? void 0 : _a.last();\n        }\n        let taken = 0;\n        return (_b = this.mergeTree.pendingSegments) === null || _b === void 0 ? void 0 : _b.some(() => {\n            if (taken < count) {\n                taken++;\n                return true;\n            }\n            return false;\n        }, true);\n    }\n    /**\n     * Annotate a maker and call the callback on concensus.\n     * @param marker - The marker to annotate\n     * @param props - The properties to annotate the marker with\n     * @param consensusCallback - The callback called when consensus is reached\n     * @returns The annotate op if valid, otherwise undefined\n     */\n    annotateMarkerNotifyConsensus(marker, props, consensusCallback) {\n        const combiningOp = {\n            name: \"consensus\",\n        };\n        const annotateOp = this.annotateMarker(marker, props, combiningOp);\n        if (annotateOp) {\n            const consensusInfo = {\n                callback: consensusCallback,\n                marker,\n            };\n            this.pendingConsensus.set(marker.getId(), consensusInfo);\n            return annotateOp;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Annotates the markers with the provided properties\n     * @param marker - The marker to annotate\n     * @param props - The properties to annotate the marker with\n     * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n     * @returns The annotate op if valid, otherwise undefined\n     */\n    annotateMarker(marker, props, combiningOp) {\n        const annotateOp = OpBuilder.createAnnotateMarkerOp(marker, props, combiningOp);\n        if (this.applyAnnotateRangeOp({ op: annotateOp })) {\n            return annotateOp;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Annotates the range with the provided properties\n     * @param start - The inclusive start postition of the range to annotate\n     * @param end - The exclusive end position of the range to annotate\n     * @param props - The properties to annotate the range with\n     * @param combiningOp - Specifies how to combine values for the property, such as \"incr\" for increment.\n     * @returns The annotate op if valid, otherwise undefined\n     */\n    annotateRangeLocal(start, end, props, combiningOp) {\n        const annotateOp = OpBuilder.createAnnotateRangeOp(start, end, props, combiningOp);\n        if (this.applyAnnotateRangeOp({ op: annotateOp })) {\n            return annotateOp;\n        }\n        return undefined;\n    }\n    /**\n     * Removes the range and puts the content of the removed range in a register\n     * if a register name is provided\n     *\n     * @param start - The inclusive start of the range to remove\n     * @param end - The exclusive end of the range to remove\n     * @param register - Optional. The name of the register to store the removed range in\n     */\n    removeRangeLocal(start, end, register) {\n        const removeOp = OpBuilder.createRemoveRangeOp(start, end, register);\n        if (this.applyRemoveRangeOp({ op: removeOp })) {\n            return removeOp;\n        }\n        return undefined;\n    }\n    /**\n     * @param pos - The position to insert the segment at\n     * @param segment - The segment to insert\n     */\n    insertSegmentLocal(pos, segment) {\n        if (segment.cachedLength <= 0) {\n            return undefined;\n        }\n        const insertOp = OpBuilder.createInsertSegmentOp(pos, segment);\n        if (this.applyInsertOp({ op: insertOp })) {\n            return insertOp;\n        }\n        return undefined;\n    }\n    /**\n     * @param refPos - The reference position to insert the segment at\n     * @param segment - The segment to insert\n     */\n    insertAtReferencePositionLocal(refPos, segment) {\n        const pos = this.mergeTree.referencePositionToLocalPosition(refPos, this.getCurrentSeq(), this.getClientId());\n        if (pos === LocalReference.DetachedPosition) {\n            return undefined;\n        }\n        const op = OpBuilder.createInsertSegmentOp(pos, segment);\n        const opArgs = { op };\n        let traceStart;\n        if (this.measureOps) {\n            traceStart = Trace.start();\n        }\n        this.mergeTree.insertAtReferencePosition(refPos, segment, opArgs);\n        this.completeAndLogOp(opArgs, this.getClientSequenceArgs(opArgs), { start: op.pos1 }, traceStart);\n        return op;\n    }\n    /**\n     * @param pos - The position to insert the register contents at\n     * @param register - The name of the register to insert the value of\n     */\n    pasteLocal(pos, register) {\n        const insertOp = OpBuilder.createInsertFromRegisterOp(pos, register);\n        if (this.applyInsertOp({ op: insertOp })) {\n            return insertOp;\n        }\n        return undefined;\n    }\n    /**\n     *\n     * @param start - he inclusive start of the range to copy into the register\n     * @param end - The exclusive end of the range to copy into the register\n     * @param register - The name of the register to insert the range contents into\n     */\n    copyLocal(start, end, register) {\n        const insertOp = OpBuilder.createInsertToRegisterOp(start, end, register);\n        if (this.applyInsertOp({ op: insertOp })) {\n            return insertOp;\n        }\n        return undefined;\n    }\n    walkSegments(handler, start, end, accum, splitRange = false) {\n        this.mergeTree.mapRange({\n            leaf: handler,\n        }, this.getCurrentSeq(), this.getClientId(), accum, start, end, splitRange);\n    }\n    getCollabWindow() {\n        return this.mergeTree.getCollabWindow();\n    }\n    /**\n     * Returns the current position of a segment, and -1 if the segment\n     * does not exist in this merge tree\n     * @param segment - The segment to get the position of\n     */\n    getPosition(segment) {\n        if ((segment === null || segment === void 0 ? void 0 : segment.parent) === undefined) {\n            return -1;\n        }\n        return this.mergeTree.getPosition(segment, this.getCurrentSeq(), this.getClientId());\n    }\n    addLocalReference(lref) {\n        return this.mergeTree.addLocalReference(lref);\n    }\n    removeLocalReference(lref) {\n        return this.mergeTree.removeLocalReference(lref.segment, lref);\n    }\n    /**\n     * Given a position specified relative to a marker id, lookup the marker\n     * and convert the position to a character position.\n     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.\n     */\n    posFromRelativePos(relativePos) {\n        return this.mergeTree.posFromRelativePos(relativePos);\n    }\n    getMarkerFromId(id) {\n        return this.mergeTree.getMarkerFromId(id);\n    }\n    /**\n     * Performs the remove based on the provided op\n     * @param opArgs - The ops args for the op\n     * @returns True if the remove was applied. False if it could not be.\n     */\n    applyRemoveRangeOp(opArgs) {\n        assert(opArgs.op.type === 1 /* REMOVE */, 0x02d /* \"Unexpected op type on range remove!\" */);\n        const op = opArgs.op;\n        const clientArgs = this.getClientSequenceArgs(opArgs);\n        const range = this.getValidOpRange(op, clientArgs);\n        if (!range) {\n            return false;\n        }\n        if (op.register) {\n            // Cut\n            this.copy(range, op.register, clientArgs);\n        }\n        let traceStart;\n        if (this.measureOps) {\n            traceStart = Trace.start();\n        }\n        this.mergeTree.markRangeRemoved(range.start, range.end, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, false, opArgs);\n        this.completeAndLogOp(opArgs, clientArgs, range, traceStart);\n        return true;\n    }\n    /**\n     * Performs the annotate based on the provided op\n     * @param opArgs - The ops args for the op\n     * @returns True if the annotate was applied. False if it could not be.\n     */\n    applyAnnotateRangeOp(opArgs) {\n        assert(opArgs.op.type === 2 /* ANNOTATE */, 0x02e /* \"Unexpected op type on range annotate!\" */);\n        const op = opArgs.op;\n        const clientArgs = this.getClientSequenceArgs(opArgs);\n        const range = this.getValidOpRange(op, clientArgs);\n        if (!range) {\n            return false;\n        }\n        let traceStart;\n        if (this.measureOps) {\n            traceStart = Trace.start();\n        }\n        this.mergeTree.annotateRange(range.start, range.end, op.props, op.combiningOp, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, opArgs);\n        this.completeAndLogOp(opArgs, clientArgs, range, traceStart);\n        return true;\n    }\n    /**\n     * Performs the insert based on the provided op\n     * @param opArgs - The ops args for the op\n     * @returns True if the insert was applied. False if it could not be.\n     */\n    applyInsertOp(opArgs) {\n        assert(opArgs.op.type === 0 /* INSERT */, 0x02f /* \"Unexpected op type on range insert!\" */);\n        const op = opArgs.op;\n        const clientArgs = this.getClientSequenceArgs(opArgs);\n        const range = this.getValidOpRange(op, clientArgs);\n        if (!range) {\n            return false;\n        }\n        let segments;\n        if (op.seg) {\n            segments = [this.specToSegment(op.seg)];\n        }\n        else if (op.register) {\n            if (range.end) {\n                this.copy(range, op.register, clientArgs);\n                // Enqueue an empty segment group to be dequeued on ack\n                //\n                if (clientArgs.sequenceNumber === UnassignedSequenceNumber) {\n                    this.mergeTree.pendingSegments.enqueue({ segments: [], localSeq: this.getCollabWindow().localSeq });\n                }\n                return true;\n            }\n            segments = this.registerCollection.get(this.getLongClientId(clientArgs.clientId), op.register);\n        }\n        if (!segments || segments.length === 0) {\n            return false;\n        }\n        let traceStart;\n        if (this.measureOps) {\n            traceStart = Trace.start();\n        }\n        this.mergeTree.insertSegments(range.start, segments, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, opArgs);\n        this.completeAndLogOp(opArgs, clientArgs, range, traceStart);\n        return true;\n    }\n    /**\n     *\n     * @param opArgs - The op args of the op to complete\n     * @param clientArgs - The client args for the op\n     * @param range - The range the op applied to\n     * @param clockStart - Optional. The clock start if timing data should be updated.\n     */\n    completeAndLogOp(opArgs, clientArgs, range, traceStart) {\n        if (!opArgs.sequencedMessage) {\n            if (traceStart) {\n                this.localTime += elapsedMicroseconds(traceStart);\n                this.localOps++;\n            }\n        }\n        else {\n            assert(this.mergeTree.getCollabWindow().currentSeq < clientArgs.sequenceNumber, 0x030 /* \"Incoming remote op sequence# <= local collabWindow's currentSequence#\" */);\n            assert(this.mergeTree.getCollabWindow().minSeq <= opArgs.sequencedMessage.minimumSequenceNumber, 0x031 /* \"Incoming remote op minSequence# < local collabWindow's minSequence#\" */);\n            if (traceStart) {\n                this.accumTime += elapsedMicroseconds(traceStart);\n                this.accumOps++;\n                this.accumWindow += (this.getCurrentSeq() - this.getCollabWindow().minSeq);\n            }\n        }\n        if (this.verboseOps && (!opArgs.sequencedMessage || !this.noVerboseRemoteAnnotate)) {\n            console.log(`@cli ${this.getLongClientId(this.getCollabWindow().clientId)} ` +\n                `seq ${clientArgs.sequenceNumber} ${opArgs.op.type} local ${!opArgs.sequencedMessage} ` +\n                `start ${range.start} end ${range.end} refseq ${clientArgs.referenceSequenceNumber} ` +\n                `cli ${clientArgs.clientId}`);\n        }\n    }\n    /**\n     * Returns a valid range for the op, or undefined\n     * @param op - The op to generate the range for\n     * @param clientArgs - The client args for the op\n     */\n    getValidOpRange(op, clientArgs) {\n        let start = op.pos1;\n        if (start === undefined && op.relativePos1) {\n            start = this.mergeTree.posFromRelativePos(op.relativePos1, clientArgs.referenceSequenceNumber, clientArgs.clientId);\n        }\n        let end = op.pos2;\n        if (end === undefined && op.relativePos2) {\n            end = this.mergeTree.posFromRelativePos(op.relativePos2, clientArgs.referenceSequenceNumber, clientArgs.clientId);\n        }\n        // Validate if local op\n        if (clientArgs.clientId === this.getClientId()) {\n            const length = this.getLength();\n            const invalidPositions = [];\n            // Validate start position\n            //\n            if (start === undefined\n                || start < 0\n                || start > length\n                || start === length && op.type !== 0 /* INSERT */) {\n                invalidPositions.push(\"start\");\n            }\n            // Validate end if not insert, or insert has end\n            //\n            if (op.type !== 0 /* INSERT */ || end !== undefined) {\n                if (end === undefined || end <= start) {\n                    invalidPositions.push(\"end\");\n                }\n            }\n            if (invalidPositions.length > 0) {\n                throw new LoggingError(\"RangeOutOfBounds\", {\n                    UsageError: true,\n                    end,\n                    invalidPositions: invalidPositions.toString(),\n                    length,\n                    opPos1: op.pos1,\n                    opPos1Relative: op.relativePos1 !== undefined,\n                    opPos2: op.pos2,\n                    opPos2Relative: op.relativePos2 !== undefined,\n                    opType: op.type,\n                    start,\n                });\n            }\n        }\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        return { start, end };\n    }\n    /**\n     * Gets the client args from the op if remote, otherwise uses the local clients info\n     * @param opArgs - The op arg to get the client sequence args for\n     */\n    getClientSequenceArgs(opArgs) {\n        // If there this no sequenced message, then the op is local\n        // and unacked, so use this clients sequenced args\n        //\n        if (!opArgs.sequencedMessage) {\n            const segWindow = this.getCollabWindow();\n            return {\n                clientId: segWindow.clientId,\n                referenceSequenceNumber: segWindow.currentSeq,\n                sequenceNumber: this.getLocalSequenceNumber(),\n            };\n        }\n        else {\n            return {\n                clientId: this.getShortClientId(opArgs.sequencedMessage.clientId),\n                referenceSequenceNumber: opArgs.sequencedMessage.referenceSequenceNumber,\n                sequenceNumber: opArgs.sequencedMessage.sequenceNumber,\n            };\n        }\n    }\n    /**\n     * @param range - The range to copy into the register\n     * @param register - The name of the register to copy to range into\n     * @param clientArgs - The client args to use when evaluating the range for copying\n     */\n    copy(range, register, clientArgs) {\n        const segs = this.mergeTree.cloneSegments(clientArgs.referenceSequenceNumber, clientArgs.clientId, range.start, range.end);\n        this.registerCollection.set(this.getLongClientId(clientArgs.clientId), register, segs);\n    }\n    ackPendingSegment(opArgs) {\n        const ackOp = (deltaOpArgs) => {\n            var _a;\n            let trace;\n            if (this.measureOps) {\n                trace = Trace.start();\n            }\n            this.mergeTree.ackPendingSegment(deltaOpArgs, this.verboseOps);\n            if (deltaOpArgs.op.type === 2 /* ANNOTATE */) {\n                if (deltaOpArgs.op.combiningOp && (deltaOpArgs.op.combiningOp.name === \"consensus\")) {\n                    this.updateConsensusProperty(deltaOpArgs.op, deltaOpArgs.sequencedMessage);\n                }\n            }\n            if (trace) {\n                this.accumTime += elapsedMicroseconds(trace);\n                this.accumOps++;\n                this.accumWindow += (this.getCurrentSeq() - this.getCollabWindow().minSeq);\n            }\n            if (this.verboseOps) {\n                console.log(`@cli ${this.getLongClientId(this.getCollabWindow().clientId)} ` +\n                    `ack seq # ${(_a = deltaOpArgs.sequencedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber}`);\n            }\n        };\n        if (opArgs.op.type === 3 /* GROUP */) {\n            for (const memberOp of opArgs.op.ops) {\n                ackOp({\n                    groupOp: opArgs.op,\n                    op: memberOp,\n                    sequencedMessage: opArgs.sequencedMessage,\n                });\n            }\n        }\n        else {\n            ackOp(opArgs);\n        }\n    }\n    // as functions are modified move them above the eslint-disabled waterline and lint them\n    cloneFromSegments() {\n        const clone = new Client(this.specToSegment, this.logger, this.mergeTree.options);\n        const segments = [];\n        const newRoot = this.mergeTree.blockClone(this.mergeTree.root, segments);\n        clone.mergeTree.root = newRoot;\n        return clone;\n    }\n    getOrAddShortClientId(longClientId) {\n        if (!this.clientNameToIds.get(longClientId)) {\n            this.addLongClientId(longClientId);\n        }\n        return this.getShortClientId(longClientId);\n    }\n    getShortClientId(longClientId) {\n        return this.clientNameToIds.get(longClientId).data;\n    }\n    getLongClientId(shortClientId) {\n        if (shortClientId >= 0) {\n            return this.shortClientIdMap[shortClientId];\n        }\n        else {\n            return \"original\";\n        }\n    }\n    addLongClientId(longClientId) {\n        this.clientNameToIds.put(longClientId, this.shortClientIdMap.length);\n        this.shortClientIdMap.push(longClientId);\n    }\n    /**\n     * During reconnect, we must find the positions to pending segments\n     * relative to other pending segments. This methods computes that\n     * position relative to a localSeq. Pending segments above the localSeq\n     * will be ignored.\n     *\n     * @param segment - The segment to find the position for\n     * @param localSeq - The localSeq to find the position of the segment at\n     */\n    findReconnectionPostition(segment, localSeq) {\n        assert(localSeq <= this.mergeTree.collabWindow.localSeq, 0x032 /* \"localSeq greater than collab window\" */);\n        let segmentPosition = 0;\n        /*\n            Walk the segments up to the current segment, and calculate it's\n            position taking into account local segments that were modified,\n            after the current segment.\n\n            TODO: Consider embedding this information into the tree for\n            more efficient look up of pending segment positions.\n        */\n        this.mergeTree.walkAllSegments(this.mergeTree.root, (seg) => {\n            // If we've found the desired segment, terminate the walk and return 'segmentPosition'.\n            if (seg === segment) {\n                return false;\n            }\n            // Otherwise, advance segmentPosition if the segment has been inserted and not removed\n            // with respect to the given 'localSeq'.\n            //\n            // Note that all ACKed / remote ops are applied and we only need concern ourself with\n            // determining if locally pending ops fall before/after the given 'localSeq'.\n            if ((seg.localSeq === undefined || seg.localSeq <= localSeq) // Is inserted\n                && (seg.removedSeq === undefined || seg.localRemovedSeq > localSeq) // Not removed\n            ) {\n                segmentPosition += seg.cachedLength;\n            }\n            return true;\n        });\n        return segmentPosition;\n    }\n    resetPendingDeltaToOps(resetOp, segmentGroup) {\n        var _a, _b;\n        assert(!!segmentGroup, 0x033 /* \"Segment group undefined\" */);\n        const NACKedSegmentGroup = (_a = this.mergeTree.pendingSegments) === null || _a === void 0 ? void 0 : _a.dequeue();\n        assert(segmentGroup === NACKedSegmentGroup, 0x034 /* \"Segment group not at head of merge tree pending queue\" */);\n        const opList = [];\n        // We need to sort the segments by ordinal, as the segments are not sorted in the segment group.\n        // The reason they need them sorted, as they have the same local sequence number and which means\n        // farther segments will  take into account nearer segments when calculating their position.\n        // By sorting we ensure the nearer segment will be applied and sequenced before the father segments\n        // so their recalulated positions will be correct.\n        for (const segment of segmentGroup.segments.sort((a, b) => a.ordinal < b.ordinal ? -1 : 1)) {\n            const segmentSegGroup = segment.segmentGroups.dequeue();\n            assert(segmentGroup === segmentSegGroup, 0x035 /* \"Segment group not at head of segment pending queue\" */);\n            const segmentPosition = this.findReconnectionPostition(segment, segmentGroup.localSeq);\n            let newOp;\n            switch (resetOp.type) {\n                case 2 /* ANNOTATE */:\n                    assert(((_b = segment.propertyManager) === null || _b === void 0 ? void 0 : _b.hasPendingProperties()) === true, 0x036 /* \"Segment has no pending properties\" */);\n                    newOp = OpBuilder.createAnnotateRangeOp(segmentPosition, segmentPosition + segment.cachedLength, resetOp.props, resetOp.combiningOp);\n                    break;\n                case 0 /* INSERT */:\n                    assert(segment.seq === UnassignedSequenceNumber, 0x037 /* \"Segment already has assigned sequence number\" */);\n                    newOp = OpBuilder.createInsertSegmentOp(segmentPosition, segment);\n                    break;\n                case 1 /* REMOVE */:\n                    if (segment.localRemovedSeq !== undefined) {\n                        newOp = OpBuilder.createRemoveRangeOp(segmentPosition, segmentPosition + segment.cachedLength);\n                    }\n                    break;\n                default:\n                    throw new Error(`Invalid op type`);\n            }\n            if (newOp) {\n                const newSegmentGroup = { segments: [], localSeq: segmentGroup.localSeq };\n                segment.segmentGroups.enqueue(newSegmentGroup);\n                this.mergeTree.pendingSegments.enqueue(newSegmentGroup);\n                opList.push(newOp);\n            }\n        }\n        return opList;\n    }\n    applyRemoteOp(opArgs) {\n        const op = opArgs.op;\n        const msg = opArgs.sequencedMessage;\n        this.getOrAddShortClientId(msg.clientId);\n        switch (op.type) {\n            case 0 /* INSERT */:\n                this.applyInsertOp(opArgs);\n                break;\n            case 1 /* REMOVE */:\n                this.applyRemoveRangeOp(opArgs);\n                break;\n            case 2 /* ANNOTATE */:\n                this.applyAnnotateRangeOp(opArgs);\n                break;\n            case 3 /* GROUP */: {\n                for (const memberOp of op.ops) {\n                    this.applyRemoteOp({\n                        op: memberOp,\n                        groupOp: op,\n                        sequencedMessage: msg,\n                    });\n                }\n                break;\n            }\n            default:\n                break;\n        }\n    }\n    applyMsg(msg) {\n        var _a;\n        // Ensure client ID is registered\n        this.getOrAddShortClientId(msg.clientId);\n        // Apply if an operation message\n        if (msg.type === MessageType.Operation) {\n            const opArgs = {\n                op: msg.contents,\n                sequencedMessage: msg,\n            };\n            if (((_a = opArgs.sequencedMessage) === null || _a === void 0 ? void 0 : _a.clientId) === this.longClientId) {\n                this.ackPendingSegment(opArgs);\n            }\n            else {\n                this.applyRemoteOp(opArgs);\n            }\n        }\n        this.updateSeqNumbers(msg.minimumSequenceNumber, msg.sequenceNumber);\n    }\n    updateSeqNumbers(min, seq) {\n        const collabWindow = this.mergeTree.getCollabWindow();\n        // Equal is fine here due to SharedSegmentSequence<>.snapshotContent() potentially updating with same #\n        assert(collabWindow.currentSeq <= seq, 0x038 /* \"Incoming op sequence# < local collabWindow's currentSequence#\" */);\n        collabWindow.currentSeq = seq;\n        assert(min <= seq, 0x039 /* \"Incoming op sequence# < minSequence#\" */);\n        this.updateMinSeq(min);\n    }\n    /**\n     * Resolves a remote client's position against the local sequence\n     * and returns the remote client's position relative to the local\n     * sequence\n     * @param remoteClientPosition - The remote client's position to resolve\n     * @param remoteClientRefSeq - The reference sequence number of the remote client\n     * @param remoteClientId - The client id of the remote client\n     */\n    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {\n        const shortRemoteClientId = this.getOrAddShortClientId(remoteClientId);\n        return this.mergeTree.resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, shortRemoteClientId);\n    }\n    /**\n     *  Given an pending operation and segment group, regenerate the op, so it\n     *  can be resubmitted\n     * @param resetOp - The op to reset\n     * @param segmentGroup - The segment group associated with the op\n     */\n    regeneratePendingOp(resetOp, segmentGroup) {\n        const trace = Trace.start();\n        try {\n            const opList = [];\n            if (resetOp.type === 3 /* GROUP */) {\n                if (Array.isArray(segmentGroup)) {\n                    assert(resetOp.ops.length === segmentGroup.length, 0x03a /* \"Number of ops in 'resetOp' must match the number of segment groups provided.\" */);\n                    for (let i = 0; i < resetOp.ops.length; i++) {\n                        opList.push(...this.resetPendingDeltaToOps(resetOp.ops[i], segmentGroup[i]));\n                    }\n                }\n                else {\n                    // A group op containing a single op will pass a direct reference to 'segmentGroup'\n                    // rather than an array of segment groups.  (See 'peekPendingSegmentGroups()')\n                    assert(resetOp.ops.length === 1, 0x03b /* \"Number of ops in 'resetOp' must match the number of segment groups provided.\" */);\n                    opList.push(...this.resetPendingDeltaToOps(resetOp.ops[0], segmentGroup));\n                }\n            }\n            else {\n                assert(resetOp.type !== 3 /* GROUP */, 0x03c /* \"Reset op has 'group' delta type!\" */);\n                assert(!Array.isArray(segmentGroup), 0x03d /* \"segmentGroup is array rather than singleton!\" */);\n                opList.push(...this.resetPendingDeltaToOps(resetOp, segmentGroup));\n            }\n            return opList.length === 1 ? opList[0] : OpBuilder.createGroupOp(...opList);\n        }\n        finally {\n            this.logger.sendPerformanceEvent({\n                eventName: \"MergeTree:RegeneratePendingOp\",\n                category: \"performance\",\n                duration: elapsedMicroseconds(trace),\n            });\n        }\n    }\n    createTextHelper() {\n        return new MergeTreeTextHelper(this.mergeTree);\n    }\n    // TODO: Remove `catchUpMsgs` once new snapshot format is adopted as default.\n    //       (See https://github.com/microsoft/FluidFramework/issues/84)\n    snapshot(runtime, handle, serializer, catchUpMsgs) {\n        var _a;\n        const deltaManager = runtime.deltaManager;\n        const minSeq = deltaManager.minimumSequenceNumber;\n        // Catch up to latest MSN, if we have not had a chance to do it.\n        // Required for case where FluidDataStoreRuntime.attachChannel()\n        // generates snapshot right after loading data store.\n        this.updateSeqNumbers(minSeq, deltaManager.lastSequenceNumber);\n        // One of the snapshots (from SPO) I observed to have chunk.chunkSequenceNumber > minSeq!\n        // Not sure why - need to catch it sooner\n        assert(this.getCollabWindow().minSeq === minSeq, 0x03e /* \"minSeq mismatch between collab window and delta manager!\" */);\n        // TODO: Remove options flag once new snapshot format is adopted as default.\n        //       (See https://github.com/microsoft/FluidFramework/issues/84)\n        if (((_a = this.mergeTree.options) === null || _a === void 0 ? void 0 : _a.newMergeTreeSnapshotFormat) === true) {\n            assert(catchUpMsgs === undefined || catchUpMsgs.length === 0, 0x03f /* \"New format should not emit catchup ops\" */);\n            const snap = new SnapshotV1(this.mergeTree, this.logger);\n            snap.extractSync();\n            return snap.emit(serializer, handle);\n        }\n        else {\n            const snap = new SnapshotLegacy(this.mergeTree, this.logger);\n            snap.extractSync();\n            return snap.emit(catchUpMsgs, serializer, handle);\n        }\n    }\n    async load(runtime, storage, serializer) {\n        const loader = new SnapshotLoader(runtime, this, this.mergeTree, this.logger, serializer);\n        return loader.initialize(storage);\n    }\n    getStackContext(startPos, rangeLabels) {\n        return this.mergeTree.getStackContext(startPos, this.getCollabWindow().clientId, rangeLabels);\n    }\n    getLocalSequenceNumber() {\n        const segWindow = this.getCollabWindow();\n        if (segWindow.collaborating) {\n            return UnassignedSequenceNumber;\n        }\n        else {\n            return UniversalSequenceNumber;\n        }\n    }\n    localTransaction(groupOp) {\n        for (const op of groupOp.ops) {\n            const opArgs = {\n                op,\n                groupOp,\n            };\n            switch (op.type) {\n                case 0 /* INSERT */:\n                    this.applyInsertOp(opArgs);\n                    break;\n                case 2 /* ANNOTATE */:\n                    this.applyAnnotateRangeOp(opArgs);\n                    break;\n                case 1 /* REMOVE */:\n                    this.applyRemoveRangeOp(opArgs);\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n    updateConsensusProperty(op, msg) {\n        const markerId = op.relativePos1.id;\n        const consensusInfo = this.pendingConsensus.get(markerId);\n        if (consensusInfo) {\n            consensusInfo.marker.addProperties(op.props, op.combiningOp, msg.sequenceNumber);\n        }\n        this.mergeTree.addMinSeqListener(msg.sequenceNumber, () => consensusInfo.callback(consensusInfo.marker));\n    }\n    updateMinSeq(minSeq) {\n        let trace;\n        if (this.measureOps) {\n            trace = Trace.start();\n        }\n        this.mergeTree.setMinSeq(minSeq);\n        if (trace) {\n            const elapsed = elapsedMicroseconds(trace);\n            this.accumWindowTime += elapsed;\n            if (elapsed > this.maxWindowTime) {\n                this.maxWindowTime = elapsed;\n            }\n        }\n    }\n    getContainingSegment(pos) {\n        const segWindow = this.mergeTree.getCollabWindow();\n        return this.mergeTree.getContainingSegment(pos, segWindow.currentSeq, segWindow.clientId);\n    }\n    getPropertiesAtPosition(pos) {\n        const segWindow = this.getCollabWindow();\n        if (this.verboseOps) {\n            // eslint-disable-next-line max-len\n            console.log(`getPropertiesAtPosition cli ${this.getLongClientId(segWindow.clientId)} ref seq ${segWindow.currentSeq}`);\n        }\n        let propertiesAtPosition;\n        const segoff = this.getContainingSegment(pos);\n        const seg = segoff.segment;\n        if (seg) {\n            propertiesAtPosition = seg.properties;\n        }\n        return propertiesAtPosition;\n    }\n    getRangeExtentsOfPosition(pos) {\n        const segWindow = this.getCollabWindow();\n        if (this.verboseOps) {\n            // eslint-disable-next-line max-len\n            console.log(`getRangeExtentsOfPosition cli ${this.getLongClientId(segWindow.clientId)} ref seq ${segWindow.currentSeq}`);\n        }\n        let posStart;\n        let posAfterEnd;\n        const segoff = this.getContainingSegment(pos);\n        const seg = segoff.segment;\n        if (seg) {\n            posStart = this.getPosition(seg);\n            posAfterEnd = posStart + seg.cachedLength;\n        }\n        return { posStart, posAfterEnd };\n    }\n    getCurrentSeq() {\n        return this.getCollabWindow().currentSeq;\n    }\n    getClientId() {\n        return this.getCollabWindow().clientId;\n    }\n    getLength() { return this.mergeTree.length; }\n    startOrUpdateCollaboration(longClientId, minSeq = 0, currentSeq = 0) {\n        // we should always have a client id if we are collaborating\n        // if the client id is undefined we are likely bound to a detached\n        // container, so we should keep going in local mode. once\n        // the container attaches this will be called again on connect with the\n        // client id\n        if (longClientId !== undefined) {\n            if (this.longClientId === undefined) {\n                this.longClientId = longClientId;\n                this.addLongClientId(this.longClientId);\n                this.mergeTree.startCollaboration(this.getShortClientId(this.longClientId), minSeq, currentSeq);\n            }\n            else {\n                const oldClientId = this.longClientId;\n                const oldData = this.clientNameToIds.get(oldClientId).data;\n                this.longClientId = longClientId;\n                this.clientNameToIds.put(longClientId, oldData);\n                this.shortClientIdMap[oldData] = longClientId;\n            }\n        }\n    }\n    findTile(startPos, tileLabel, preceding = true) {\n        const clientId = this.getClientId();\n        return this.mergeTree.findTile(startPos, clientId, tileLabel, preceding);\n    }\n}\n//# sourceMappingURL=client.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/* eslint-disable @typescript-eslint/consistent-type-assertions, eqeqeq, object-shorthand */\n/* eslint-disable no-bitwise */\n/* Remove once strictNullCheck is enabled */\nimport { Trace } from \"@fluidframework/common-utils\";\nimport * as MergeTree from \"./mergeTree\";\nexport class Stack {\n    constructor() {\n        this.items = [];\n    }\n    push(val) {\n        this.items.push(val);\n    }\n    empty() {\n        return this.items.length === 0;\n    }\n    top() {\n        return this.items[this.items.length - 1];\n    }\n    pop() {\n        return this.items.pop();\n    }\n}\nexport function ListRemoveEntry(entry) {\n    if (entry === undefined) {\n        return undefined;\n    }\n    else if (entry.isHead) {\n        return undefined;\n    }\n    else {\n        entry.next.prev = entry.prev;\n        entry.prev.next = entry.next;\n    }\n    return (entry);\n}\nexport function ListMakeEntry(data) {\n    return new List(false, data);\n}\nexport function ListMakeHead() {\n    return new List(true, undefined);\n}\nexport class List {\n    constructor(isHead, data) {\n        this.isHead = isHead;\n        this.data = data;\n        this.prev = this;\n        this.next = this;\n    }\n    clear() {\n        if (this.isHead) {\n            this.prev = this;\n            this.next = this;\n        }\n    }\n    add(data) {\n        const entry = ListMakeEntry(data);\n        this.prev.next = entry;\n        entry.next = this;\n        entry.prev = this.prev;\n        this.prev = entry;\n        return (entry);\n    }\n    dequeue() {\n        if (!this.empty()) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const removedEntry = ListRemoveEntry(this.next);\n            return removedEntry.data;\n        }\n    }\n    enqueue(data) {\n        return this.add(data);\n    }\n    walk(fn) {\n        for (let entry = this.next; !(entry.isHead); entry = entry.next) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            fn(entry.data, entry);\n        }\n    }\n    some(fn, rev) {\n        const rtn = [];\n        const start = rev ? this.prev : this.next;\n        for (let entry = start; !(entry.isHead); entry = rev ? entry.prev : entry.next) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const data = entry.data;\n            if (fn(data, entry)) {\n                if (rev) {\n                    // preserve list order when in reverse\n                    rtn.unshift(data);\n                }\n                else {\n                    rtn.push(data);\n                }\n            }\n        }\n        return rtn;\n    }\n    count() {\n        let entry;\n        let i;\n        entry = this.next;\n        for (i = 0; !(entry.isHead); i++) {\n            entry = entry.next;\n        }\n        return (i);\n    }\n    first() {\n        if (!this.empty()) {\n            return (this.next.data);\n        }\n    }\n    last() {\n        if (!this.empty()) {\n            return (this.prev.data);\n        }\n    }\n    empty() {\n        return (this.next === this);\n    }\n    pushEntry(entry) {\n        entry.isHead = false;\n        entry.next = this.next;\n        entry.prev = this;\n        this.next = entry;\n        entry.next.prev = entry;\n    }\n    push(data) {\n        const entry = ListMakeEntry(data);\n        entry.data = data;\n        entry.isHead = false;\n        entry.next = this.next;\n        entry.prev = this;\n        this.next = entry;\n        entry.next.prev = entry;\n    }\n    popEntry(head) {\n        if (this.next.isHead) {\n            return undefined;\n        }\n        else {\n            return ListRemoveEntry(this.next);\n        }\n    }\n    insertEntry(entry) {\n        entry.isHead = false;\n        this.prev.next = entry;\n        entry.next = this;\n        entry.prev = this.prev;\n        this.prev = entry;\n        return entry;\n    }\n    insertAfter(data) {\n        const entry = ListMakeEntry(data);\n        entry.next = this.next;\n        entry.prev = this;\n        this.next = entry;\n        entry.next.prev = entry;\n        return (entry);\n    }\n    insertBefore(data) {\n        const entry = ListMakeEntry(data);\n        return this.insertEntryBefore(entry);\n    }\n    insertEntryBefore(entry) {\n        this.prev.next = entry;\n        entry.next = this;\n        entry.prev = this.prev;\n        this.prev = entry;\n        return (entry);\n    }\n}\nexport const numberComparer = {\n    min: Number.MIN_VALUE,\n    compare: (a, b) => a - b,\n};\nexport class Heap {\n    constructor(a, comp) {\n        this.comp = comp;\n        this.L = [comp.min];\n        for (let i = 0, len = a.length; i < len; i++) {\n            this.add(a[i]);\n        }\n    }\n    count() {\n        return this.L.length - 1;\n    }\n    peek() {\n        return this.L[1];\n    }\n    get() {\n        const x = this.L[1];\n        this.L[1] = this.L[this.count()];\n        this.L.pop();\n        this.fixdown(1);\n        return x;\n    }\n    add(x) {\n        this.L.push(x);\n        this.fixup(this.count());\n    }\n    fixup(k) {\n        let _k = k;\n        while (_k > 1 && (this.comp.compare(this.L[_k >> 1], this.L[_k]) > 0)) {\n            const tmp = this.L[_k >> 1];\n            this.L[_k >> 1] = this.L[_k];\n            this.L[_k] = tmp;\n            _k = _k >> 1;\n        }\n    }\n    fixdown(k) {\n        let _k = k;\n        while ((_k << 1) <= (this.count())) {\n            let j = _k << 1;\n            if ((j < this.count()) && (this.comp.compare(this.L[j], this.L[j + 1]) > 0)) {\n                j++;\n            }\n            if (this.comp.compare(this.L[_k], this.L[j]) <= 0) {\n                break;\n            }\n            const tmp = this.L[_k];\n            this.L[_k] = this.L[j];\n            this.L[j] = tmp;\n            _k = j;\n        }\n    }\n}\n// For testing\nexport function LinearDictionary(compareKeys) {\n    const props = [];\n    const compareProps = (a, b) => compareKeys(a.key, b.key);\n    function diag() {\n        console.log(`size is ${props.length}`);\n    }\n    function mapRange(action, accum, start, end) {\n        let _start = start;\n        let _end = end;\n        if (props.length !== 0) {\n            return;\n        }\n        if (_start === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            _start = min().key;\n        }\n        if (_end === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            _end = max().key;\n        }\n        for (let i = 0, len = props.length; i < len; i++) {\n            if (compareKeys(_start, props[i].key) <= 0) {\n                const ecmp = compareKeys(_end, props[i].key);\n                if (ecmp < 0) {\n                    break;\n                }\n                if (!action(props[i], accum)) {\n                    break;\n                }\n            }\n        }\n    }\n    function map(action, accum) {\n        mapRange(action, accum);\n    }\n    function min() {\n        if (props.length > 0) {\n            return props[0];\n        }\n    }\n    function max() {\n        if (props.length > 0) {\n            return props[props.length - 1];\n        }\n    }\n    function get(key) {\n        for (let i = 0, len = props.length; i < len; i++) {\n            if (props[i].key == key) {\n                return props[i];\n            }\n        }\n    }\n    function put(key, data) {\n        if (key !== undefined) {\n            if (data === undefined) {\n                remove(key);\n            }\n            else {\n                props.push({ key, data });\n                props.sort(compareProps); // Go to insertion sort if too slow\n            }\n        }\n    }\n    function remove(key) {\n        if (key !== undefined) {\n            for (let i = 0, len = props.length; i < len; i++) {\n                if (props[i].key == key) {\n                    props[i] = props[len - 1];\n                    props.length--;\n                    props.sort(compareProps);\n                    break;\n                }\n            }\n        }\n    }\n    return {\n        min: min,\n        max: max,\n        map: map,\n        mapRange: mapRange,\n        remove: remove,\n        get: get,\n        put: put,\n        diag: diag,\n    };\n}\nexport var RBColor;\n(function (RBColor) {\n    RBColor[RBColor[\"RED\"] = 0] = \"RED\";\n    RBColor[RBColor[\"BLACK\"] = 1] = \"BLACK\";\n})(RBColor || (RBColor = {}));\nexport class RedBlackTree {\n    constructor(compareKeys, aug) {\n        this.compareKeys = compareKeys;\n        this.aug = aug;\n    }\n    makeNode(key, data, color, size) {\n        const node = { key, data, color, size };\n        if (this.aug && this.aug.init) {\n            this.aug.init(node);\n        }\n        return node;\n    }\n    isRed(node) {\n        return !!node && (node.color == 0 /* RED */);\n    }\n    nodeSize(node) {\n        return node ? node.size : 0;\n    }\n    size() {\n        return this.nodeSize(this.root);\n    }\n    isEmpty() {\n        return !this.root;\n    }\n    get(key) {\n        if (key !== undefined) {\n            return this.nodeGet(this.root, key);\n        }\n    }\n    nodeGet(node, key) {\n        let _node = node;\n        while (_node) {\n            const cmp = this.compareKeys(key, _node.key);\n            if (cmp < 0) {\n                _node = _node.left;\n            }\n            else if (cmp > 0) {\n                _node = _node.right;\n            }\n            else {\n                return _node;\n            }\n        }\n    }\n    contains(key) {\n        return this.get(key);\n    }\n    gather(key, matcher) {\n        const results = [];\n        if (key !== undefined) {\n            this.nodeGather(this.root, results, key, matcher);\n        }\n        return results;\n    }\n    nodeGather(node, results, key, matcher) {\n        if (node) {\n            if (matcher.continueSubtree(node.left, key)) {\n                this.nodeGather(node.left, results, key, matcher);\n            }\n            if (matcher.matchNode(node, key)) {\n                results.push(node);\n            }\n            if (matcher.continueSubtree(node.right, key)) {\n                this.nodeGather(node.right, results, key, matcher);\n            }\n        }\n    }\n    put(key, data, conflict) {\n        if (key !== undefined) {\n            if (data === undefined) {\n                this.remove(key);\n            }\n            else {\n                this.root = this.nodePut(this.root, key, data, conflict);\n                this.root.color = 1 /* BLACK */;\n            }\n        }\n    }\n    nodePut(node, key, data, conflict) {\n        let _node = node;\n        if (!_node) {\n            return this.makeNode(key, data, 0 /* RED */, 1);\n        }\n        else {\n            const cmp = this.compareKeys(key, _node.key);\n            if (cmp < 0) {\n                _node.left = this.nodePut(_node.left, key, data, conflict);\n            }\n            else if (cmp > 0) {\n                _node.right = this.nodePut(_node.right, key, data, conflict);\n            }\n            else {\n                if (conflict) {\n                    const kd = conflict(key, _node.key, data, _node.data);\n                    if (kd.key) {\n                        _node.key = kd.key;\n                    }\n                    if (kd.data) {\n                        _node.data = kd.data;\n                    }\n                    else {\n                        _node.data = data;\n                    }\n                }\n                else {\n                    _node.data = data;\n                }\n            }\n            if (this.isRed(_node.right) && (!this.isRed(_node.left))) {\n                _node = this.rotateLeft(_node);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if (this.isRed(_node.left) && this.isRed(_node.left.left)) {\n                _node = this.rotateRight(_node);\n            }\n            if (this.isRed(_node.left) && this.isRed(_node.right)) {\n                this.flipColors(_node);\n            }\n            _node.size = this.nodeSize(_node.left) + this.nodeSize(_node.right) + 1;\n            if (this.aug) {\n                this.updateLocal(_node);\n            }\n            return _node;\n        }\n    }\n    updateLocal(node) {\n        if (this.aug) {\n            if (this.isRed(node.left)) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this.aug.update(node.left);\n            }\n            if (this.isRed(node.right)) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this.aug.update(node.right);\n            }\n            this.aug.update(node);\n        }\n    }\n    removeMin() {\n        if (this.root) {\n            if ((!this.isRed(this.root.left)) && (!this.isRed(this.root.right))) {\n                this.root.color = 0 /* RED */;\n            }\n            this.root = this.nodeRemoveMin(this.root);\n            if (this.root) {\n                this.root.color = 1 /* BLACK */;\n            }\n        }\n        // TODO: error on empty\n    }\n    nodeRemoveMin(node) {\n        let _node = node;\n        if (_node.left) {\n            if ((!this.isRed(_node.left)) && (!this.isRed(_node.left.left))) {\n                _node = this.moveRedLeft(_node);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            _node.left = this.nodeRemoveMin(_node.left);\n            return this.balance(_node);\n        }\n    }\n    removeMax() {\n        if (this.root) {\n            if ((!this.isRed(this.root.left)) && (!this.isRed(this.root.right))) {\n                this.root.color = 0 /* RED */;\n            }\n            this.root = this.nodeRemoveMax(this.root);\n            if (this.root) {\n                this.root.color = 1 /* BLACK */;\n            }\n        }\n        // TODO: error on empty\n    }\n    nodeRemoveMax(node) {\n        let _node = node;\n        if (this.isRed(_node.left)) {\n            _node = this.rotateRight(_node);\n        }\n        if (!_node.right) {\n            return undefined;\n        }\n        if ((!this.isRed(_node.right)) && (!this.isRed(_node.right.left))) {\n            _node = this.moveRedRight(_node);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        _node.right = this.nodeRemoveMax(_node.right);\n        return this.balance(_node);\n    }\n    remove(key) {\n        if (key !== undefined) {\n            if (!this.contains(key)) {\n                return;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if ((!this.isRed(this.root.left)) && (!this.isRed(this.root.right))) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this.root.color = 0 /* RED */;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.root = this.nodeRemove(this.root, key);\n        }\n        // TODO: error on undefined key\n    }\n    nodeRemove(node, key) {\n        let _node = node;\n        if (this.compareKeys(key, _node.key) < 0) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if ((!this.isRed(_node.left)) && (!this.isRed(_node.left.left))) {\n                _node = this.moveRedLeft(_node);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            _node.left = this.nodeRemove(_node.left, key);\n        }\n        else {\n            if (this.isRed(_node.left)) {\n                _node = this.rotateRight(_node);\n            }\n            if ((this.compareKeys(key, _node.key) == 0) && (!_node.right)) {\n                return undefined;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if ((!this.isRed(_node.right)) && (!this.isRed(_node.right.left))) {\n                _node = this.moveRedRight(_node);\n            }\n            if (this.compareKeys(key, _node.key) == 0) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const subtreeMin = this.nodeMin(_node.right);\n                _node.key = subtreeMin.key;\n                _node.data = subtreeMin.data;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                _node.right = this.nodeRemoveMin(_node.right);\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                _node.right = this.nodeRemove(_node.right, key);\n            }\n        }\n        return this.balance(_node);\n    }\n    height() {\n        return this.nodeHeight(this.root);\n    }\n    nodeHeight(node) {\n        if (node === undefined) {\n            return -1;\n        }\n        else {\n            return 1 + Math.max(this.nodeHeight(node.left), this.nodeHeight(node.right));\n        }\n    }\n    floor(key) {\n        if (!this.isEmpty()) {\n            return this.nodeFloor(this.root, key);\n        }\n    }\n    nodeFloor(node, key) {\n        if (node) {\n            const cmp = this.compareKeys(key, node.key);\n            if (cmp == 0) {\n                return node;\n            }\n            else if (cmp < 0) {\n                return this.nodeFloor(node.left, key);\n            }\n            else {\n                const rightFloor = this.nodeFloor(node.right, key);\n                if (rightFloor) {\n                    return rightFloor;\n                }\n                else {\n                    return node;\n                }\n            }\n        }\n    }\n    ceil(key) {\n        if (!this.isEmpty()) {\n            return this.nodeCeil(this.root, key);\n        }\n    }\n    nodeCeil(node, key) {\n        if (node) {\n            const cmp = this.compareKeys(key, node.key);\n            if (cmp == 0) {\n                return node;\n            }\n            else if (cmp > 0) {\n                return this.nodeCeil(node.right, key);\n            }\n            else {\n                const leftCeil = this.nodeCeil(node.left, key);\n                if (leftCeil) {\n                    return leftCeil;\n                }\n                else {\n                    return node;\n                }\n            }\n        }\n    }\n    min() {\n        if (this.root) {\n            return this.nodeMin(this.root);\n        }\n    }\n    nodeMin(node) {\n        if (!node.left) {\n            return node;\n        }\n        else {\n            return this.nodeMin(node.left);\n        }\n    }\n    max() {\n        if (this.root) {\n            return this.nodeMax(this.root);\n        }\n    }\n    nodeMax(node) {\n        if (!node.right) {\n            return node;\n        }\n        else {\n            return this.nodeMax(node.right);\n        }\n    }\n    rotateRight(node) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const leftChild = node.left;\n        node.left = leftChild.right;\n        leftChild.right = node;\n        leftChild.color = leftChild.right.color;\n        leftChild.right.color = 0 /* RED */;\n        leftChild.size = node.size;\n        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n        if (this.aug) {\n            this.updateLocal(node);\n            this.updateLocal(leftChild);\n        }\n        return leftChild;\n    }\n    rotateLeft(node) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const rightChild = node.right;\n        node.right = rightChild.left;\n        rightChild.left = node;\n        rightChild.color = rightChild.left.color;\n        rightChild.left.color = 0 /* RED */;\n        rightChild.size = node.size;\n        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n        if (this.aug) {\n            this.updateLocal(node);\n            this.updateLocal(rightChild);\n        }\n        return rightChild;\n    }\n    oppositeColor(c) {\n        return (c == 1 /* BLACK */) ? 0 /* RED */ : 1 /* BLACK */;\n    }\n    flipColors(node) {\n        node.color = this.oppositeColor(node.color);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        node.left.color = this.oppositeColor(node.left.color);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        node.right.color = this.oppositeColor(node.right.color);\n    }\n    moveRedLeft(node) {\n        let _node = node;\n        this.flipColors(_node);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (this.isRed(_node.right.left)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            _node.right = this.rotateRight(_node.right);\n            _node = this.rotateLeft(_node);\n            this.flipColors(_node);\n        }\n        return _node;\n    }\n    moveRedRight(node) {\n        let _node = node;\n        this.flipColors(_node);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (this.isRed(_node.left.left)) {\n            _node = this.rotateRight(_node);\n            this.flipColors(_node);\n        }\n        return _node;\n    }\n    balance(input) {\n        let node = input;\n        if (this.isRed(node.right)) {\n            node = this.rotateLeft(node);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (this.isRed(node.left) && this.isRed(node.left.left)) {\n            node = this.rotateRight(node);\n        }\n        if (this.isRed(node.left) && (this.isRed(node.right))) {\n            this.flipColors(node);\n        }\n        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n        if (this.aug) {\n            this.aug.update(node);\n        }\n        return node;\n    }\n    mapRange(action, accum, start, end) {\n        this.nodeMap(this.root, action, start, end);\n    }\n    map(action, accum) {\n        // TODO: optimize to avoid comparisons\n        this.nodeMap(this.root, action, accum);\n    }\n    keys() {\n        const keyList = [];\n        const actions = {\n            showStructure: true,\n            infix: (node) => {\n                keyList.push(node.key);\n                return true;\n            },\n        };\n        this.walk(actions);\n        return keyList;\n    }\n    /**\n     * Depth-first traversal with custom action; if action returns\n     * false, traversal is halted.\n     * @param action - action to apply to each node\n     */\n    walk(actions) {\n        this.nodeWalk(this.root, actions);\n    }\n    nodeWalk(node, actions) {\n        let go = true;\n        if (node) {\n            if (actions.pre) {\n                if (actions.showStructure || (node.color === 1 /* BLACK */)) {\n                    go = actions.pre(node);\n                }\n            }\n            if (node.left) {\n                go = this.nodeWalk(node.left, actions);\n            }\n            if (go && actions.infix) {\n                if (actions.showStructure || (node.color === 1 /* BLACK */)) {\n                    go = actions.infix(node);\n                }\n            }\n            if (go) {\n                go = this.nodeWalk(node.right, actions);\n            }\n            if (go && actions.post) {\n                if (actions.showStructure || (node.color === 1 /* BLACK */)) {\n                    go = actions.post(node);\n                }\n            }\n        }\n        return go;\n    }\n    nodeMap(node, action, accum, start, end) {\n        let _start = start;\n        let _end = end;\n        if (!node) {\n            return true;\n        }\n        if (_start === undefined) {\n            _start = this.nodeMin(node).key;\n        }\n        if (_end === undefined) {\n            _end = this.nodeMax(node).key;\n        }\n        const cmpStart = this.compareKeys(_start, node.key);\n        const cmpEnd = this.compareKeys(_end, node.key);\n        let go = true;\n        if (cmpStart < 0) {\n            go = this.nodeMap(node.left, action, accum, _start, _end);\n        }\n        if (go && (cmpStart <= 0) && (cmpEnd >= 0)) {\n            // REVIEW: test for black node here\n            go = action(node, accum);\n        }\n        if (go && (cmpEnd > 0)) {\n            go = this.nodeMap(node.right, action, accum, _start, _end);\n        }\n        return go;\n    }\n    diag() {\n        console.log(`Height is ${this.height()}`);\n    }\n}\n/**\n * Union of two ranges; assumes for both ranges start \\<= end.\n * @param a - A range\n * @param b - A range\n */\nexport function integerRangeUnion(a, b) {\n    return {\n        start: Math.min(a.start, b.start),\n        end: Math.max(a.end, b.end),\n    };\n}\nexport function integerRangeOverlaps(a, b) {\n    return (a.start < b.end) && (a.end > b.start);\n}\nexport function integerRangeComparer(a, b) {\n    if (a.start === b.start) {\n        return a.end - b.end;\n    }\n    else {\n        return a.start - b.start;\n    }\n}\nexport const integerRangeCopy = (r) => ({ start: r.start, end: r.end });\nexport const integerRangeToString = (range) => `[${range.start},${range.end})`;\n// TODO: handle duplicate keys\nexport class IntegerRangeTree {\n    constructor() {\n        this.ranges = new RedBlackTree(integerRangeComparer, this);\n        this.diag = false;\n    }\n    remove(r) {\n        this.ranges.remove(r);\n    }\n    put(r) {\n        this.ranges.put(r, { minmax: integerRangeCopy(r) });\n    }\n    toString() {\n        return this.nodeToString(this.ranges.root);\n    }\n    nodeToString(node) {\n        let buf = \"\";\n        let indentAmt = 0;\n        const actions = {\n            pre: (n) => {\n                let red = \"\";\n                if (n.color === 0 /* RED */) {\n                    red = \"R \";\n                }\n                buf += MergeTree.internedSpaces(indentAmt);\n                buf += `${red}key: ${integerRangeToString(n.key)} minmax: ${integerRangeToString(n.data.minmax)}\\n`;\n                indentAmt += 2;\n                return true;\n            },\n            post: (n) => {\n                indentAmt -= 2;\n                return true;\n            },\n            showStructure: true,\n        };\n        this.ranges.nodeWalk(node, actions);\n        return buf;\n    }\n    matchPos(pos) {\n        return this.match({ start: pos, end: pos + 1 });\n    }\n    match(r) {\n        return this.ranges.gather(r, this);\n    }\n    matchNode(node, key) {\n        return !!node && integerRangeOverlaps(node.key, key);\n    }\n    continueSubtree(node, key) {\n        const cont = !!node && integerRangeOverlaps(node.data.minmax, key);\n        if (this.diag && (!cont)) {\n            if (node) {\n                console.log(`skipping subtree of size ${node.size} key ${integerRangeToString(key)}`);\n                console.log(this.nodeToString(node));\n            }\n        }\n        return cont;\n    }\n    update(node) {\n        if (node.left && node.right) {\n            node.data.minmax = integerRangeUnion(node.key, integerRangeUnion(node.left.data.minmax, node.right.data.minmax));\n        }\n        else {\n            if (node.left) {\n                node.data.minmax = integerRangeUnion(node.key, node.left.data.minmax);\n            }\n            else if (node.right) {\n                node.data.minmax = integerRangeUnion(node.key, node.right.data.minmax);\n            }\n            else {\n                node.data.minmax = integerRangeCopy(node.key);\n            }\n        }\n    }\n}\nexport const intervalComparer = (a, b) => a.compare(b);\nexport class IntervalTree {\n    constructor() {\n        this.intervals = new RedBlackTree(intervalComparer, this);\n        this.diag = false;\n        this.timePut = false;\n        this.putTime = 0;\n        this.putCount = 0;\n    }\n    printTiming() {\n        console.log(`put total = ${this.putTime} avg=${(this.putTime / this.putCount).toFixed(2)}`);\n    }\n    remove(x) {\n        this.intervals.remove(x);\n    }\n    put(x, conflict) {\n        let rbConflict;\n        if (conflict) {\n            rbConflict = (key, currentKey) => {\n                const ival = conflict(key, currentKey);\n                return {\n                    key: ival,\n                };\n            };\n        }\n        if (this.timePut) {\n            const trace = Trace.start();\n            this.intervals.put(x, { minmax: x.clone() }, rbConflict);\n            this.putTime += trace.trace().duration * 1000;\n            this.putCount++;\n        }\n        else {\n            this.intervals.put(x, { minmax: x.clone() }, rbConflict);\n        }\n    }\n    map(fn) {\n        const actions = {\n            infix: (node) => {\n                fn(node.key);\n                return true;\n            },\n            showStructure: true,\n        };\n        this.intervals.walk(actions);\n    }\n    // TODO: toString()\n    match(x) {\n        return this.intervals.gather(x, this);\n    }\n    matchNode(node, key) {\n        return !!node && node.key.overlaps(key);\n    }\n    continueSubtree(node, key) {\n        const cont = !!node && node.data.minmax.overlaps(key);\n        if (this.diag && (!cont)) {\n            if (node) {\n                console.log(`skipping subtree of size ${node.size} key ${key.toString()}`);\n                // console.log(this.nodeToString(node));\n            }\n        }\n        return cont;\n    }\n    update(node) {\n        if (node.left && node.right) {\n            node.data.minmax = node.key.union(node.left.data.minmax.union(node.right.data.minmax));\n        }\n        else {\n            if (node.left) {\n                node.data.minmax = node.key.union(node.left.data.minmax);\n            }\n            else if (node.right) {\n                node.data.minmax = node.key.union(node.right.data.minmax);\n            }\n            else {\n                node.data.minmax = node.key.clone();\n            }\n        }\n    }\n}\nexport class TST {\n    constructor() {\n        this.n = 0;\n    }\n    size() {\n        return this.n;\n    }\n    contains(key) {\n        return this.get(key);\n    }\n    get(key) {\n        const x = this.nodeGet(this.root, key, 0);\n        if (x === undefined) {\n            return undefined;\n        }\n        return x.val;\n    }\n    nodeGet(x, key, d) {\n        if (x === undefined) {\n            return undefined;\n        }\n        const c = key.charAt(d);\n        if (c < x.c) {\n            return this.nodeGet(x.left, key, d);\n        }\n        else if (c > x.c) {\n            return this.nodeGet(x.right, key, d);\n        }\n        else if (d < (key.length - 1)) {\n            return this.nodeGet(x.mid, key, d + 1);\n        }\n        else {\n            return x;\n        }\n    }\n    put(key, val) {\n        if (!this.contains(key)) {\n            this.n++;\n        }\n        this.root = this.nodePut(this.root, key, val, 0);\n        // console.log(`put ${key}`);\n    }\n    nodePut(x, key, val, d) {\n        let _x = x;\n        const c = key.charAt(d);\n        if (_x === undefined) {\n            _x = { c };\n        }\n        if (c < _x.c) {\n            _x.left = this.nodePut(_x.left, key, val, d);\n        }\n        else if (c > _x.c) {\n            _x.right = this.nodePut(_x.right, key, val, d);\n        }\n        else if (d < (key.length - 1)) {\n            _x.mid = this.nodePut(_x.mid, key, val, d + 1);\n        }\n        else {\n            _x.val = val;\n        }\n        return _x;\n    }\n    neighbors(text, distance = 2) {\n        let q = [];\n        this.nodeProximity(this.root, { text: \"\" }, 0, text, distance, q);\n        q = q.filter((value) => (value.text.length > 0));\n        return q;\n    }\n    keysWithPrefix(text) {\n        const q = [];\n        const x = this.nodeGet(this.root, text, 0);\n        if (x === undefined) {\n            return q;\n        }\n        if (x.val !== undefined) {\n            q.push(text);\n        }\n        this.collect(x.mid, { text }, q);\n        return q;\n    }\n    collect(x, prefix, q) {\n        if (x === undefined) {\n            return;\n        }\n        this.collect(x.left, prefix, q);\n        if (x.val !== undefined) {\n            q.push(prefix.text + x.c);\n        }\n        this.collect(x.mid, { text: prefix.text + x.c }, q);\n        this.collect(x.right, prefix, q);\n    }\n    mapNode(x, prefix, fn) {\n        if (x === undefined) {\n            return;\n        }\n        const key = prefix.text + x.c;\n        this.mapNode(x.left, prefix, fn);\n        if (x.val) {\n            fn(key, x.val);\n        }\n        this.mapNode(x.mid, { text: key }, fn);\n        this.mapNode(x.right, prefix, fn);\n    }\n    map(fn) {\n        this.mapNode(this.root, { text: \"\" }, fn);\n    }\n    pairsWithPrefix(text) {\n        const q = [];\n        const x = this.nodeGet(this.root, text, 0);\n        if (x === undefined) {\n            return q;\n        }\n        if (x.val !== undefined) {\n            q.push({ key: text, val: x.val });\n        }\n        this.collectPairs(x.mid, { text }, q);\n        return q;\n    }\n    collectPairs(x, prefix, q) {\n        if (x === undefined) {\n            return;\n        }\n        this.collectPairs(x.left, prefix, q);\n        if (x.val !== undefined) {\n            q.push({ key: prefix.text + x.c, val: x.val });\n        }\n        this.collectPairs(x.mid, { text: prefix.text + x.c }, q);\n        this.collectPairs(x.right, prefix, q);\n    }\n    patternCollect(x, prefix, d, pattern, q) {\n        if (x === undefined) {\n            return;\n        }\n        const c = pattern.charAt(d);\n        if ((c === \".\") || (c < x.c)) {\n            this.patternCollect(x.left, prefix, d, pattern, q);\n        }\n        else if ((c === \".\") || (c === x.c)) {\n            if ((d === (pattern.length - 1)) && (x.val !== undefined)) {\n                q.push(prefix.text + x.c);\n            }\n            else if (d < (pattern.length - 1)) {\n                this.patternCollect(x.mid, { text: prefix.text + x.c }, d + 1, pattern, q);\n            }\n        }\n        if ((c === \".\") || (c > x.c)) {\n            this.patternCollect(x.right, prefix, d, pattern, q);\n        }\n    }\n    nodeProximity(x, prefix, d, pattern, distance, q) {\n        if ((x === undefined) || (distance < 0)) {\n            return;\n        }\n        const c = pattern.charAt(d);\n        if ((distance > 0) || (c < x.c)) {\n            this.nodeProximity(x.left, prefix, d, pattern, distance, q);\n        }\n        if (x.val !== undefined) {\n            const remD = distance - (pattern.length - d);\n            if (remD >= 0) {\n                let invD = distance;\n                if (c !== x.c) {\n                    invD--;\n                }\n                q.push({ text: prefix.text + x.c, val: x.val, invDistance: invD });\n            }\n        }\n        const recurD = (d < (pattern.length - 1)) ? d + 1 : d;\n        if (c === x.c) {\n            this.nodeProximity(x.mid, { text: prefix.text + x.c }, recurD, pattern, distance, q);\n        }\n        else {\n            this.nodeProximity(x.mid, { text: prefix.text + x.c }, recurD, pattern, distance - 1, q);\n        }\n        if ((distance > 0) || (c > x.c)) {\n            this.nodeProximity(x.right, prefix, d, pattern, distance, q);\n        }\n    }\n    match(pattern) {\n        const q = [];\n        this.patternCollect(this.root, { text: \"\" }, 0, pattern, q);\n        return q;\n    }\n}\n//# sourceMappingURL=collections.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Sequence numbers for shared segments start at 1 or greater.  Every segment marked\n * with sequence number zero will be counted as part of the requested string.\n */\nexport const UniversalSequenceNumber = 0;\nexport const UnassignedSequenceNumber = -1;\nexport const TreeMaintenanceSequenceNumber = -2;\nexport const LocalClientId = -1;\nexport const NonCollabClient = -2;\n//# sourceMappingURL=constants.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { refGetRangeLabels, refGetTileLabels, refHasRangeLabel, refHasTileLabel, } from \"./mergeTree\";\nimport { ReferenceType } from \"./ops\";\nimport { addProperties } from \"./properties\";\nexport class LocalReference {\n    constructor(client, initSegment, offset = 0, refType = ReferenceType.Simple) {\n        this.client = client;\n        this.offset = offset;\n        this.refType = refType;\n        this.segment = initSegment;\n    }\n    min(b) {\n        if (this.compare(b) < 0) {\n            return this;\n        }\n        else {\n            return b;\n        }\n    }\n    max(b) {\n        if (this.compare(b) > 0) {\n            return this;\n        }\n        else {\n            return b;\n        }\n    }\n    compare(b) {\n        if (this.segment === b.segment) {\n            return this.offset - b.offset;\n        }\n        else {\n            if (this.segment === undefined\n                || (b.segment !== undefined &&\n                    this.segment.ordinal < b.segment.ordinal)) {\n                return -1;\n            }\n            else {\n                return 1;\n            }\n        }\n    }\n    toPosition() {\n        if (this.segment && this.segment.parent) {\n            return this.getOffset() + this.client.getPosition(this.segment);\n        }\n        else {\n            return LocalReference.DetachedPosition;\n        }\n    }\n    hasTileLabels() {\n        return !!this.getTileLabels();\n    }\n    hasRangeLabels() {\n        return !!this.getRangeLabels();\n    }\n    hasTileLabel(label) {\n        return refHasTileLabel(this, label);\n    }\n    hasRangeLabel(label) {\n        return refHasRangeLabel(this, label);\n    }\n    getTileLabels() {\n        return refGetTileLabels(this);\n    }\n    getRangeLabels() {\n        return refGetRangeLabels(this);\n    }\n    isLeaf() {\n        return false;\n    }\n    addProperties(newProps, op) {\n        this.properties = addProperties(this.properties, newProps, op);\n    }\n    getSegment() {\n        return this.segment;\n    }\n    getOffset() {\n        var _a;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if ((_a = this.segment) === null || _a === void 0 ? void 0 : _a.removedSeq) {\n            return 0;\n        }\n        return this.offset;\n    }\n    getProperties() {\n        return this.properties;\n    }\n}\nLocalReference.DetachedPosition = -1;\nexport class LocalReferenceCollection {\n    constructor(segment, initialRefsByfOffset = new Array(segment.cachedLength)) {\n        this.segment = segment;\n        this.hierRefCount = 0;\n        this.refCount = 0;\n        // Since javascript arrays are sparse the above won't populate any of the\n        // indicies, but it will ensure the length property of the array matches\n        // the length of the segment.\n        this.refsByOffset = initialRefsByfOffset;\n    }\n    static append(seg1, seg2) {\n        if (seg2.localRefs && !seg2.localRefs.empty) {\n            if (!seg1.localRefs) {\n                seg1.localRefs = new LocalReferenceCollection(seg1);\n            }\n            seg1.localRefs.append(seg2.localRefs);\n        }\n    }\n    [Symbol.iterator]() {\n        const subiterators = [];\n        for (const refs of this.refsByOffset) {\n            if (refs) {\n                if (refs.before) {\n                    subiterators.push(refs.before[Symbol.iterator]());\n                }\n                if (refs.at) {\n                    subiterators.push(refs.at[Symbol.iterator]());\n                }\n                if (refs.after) {\n                    subiterators.push(refs.after[Symbol.iterator]());\n                }\n            }\n        }\n        const iterator = {\n            next() {\n                while (subiterators.length > 0) {\n                    const next = subiterators[0].next();\n                    if (next.done === true) {\n                        subiterators.shift();\n                    }\n                    else {\n                        return next;\n                    }\n                }\n                return { value: undefined, done: true };\n            },\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n        return iterator;\n    }\n    clear() {\n        this.refCount = 0;\n        this.hierRefCount = 0;\n        const detachSegments = (refs) => {\n            if (refs) {\n                refs.forEach((r) => {\n                    if (r.segment === this.segment) {\n                        r.segment = undefined;\n                    }\n                });\n            }\n        };\n        for (let i = 0; i < this.refsByOffset.length; i++) {\n            const refsAtOffset = this.refsByOffset[i];\n            if (refsAtOffset) {\n                detachSegments(refsAtOffset.before);\n                detachSegments(refsAtOffset.at);\n                detachSegments(refsAtOffset.before);\n                this.refsByOffset[i] = undefined;\n            }\n        }\n    }\n    get empty() {\n        return this.refCount === 0;\n    }\n    addLocalRef(lref) {\n        const refsAtOffset = this.refsByOffset[lref.offset];\n        if (refsAtOffset === undefined) {\n            this.refsByOffset[lref.offset] = {\n                at: [lref],\n            };\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            refsAtOffset.at.push(lref);\n        }\n        if (lref.hasRangeLabels() || lref.hasTileLabels()) {\n            this.hierRefCount++;\n        }\n        this.refCount++;\n    }\n    removeLocalRef(lref) {\n        const tryRemoveRef = (refs) => {\n            if (refs) {\n                const index = refs.indexOf(lref);\n                if (index >= 0) {\n                    refs.splice(index, 1);\n                    if (lref.hasRangeLabels() || lref.hasTileLabels()) {\n                        this.hierRefCount--;\n                    }\n                    this.refCount--;\n                    return lref;\n                }\n            }\n        };\n        const refAtOffset = this.refsByOffset[lref.offset];\n        if (refAtOffset !== undefined) {\n            let ref = tryRemoveRef(refAtOffset.before);\n            if (ref) {\n                return ref;\n            }\n            ref = tryRemoveRef(refAtOffset.at);\n            if (ref) {\n                return ref;\n            }\n            ref = tryRemoveRef(refAtOffset.after);\n            if (ref) {\n                return ref;\n            }\n        }\n    }\n    /**\n     * Called by 'append()' implementations to append local refs from the given 'other' segment to the\n     * end of 'this' segment.\n     *\n     * Note: This method should be invoked after the caller has ensured that segments can be merged,\n     *       but before 'this' segment's cachedLength has changed, or the adjustment to the local refs\n     *       will be incorrect.\n     */\n    append(other) {\n        if (!other || other.empty) {\n            return;\n        }\n        this.hierRefCount += other.hierRefCount;\n        this.refCount += other.refCount;\n        other.hierRefCount = 0;\n        for (const lref of other) {\n            lref.segment = this.segment;\n            lref.offset += this.refsByOffset.length;\n        }\n        this.refsByOffset.push(...other.refsByOffset);\n    }\n    split(offset, splitSeg) {\n        if (!this.empty) {\n            const localRefs = new LocalReferenceCollection(splitSeg, this.refsByOffset.splice(offset, this.refsByOffset.length - offset));\n            splitSeg.localRefs = localRefs;\n            for (const lref of localRefs) {\n                lref.segment = splitSeg;\n                lref.offset -= offset;\n                if (lref.hasRangeLabels() || lref.hasTileLabels()) {\n                    this.hierRefCount--;\n                    localRefs.hierRefCount++;\n                }\n                this.refCount--;\n                localRefs.refCount++;\n            }\n        }\n    }\n    addBeforeTombstones(...refs) {\n        const beforeRefs = [];\n        for (const iterable of refs) {\n            for (const lref of iterable) {\n                // eslint-disable-next-line no-bitwise\n                if (lref.refType & ReferenceType.SlideOnRemove) {\n                    beforeRefs.push(lref);\n                    lref.segment = this.segment;\n                    lref.offset = 0;\n                    if (lref.hasRangeLabels() || lref.hasTileLabels()) {\n                        this.hierRefCount++;\n                    }\n                    this.refCount++;\n                }\n                else {\n                    lref.segment = undefined;\n                }\n            }\n        }\n        if (beforeRefs.length > 0) {\n            if (this.refsByOffset[0] === undefined) {\n                this.refsByOffset[0] = { before: beforeRefs };\n            }\n            else if (this.refsByOffset[0].before === undefined) {\n                this.refsByOffset[0].before = beforeRefs;\n            }\n            else {\n                this.refsByOffset[0].before.unshift(...beforeRefs);\n            }\n        }\n    }\n    addAfterTombstones(...refs) {\n        const afterRefs = [];\n        for (const iterable of refs) {\n            for (const lref of iterable) {\n                // eslint-disable-next-line no-bitwise\n                if (lref.refType & ReferenceType.SlideOnRemove) {\n                    afterRefs.push(lref);\n                    lref.segment = this.segment;\n                    lref.offset = this.segment.cachedLength - 1;\n                    if (lref.hasRangeLabels() || lref.hasTileLabels()) {\n                        this.hierRefCount++;\n                    }\n                    this.refCount++;\n                }\n                else {\n                    lref.segment = undefined;\n                }\n            }\n        }\n        if (afterRefs.length > 0) {\n            const refsAtOffset = this.refsByOffset[this.segment.cachedLength - 1];\n            if (refsAtOffset === undefined) {\n                this.refsByOffset[this.segment.cachedLength - 1] = { after: afterRefs };\n            }\n            else if (refsAtOffset.after === undefined) {\n                refsAtOffset.after = afterRefs;\n            }\n            else {\n                refsAtOffset.after.push(...afterRefs);\n            }\n        }\n    }\n}\n//# sourceMappingURL=localReference.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-shadow, max-len, no-bitwise */\nimport { assert, Trace } from \"@fluidframework/common-utils\";\nimport * as Collections from \"./collections\";\nimport { LocalClientId, NonCollabClient, TreeMaintenanceSequenceNumber, UnassignedSequenceNumber, UniversalSequenceNumber, } from \"./constants\";\nimport { LocalReference, LocalReferenceCollection } from \"./localReference\";\nimport { TrackingGroupCollection } from \"./mergeTreeTracking\";\nimport * as ops from \"./ops\";\nimport { PartialSequenceLengths } from \"./partialLengths\";\nimport * as Properties from \"./properties\";\nimport { SegmentGroupCollection } from \"./segmentGroupCollection\";\nimport { SegmentPropertiesManager } from \"./segmentPropertiesManager\";\nexport class MergeNode {\n    constructor() {\n        this.index = 0;\n        this.ordinal = \"\";\n        this.cachedLength = 0;\n    }\n    isLeaf() {\n        return false;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction addTile(tile, tiles) {\n    const tileLabels = tile.getTileLabels();\n    if (tileLabels) {\n        for (const tileLabel of tileLabels) {\n            tiles[tileLabel] = tile;\n        }\n    }\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction addTileIfNotPresent(tile, tiles) {\n    const tileLabels = tile.getTileLabels();\n    if (tileLabels) {\n        for (const tileLabel of tileLabels) {\n            if (tiles[tileLabel] === undefined) {\n                tiles[tileLabel] = tile;\n            }\n        }\n    }\n}\nfunction applyStackDelta(currentStackMap, deltaStackMap) {\n    // eslint-disable-next-line guard-for-in, no-restricted-syntax\n    for (const label in deltaStackMap) {\n        const deltaStack = deltaStackMap[label];\n        if (!deltaStack.empty()) {\n            let currentStack = currentStackMap[label];\n            if (currentStack === undefined) {\n                currentStack = new Collections.Stack();\n                currentStackMap[label] = currentStack;\n            }\n            for (const delta of deltaStack.items) {\n                applyRangeReference(currentStack, delta);\n            }\n        }\n    }\n}\nfunction applyRangeReference(stack, delta) {\n    if (delta.refType & ops.ReferenceType.NestBegin) {\n        stack.push(delta);\n        return true;\n    }\n    else {\n        // Assume delta is end reference\n        const top = stack.top();\n        // TODO: match end with begin\n        if (top && (top.refType & ops.ReferenceType.NestBegin)) {\n            stack.pop();\n        }\n        else {\n            stack.push(delta);\n        }\n        return false;\n    }\n}\nfunction addNodeReferences(mergeTree, node, rightmostTiles, leftmostTiles, rangeStacks) {\n    function updateRangeInfo(label, refPos) {\n        let stack = rangeStacks[label];\n        if (stack === undefined) {\n            stack = new Collections.Stack();\n            rangeStacks[label] = stack;\n        }\n        applyRangeReference(stack, refPos);\n    }\n    if (node.isLeaf()) {\n        const segment = node;\n        if (mergeTree.localNetLength(segment) > 0) {\n            if (Marker.is(segment)) {\n                const markerId = segment.getId();\n                // Also in insertMarker but need for reload segs case\n                // can add option for this only from reload segs\n                if (markerId) {\n                    mergeTree.mapIdToSegment(markerId, segment);\n                }\n                if (segment.refType & ops.ReferenceType.Tile) {\n                    addTile(segment, rightmostTiles);\n                    addTileIfNotPresent(segment, leftmostTiles);\n                }\n                if (segment.refType & (ops.ReferenceType.NestBegin | ops.ReferenceType.NestEnd)) {\n                    const rangeLabels = segment.getRangeLabels();\n                    if (rangeLabels) {\n                        for (const label of segment.getRangeLabels()) {\n                            updateRangeInfo(label, segment);\n                        }\n                    }\n                }\n            }\n            else {\n                const baseSegment = node;\n                if (baseSegment.localRefs && (baseSegment.localRefs.hierRefCount !== undefined) &&\n                    (baseSegment.localRefs.hierRefCount > 0)) {\n                    for (const lref of baseSegment.localRefs) {\n                        if (lref.refType & ops.ReferenceType.Tile) {\n                            addTile(lref, rightmostTiles);\n                            addTileIfNotPresent(lref, leftmostTiles);\n                        }\n                        if (lref.refType & (ops.ReferenceType.NestBegin | ops.ReferenceType.NestEnd)) {\n                            for (const label of lref.getRangeLabels()) {\n                                updateRangeInfo(label, lref);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else {\n        const block = node;\n        applyStackDelta(rangeStacks, block.rangeStacks);\n        Properties.extend(rightmostTiles, block.rightmostTiles);\n        Properties.extendIfUndefined(leftmostTiles, block.leftmostTiles);\n    }\n}\nexport function ordinalToArray(ord) {\n    const a = [];\n    if (ord) {\n        for (let i = 0, len = ord.length; i < len; i++) {\n            a.push(ord.charCodeAt(i));\n        }\n    }\n    return a;\n}\n// Note that the actual branching factor of the MergeTree is `MaxNodesInBlock - 1`.  This is because\n// the MergeTree always inserts first, then checks for overflow and splits if the child count equals\n// `MaxNodesInBlock`.  (i.e., `MaxNodesInBlock` contains 1 extra slot for temporary storage to\n// facilitate splits.)\nexport const MaxNodesInBlock = 8;\nexport class MergeBlock extends MergeNode {\n    constructor(childCount) {\n        super();\n        this.childCount = childCount;\n        this.children = new Array(MaxNodesInBlock);\n    }\n    hierBlock() {\n        return undefined;\n    }\n    setOrdinal(child, index) {\n        let childCount = this.childCount;\n        if (childCount === 8) {\n            childCount = 7;\n        }\n        assert((childCount >= 1) && (childCount <= 7), 0x040 /* \"Child count is not within [1,7] range!\" */);\n        let localOrdinal;\n        const ordinalWidth = 1 << (MaxNodesInBlock - (childCount + 1));\n        if (index === 0) {\n            localOrdinal = ordinalWidth - 1;\n        }\n        else {\n            const prevOrd = this.children[index - 1].ordinal;\n            const prevOrdCode = prevOrd.charCodeAt(prevOrd.length - 1);\n            localOrdinal = prevOrdCode + ordinalWidth;\n        }\n        child.ordinal = this.ordinal + String.fromCharCode(localOrdinal);\n        if (MergeBlock.traceOrdinals) {\n            console.log(`so: prnt chld prev ${ordinalToArray(this.ordinal)} ${ordinalToArray(child.ordinal)} ${(index > 0) ? ordinalToArray(this.children[index - 1].ordinal) : \"NA\"}`);\n        }\n        assert(child.ordinal.length === (this.ordinal.length + 1), 0x041 /* \"Unexpected child ordinal length!\" */);\n        if (index > 0) {\n            assert(child.ordinal > this.children[index - 1].ordinal, 0x042 /* \"Child ordinal <= previous sibling ordinal!\" */);\n            // console.log(`${ordinalToArray(this.ordinal)} ${ordinalToArray(child.ordinal)} ${ordinalToArray(this.children[index - 1].ordinal)}`);\n            // console.log(`ord width ${ordinalWidth}`);\n        }\n    }\n    assignChild(child, index, updateOrdinal = true) {\n        child.parent = this;\n        child.index = index;\n        if (updateOrdinal) {\n            this.setOrdinal(child, index);\n        }\n        this.children[index] = child;\n    }\n}\nMergeBlock.traceOrdinals = false;\nclass HierMergeBlock extends MergeBlock {\n    constructor(childCount) {\n        super(childCount);\n        this.rightmostTiles = Properties.createMap();\n        this.leftmostTiles = Properties.createMap();\n        this.rangeStacks = Properties.createMap();\n    }\n    addNodeReferences(mergeTree, node) {\n        addNodeReferences(mergeTree, node, this.rightmostTiles, this.leftmostTiles, this.rangeStacks);\n    }\n    hierBlock() {\n        return this;\n    }\n    hierToString(indentCount) {\n        let strbuf = \"\";\n        // eslint-disable-next-line guard-for-in, no-restricted-syntax\n        for (const key in this.rangeStacks) {\n            const stack = this.rangeStacks[key];\n            strbuf += internedSpaces(indentCount);\n            strbuf += `${key}: `;\n            for (const item of stack.items) {\n                strbuf += `${item.toString()} `;\n            }\n            strbuf += \"\\n\";\n        }\n        return strbuf;\n    }\n}\nfunction nodeTotalLength(mergeTree, node) {\n    if (!node.isLeaf()) {\n        return node.cachedLength;\n    }\n    return mergeTree.localNetLength(node);\n}\nexport class BaseSegment extends MergeNode {\n    constructor() {\n        super();\n        this.clientId = LocalClientId;\n        this.seq = UniversalSequenceNumber;\n        this.segmentGroups = new SegmentGroupCollection(this);\n        this.trackingCollection = new TrackingGroupCollection(this);\n    }\n    addProperties(newProps, op, seq, collabWindow) {\n        if (!this.propertyManager) {\n            this.propertyManager = new SegmentPropertiesManager(this);\n        }\n        return this.propertyManager.addProperties(newProps, op, seq, collabWindow);\n    }\n    hasProperty(key) {\n        return !!this.properties && (this.properties[key] !== undefined);\n    }\n    isLeaf() {\n        return true;\n    }\n    cloneInto(b) {\n        b.clientId = this.clientId;\n        // TODO: deep clone properties\n        b.properties = Properties.clone(this.properties);\n        b.removedClientId = this.removedClientId;\n        // TODO: copy removed client overlap and branch removal info\n        b.removedSeq = this.removedSeq;\n        b.seq = this.seq;\n    }\n    canAppend(segment) {\n        return false;\n    }\n    addSerializedProps(jseg) {\n        if (this.properties) {\n            jseg.props = this.properties;\n        }\n    }\n    ack(segmentGroup, opArgs, mergeTree) {\n        const currentSegmentGroup = this.segmentGroups.dequeue();\n        assert(currentSegmentGroup === segmentGroup, 0x043 /* \"On ack, unexpected segmentGroup!\" */);\n        switch (opArgs.op.type) {\n            case 2 /* ANNOTATE */:\n                assert(!!this.propertyManager, 0x044 /* \"On annotate ack, missing segment property manager!\" */);\n                this.propertyManager.ackPendingProperties(opArgs.op);\n                return true;\n            case 0 /* INSERT */:\n                assert(this.seq === UnassignedSequenceNumber, 0x045 /* \"On insert, seq number already assigned!\" */);\n                this.seq = opArgs.sequencedMessage.sequenceNumber;\n                this.localSeq = undefined;\n                return true;\n            case 1 /* REMOVE */:\n                const removalInfo = mergeTree.getRemovalInfo(this);\n                assert(!!removalInfo, 0x046 /* \"On remove ack, missing removal info!\" */);\n                assert(!!removalInfo.removedSeq, 0x047 /* \"On remove ack, missing removed sequence number!\" */);\n                this.localRemovedSeq = undefined;\n                if (removalInfo.removedSeq === UnassignedSequenceNumber) {\n                    removalInfo.removedSeq = opArgs.sequencedMessage.sequenceNumber;\n                    return true;\n                }\n                if (MergeTree.diagOverlappingRemove) {\n                    console.log(`grump @seq ${opArgs.sequencedMessage.sequenceNumber} ` +\n                        `cli ${glc(mergeTree, mergeTree.collabWindow.clientId)} ` +\n                        `from ${removalInfo.removedSeq} text ${mergeTree.toString()}`);\n                }\n                return false;\n            default:\n                throw new Error(`${opArgs.op.type} is in unrecognized operation type`);\n        }\n    }\n    splitAt(pos) {\n        if (pos > 0) {\n            const leafSegment = this.createSplitSegmentAt(pos);\n            if (leafSegment) {\n                if (this.propertyManager) {\n                    this.propertyManager.copyTo(leafSegment);\n                }\n                leafSegment.parent = this.parent;\n                // Give the leaf a temporary yet valid ordinal.\n                // when this segment is put in the tree, it will get it's real ordinal,\n                // but this ordinal meets all the necessary invariants for now.\n                leafSegment.ordinal = this.ordinal + String.fromCharCode(0);\n                leafSegment.removedClientId = this.removedClientId;\n                leafSegment.removedSeq = this.removedSeq;\n                leafSegment.localRemovedSeq = this.localRemovedSeq;\n                leafSegment.seq = this.seq;\n                leafSegment.localSeq = this.localSeq;\n                leafSegment.clientId = this.clientId;\n                if (this.removedClientOverlap) {\n                    leafSegment.removedClientOverlap = [...this.removedClientOverlap];\n                }\n                this.segmentGroups.copyTo(leafSegment);\n                this.trackingCollection.copyTo(leafSegment);\n                if (this.localRefs) {\n                    this.localRefs.split(pos, leafSegment);\n                }\n            }\n            return leafSegment;\n        }\n    }\n}\nexport const reservedTileLabelsKey = \"referenceTileLabels\";\nexport const reservedRangeLabelsKey = \"referenceRangeLabels\";\nexport const reservedMarkerIdKey = \"markerId\";\nexport const reservedMarkerSimpleTypeKey = \"markerSimpleType\";\nexport const refGetTileLabels = (refPos) => (refPos.refType & ops.ReferenceType.Tile) &&\n    refPos.properties ? refPos.properties[reservedTileLabelsKey] : undefined;\nexport const refGetRangeLabels = (refPos) => (refPos.refType & (ops.ReferenceType.NestBegin | ops.ReferenceType.NestEnd)) &&\n    refPos.properties ? refPos.properties[reservedRangeLabelsKey] : undefined;\nexport function refHasTileLabel(refPos, label) {\n    const tileLabels = refPos.getTileLabels();\n    if (tileLabels) {\n        for (const refLabel of tileLabels) {\n            if (label === refLabel) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function refHasRangeLabel(refPos, label) {\n    const rangeLabels = refPos.getRangeLabels();\n    if (rangeLabels) {\n        for (const refLabel of rangeLabels) {\n            if (label === refLabel) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport class Marker extends BaseSegment {\n    constructor(refType) {\n        super();\n        this.refType = refType;\n        this.type = Marker.type;\n        this.cachedLength = 1;\n    }\n    static is(segment) {\n        return segment.type === Marker.type;\n    }\n    static make(refType, props) {\n        const marker = new Marker(refType);\n        if (props) {\n            marker.addProperties(props);\n        }\n        return marker;\n    }\n    toJSONObject() {\n        const obj = { marker: { refType: this.refType } };\n        super.addSerializedProps(obj);\n        return obj;\n    }\n    static fromJSONObject(spec) {\n        if (spec && typeof spec === \"object\" && \"marker\" in spec) {\n            return Marker.make(spec.marker.refType, spec.props);\n        }\n        return undefined;\n    }\n    clone() {\n        const b = Marker.make(this.refType, this.properties);\n        this.cloneInto(b);\n        return b;\n    }\n    getSegment() {\n        return this;\n    }\n    getOffset() {\n        return 0;\n    }\n    hasSimpleType(simpleTypeName) {\n        return !!this.properties &&\n            this.properties[reservedMarkerSimpleTypeKey] === simpleTypeName;\n    }\n    getProperties() {\n        return this.properties;\n    }\n    getId() {\n        if (this.properties && this.properties[reservedMarkerIdKey]) {\n            return this.properties[reservedMarkerIdKey];\n        }\n    }\n    hasTileLabels() {\n        return !!this.getTileLabels();\n    }\n    hasRangeLabels() {\n        return !!this.getRangeLabels();\n    }\n    hasTileLabel(label) {\n        return refHasTileLabel(this, label);\n    }\n    hasRangeLabel(label) {\n        return refHasRangeLabel(this, label);\n    }\n    getTileLabels() {\n        return refGetTileLabels(this);\n    }\n    getRangeLabels() {\n        return refGetRangeLabels(this);\n    }\n    toString() {\n        let bbuf = \"\";\n        if (this.refType & ops.ReferenceType.Tile) {\n            bbuf += \"Tile\";\n        }\n        if (this.refType & ops.ReferenceType.NestBegin) {\n            if (bbuf.length > 0) {\n                bbuf += \"; \";\n            }\n            bbuf += \"RangeBegin\";\n        }\n        if (this.refType & ops.ReferenceType.NestEnd) {\n            if (bbuf.length > 0) {\n                bbuf += \"; \";\n            }\n            bbuf += \"RangeEnd\";\n        }\n        let lbuf = \"\";\n        const id = this.getId();\n        if (id) {\n            bbuf += ` (${id}) `;\n        }\n        const tileLabels = this.getTileLabels();\n        if (tileLabels) {\n            lbuf += \"tile -- \";\n            for (let i = 0, len = tileLabels.length; i < len; i++) {\n                const tileLabel = tileLabels[i];\n                if (i > 0) {\n                    lbuf += \"; \";\n                }\n                lbuf += tileLabel;\n            }\n        }\n        const rangeLabels = this.getRangeLabels();\n        if (rangeLabels) {\n            let rangeKind = \"begin\";\n            if (this.refType & ops.ReferenceType.NestEnd) {\n                rangeKind = \"end\";\n            }\n            if (tileLabels) {\n                lbuf += \" \";\n            }\n            lbuf += `range ${rangeKind} -- `;\n            const labels = rangeLabels;\n            for (let i = 0, len = labels.length; i < len; i++) {\n                const rangeLabel = labels[i];\n                if (i > 0) {\n                    lbuf += \"; \";\n                }\n                lbuf += rangeLabel;\n            }\n        }\n        let pbuf = \"\";\n        if (this.properties) {\n            pbuf += JSON.stringify(this.properties, (key, value) => {\n                // Avoid circular reference when stringifying makers containing handles.\n                // (Substitute a debug string instead.)\n                const handle = !!value && value.IFluidHandle;\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return handle\n                    ? `#Handle(${handle.routeContext.path}/${handle.path})`\n                    : value;\n            });\n        }\n        return `M ${bbuf}: ${lbuf} ${pbuf}`;\n    }\n    createSplitSegmentAt(pos) {\n        return undefined;\n    }\n    canAppend(segment) {\n        return false;\n    }\n    append() { throw new Error(\"Can not append to marker\"); }\n}\nMarker.type = \"Marker\";\nexport var IncrementalExecOp;\n(function (IncrementalExecOp) {\n    IncrementalExecOp[IncrementalExecOp[\"Go\"] = 0] = \"Go\";\n    IncrementalExecOp[IncrementalExecOp[\"Stop\"] = 1] = \"Stop\";\n    IncrementalExecOp[IncrementalExecOp[\"Yield\"] = 2] = \"Yield\";\n})(IncrementalExecOp || (IncrementalExecOp = {}));\nexport class IncrementalMapState {\n    constructor(block, actions, pos, refSeq, clientId, context, start, end, childIndex = 0) {\n        this.block = block;\n        this.actions = actions;\n        this.pos = pos;\n        this.refSeq = refSeq;\n        this.clientId = clientId;\n        this.context = context;\n        this.start = start;\n        this.end = end;\n        this.childIndex = childIndex;\n        this.op = IncrementalExecOp.Go;\n    }\n}\nexport class CollaborationWindow {\n    constructor() {\n        this.clientId = LocalClientId;\n        this.collaborating = false;\n        // Lowest-numbered segment in window; no client can reference a state before this one\n        this.minSeq = 0;\n        // Highest-numbered segment in window and current\n        // reference segment for this client\n        this.currentSeq = 0;\n        this.localSeq = 0;\n    }\n    loadFrom(a) {\n        this.clientId = a.clientId;\n        this.collaborating = a.collaborating;\n        this.minSeq = a.minSeq;\n        this.currentSeq = a.currentSeq;\n    }\n}\nexport const compareNumbers = (a, b) => a - b;\nexport const compareStrings = (a, b) => a.localeCompare(b);\nexport function clock() {\n    return Trace.start();\n}\nexport function elapsedMicroseconds(trace) {\n    return trace.trace().duration * 1000;\n}\nconst indentStrings = [\"\", \" \", \"  \"];\nexport function internedSpaces(n) {\n    if (indentStrings[n] === undefined) {\n        indentStrings[n] = \"\";\n        for (let i = 0; i < n; i++) {\n            indentStrings[n] += \" \";\n        }\n    }\n    return indentStrings[n];\n}\nexport class RegisterCollection {\n    constructor() {\n        this.clientCollections = Properties.createMap();\n        // TODO: snapshot\n    }\n    set(clientId, id, segments) {\n        let clientCollection = this.clientCollections[clientId];\n        if (!clientCollection) {\n            clientCollection = Properties.createMap();\n            this.clientCollections[clientId] = clientCollection;\n        }\n        clientCollection[id] = segments;\n    }\n    get(clientId, id) {\n        const clientCollection = this.clientCollections[clientId];\n        if (clientCollection) {\n            return clientCollection[id];\n        }\n    }\n    getLength(clientId, id) {\n        const segs = this.get(clientId, id);\n        let len = 0;\n        if (segs) {\n            for (const seg of segs) {\n                len += seg.cachedLength;\n            }\n        }\n        return len;\n    }\n    removeClient(clientId) {\n        this.clientCollections[clientId] = undefined;\n    }\n}\nexport const clientSeqComparer = {\n    min: { refSeq: -1, clientId: \"\" },\n    compare: (a, b) => a.refSeq - b.refSeq,\n};\nconst LRUSegmentComparer = {\n    min: { maxSeq: -2 },\n    compare: (a, b) => a.maxSeq - b.maxSeq,\n};\nexport function glc(mergeTree, id) {\n    if (mergeTree.getLongClientId) {\n        return mergeTree.getLongClientId(id);\n    }\n    else {\n        return id.toString();\n    }\n}\nfunction applyLeafRangeMarker(marker, searchInfo) {\n    for (const rangeLabel of searchInfo.rangeLabels) {\n        if (marker.hasRangeLabel(rangeLabel)) {\n            let currentStack = searchInfo.stacks[rangeLabel];\n            if (currentStack === undefined) {\n                currentStack = new Collections.Stack();\n                searchInfo.stacks[rangeLabel] = currentStack;\n            }\n            applyRangeReference(currentStack, marker);\n        }\n    }\n}\nfunction recordRangeLeaf(segment, segpos, refSeq, clientId, start, end, searchInfo) {\n    if (Marker.is(segment)) {\n        if (segment.refType &\n            (ops.ReferenceType.NestBegin | ops.ReferenceType.NestEnd)) {\n            applyLeafRangeMarker(segment, searchInfo);\n        }\n    }\n    return false;\n}\nfunction rangeShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {\n    if (node.isLeaf()) {\n        const seg = node;\n        if ((searchInfo.mergeTree.localNetLength(seg) > 0) && Marker.is(seg)) {\n            if (seg.refType &\n                (ops.ReferenceType.NestBegin | ops.ReferenceType.NestEnd)) {\n                applyLeafRangeMarker(seg, searchInfo);\n            }\n        }\n    }\n    else {\n        const block = node;\n        applyStackDelta(searchInfo.stacks, block.rangeStacks);\n    }\n    return true;\n}\nfunction recordTileStart(segment, segpos, refSeq, clientId, start, end, searchInfo) {\n    if (Marker.is(segment)) {\n        if (segment.hasTileLabel(searchInfo.tileLabel)) {\n            searchInfo.tile = segment;\n        }\n    }\n    return false;\n}\nfunction tileShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {\n    if (node.isLeaf()) {\n        const seg = node;\n        if ((searchInfo.mergeTree.localNetLength(seg) > 0) && Marker.is(seg)) {\n            if (seg.hasTileLabel(searchInfo.tileLabel)) {\n                searchInfo.tile = seg;\n            }\n        }\n    }\n    else {\n        const block = node;\n        let marker;\n        if (searchInfo.posPrecedesTile) {\n            marker = block.rightmostTiles[searchInfo.tileLabel];\n        }\n        else {\n            marker = block.leftmostTiles[searchInfo.tileLabel];\n        }\n        if (marker !== undefined) {\n            searchInfo.tile = marker;\n        }\n    }\n    return true;\n}\nconst minListenerComparer = {\n    min: { minRequired: Number.MIN_VALUE, onMinGE: () => { assert(false, 0x048 /* \"onMinGE()\" */); } },\n    compare: (a, b) => a.minRequired - b.minRequired,\n};\n// Represents a sequence of text segments\nexport class MergeTree {\n    // TODO: make and use interface describing options\n    constructor(options) {\n        this.options = options;\n        this.windowTime = 0;\n        this.packTime = 0;\n        this.ordTime = 0;\n        this.maxOrdTime = 0;\n        this.collabWindow = new CollaborationWindow();\n        // TODO: change this to ES6 map; add remove on segment remove\n        // for now assume only markers have ids and so point directly at the Segment\n        // if we need to have pointers to non-markers, we can change to point at local refs\n        this.idToSegment = Properties.createMap();\n        this.splitLeafSegment = (segment, pos) => {\n            if (!(pos > 0 && segment)) {\n                return {};\n            }\n            const next = segment.splitAt(pos);\n            if (this.mergeTreeMaintenanceCallback) {\n                this.mergeTreeMaintenanceCallback({\n                    operation: -2 /* SPLIT */,\n                    deltaSegments: [{ segment }, { segment: next }],\n                }, undefined);\n            }\n            return { next };\n        };\n        this.blockUpdateActions = MergeTree.initBlockUpdateActions;\n        this.root = this.makeBlock(0);\n    }\n    makeBlock(childCount) {\n        let block;\n        if (MergeTree.blockUpdateMarkers) {\n            block = new HierMergeBlock(childCount);\n        }\n        else {\n            block = new MergeBlock(childCount);\n        }\n        block.ordinal = \"\";\n        return block;\n    }\n    clone() {\n        const b = new MergeTree(this.options);\n        // For now assume that b will not collaborate\n        b.root = b.blockClone(this.root);\n    }\n    blockClone(block, segments) {\n        const bBlock = this.makeBlock(block.childCount);\n        for (let i = 0; i < block.childCount; i++) {\n            const child = block.children[i];\n            if (child.isLeaf()) {\n                const segment = this.segmentClone(child);\n                bBlock.assignChild(segment, i);\n                if (segments) {\n                    segments.push(segment);\n                }\n            }\n            else {\n                bBlock.assignChild(this.blockClone(child, segments), i);\n            }\n        }\n        this.nodeUpdateLengthNewStructure(bBlock);\n        this.nodeUpdateOrdinals(bBlock);\n        return bBlock;\n    }\n    segmentClone(segment) {\n        const b = segment.clone();\n        return b;\n    }\n    localNetLength(segment) {\n        const removalInfo = this.getRemovalInfo(segment);\n        if (removalInfo.removedSeq !== undefined) {\n            return 0;\n        }\n        else {\n            return segment.cachedLength;\n        }\n    }\n    // TODO: remove id when segment removed\n    mapIdToSegment(id, segment) {\n        this.idToSegment[id] = segment;\n    }\n    addNode(block, node) {\n        const index = block.childCount++;\n        block.assignChild(node, index, false);\n        return index;\n    }\n    reloadFromSegments(segments) {\n        // This code assumes that a later call to `startCollaboration()` will initialize partial lengths.\n        assert(!this.collabWindow.collaborating, 0x049 /* \"Trying to reload from segments while collaborating!\" */);\n        const maxChildren = MaxNodesInBlock - 1;\n        const measureReloadTime = false;\n        // Starting with the leaf segments, recursively builds the B-Tree layer by layer from the bottom up.\n        const buildMergeBlock = (nodes) => {\n            const blockCount = Math.ceil(nodes.length / maxChildren); // Compute # blocks require for this level of B-Tree\n            const blocks = new Array(blockCount); // Pre-alloc array to collect nodes\n            // For each block in this level of the B-Tree...\n            for (let nodeIndex = 0, blockIndex = 0; // Start with the first block and first node\n             blockIndex < blockCount; // If we have more blocks, we also have more nodes to insert\n             blockIndex++ // Advance to next block in this layer.\n            ) {\n                const block = blocks[blockIndex] = this.makeBlock(0);\n                // For each child of the current block, insert a node (while we have nodes left)\n                // and update the block's info.\n                for (let childIndex = 0; childIndex < maxChildren && nodeIndex < nodes.length; // While we still have children & nodes left\n                 childIndex++, nodeIndex++ // Advance to next child & node\n                ) {\n                    // Insert the next node into the current block\n                    this.addNode(block, nodes[nodeIndex]);\n                }\n                // Calculate this block's info.  Previously this was inlined into the above loop as a micro-optimization,\n                // but it turns out to be negligible in practice since `reloadFromSegments()` is only invoked for the\n                // snapshot header.  The bulk of the segments in long documents are inserted via `insertSegments()`.\n                this.blockUpdate(block);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return blocks.length === 1 // If there is only one block at this layer...\n                ? blocks[0] // ...then we're done.  Return the root.\n                : buildMergeBlock(blocks); // ...otherwise recursively build the next layer above blocks.\n        };\n        let clockStart;\n        if (measureReloadTime) {\n            clockStart = clock();\n        }\n        if (segments.length > 0) {\n            this.root = buildMergeBlock(segments);\n            this.nodeUpdateOrdinals(this.root);\n        }\n        else {\n            this.root = this.makeBlock(0);\n        }\n        if (clockStart) {\n            console.log(`reload time ${elapsedMicroseconds(clockStart)}`);\n        }\n    }\n    // For now assume min starts at zero\n    startCollaboration(localClientId, minSeq, currentSeq) {\n        this.collabWindow.clientId = localClientId;\n        this.collabWindow.minSeq = minSeq;\n        this.collabWindow.collaborating = true;\n        this.collabWindow.currentSeq = currentSeq;\n        this.segmentsToScour = new Collections.Heap([], LRUSegmentComparer);\n        this.pendingSegments = Collections.ListMakeHead();\n        const measureFullCollab = false;\n        let clockStart;\n        if (measureFullCollab) {\n            clockStart = clock();\n        }\n        this.nodeUpdateLengthNewStructure(this.root, true);\n        if (clockStart) {\n            console.log(`update partial lengths at start ${elapsedMicroseconds(clockStart)}`);\n        }\n    }\n    addToLRUSet(segment, seq) {\n        // If the parent node has not yet been marked for scour (i.e., needsScour is not false or undefined),\n        // add the segment and mark the mark the node now.\n        // TODO: 'seq' may be less than the current sequence number when inserting pre-ACKed\n        //       segments from a snapshot.  We currently skip these for now.\n        if (segment.parent.needsScour !== true && seq > this.collabWindow.currentSeq) {\n            segment.parent.needsScour = true;\n            this.segmentsToScour.add({ segment, maxSeq: seq });\n        }\n    }\n    underflow(node) {\n        return node.childCount < (MaxNodesInBlock / 2);\n    }\n    scourNode(node, holdNodes) {\n        let prevSegment;\n        for (let k = 0; k < node.childCount; k++) {\n            const childNode = node.children[k];\n            if (childNode.isLeaf()) {\n                const segment = childNode;\n                if (segment.segmentGroups.empty) {\n                    if (segment.removedSeq !== undefined) {\n                        if (segment.removedSeq > this.collabWindow.minSeq) {\n                            holdNodes.push(segment);\n                        }\n                        else if (!segment.trackingCollection.empty) {\n                            holdNodes.push(segment);\n                        }\n                        else {\n                            if (MergeTree.traceZRemove) {\n                                // eslint-disable-next-line @typescript-eslint/dot-notation\n                                console.log(`${this.getLongClientId(this.collabWindow.clientId)}: Zremove ${segment[\"text\"]}; cli ${this.getLongClientId(segment.clientId)}`);\n                            }\n                            // Notify maintenance event observers that the segment is being unlinked from the MergeTree.\n                            if (this.mergeTreeMaintenanceCallback) {\n                                this.mergeTreeMaintenanceCallback({\n                                    operation: -3 /* UNLINK */,\n                                    deltaSegments: [{ segment }],\n                                }, undefined);\n                            }\n                            segment.parent = undefined;\n                        }\n                        prevSegment = undefined;\n                    }\n                    else {\n                        if (segment.seq <= this.collabWindow.minSeq) {\n                            const canAppend = prevSegment\n                                && prevSegment.canAppend(segment)\n                                && Properties.matchProperties(prevSegment.properties, segment.properties)\n                                && prevSegment.trackingCollection.matches(segment.trackingCollection)\n                                && this.localNetLength(segment) > 0;\n                            if (canAppend) {\n                                if (MergeTree.traceAppend) {\n                                    // eslint-disable-next-line @typescript-eslint/dot-notation\n                                    console.log(`${this.getLongClientId(this.collabWindow.clientId)}: append ${prevSegment[\"text\"]} + ${segment[\"text\"]}; cli ${this.getLongClientId(prevSegment.clientId)} + cli ${this.getLongClientId(segment.clientId)}`);\n                                }\n                                prevSegment.append(segment);\n                                if (this.mergeTreeMaintenanceCallback) {\n                                    this.mergeTreeMaintenanceCallback({\n                                        operation: -1 /* APPEND */,\n                                        deltaSegments: [{ segment: prevSegment }, { segment }],\n                                    }, undefined);\n                                }\n                                segment.parent = undefined;\n                                segment.trackingCollection.trackingGroups.forEach((tg) => tg.unlink(segment));\n                            }\n                            else {\n                                holdNodes.push(segment);\n                                if (this.localNetLength(segment) > 0) {\n                                    prevSegment = segment;\n                                }\n                                else {\n                                    prevSegment = undefined;\n                                }\n                            }\n                        }\n                        else {\n                            holdNodes.push(segment);\n                            prevSegment = undefined;\n                        }\n                    }\n                }\n                else {\n                    holdNodes.push(segment);\n                    prevSegment = undefined;\n                }\n            }\n            else {\n                holdNodes.push(childNode);\n                prevSegment = undefined;\n            }\n        }\n    }\n    // Interior node with all node children\n    packParent(parent) {\n        const children = parent.children;\n        let childIndex;\n        let childBlock;\n        const holdNodes = [];\n        for (childIndex = 0; childIndex < parent.childCount; childIndex++) {\n            // Debug assert not isLeaf()\n            childBlock = children[childIndex];\n            this.scourNode(childBlock, holdNodes);\n            // Will replace this block with a packed block\n            childBlock.parent = undefined;\n        }\n        const totalNodeCount = holdNodes.length;\n        const halfCount = MaxNodesInBlock / 2;\n        let childCount = Math.min(MaxNodesInBlock - 1, Math.floor(totalNodeCount / halfCount));\n        if (childCount < 1) {\n            childCount = 1;\n        }\n        const baseCount = Math.floor(totalNodeCount / childCount);\n        let extraCount = totalNodeCount % childCount;\n        const packedBlocks = new Array(MaxNodesInBlock);\n        let readCount = 0;\n        for (let nodeIndex = 0; nodeIndex < childCount; nodeIndex++) {\n            let nodeCount = baseCount;\n            if (extraCount > 0) {\n                nodeCount++;\n                extraCount--;\n            }\n            const packedBlock = this.makeBlock(nodeCount);\n            for (let packedNodeIndex = 0; packedNodeIndex < nodeCount; packedNodeIndex++) {\n                const nodeToPack = holdNodes[readCount++];\n                packedBlock.assignChild(nodeToPack, packedNodeIndex, false);\n            }\n            packedBlock.parent = parent;\n            packedBlocks[nodeIndex] = packedBlock;\n            this.nodeUpdateLengthNewStructure(packedBlock);\n        }\n        if (readCount !== totalNodeCount) {\n            console.log(`total count ${totalNodeCount} readCount ${readCount}`);\n        }\n        parent.children = packedBlocks;\n        for (let j = 0; j < childCount; j++) {\n            parent.assignChild(packedBlocks[j], j, false);\n        }\n        parent.childCount = childCount;\n        if (this.underflow(parent) && (parent.parent)) {\n            this.packParent(parent.parent);\n        }\n        else {\n            this.nodeUpdateOrdinals(parent);\n            this.blockUpdatePathLengths(parent, UnassignedSequenceNumber, -1, true);\n        }\n    }\n    zamboniSegments(zamboniSegmentsMaxCount = MergeTree.zamboniSegmentsMaxCount) {\n        if (!this.collabWindow.collaborating) {\n            return;\n        }\n        let clockStart;\n        if (MergeTree.options.measureWindowTime) {\n            clockStart = clock();\n        }\n        for (let i = 0; i < zamboniSegmentsMaxCount; i++) {\n            let segmentToScour = this.segmentsToScour.peek();\n            if (!segmentToScour || segmentToScour.maxSeq > this.collabWindow.minSeq) {\n                break;\n            }\n            segmentToScour = this.segmentsToScour.get();\n            // Only skip scouring if needs scour is explicitly false, not true or undefined\n            if (segmentToScour.segment.parent && segmentToScour.segment.parent.needsScour !== false) {\n                const block = segmentToScour.segment.parent;\n                const childrenCopy = [];\n                // console.log(`scouring from ${segmentToScour.segment.seq}`);\n                this.scourNode(block, childrenCopy);\n                // This will avoid the cost of re-scouring nodes\n                // that have recently been scoured\n                block.needsScour = false;\n                const newChildCount = childrenCopy.length;\n                if (newChildCount < block.childCount) {\n                    block.childCount = newChildCount;\n                    block.children = childrenCopy;\n                    for (let j = 0; j < newChildCount; j++) {\n                        block.assignChild(childrenCopy[j], j, false);\n                    }\n                    if (this.underflow(block) && block.parent) {\n                        // nodeUpdatePathLengths(node, UnassignedSequenceNumber, -1, true);\n                        let packClockStart;\n                        if (MergeTree.options.measureWindowTime) {\n                            packClockStart = clock();\n                        }\n                        this.packParent(block.parent);\n                        if (MergeTree.options.measureWindowTime) {\n                            this.packTime += elapsedMicroseconds(packClockStart);\n                        }\n                    }\n                    else {\n                        this.nodeUpdateOrdinals(block);\n                        this.blockUpdatePathLengths(block, UnassignedSequenceNumber, -1, true);\n                    }\n                }\n            }\n        }\n        if (MergeTree.options.measureWindowTime) {\n            this.windowTime += elapsedMicroseconds(clockStart);\n        }\n    }\n    getCollabWindow() {\n        return this.collabWindow;\n    }\n    getStats() {\n        const nodeGetStats = (block) => {\n            const stats = { maxHeight: 0, nodeCount: 0, leafCount: 0, removedLeafCount: 0, liveCount: 0, histo: [] };\n            for (let k = 0; k < MaxNodesInBlock; k++) {\n                stats.histo[k] = 0;\n            }\n            for (let i = 0; i < block.childCount; i++) {\n                const child = block.children[i];\n                let height = 1;\n                if (!child.isLeaf()) {\n                    const childStats = nodeGetStats(child);\n                    height = 1 + childStats.maxHeight;\n                    stats.nodeCount += childStats.nodeCount;\n                    stats.leafCount += childStats.leafCount;\n                    stats.removedLeafCount += childStats.removedLeafCount;\n                    stats.liveCount += childStats.liveCount;\n                    for (let i = 0; i < MaxNodesInBlock; i++) {\n                        stats.histo[i] += childStats.histo[i];\n                    }\n                }\n                else {\n                    stats.leafCount++;\n                    const segment = child;\n                    if (segment.removedSeq !== undefined) {\n                        stats.removedLeafCount++;\n                    }\n                }\n                if (height > stats.maxHeight) {\n                    stats.maxHeight = height;\n                }\n            }\n            stats.histo[block.childCount]++;\n            stats.nodeCount++;\n            stats.liveCount += block.childCount;\n            return stats;\n        };\n        const rootStats = nodeGetStats(this.root);\n        if (MergeTree.options.measureWindowTime) {\n            rootStats.windowTime = this.windowTime;\n            rootStats.packTime = this.packTime;\n            rootStats.ordTime = this.ordTime;\n            rootStats.maxOrdTime = this.maxOrdTime;\n        }\n        return rootStats;\n    }\n    findHistorialPosition(pos, fromSeq, toSeq, clientId) {\n        return this.findHistorialPositionFromClient(pos, fromSeq, toSeq, clientId);\n    }\n    findHistorialPositionFromClient(pos, fromSeq, toSeq, clientId) {\n        assert(fromSeq < toSeq, 0x04a /* \"Invalid range for historical position search!\" */);\n        if (pos < this.getLength(fromSeq, clientId)) {\n            assert(toSeq <= this.collabWindow.currentSeq, 0x04b /* \"Out-of-bounds end sequence number for historical position search!\" */);\n            const segoff = this.getContainingSegment(pos, fromSeq, clientId);\n            assert(segoff.segment !== undefined, 0x04c /* \"Containing segment for historical position search is undefined!\" */);\n            const toPos = this.getPosition(segoff.segment, toSeq, clientId);\n            const ret = toPos + segoff.offset;\n            assert(ret !== undefined, 0x04d /* \"Return value for historical position search is undefined!\" */);\n            return ret;\n        }\n        else {\n            return pos;\n        }\n    }\n    findHistorialRangeFromClient(rangeStart, rangeEnd, fromSeq, toSeq, clientId) {\n        const ranges = [];\n        const recordRange = (segment, pos, refSeq, clientId, segStart, segEnd) => {\n            let _segStart = segStart;\n            let _segEnd = segEnd;\n            if (this.nodeLength(segment, toSeq, clientId) > 0) {\n                const position = this.getPosition(segment, toSeq, clientId);\n                if (_segStart < 0) {\n                    _segStart = 0;\n                }\n                if (_segEnd > segment.cachedLength) {\n                    _segEnd = segment.cachedLength;\n                }\n                ranges.push({ start: position + _segStart, end: position + _segEnd });\n            }\n            return true;\n        };\n        this.mapRange({ leaf: recordRange }, fromSeq, clientId, undefined, rangeStart, rangeEnd);\n        return ranges;\n    }\n    findHistorialRange(rangeStart, rangeEnd, fromSeq, toSeq, clientId) {\n        return this.findHistorialRangeFromClient(rangeStart, rangeEnd, fromSeq, toSeq, clientId);\n    }\n    getLength(refSeq, clientId) {\n        return this.blockLength(this.root, refSeq, clientId);\n    }\n    /**\n     * Returns the current length of the MergeTree for the local client.\n     */\n    get length() { return this.root.cachedLength; }\n    getPosition(node, refSeq, clientId) {\n        let totalOffset = 0;\n        let parent = node.parent;\n        let prevParent;\n        while (parent) {\n            const children = parent.children;\n            for (let childIndex = 0; childIndex < parent.childCount; childIndex++) {\n                const child = children[childIndex];\n                if ((prevParent && (child === prevParent)) || (child === node)) {\n                    break;\n                }\n                totalOffset += this.nodeLength(child, refSeq, clientId);\n            }\n            prevParent = parent;\n            parent = parent.parent;\n        }\n        return totalOffset;\n    }\n    cloneSegments(refSeq, clientId, start = 0, end) {\n        let _end = end;\n        const gatherSegment = (segment, pos, refSeq, clientId, start, end, accumSegments) => {\n            accumSegments.segments.push(segment.clone());\n            return true;\n        };\n        if (_end === undefined) {\n            _end = this.blockLength(this.root, refSeq, clientId);\n        }\n        const accum = {\n            segments: [],\n        };\n        this.mapRange({ leaf: gatherSegment }, refSeq, clientId, accum, start, _end);\n        return accum.segments;\n    }\n    getContainingSegment(pos, refSeq, clientId) {\n        let segment;\n        let offset;\n        const leaf = (leafSeg, segpos, refSeq, clientId, start) => {\n            segment = leafSeg;\n            offset = start;\n            return false;\n        };\n        this.searchBlock(this.root, pos, 0, refSeq, clientId, { leaf }, undefined);\n        return { segment, offset };\n    }\n    blockLength(node, refSeq, clientId) {\n        if ((this.collabWindow.collaborating) && (clientId !== this.collabWindow.clientId)) {\n            return node.partialLengths.getPartialLength(refSeq, clientId);\n        }\n        else {\n            return node.cachedLength;\n        }\n    }\n    getRemovalInfo(segment) {\n        return segment;\n    }\n    nodeLength(node, refSeq, clientId) {\n        if ((!this.collabWindow.collaborating) || (this.collabWindow.clientId === clientId)) {\n            // Local client sees all segments, even when collaborating\n            if (!node.isLeaf()) {\n                return node.cachedLength;\n            }\n            else {\n                return this.localNetLength(node);\n            }\n        }\n        else {\n            // Sequence number within window\n            if (!node.isLeaf()) {\n                return node.partialLengths.getPartialLength(refSeq, clientId);\n            }\n            else {\n                const segment = node;\n                if (((segment.clientId === clientId) ||\n                    ((segment.seq !== UnassignedSequenceNumber) && (segment.seq <= refSeq)))) {\n                    const removalInfo = this.getRemovalInfo(segment);\n                    // Segment happened by reference sequence number or segment from requesting client\n                    if (removalInfo.removedSeq !== undefined) {\n                        if ((removalInfo.removedClientId === clientId) ||\n                            (removalInfo.removedClientOverlap && (removalInfo.removedClientOverlap.includes(clientId))) ||\n                            ((removalInfo.removedSeq !== UnassignedSequenceNumber) && (removalInfo.removedSeq <= refSeq))) {\n                            return 0;\n                        }\n                        else {\n                            return segment.cachedLength;\n                        }\n                    }\n                    else {\n                        return segment.cachedLength;\n                    }\n                }\n                else {\n                    // Segment invisible to client at reference sequence number/branch id/client id of op\n                    return 0;\n                }\n            }\n        }\n    }\n    addMinSeqListener(minRequired, onMinGE) {\n        if (!this.minSeqListeners) {\n            this.minSeqListeners = new Collections.Heap([], minListenerComparer);\n        }\n        this.minSeqListeners.add({ minRequired, onMinGE });\n    }\n    notifyMinSeqListeners() {\n        if (this.minSeqListeners) {\n            while ((this.minSeqListeners.count() > 0) &&\n                (this.minSeqListeners.peek().minRequired <= this.collabWindow.minSeq)) {\n                const minListener = this.minSeqListeners.get();\n                minListener.onMinGE(this.collabWindow.minSeq);\n            }\n        }\n    }\n    setMinSeq(minSeq) {\n        assert(minSeq <= this.collabWindow.currentSeq, 0x04e /* \"Trying to set minSeq above currentSeq of collab window!\" */);\n        // Only move forward\n        assert(this.collabWindow.minSeq <= minSeq, 0x04f /* \"minSeq of collab window > target minSeq!\" */);\n        if (minSeq > this.collabWindow.minSeq) {\n            this.collabWindow.minSeq = minSeq;\n            if (MergeTree.options.zamboniSegments) {\n                this.zamboniSegments();\n            }\n            this.notifyMinSeqListeners();\n        }\n    }\n    referencePositionToLocalPosition(refPos, refSeq = this.collabWindow.currentSeq, clientId = this.collabWindow.clientId) {\n        const seg = refPos.getSegment();\n        if (seg && seg.parent) {\n            const offset = !seg.removedSeq ? refPos.getOffset() : 0;\n            return offset + this.getPosition(seg, refSeq, clientId);\n        }\n        return LocalReference.DetachedPosition;\n    }\n    getStackContext(startPos, clientId, rangeLabels) {\n        const searchInfo = {\n            mergeTree: this,\n            stacks: Properties.createMap(),\n            rangeLabels,\n        };\n        this.search(startPos, UniversalSequenceNumber, clientId, { leaf: recordRangeLeaf, shift: rangeShift }, searchInfo);\n        return searchInfo.stacks;\n    }\n    // TODO: filter function\n    findTile(startPos, clientId, tileLabel, posPrecedesTile = true) {\n        const searchInfo = {\n            mergeTree: this,\n            posPrecedesTile,\n            tileLabel,\n        };\n        if (posPrecedesTile) {\n            this.search(startPos, UniversalSequenceNumber, clientId, { leaf: recordTileStart, shift: tileShift }, searchInfo);\n        }\n        else {\n            this.backwardSearch(startPos, UniversalSequenceNumber, clientId, { leaf: recordTileStart, shift: tileShift }, searchInfo);\n        }\n        if (searchInfo.tile) {\n            let pos;\n            if (searchInfo.tile.isLeaf()) {\n                const marker = searchInfo.tile;\n                pos = this.getPosition(marker, UniversalSequenceNumber, clientId);\n            }\n            else {\n                const localRef = searchInfo.tile;\n                pos = localRef.toPosition();\n            }\n            return { tile: searchInfo.tile, pos };\n        }\n    }\n    search(pos, refSeq, clientId, actions, clientData) {\n        return this.searchBlock(this.root, pos, 0, refSeq, clientId, actions, clientData);\n    }\n    searchBlock(block, pos, segpos, refSeq, clientId, actions, clientData) {\n        let _pos = pos;\n        let _segpos = segpos;\n        const children = block.children;\n        if (actions && actions.pre) {\n            actions.pre(block, _segpos, refSeq, clientId, undefined, undefined, clientData);\n        }\n        const contains = actions && actions.contains;\n        for (let childIndex = 0; childIndex < block.childCount; childIndex++) {\n            const child = children[childIndex];\n            const len = this.nodeLength(child, refSeq, clientId);\n            if (((!contains) && (_pos < len)) || (contains && contains(child, _pos, refSeq, clientId, undefined, undefined, clientData))) {\n                // Found entry containing pos\n                if (!child.isLeaf()) {\n                    return this.searchBlock(child, _pos, _segpos, refSeq, clientId, actions, clientData);\n                }\n                else {\n                    if (actions && actions.leaf) {\n                        actions.leaf(child, _segpos, refSeq, clientId, _pos, -1, clientData);\n                    }\n                    return child;\n                }\n            }\n            else {\n                if (actions && actions.shift) {\n                    actions.shift(child, _segpos, refSeq, clientId, _pos, undefined, clientData);\n                }\n                _pos -= len;\n                _segpos += len;\n            }\n        }\n        if (actions && actions.post) {\n            actions.post(block, _segpos, refSeq, clientId, undefined, undefined, clientData);\n        }\n    }\n    backwardSearch(pos, refSeq, clientId, actions, clientData) {\n        const len = this.getLength(refSeq, clientId);\n        if (pos > len) {\n            return undefined;\n        }\n        return this.backwardSearchBlock(this.root, pos, len, refSeq, clientId, actions, clientData);\n    }\n    backwardSearchBlock(block, pos, segEnd, refSeq, clientId, actions, clientData) {\n        let _segEnd = segEnd;\n        const children = block.children;\n        if (actions && actions.pre) {\n            actions.pre(block, _segEnd, refSeq, clientId, undefined, undefined, clientData);\n        }\n        const contains = actions && actions.contains;\n        for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {\n            const child = children[childIndex];\n            const len = this.nodeLength(child, refSeq, clientId);\n            const segpos = _segEnd - len;\n            if (((!contains) && (pos >= segpos)) ||\n                (contains && contains(child, pos, refSeq, clientId, undefined, undefined, clientData))) {\n                // Found entry containing pos\n                if (!child.isLeaf()) {\n                    return this.backwardSearchBlock(child, pos, _segEnd, refSeq, clientId, actions, clientData);\n                }\n                else {\n                    if (actions && actions.leaf) {\n                        actions.leaf(child, segpos, refSeq, clientId, pos, -1, clientData);\n                    }\n                    return child;\n                }\n            }\n            else {\n                if (actions && actions.shift) {\n                    actions.shift(child, segpos, refSeq, clientId, pos, undefined, clientData);\n                }\n                _segEnd = segpos;\n            }\n        }\n        if (actions && actions.post) {\n            actions.post(block, _segEnd, refSeq, clientId, undefined, undefined, clientData);\n        }\n    }\n    updateRoot(splitNode) {\n        if (splitNode !== undefined) {\n            const newRoot = this.makeBlock(2);\n            newRoot.assignChild(this.root, 0, false);\n            newRoot.assignChild(splitNode, 1, false);\n            this.root = newRoot;\n            this.nodeUpdateOrdinals(this.root);\n            this.nodeUpdateLengthNewStructure(this.root);\n        }\n    }\n    /**\n     * Assign sequence number to existing segment; update partial lengths to reflect the change\n     * @param seq - sequence number given by server to pending segment\n     */\n    ackPendingSegment(opArgs, verboseOps = false) {\n        const seq = opArgs.sequencedMessage.sequenceNumber;\n        const pendingSegmentGroup = this.pendingSegments.dequeue();\n        const nodesToUpdate = [];\n        let overwrite = false;\n        if (pendingSegmentGroup !== undefined) {\n            if (verboseOps) {\n                console.log(`segment group has ${pendingSegmentGroup.segments.length} segments`);\n            }\n            const deltaSegments = [];\n            pendingSegmentGroup.segments.map((pendingSegment) => {\n                overwrite = !pendingSegment.ack(pendingSegmentGroup, opArgs, this) || overwrite;\n                if (MergeTree.options.zamboniSegments) {\n                    this.addToLRUSet(pendingSegment, seq);\n                }\n                if (!nodesToUpdate.includes(pendingSegment.parent)) {\n                    nodesToUpdate.push(pendingSegment.parent);\n                }\n                deltaSegments.push({\n                    segment: pendingSegment,\n                });\n            });\n            if (this.mergeTreeMaintenanceCallback) {\n                this.mergeTreeMaintenanceCallback({\n                    deltaSegments,\n                    operation: -4 /* ACKNOWLEDGED */,\n                }, opArgs);\n            }\n            const clientId = this.collabWindow.clientId;\n            for (const node of nodesToUpdate) {\n                this.blockUpdatePathLengths(node, seq, clientId, overwrite);\n                // NodeUpdatePathLengths(node, seq, clientId, true);\n            }\n        }\n        if (MergeTree.options.zamboniSegments) {\n            this.zamboniSegments();\n        }\n    }\n    addToPendingList(segment, segmentGroup, localSeq) {\n        let _segmentGroup = segmentGroup;\n        if (_segmentGroup === undefined) {\n            // TODO: review the cast\n            _segmentGroup = { segments: [], localSeq };\n            this.pendingSegments.enqueue(_segmentGroup);\n        }\n        segment.segmentGroups.enqueue(_segmentGroup);\n        return _segmentGroup;\n    }\n    // TODO: error checking\n    getMarkerFromId(id) {\n        return this.idToSegment[id];\n    }\n    /**\n     * Given a position specified relative to a marker id, lookup the marker\n     * and convert the position to a character position.\n     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.\n     * @param refseq - The reference sequence number at which to compute the position.\n     * @param clientId - The client id with which to compute the position.\n     */\n    posFromRelativePos(relativePos, refseq = this.collabWindow.currentSeq, clientId = this.collabWindow.clientId) {\n        let pos = -1;\n        let marker;\n        if (relativePos.id) {\n            marker = this.getMarkerFromId(relativePos.id);\n        }\n        if (marker) {\n            pos = this.getPosition(marker, refseq, clientId);\n            if (!relativePos.before) {\n                pos += marker.cachedLength;\n                if (relativePos.offset !== undefined) {\n                    pos += relativePos.offset;\n                }\n            }\n            else {\n                if (relativePos.offset !== undefined) {\n                    pos -= relativePos.offset;\n                }\n            }\n        }\n        return pos;\n    }\n    insertSegments(pos, segments, refSeq, clientId, seq, opArgs) {\n        // const tt = MergeTree.traceTraversal;\n        // MergeTree.traceTraversal = true;\n        this.ensureIntervalBoundary(pos, refSeq, clientId);\n        if (MergeTree.traceOrdinals) {\n            this.ordinalIntegrity();\n        }\n        const localSeq = seq === UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;\n        this.blockInsert(pos, refSeq, clientId, seq, localSeq, segments);\n        // opArgs == undefined => loading snapshot or test code\n        if (this.mergeTreeDeltaCallback && opArgs !== undefined) {\n            this.mergeTreeDeltaCallback(opArgs, {\n                operation: 0 /* INSERT */,\n                deltaSegments: segments.map((segment) => ({ segment })),\n            });\n        }\n        // MergeTree.traceTraversal = tt;\n        if (MergeTree.traceOrdinals) {\n            this.ordinalIntegrity();\n        }\n        if (this.collabWindow.collaborating && MergeTree.options.zamboniSegments &&\n            (seq !== UnassignedSequenceNumber)) {\n            this.zamboniSegments();\n        }\n    }\n    insertAtReferencePosition(referencePosition, insertSegment, opArgs) {\n        if (insertSegment.cachedLength === 0) {\n            return;\n        }\n        if (insertSegment.parent\n            || insertSegment.removedSeq\n            || insertSegment.seq !== UniversalSequenceNumber) {\n            throw new Error(\"Cannot insert segment that has already been inserted.\");\n        }\n        const rebalanceTree = (segment) => {\n            // Blocks should never be left full\n            // if the inserts makes the block full\n            // then we need to walk up the chain of parents\n            // and split the blocks until we find a block with\n            // room\n            let block = segment.parent;\n            let ordinalUpdateNode = block;\n            while (block !== undefined) {\n                if (block.childCount >= MaxNodesInBlock) {\n                    const splitNode = this.split(block);\n                    if (block === this.root) {\n                        this.updateRoot(splitNode);\n                        // Update root already updates all it's children ordinals\n                        ordinalUpdateNode = undefined;\n                    }\n                    else {\n                        this.insertChildNode(block.parent, splitNode, block.index + 1);\n                        ordinalUpdateNode = splitNode.parent;\n                        this.blockUpdateLength(block.parent, UnassignedSequenceNumber, clientId);\n                    }\n                }\n                else {\n                    this.blockUpdateLength(block, UnassignedSequenceNumber, clientId);\n                }\n                block = block.parent;\n            }\n            // Only update ordinals once, for all children,\n            // on the path\n            if (ordinalUpdateNode) {\n                this.nodeUpdateOrdinals(ordinalUpdateNode);\n            }\n        };\n        const clientId = this.collabWindow.clientId;\n        const refSegment = referencePosition.getSegment();\n        const refOffset = referencePosition.getOffset();\n        const refSegLen = this.nodeLength(refSegment, this.collabWindow.currentSeq, clientId);\n        let startSeg = refSegment;\n        if (refOffset !== 0 && refSegLen !== 0) {\n            const splitSeg = this.splitLeafSegment(refSegment, refOffset);\n            assert(!!splitSeg.next, 0x050 /* \"Next segment changes are undefined!\" */);\n            this.insertChildNode(refSegment.parent, splitSeg.next, refSegment.index + 1);\n            rebalanceTree(splitSeg.next);\n            startSeg = splitSeg.next;\n        }\n        this.leftExcursion(startSeg, (backSeg) => {\n            if (!backSeg.isLeaf()) {\n                return true;\n            }\n            const backLen = this.nodeLength(backSeg, this.collabWindow.currentSeq, clientId);\n            // Find the nearest 0 length seg we can insert over, as all other inserts\n            // go near to far\n            if (backLen === 0) {\n                if (this.breakTie(0, 0, backSeg, this.collabWindow.currentSeq, clientId)) {\n                    startSeg = backSeg;\n                }\n                return true;\n            }\n            return false;\n        });\n        if (this.collabWindow.collaborating) {\n            insertSegment.localSeq = ++this.collabWindow.localSeq;\n            insertSegment.seq = UnassignedSequenceNumber;\n        }\n        else {\n            insertSegment.seq = UniversalSequenceNumber;\n        }\n        insertSegment.clientId = clientId;\n        if (Marker.is(insertSegment)) {\n            const markerId = insertSegment.getId();\n            if (markerId) {\n                this.mapIdToSegment(markerId, insertSegment);\n            }\n        }\n        this.insertChildNode(startSeg.parent, insertSegment, startSeg.index);\n        rebalanceTree(insertSegment);\n        if (this.mergeTreeDeltaCallback) {\n            this.mergeTreeDeltaCallback(opArgs, {\n                deltaSegments: [{ segment: insertSegment }],\n                operation: 0 /* INSERT */,\n            });\n        }\n        if (this.collabWindow.collaborating) {\n            this.addToPendingList(insertSegment, undefined, insertSegment.localSeq);\n        }\n    }\n    /**\n     * Resolves a remote client's position against the local sequence\n     * and returns the remote client's position relative to the local\n     * sequence\n     * @param remoteClientPosition - The remote client's position to resolve\n     * @param remoteClientRefSeq - The reference sequence number of the remote client\n     * @param remoteClientId - The client id of the remote client\n     */\n    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {\n        const segmentInfo = this.getContainingSegment(remoteClientPosition, remoteClientRefSeq, remoteClientId);\n        const segwindow = this.getCollabWindow();\n        if (segmentInfo && segmentInfo.segment) {\n            const segmentPosition = this.getPosition(segmentInfo.segment, segwindow.currentSeq, segwindow.clientId);\n            return segmentPosition + segmentInfo.offset;\n        }\n        else {\n            if (remoteClientPosition === this.getLength(remoteClientRefSeq, remoteClientId)) {\n                return this.getLength(segwindow.currentSeq, segwindow.clientId);\n            }\n        }\n    }\n    insertChildNode(block, child, childIndex) {\n        assert(block.childCount < MaxNodesInBlock, 0x051 /* \"Too many children on merge block!\" */);\n        for (let i = block.childCount; i > childIndex; i--) {\n            block.children[i] = block.children[i - 1];\n            block.children[i].index = i;\n        }\n        block.childCount++;\n        block.assignChild(child, childIndex, false);\n    }\n    blockInsert(pos, refSeq, clientId, seq, localSeq, newSegments) {\n        let segIsLocal = false;\n        const checkSegmentIsLocal = (segment, pos, refSeq, clientId) => {\n            if (segment.seq === UnassignedSequenceNumber) {\n                if (MergeTree.diagInsertTie) {\n                    console.log(`@cli ${glc(this, this.collabWindow.clientId)}: promoting continue due to seq ${segment.seq} text ${segment.toString()} ref ${refSeq}`);\n                }\n                segIsLocal = true;\n            }\n            // Only need to look at first segment that follows finished node\n            return false;\n        };\n        const continueFrom = (node) => {\n            segIsLocal = false;\n            this.rightExcursion(node, checkSegmentIsLocal);\n            if (MergeTree.diagInsertTie && segIsLocal) {\n                console.log(`@cli ${glc(this, this.collabWindow.clientId)}: attempting continue with seq ${seq}  ref ${refSeq} `);\n            }\n            return segIsLocal;\n        };\n        let segmentGroup;\n        const saveIfLocal = (locSegment) => {\n            // Save segment so can assign sequence number when acked by server\n            if (this.collabWindow.collaborating) {\n                if ((locSegment.seq === UnassignedSequenceNumber) &&\n                    (clientId === this.collabWindow.clientId)) {\n                    segmentGroup = this.addToPendingList(locSegment, segmentGroup, localSeq);\n                }\n                // LocSegment.seq === 0 when coming from SharedSegmentSequence.loadBody()\n                // In all other cases this has to be true (checked by addToLRUSet):\n                // locSegment.seq > this.collabWindow.currentSeq\n                else if ((locSegment.seq > this.collabWindow.minSeq) &&\n                    MergeTree.options.zamboniSegments) {\n                    this.addToLRUSet(locSegment, locSegment.seq);\n                }\n            }\n        };\n        const onLeaf = (segment, pos, context) => {\n            const segmentChanges = {};\n            if (segment) {\n                // Insert before segment\n                segmentChanges.replaceCurrent = context.candidateSegment;\n                segmentChanges.next = segment;\n            }\n            else {\n                segmentChanges.next = context.candidateSegment;\n            }\n            return segmentChanges;\n        };\n        // TODO: build tree from segs and insert all at once\n        let insertPos = pos;\n        for (const newSegment of newSegments) {\n            segIsLocal = false;\n            if (newSegment.cachedLength > 0) {\n                newSegment.seq = seq;\n                newSegment.localSeq = localSeq;\n                newSegment.clientId = clientId;\n                if (Marker.is(newSegment)) {\n                    const markerId = newSegment.getId();\n                    if (markerId) {\n                        this.mapIdToSegment(markerId, newSegment);\n                    }\n                }\n                const splitNode = this.insertingWalk(this.root, insertPos, refSeq, clientId, seq, { leaf: onLeaf, candidateSegment: newSegment, continuePredicate: continueFrom });\n                if (newSegment.parent === undefined) {\n                    throw new Error(`MergeTree insert failed: ${JSON.stringify({\n                        currentSeq: this.collabWindow.currentSeq,\n                        minSeq: this.collabWindow.minSeq,\n                        segSeq: newSegment.seq,\n                    })}`);\n                }\n                this.updateRoot(splitNode);\n                saveIfLocal(newSegment);\n                insertPos += newSegment.cachedLength;\n            }\n        }\n    }\n    ensureIntervalBoundary(pos, refSeq, clientId) {\n        const splitNode = this.insertingWalk(this.root, pos, refSeq, clientId, TreeMaintenanceSequenceNumber, { leaf: this.splitLeafSegment });\n        this.updateRoot(splitNode);\n    }\n    // Assume called only when pos == len\n    breakTie(pos, len, node, refSeq, clientId, candidateSegment) {\n        if (node.isLeaf()) {\n            if (pos === 0) {\n                const segment = node;\n                const removalInfo = this.getRemovalInfo(segment);\n                if (removalInfo.removedSeq\n                    && removalInfo.removedSeq <= refSeq\n                    && removalInfo.removedSeq !== UnassignedSequenceNumber) {\n                    return false;\n                }\n                // Local change see everything\n                if (clientId === this.collabWindow.clientId) {\n                    return true;\n                }\n                if (node.seq !== UnassignedSequenceNumber) {\n                    // Ensure we merge right. newer segments should come before older segments\n                    return true;\n                }\n            }\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    // Visit segments starting from node's left siblings, then up to node's parent\n    leftExcursion(node, leafAction) {\n        let go = true;\n        let startNode = node;\n        let parent = startNode.parent;\n        while (parent) {\n            const children = parent.children;\n            let childIndex;\n            let node;\n            let matchedStart = false;\n            for (childIndex = parent.childCount - 1; childIndex >= 0; childIndex--) {\n                node = children[childIndex];\n                if (matchedStart) {\n                    if (!node.isLeaf()) {\n                        const childBlock = node;\n                        go = this.nodeMapReverse(childBlock, leafAction, 0, UniversalSequenceNumber, this.collabWindow.clientId);\n                    }\n                    else {\n                        go = leafAction(node, 0, UniversalSequenceNumber, this.collabWindow.clientId, 0, 0, undefined);\n                    }\n                    if (!go) {\n                        return;\n                    }\n                }\n                else {\n                    matchedStart = (startNode === node);\n                }\n            }\n            startNode = parent;\n            parent = parent.parent;\n        }\n    }\n    // Visit segments starting from node's right siblings, then up to node's parent\n    rightExcursion(node, leafAction) {\n        const actions = { leaf: leafAction };\n        let go = true;\n        let startNode = node;\n        let parent = startNode.parent;\n        while (parent) {\n            const children = parent.children;\n            let childIndex;\n            let node;\n            let matchedStart = false;\n            for (childIndex = 0; childIndex < parent.childCount; childIndex++) {\n                node = children[childIndex];\n                if (matchedStart) {\n                    if (!node.isLeaf()) {\n                        const childBlock = node;\n                        go = this.nodeMap(childBlock, actions, 0, UniversalSequenceNumber, this.collabWindow.clientId, undefined);\n                    }\n                    else {\n                        go = leafAction(node, 0, UniversalSequenceNumber, this.collabWindow.clientId, 0, 0, undefined);\n                    }\n                    if (!go) {\n                        return;\n                    }\n                }\n                else {\n                    matchedStart = (startNode === node);\n                }\n            }\n            startNode = parent;\n            parent = parent.parent;\n        }\n    }\n    insertingWalk(block, pos, refSeq, clientId, seq, context) {\n        let _pos = pos;\n        const children = block.children;\n        let childIndex;\n        let child;\n        let newNode;\n        let fromSplit;\n        let found = false;\n        for (childIndex = 0; childIndex < block.childCount; childIndex++) {\n            child = children[childIndex];\n            const len = this.nodeLength(child, refSeq, clientId);\n            if (MergeTree.traceTraversal) {\n                let segInfo;\n                if ((!child.isLeaf()) && this.collabWindow.collaborating) {\n                    segInfo = `minLength: ${child.partialLengths.minLength}`;\n                }\n                else {\n                    const segment = child;\n                    segInfo = `cli: ${glc(this, segment.clientId)} seq: ${segment.seq} text: ${segment.toString()}`;\n                    if (segment.removedSeq !== undefined) {\n                        segInfo += ` rcli: ${glc(this, segment.removedClientId)} rseq: ${segment.removedSeq}`;\n                    }\n                }\n                console.log(`@tcli: ${glc(this, this.collabWindow.clientId)} len: ${len} pos: ${_pos} ${segInfo}`);\n            }\n            if ((_pos < len) || ((_pos === len) && this.breakTie(_pos, len, child, refSeq, clientId, context.candidateSegment))) {\n                // Found entry containing pos\n                found = true;\n                if (!child.isLeaf()) {\n                    const childBlock = child;\n                    // Internal node\n                    const splitNode = this.insertingWalk(childBlock, _pos, refSeq, clientId, seq, context);\n                    if (splitNode === undefined) {\n                        if (context.structureChange) {\n                            this.nodeUpdateLengthNewStructure(block);\n                        }\n                        else {\n                            this.blockUpdateLength(block, seq, clientId);\n                        }\n                        return undefined;\n                    }\n                    else if (splitNode === MergeTree.theUnfinishedNode) {\n                        if (MergeTree.traceTraversal) {\n                            console.log(`@cli ${glc(this, this.collabWindow.clientId)} unfinished bus pos ${_pos} len ${len}`);\n                        }\n                        _pos -= len; // Act as if shifted segment\n                        continue;\n                    }\n                    else {\n                        newNode = splitNode;\n                        fromSplit = splitNode;\n                        childIndex++; // Insert after\n                    }\n                }\n                else {\n                    if (MergeTree.traceTraversal) {\n                        console.log(`@tcli: ${glc(this, this.collabWindow.clientId)}: leaf action`);\n                    }\n                    const segment = child;\n                    const segmentChanges = context.leaf(segment, _pos, context);\n                    if (segmentChanges.replaceCurrent) {\n                        if (MergeTree.traceOrdinals) {\n                            console.log(`assign from leaf with block ord ${ordinalToArray(block.ordinal)}`);\n                        }\n                        block.assignChild(segmentChanges.replaceCurrent, childIndex, false);\n                        segmentChanges.replaceCurrent.ordinal = child.ordinal;\n                    }\n                    if (segmentChanges.next) {\n                        newNode = segmentChanges.next;\n                        childIndex++; // Insert after\n                    }\n                    else {\n                        // No change\n                        if (context.structureChange) {\n                            this.nodeUpdateLengthNewStructure(block);\n                        }\n                        return undefined;\n                    }\n                }\n                break;\n            }\n            else {\n                _pos -= len;\n            }\n        }\n        if (MergeTree.traceTraversal) {\n            if ((!found) && (_pos > 0)) {\n                console.log(`inserting walk fell through pos ${_pos} len: ${this.blockLength(this.root, refSeq, clientId)}`);\n            }\n        }\n        if (!newNode) {\n            if (_pos === 0) {\n                if ((seq !== UnassignedSequenceNumber) && context.continuePredicate &&\n                    context.continuePredicate(block)) {\n                    return MergeTree.theUnfinishedNode;\n                }\n                else {\n                    if (MergeTree.traceTraversal) {\n                        console.log(`@tcli: ${glc(this, this.collabWindow.clientId)}: leaf action pos 0`);\n                    }\n                    const segmentChanges = context.leaf(undefined, _pos, context);\n                    newNode = segmentChanges.next;\n                    // Assert segmentChanges.replaceCurrent === undefined\n                }\n            }\n        }\n        if (newNode) {\n            for (let i = block.childCount; i > childIndex; i--) {\n                block.children[i] = block.children[i - 1];\n                block.children[i].index = i;\n            }\n            block.assignChild(newNode, childIndex, false);\n            block.childCount++;\n            block.setOrdinal(newNode, childIndex);\n            if (block.childCount < MaxNodesInBlock) {\n                if (fromSplit) {\n                    if (MergeTree.traceOrdinals) {\n                        console.log(`split ord ${ordinalToArray(fromSplit.ordinal)}`);\n                    }\n                    this.nodeUpdateOrdinals(fromSplit);\n                }\n                if (context.structureChange) {\n                    this.nodeUpdateLengthNewStructure(block);\n                }\n                else {\n                    this.blockUpdateLength(block, seq, clientId);\n                }\n                return undefined;\n            }\n            else {\n                // Don't update ordinals because higher block will do it\n                return this.split(block);\n            }\n        }\n        else {\n            return undefined;\n        }\n    }\n    split(node) {\n        const halfCount = MaxNodesInBlock / 2;\n        const newNode = this.makeBlock(halfCount);\n        node.childCount = halfCount;\n        // Update ordinals to reflect lowered child count\n        this.nodeUpdateOrdinals(node);\n        for (let i = 0; i < halfCount; i++) {\n            newNode.assignChild(node.children[halfCount + i], i, false);\n            node.children[halfCount + i] = undefined;\n        }\n        this.nodeUpdateLengthNewStructure(node);\n        this.nodeUpdateLengthNewStructure(newNode);\n        return newNode;\n    }\n    ordinalIntegrity() {\n        console.log(\"chk ordnls\");\n        this.nodeOrdinalIntegrity(this.root);\n    }\n    nodeOrdinalIntegrity(block) {\n        const olen = block.ordinal.length;\n        for (let i = 0; i < block.childCount; i++) {\n            const child = block.children[i];\n            if (child.ordinal) {\n                if (olen !== (child.ordinal.length - 1)) {\n                    console.log(\"node integrity issue\");\n                }\n                if (i > 0) {\n                    if (child.ordinal <= block.children[i - 1].ordinal) {\n                        console.log(\"node sib integrity issue\");\n                        console.log(`??: prnt chld prev ${ordinalToArray(block.ordinal)} ${ordinalToArray(child.ordinal)} ${(i > 0) ? ordinalToArray(block.children[i - 1].ordinal) : \"NA\"}`);\n                    }\n                }\n                if (!child.isLeaf()) {\n                    this.nodeOrdinalIntegrity(child);\n                }\n            }\n            else {\n                console.log(`node child ordinal not set ${i}`);\n                console.log(`??: prnt ${ordinalToArray(block.ordinal)}`);\n            }\n        }\n    }\n    nodeUpdateOrdinals(block) {\n        if (MergeTree.traceOrdinals) {\n            console.log(`update ordinals for children of node with ordinal ${ordinalToArray(block.ordinal)}`);\n        }\n        let clockStart;\n        if (MergeTree.options.measureOrdinalTime) {\n            clockStart = clock();\n        }\n        for (let i = 0; i < block.childCount; i++) {\n            const child = block.children[i];\n            block.setOrdinal(child, i);\n            if (!child.isLeaf()) {\n                this.nodeUpdateOrdinals(child);\n            }\n        }\n        if (clockStart) {\n            const elapsed = elapsedMicroseconds(clockStart);\n            if (elapsed > this.maxOrdTime) {\n                this.maxOrdTime = elapsed;\n            }\n            this.ordTime += elapsed;\n        }\n    }\n    addOverlappingClient(removalInfo, clientId) {\n        if (!removalInfo.removedClientOverlap) {\n            removalInfo.removedClientOverlap = [];\n        }\n        if (MergeTree.diagOverlappingRemove) {\n            console.log(`added cli ${glc(this, clientId)} to rseq: ${removalInfo.removedSeq}`);\n        }\n        removalInfo.removedClientOverlap.push(clientId);\n    }\n    /**\n     * Annotate a range with properties\n     * @param start - The inclusive start postition of the range to annotate\n     * @param end - The exclusive end position of the range to annotate\n     * @param props - The properties to annotate the range with\n     * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n     * @param refSeq - The reference sequence number to use to apply the annotate\n     * @param clientId - The id of the client making the annotate\n     * @param seq - The sequence number of the annotate operation\n     * @param opArgs - The op args for the annotate op. this is passed to the merge tree callback if there is one\n     */\n    annotateRange(start, end, props, combiningOp, refSeq, clientId, seq, opArgs) {\n        this.ensureIntervalBoundary(start, refSeq, clientId);\n        this.ensureIntervalBoundary(end, refSeq, clientId);\n        const deltaSegments = [];\n        const localSeq = seq === UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;\n        let segmentGroup;\n        const annotateSegment = (segment) => {\n            const propertyDeltas = segment.addProperties(props, combiningOp, seq, this.collabWindow);\n            deltaSegments.push({ segment, propertyDeltas });\n            if (this.collabWindow.collaborating) {\n                if (seq === UnassignedSequenceNumber) {\n                    segmentGroup = this.addToPendingList(segment, segmentGroup, localSeq);\n                }\n                else {\n                    if (MergeTree.options.zamboniSegments) {\n                        this.addToLRUSet(segment, seq);\n                    }\n                }\n            }\n            return true;\n        };\n        this.mapRange({ leaf: annotateSegment }, refSeq, clientId, undefined, start, end);\n        // OpArgs == undefined => test code\n        if (this.mergeTreeDeltaCallback) {\n            this.mergeTreeDeltaCallback(opArgs, {\n                operation: 2 /* ANNOTATE */,\n                deltaSegments,\n            });\n        }\n        if (this.collabWindow.collaborating && (seq !== UnassignedSequenceNumber)) {\n            if (MergeTree.options.zamboniSegments) {\n                this.zamboniSegments();\n            }\n        }\n    }\n    markRangeRemoved(start, end, refSeq, clientId, seq, overwrite = false, opArgs) {\n        let _overwrite = overwrite;\n        this.ensureIntervalBoundary(start, refSeq, clientId);\n        this.ensureIntervalBoundary(end, refSeq, clientId);\n        let segmentGroup;\n        const removedSegments = [];\n        const savedLocalRefs = [];\n        const localSeq = seq === UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;\n        const markRemoved = (segment, pos, start, end) => {\n            const removalInfo = this.getRemovalInfo(segment);\n            if (removalInfo.removedSeq !== undefined) {\n                if (MergeTree.diagOverlappingRemove) {\n                    console.log(`yump @seq ${seq} cli ${glc(this, this.collabWindow.clientId)}: overlaps deleted segment ${removalInfo.removedSeq} text '${segment.toString()}'`);\n                }\n                _overwrite = true;\n                if (removalInfo.removedSeq === UnassignedSequenceNumber) {\n                    // replace because comes later\n                    removalInfo.removedClientId = clientId;\n                    removalInfo.removedSeq = seq;\n                    segment.localRemovedSeq = undefined;\n                }\n                else {\n                    // Do not replace earlier sequence number for remove\n                    this.addOverlappingClient(removalInfo, clientId);\n                }\n            }\n            else {\n                removalInfo.removedClientId = clientId;\n                removalInfo.removedSeq = seq;\n                segment.localRemovedSeq = localSeq;\n                removedSegments.push({ segment });\n                if (segment.localRefs && !segment.localRefs.empty) {\n                    savedLocalRefs.push(segment.localRefs);\n                }\n                segment.localRefs = undefined;\n            }\n            // Save segment so can assign removed sequence number when acked by server\n            if (this.collabWindow.collaborating) {\n                // Use removal information\n                const removalInfo = this.getRemovalInfo(segment);\n                if ((removalInfo.removedSeq === UnassignedSequenceNumber) && (clientId === this.collabWindow.clientId)) {\n                    segmentGroup = this.addToPendingList(segment, segmentGroup, localSeq);\n                }\n                else {\n                    if (MergeTree.options.zamboniSegments) {\n                        this.addToLRUSet(segment, seq);\n                    }\n                }\n                // console.log(`saved local removed seg with text: ${textSegment.text}`);\n            }\n            return true;\n        };\n        const afterMarkRemoved = (node, pos, start, end) => {\n            if (_overwrite) {\n                this.nodeUpdateLengthNewStructure(node);\n            }\n            else {\n                this.blockUpdateLength(node, seq, clientId);\n            }\n            return true;\n        };\n        // MergeTree.traceTraversal = true;\n        this.mapRange({ leaf: markRemoved, post: afterMarkRemoved }, refSeq, clientId, undefined, start, end);\n        if (savedLocalRefs.length > 0) {\n            const length = this.getLength(refSeq, clientId);\n            let refSegment;\n            if (start < length) {\n                const afterSegOff = this.getContainingSegment(start, refSeq, clientId);\n                refSegment = afterSegOff.segment;\n                assert(!!refSegment, 0x052 /* \"Missing reference segment!\" */);\n                if (!refSegment.localRefs) {\n                    refSegment.localRefs = new LocalReferenceCollection(refSegment);\n                }\n                refSegment.localRefs.addBeforeTombstones(...savedLocalRefs);\n            }\n            else if (length > 0) {\n                const beforeSegOff = this.getContainingSegment(length - 1, refSeq, clientId);\n                refSegment = beforeSegOff.segment;\n                assert(!!refSegment, 0x053 /* \"Missing reference segment!\" */);\n                if (!refSegment.localRefs) {\n                    refSegment.localRefs = new LocalReferenceCollection(refSegment);\n                }\n                refSegment.localRefs.addAfterTombstones(...savedLocalRefs);\n            }\n            else {\n                // TODO: The tree is empty, so there isn't anywhere to put these\n                // they should be preserved somehow\n                for (const refsCollection of savedLocalRefs) {\n                    refsCollection.clear();\n                }\n            }\n            if (refSegment) {\n                this.blockUpdatePathLengths(refSegment.parent, TreeMaintenanceSequenceNumber, LocalClientId);\n            }\n        }\n        // opArgs == undefined => test code\n        if (this.mergeTreeDeltaCallback) {\n            this.mergeTreeDeltaCallback(opArgs, {\n                operation: 1 /* REMOVE */,\n                deltaSegments: removedSegments,\n            });\n        }\n        if (this.collabWindow.collaborating && (seq !== UnassignedSequenceNumber)) {\n            if (MergeTree.options.zamboniSegments) {\n                this.zamboniSegments();\n            }\n        }\n        // MergeTree.traceTraversal = false;\n    }\n    nodeUpdateLengthNewStructure(node, recur = false) {\n        this.blockUpdate(node);\n        if (this.collabWindow.collaborating) {\n            node.partialLengths = PartialSequenceLengths.combine(this, node, this.collabWindow, recur);\n        }\n    }\n    removeLocalReference(segment, lref) {\n        if (segment.localRefs) {\n            const removedRef = segment.localRefs.removeLocalRef(lref);\n            if (removedRef) {\n                this.blockUpdatePathLengths(segment.parent, TreeMaintenanceSequenceNumber, LocalClientId);\n            }\n        }\n    }\n    addLocalReference(lref) {\n        const segment = lref.segment;\n        let localRefs = segment.localRefs;\n        if (!localRefs) {\n            localRefs = new LocalReferenceCollection(segment);\n            segment.localRefs = localRefs;\n        }\n        localRefs.addLocalRef(lref);\n        this.blockUpdatePathLengths(segment.parent, TreeMaintenanceSequenceNumber, LocalClientId);\n    }\n    blockUpdate(block) {\n        let len = 0;\n        const hierBlock = block.hierBlock();\n        if (hierBlock) {\n            hierBlock.rightmostTiles = Properties.createMap();\n            hierBlock.leftmostTiles = Properties.createMap();\n            hierBlock.rangeStacks = {};\n        }\n        for (let i = 0; i < block.childCount; i++) {\n            const child = block.children[i];\n            len += nodeTotalLength(this, child);\n            if (hierBlock) {\n                hierBlock.addNodeReferences(this, child);\n            }\n            if (this.blockUpdateActions) {\n                this.blockUpdateActions.child(block, i);\n            }\n        }\n        block.cachedLength = len;\n    }\n    blockUpdatePathLengths(startBlock, seq, clientId, newStructure = false) {\n        let block = startBlock;\n        while (block !== undefined) {\n            if (newStructure) {\n                this.nodeUpdateLengthNewStructure(block);\n            }\n            else {\n                this.blockUpdateLength(block, seq, clientId);\n            }\n            block = block.parent;\n        }\n    }\n    blockUpdateLength(node, seq, clientId) {\n        this.blockUpdate(node);\n        if (this.collabWindow.collaborating && (seq !== UnassignedSequenceNumber) && (seq !== TreeMaintenanceSequenceNumber)) {\n            if (node.partialLengths !== undefined && MergeTree.options.incrementalUpdate && clientId !== NonCollabClient) {\n                node.partialLengths.update(this, node, seq, clientId, this.collabWindow);\n            }\n            else {\n                node.partialLengths = PartialSequenceLengths.combine(this, node, this.collabWindow);\n            }\n        }\n    }\n    map(actions, refSeq, clientId, accum) {\n        // TODO: optimize to avoid comparisons\n        this.nodeMap(this.root, actions, 0, refSeq, clientId, accum);\n    }\n    mapRange(actions, refSeq, clientId, accum, start, end, splitRange = false) {\n        if (splitRange) {\n            if (start) {\n                this.ensureIntervalBoundary(start, refSeq, clientId);\n            }\n            if (end) {\n                this.ensureIntervalBoundary(end, refSeq, clientId);\n            }\n        }\n        this.nodeMap(this.root, actions, 0, refSeq, clientId, accum, start, end);\n    }\n    nodeToString(block, strbuf, indentCount = 0) {\n        let _strbuf = strbuf;\n        _strbuf += internedSpaces(indentCount);\n        _strbuf += `Node (len ${block.cachedLength}) p len (${block.parent ? block.parent.cachedLength : 0}) ord ${ordinalToArray(block.ordinal)} with ${block.childCount} segs:\\n`;\n        if (MergeTree.blockUpdateMarkers) {\n            _strbuf += internedSpaces(indentCount);\n            _strbuf += block.hierToString(indentCount);\n        }\n        if (this.collabWindow.collaborating) {\n            _strbuf += internedSpaces(indentCount);\n            _strbuf += `${block.partialLengths.toString((id) => glc(this, id), indentCount)}\\n`;\n        }\n        const children = block.children;\n        for (let childIndex = 0; childIndex < block.childCount; childIndex++) {\n            const child = children[childIndex];\n            if (!child.isLeaf()) {\n                _strbuf = this.nodeToString(child, _strbuf, indentCount + 4);\n            }\n            else {\n                const segment = child;\n                _strbuf += internedSpaces(indentCount + 4);\n                _strbuf += `cli: ${glc(this, segment.clientId)} seq: ${segment.seq} ord: ${ordinalToArray(segment.ordinal)}`;\n                const removalInfo = this.getRemovalInfo(segment);\n                if (removalInfo.removedSeq !== undefined) {\n                    _strbuf += ` rcli: ${glc(this, removalInfo.removedClientId)} rseq: ${removalInfo.removedSeq}`;\n                }\n                _strbuf += \"\\n\";\n                _strbuf += internedSpaces(indentCount + 4);\n                _strbuf += segment.toString();\n                _strbuf += \"\\n\";\n            }\n        }\n        return _strbuf;\n    }\n    toString() {\n        return this.nodeToString(this.root, \"\", 0);\n    }\n    incrementalBlockMap(stateStack) {\n        while (!stateStack.empty()) {\n            // We already check the stack is not empty\n            const state = stateStack.top();\n            if (state.op !== IncrementalExecOp.Go) {\n                return;\n            }\n            if (state.childIndex === 0) {\n                if (state.start === undefined) {\n                    state.start = 0;\n                }\n                if (state.end === undefined) {\n                    state.end = this.blockLength(state.block, state.refSeq, state.clientId);\n                }\n                if (state.actions.pre) {\n                    state.actions.pre(state);\n                }\n            }\n            if ((state.op === IncrementalExecOp.Go) && (state.childIndex < state.block.childCount)) {\n                const child = state.block.children[state.childIndex];\n                const len = this.nodeLength(child, state.refSeq, state.clientId);\n                if (MergeTree.traceIncrTraversal) {\n                    if (child.isLeaf()) {\n                        // eslint-disable-next-line @typescript-eslint/dot-notation\n                        console.log(`considering (r ${state.refSeq} c ${glc(this, state.clientId)}) seg with text ${child[\"text\"]} len ${len} seq ${child.seq} rseq ${child.removedSeq} cli ${glc(this, child.clientId)}`);\n                    }\n                }\n                if ((len > 0) && (state.start < len) && (state.end > 0)) {\n                    if (!child.isLeaf()) {\n                        const childState = new IncrementalMapState(child, state.actions, state.pos, state.refSeq, state.clientId, state.context, state.start, state.end, 0);\n                        stateStack.push(childState);\n                    }\n                    else {\n                        if (MergeTree.traceIncrTraversal) {\n                            // eslint-disable-next-line @typescript-eslint/dot-notation\n                            console.log(`action on seg with text ${child[\"text\"]}`);\n                        }\n                        state.actions.leaf(child, state);\n                    }\n                }\n                state.pos += len;\n                state.start -= len;\n                state.end -= len;\n                state.childIndex++;\n            }\n            else {\n                if (state.childIndex === state.block.childCount) {\n                    if ((state.op === IncrementalExecOp.Go) && state.actions.post) {\n                        state.actions.post(state);\n                    }\n                    stateStack.pop();\n                }\n            }\n        }\n    }\n    nodeMap(node, actions, pos, refSeq, clientId, accum, start, end) {\n        let _start = start;\n        let _end = end;\n        let _pos = pos;\n        if (_start === undefined) {\n            _start = 0;\n        }\n        if (_end === undefined) {\n            _end = this.blockLength(node, refSeq, clientId);\n        }\n        let go = true;\n        if (actions.pre) {\n            go = actions.pre(node, _pos, refSeq, clientId, _start, _end, accum);\n            if (!go) {\n                // Cancel this node but not entire traversal\n                return true;\n            }\n        }\n        const children = node.children;\n        for (let childIndex = 0; childIndex < node.childCount; childIndex++) {\n            const child = children[childIndex];\n            const len = this.nodeLength(child, refSeq, clientId);\n            if (MergeTree.traceTraversal) {\n                let segInfo;\n                if ((!child.isLeaf()) && this.collabWindow.collaborating) {\n                    segInfo = `minLength: ${child.partialLengths.minLength}`;\n                }\n                else {\n                    const segment = child;\n                    segInfo = `cli: ${glc(this, segment.clientId)} seq: ${segment.seq} text: '${segment.toString()}'`;\n                    if (segment.removedSeq !== undefined) {\n                        segInfo += ` rcli: ${glc(this, segment.removedClientId)} rseq: ${segment.removedSeq}`;\n                    }\n                }\n                console.log(`@tcli ${glc(this, this.collabWindow.clientId)}: map len: ${len} start: ${_start} end: ${_end} ${segInfo}`);\n            }\n            if (go && (_end > 0) && (len > 0) && (_start < len)) {\n                // Found entry containing pos\n                if (!child.isLeaf()) {\n                    if (go) {\n                        go = this.nodeMap(child, actions, _pos, refSeq, clientId, accum, _start, _end);\n                    }\n                }\n                else {\n                    if (MergeTree.traceTraversal) {\n                        console.log(`@tcli ${glc(this, this.collabWindow.clientId)}: map leaf action`);\n                    }\n                    if (actions.leaf) {\n                        go = actions.leaf(child, _pos, refSeq, clientId, _start, _end, accum);\n                    }\n                }\n            }\n            if (!go) {\n                break;\n            }\n            if (actions.shift) {\n                actions.shift(child, _pos, refSeq, clientId, _start, _end, accum);\n            }\n            _pos += len;\n            _start -= len;\n            _end -= len;\n        }\n        if (go && actions.post) {\n            go = actions.post(node, _pos, refSeq, clientId, _start, _end, accum);\n        }\n        return go;\n    }\n    // Invokes the leaf action for all segments.  Note that *all* segments are visited\n    // regardless of if they would be visible to the current `clientId` and `refSeq`.\n    walkAllSegments(block, action, accum) {\n        let go = true;\n        const children = block.children;\n        for (let childIndex = 0; go && childIndex < block.childCount; childIndex++) {\n            const child = children[childIndex];\n            go = child.isLeaf()\n                ? action(child, accum)\n                : this.walkAllSegments(child, action, accum);\n        }\n        return go;\n    }\n    // Straight call every segment; goes until leaf action returns false\n    nodeMapReverse(block, leafAction, pos, refSeq, clientId) {\n        let go = true;\n        const children = block.children;\n        for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {\n            const child = children[childIndex];\n            if (go) {\n                // Found entry containing pos\n                if (!child.isLeaf()) {\n                    if (go) {\n                        go = this.nodeMapReverse(child, leafAction, pos, refSeq, clientId);\n                    }\n                }\n                else {\n                    go = leafAction(child, pos, refSeq, clientId, 0, 0, undefined);\n                }\n            }\n            if (!go) {\n                break;\n            }\n        }\n        return go;\n    }\n}\n// Maximum length of text segment to be considered to be merged with other segment.\n// Maximum segment length is at least 2x of it (not taking into account initial segment creation).\n// The bigger it is, the more expensive it is to break segment into sub-segments (on edits)\n// The smaller it is, the more segments we have in snapshots (and in memory) - it's more expensive to load snapshots.\n// Small number also makes ReplayTool produce false positives (\"same\" snapshots have slightly different binary representations).\n// More measurements needs to be done, but it's very likely the right spot is somewhere between 1K-2K mark.\n// That said, we also break segments on newline and there are very few segments that are longer than 256 because of it.\n// must be an even number\nMergeTree.TextSegmentGranularity = 256;\nMergeTree.zamboniSegmentsMaxCount = 2;\nMergeTree.options = {\n    incrementalUpdate: true,\n    insertAfterRemovedSegs: true,\n    measureOrdinalTime: true,\n    measureWindowTime: true,\n    zamboniSegments: true,\n};\nMergeTree.traceAppend = false;\nMergeTree.traceZRemove = false;\nMergeTree.traceOrdinals = false;\nMergeTree.traceGatherText = false;\nMergeTree.diagInsertTie = false;\nMergeTree.skipLeftShift = true;\nMergeTree.diagOverlappingRemove = false;\nMergeTree.traceTraversal = false;\nMergeTree.traceIncrTraversal = false;\nMergeTree.theUnfinishedNode = { childCount: -1 };\n// WARNING:\n// Setting blockUpdateMarkers to false will result in eventual consistency issues\n// for property updates on markers when loading from snapshots\nMergeTree.blockUpdateMarkers = true;\n//# sourceMappingURL=mergeTree.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { SortedSegmentSet } from \"./sortedSegmentSet\";\nexport class TrackingGroup {\n    constructor() {\n        this.segmentSet = new SortedSegmentSet();\n    }\n    get segments() {\n        return this.segmentSet.items;\n    }\n    get size() {\n        return this.segmentSet.size;\n    }\n    has(segment) {\n        return this.segmentSet.has(segment);\n    }\n    link(segment) {\n        if (!this.segmentSet.has(segment)) {\n            this.segmentSet.addOrUpdate(segment);\n            segment.trackingCollection.link(this);\n        }\n    }\n    unlink(segment) {\n        if (this.segmentSet.remove(segment)) {\n            segment.trackingCollection.unlink(this);\n        }\n    }\n}\nexport class TrackingGroupCollection {\n    constructor(segment) {\n        this.segment = segment;\n        this.trackingGroups = new Set();\n    }\n    link(trackingGroup) {\n        if (trackingGroup) {\n            if (!this.trackingGroups.has(trackingGroup)) {\n                this.trackingGroups.add(trackingGroup);\n            }\n            if (!trackingGroup.has(this.segment)) {\n                trackingGroup.link(this.segment);\n            }\n        }\n    }\n    unlink(trackingGroup) {\n        if (trackingGroup.has(this.segment)) {\n            trackingGroup.unlink(this.segment);\n        }\n        this.trackingGroups.delete(trackingGroup);\n    }\n    copyTo(segment) {\n        this.trackingGroups.forEach((sg) => segment.trackingCollection.link(sg));\n    }\n    get empty() {\n        return this.trackingGroups.size === 0;\n    }\n    matches(trackingCollection) {\n        if (!trackingCollection\n            || this.trackingGroups.size !== trackingCollection.trackingGroups.size) {\n            return false;\n        }\n        for (const tg of this.trackingGroups.values()) {\n            if (!trackingCollection.trackingGroups.has(tg)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=mergeTreeTracking.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Creates the op for annotating the markers with the provided properties\n * @param marker - The marker to annotate\n * @param props - The properties to annotate the marker with\n * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n * @returns The annotate op\n */\nexport function createAnnotateMarkerOp(marker, props, combiningOp) {\n    const id = marker.getId();\n    if (!id) {\n        return undefined;\n    }\n    return {\n        combiningOp,\n        props,\n        relativePos1: { id, before: true },\n        relativePos2: { id },\n        type: 2 /* ANNOTATE */,\n    };\n}\n/**\n * Creates the op for annotating the range with the provided properties\n * @param start - The inclusive start postition of the range to annotate\n * @param end - The exclusive end position of the range to annotate\n * @param props - The properties to annotate the range with\n * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n * @returns The annotate op\n */\nexport function createAnnotateRangeOp(start, end, props, combiningOp) {\n    return {\n        combiningOp,\n        pos1: start,\n        pos2: end,\n        props,\n        type: 2 /* ANNOTATE */,\n    };\n}\n/**\n * Creates the op to remove a range and puts the content of the removed range in a register\n * if a register name is provided\n *\n * @param start - The inclusive start of the range to remove\n * @param end - The exclusive end of the range to remove\n * @param register - Optional. The name of the register to store the removed range in\n */\nexport function createRemoveRangeOp(start, end, register) {\n    return {\n        pos1: start,\n        pos2: end,\n        register,\n        type: 1 /* REMOVE */,\n    };\n}\n/**\n *\n * @param pos - The position to insert the segment at\n * @param segment - The segment to insert\n */\nexport function createInsertSegmentOp(pos, segment) {\n    return createInsertOp(pos, segment.toJSONObject());\n}\nexport function createInsertOp(pos, segSpec) {\n    return {\n        pos1: pos,\n        seg: segSpec,\n        type: 0 /* INSERT */,\n    };\n}\n/**\n *\n * @param pos - The position to insert the register contents at\n * @param register - The name of the register to insert the value of\n */\nexport function createInsertFromRegisterOp(pos, register) {\n    return {\n        pos1: pos,\n        register,\n        type: 0 /* INSERT */,\n    };\n}\n/**\n *\n * @param start - The inclusive start of the range to insert into the register\n * @param end - The exclusive end of the range to insert into the register\n * @param register - The name of the register to insert the range contents into\n */\nexport function createInsertToRegisterOp(start, end, register) {\n    return {\n        pos1: start,\n        pos2: end,\n        register,\n        type: 0 /* INSERT */,\n    };\n}\n/**\n *\n * @param ops - The ops to group\n */\nexport function createGroupOp(...ops) {\n    return {\n        ops,\n        type: 3 /* GROUP */,\n    };\n}\n//# sourceMappingURL=opBuilder.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nexport var ReferenceType;\n(function (ReferenceType) {\n    ReferenceType[ReferenceType[\"Simple\"] = 0] = \"Simple\";\n    ReferenceType[ReferenceType[\"Tile\"] = 1] = \"Tile\";\n    ReferenceType[ReferenceType[\"NestBegin\"] = 2] = \"NestBegin\";\n    ReferenceType[ReferenceType[\"NestEnd\"] = 4] = \"NestEnd\";\n    ReferenceType[ReferenceType[\"RangeBegin\"] = 16] = \"RangeBegin\";\n    ReferenceType[ReferenceType[\"RangeEnd\"] = 32] = \"RangeEnd\";\n    ReferenceType[ReferenceType[\"SlideOnRemove\"] = 64] = \"SlideOnRemove\";\n    ReferenceType[ReferenceType[\"Transient\"] = 256] = \"Transient\";\n})(ReferenceType || (ReferenceType = {}));\nexport var IntervalType;\n(function (IntervalType) {\n    IntervalType[IntervalType[\"Simple\"] = 0] = \"Simple\";\n    IntervalType[IntervalType[\"Nest\"] = 1] = \"Nest\";\n    IntervalType[IntervalType[\"SlideOnRemove\"] = 2] = \"SlideOnRemove\";\n    IntervalType[IntervalType[\"Transient\"] = 4] = \"Transient\";\n})(IntervalType || (IntervalType = {}));\n// Note: Assigned positive integers to avoid clashing with MergeTreeMaintenanceType\nexport var MergeTreeDeltaType;\n(function (MergeTreeDeltaType) {\n    MergeTreeDeltaType[MergeTreeDeltaType[\"INSERT\"] = 0] = \"INSERT\";\n    MergeTreeDeltaType[MergeTreeDeltaType[\"REMOVE\"] = 1] = \"REMOVE\";\n    MergeTreeDeltaType[MergeTreeDeltaType[\"ANNOTATE\"] = 2] = \"ANNOTATE\";\n    MergeTreeDeltaType[MergeTreeDeltaType[\"GROUP\"] = 3] = \"GROUP\";\n})(MergeTreeDeltaType || (MergeTreeDeltaType = {}));\n//# sourceMappingURL=ops.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { RedBlackTree } from \"./collections\";\nimport { UnassignedSequenceNumber } from \"./constants\";\nimport { compareNumbers, } from \"./mergeTree\";\n/**\n * Returns the partial length whose sequence number is\n * the greatest sequence number within a that is\n * less than or equal to key.\n * @param a - array of partial segment lengths\n * @param key - sequence number\n */\nfunction latestLEQ(a, key) {\n    let best = -1;\n    let lo = 0;\n    let hi = a.length - 1;\n    while (lo <= hi) {\n        const mid = lo + Math.floor((hi - lo) / 2);\n        if (a[mid].seq <= key) {\n            if ((best < 0) || (a[best].seq < a[mid].seq)) {\n                best = mid;\n            }\n            lo = mid + 1;\n        }\n        else {\n            hi = mid - 1;\n        }\n    }\n    return best;\n}\n/**\n * Keep track of partial sums of segment lengths for all sequence numbers\n * in the current collaboration window (if any).  Only used during active\n * collaboration.\n */\nexport class PartialSequenceLengths {\n    constructor(minSeq) {\n        this.minSeq = minSeq;\n        this.minLength = 0;\n        this.segmentCount = 0;\n        this.partialLengths = [];\n        this.clientSeqNumbers = [];\n    }\n    static combine(mergeTree, block, collabWindow, recur = false) {\n        return PartialSequenceLengths.combineBranch(mergeTree, block, collabWindow, recur);\n    }\n    /**\n     * Combine the partial lengths of block's children\n     * @param block - an interior node; it is assumed that each interior node child of this block\n     * has its partials up to date\n     * @param collabWindow - segment window of the segment tree containing textSegmentBlock\n     */\n    static combineBranch(mergeTree, block, collabWindow, recur = false) {\n        let combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);\n        PartialSequenceLengths.fromLeaves(mergeTree, combinedPartialLengths, block, collabWindow);\n        let prevPartial;\n        function cloneOverlapRemoveClients(oldTree) {\n            if (!oldTree) {\n                return undefined;\n            }\n            const newTree = new RedBlackTree(compareNumbers);\n            oldTree.map((bProp) => {\n                newTree.put(bProp.data.clientId, Object.assign({}, bProp.data));\n                return true;\n            });\n            return newTree;\n        }\n        function combineOverlapClients(a, b) {\n            const overlapRemoveClientsA = a.overlapRemoveClients;\n            if (overlapRemoveClientsA) {\n                if (b.overlapRemoveClients) {\n                    b.overlapRemoveClients.map((bProp) => {\n                        const aProp = overlapRemoveClientsA.get(bProp.key);\n                        if (aProp) {\n                            aProp.data.seglen += bProp.data.seglen;\n                        }\n                        else {\n                            overlapRemoveClientsA.put(bProp.data.clientId, Object.assign({}, bProp.data));\n                        }\n                        return true;\n                    });\n                }\n            }\n            else {\n                a.overlapRemoveClients = cloneOverlapRemoveClients(b.overlapRemoveClients);\n            }\n        }\n        function addNext(partialLength) {\n            const seq = partialLength.seq;\n            let pLen = 0;\n            if (prevPartial) {\n                if (prevPartial.seq === partialLength.seq) {\n                    prevPartial.seglen += partialLength.seglen;\n                    prevPartial.len += partialLength.seglen;\n                    combineOverlapClients(prevPartial, partialLength);\n                    return;\n                }\n                else {\n                    pLen = prevPartial.len;\n                    // Previous sequence number is finished\n                    combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);\n                }\n            }\n            prevPartial = {\n                clientId: partialLength.clientId,\n                len: pLen + partialLength.seglen,\n                overlapRemoveClients: cloneOverlapRemoveClients(partialLength.overlapRemoveClients),\n                seglen: partialLength.seglen,\n                seq,\n            };\n            combinedPartialLengths.partialLengths.push(prevPartial);\n        }\n        const childPartials = [];\n        for (let i = 0; i < block.childCount; i++) {\n            const child = block.children[i];\n            if (!child.isLeaf()) {\n                const childBlock = child;\n                if (recur) {\n                    childBlock.partialLengths =\n                        PartialSequenceLengths.combine(mergeTree, childBlock, collabWindow, true);\n                }\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                childPartials.push(childBlock.partialLengths);\n            }\n        }\n        let childPartialsLen = childPartials.length;\n        if (childPartialsLen !== 0) {\n            // Some children are interior nodes\n            if (combinedPartialLengths.partialLengths.length > 0) {\n                // Some children were leaves; add combined partials from these segments\n                childPartials.push(combinedPartialLengths);\n                childPartialsLen++;\n                combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);\n            }\n            const indices = new Array(childPartialsLen);\n            const childPartialsCounts = new Array(childPartialsLen);\n            for (let i = 0; i < childPartialsLen; i++) {\n                indices[i] = 0;\n                childPartialsCounts[i] = childPartials[i].partialLengths.length;\n                combinedPartialLengths.minLength += childPartials[i].minLength;\n                combinedPartialLengths.segmentCount += childPartials[i].segmentCount;\n            }\n            let outerIndexOfEarliest = 0;\n            let earliestPartialLength;\n            while (outerIndexOfEarliest >= 0) {\n                outerIndexOfEarliest = -1;\n                for (let k = 0; k < childPartialsLen; k++) {\n                    // Find next earliest sequence number\n                    if (indices[k] < childPartialsCounts[k]) {\n                        const cpLen = childPartials[k].partialLengths[indices[k]];\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        if ((outerIndexOfEarliest < 0) || (cpLen.seq < earliestPartialLength.seq)) {\n                            outerIndexOfEarliest = k;\n                            earliestPartialLength = cpLen;\n                        }\n                    }\n                }\n                if (outerIndexOfEarliest >= 0) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    addNext(earliestPartialLength);\n                    indices[outerIndexOfEarliest]++;\n                }\n            }\n            // Add client entry for last partial, if any\n            if (prevPartial) {\n                combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);\n            }\n        }\n        // TODO: incremental zamboni during build\n        // console.log(combinedPartialLengths.toString());\n        // console.log(`ZZZ...(min ${segmentWindow.minSeq})`);\n        if (PartialSequenceLengths.options.zamboni) {\n            combinedPartialLengths.zamboni(collabWindow);\n        }\n        if (PartialSequenceLengths.options.verify) {\n            combinedPartialLengths.verify();\n        }\n        // console.log(combinedPartialLengths.toString());\n        return combinedPartialLengths;\n    }\n    static fromLeaves(mergeTree, combinedPartialLengths, block, collabWindow) {\n        combinedPartialLengths.minLength = 0;\n        combinedPartialLengths.segmentCount = block.childCount;\n        function seqLTE(seq, minSeq) {\n            return (seq !== UnassignedSequenceNumber) && (seq <= minSeq);\n        }\n        for (let i = 0; i < block.childCount; i++) {\n            const child = block.children[i];\n            if (child.isLeaf()) {\n                // Leaf segment\n                const segment = child;\n                // eslint-disable-next-line max-len\n                // console.log(`seg br ${segBranchId} cli ${glc(mergeTree, segment.clientId)} me ${glc(mergeTree, mergeTree.collabWindow.clientId)}`);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                if (seqLTE(segment.seq, collabWindow.minSeq)) {\n                    combinedPartialLengths.minLength += segment.cachedLength;\n                }\n                else {\n                    if (segment.seq !== UnassignedSequenceNumber) {\n                        PartialSequenceLengths.insertSegment(combinedPartialLengths, segment);\n                    }\n                }\n                const removalInfo = mergeTree.getRemovalInfo(segment);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                if (seqLTE(removalInfo.removedSeq, collabWindow.minSeq)) {\n                    combinedPartialLengths.minLength -= segment.cachedLength;\n                }\n                else {\n                    if ((removalInfo.removedSeq !== undefined) &&\n                        (removalInfo.removedSeq !== UnassignedSequenceNumber)) {\n                        PartialSequenceLengths.insertSegment(combinedPartialLengths, segment, removalInfo);\n                    }\n                }\n            }\n        }\n        // Post-process correctly-ordered partials computing sums and creating\n        // lists for each present client id\n        const seqPartials = combinedPartialLengths.partialLengths;\n        const seqPartialsLen = seqPartials.length;\n        let prevLen = 0;\n        for (let i = 0; i < seqPartialsLen; i++) {\n            seqPartials[i].len = prevLen + seqPartials[i].seglen;\n            prevLen = seqPartials[i].len;\n            combinedPartialLengths.addClientSeqNumberFromPartial(seqPartials[i]);\n        }\n        if (PartialSequenceLengths.options.verify) {\n            combinedPartialLengths.verify();\n        }\n    }\n    static getOverlapClients(overlapClientids, seglen) {\n        const bst = new RedBlackTree(compareNumbers);\n        for (const clientId of overlapClientids) {\n            bst.put(clientId, { clientId, seglen });\n        }\n        return bst;\n    }\n    static accumulateRemoveClientOverlap(partialLength, overlapRemoveClientIds, seglen) {\n        if (partialLength.overlapRemoveClients) {\n            for (const clientId of overlapRemoveClientIds) {\n                const ovlapClientNode = partialLength.overlapRemoveClients.get(clientId);\n                if (!ovlapClientNode) {\n                    partialLength.overlapRemoveClients.put(clientId, { clientId, seglen });\n                }\n                else {\n                    ovlapClientNode.data.seglen += seglen;\n                }\n            }\n        }\n        else {\n            partialLength.overlapRemoveClients =\n                PartialSequenceLengths.getOverlapClients(overlapRemoveClientIds, seglen);\n        }\n    }\n    static insertSegment(combinedPartialLengths, segment, removalInfo) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        let seq = segment.seq;\n        let segmentLen = segment.cachedLength;\n        let clientId = segment.clientId;\n        let removeClientOverlap;\n        if (removalInfo) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            seq = removalInfo.removedSeq;\n            segmentLen = -segmentLen;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            clientId = removalInfo.removedClientId;\n            if (removalInfo.removedClientOverlap) {\n                removeClientOverlap = removalInfo.removedClientOverlap;\n            }\n        }\n        const seqPartials = combinedPartialLengths.partialLengths;\n        const seqPartialsLen = seqPartials.length;\n        // Find the first entry with sequence number greater or equal to seq\n        let indexFirstGTE = 0;\n        for (; indexFirstGTE < seqPartialsLen; indexFirstGTE++) {\n            if (seqPartials[indexFirstGTE].seq >= seq) {\n                break;\n            }\n        }\n        if ((indexFirstGTE < seqPartialsLen) && (seqPartials[indexFirstGTE].seq === seq)) {\n            seqPartials[indexFirstGTE].seglen += segmentLen;\n            if (removeClientOverlap) {\n                PartialSequenceLengths.accumulateRemoveClientOverlap(seqPartials[indexFirstGTE], removeClientOverlap, segmentLen);\n            }\n        }\n        else {\n            let pLen;\n            if (removeClientOverlap) {\n                const overlapClients = PartialSequenceLengths.getOverlapClients(removeClientOverlap, segmentLen);\n                pLen = { seq, clientId, len: 0, seglen: segmentLen, overlapRemoveClients: overlapClients };\n            }\n            else {\n                pLen = { seq, clientId, len: 0, seglen: segmentLen };\n            }\n            if (indexFirstGTE < seqPartialsLen) {\n                // Shift entries with greater sequence numbers\n                // TODO: investigate performance improvement using BST\n                for (let k = seqPartialsLen; k > indexFirstGTE; k--) {\n                    seqPartials[k] = seqPartials[k - 1];\n                }\n                seqPartials[indexFirstGTE] = pLen;\n            }\n            else {\n                seqPartials.push(pLen);\n            }\n        }\n    }\n    static addSeq(partialLengths, seq, seqSeglen, clientId) {\n        let seqPartialLen;\n        let penultPartialLen;\n        let leqIndex = latestLEQ(partialLengths, seq);\n        if (leqIndex >= 0) {\n            const pLen = partialLengths[leqIndex];\n            if (pLen.seq === seq) {\n                seqPartialLen = pLen;\n                leqIndex = latestLEQ(partialLengths, seq - 1);\n                if (leqIndex >= 0) {\n                    penultPartialLen = partialLengths[leqIndex];\n                }\n            }\n            else {\n                penultPartialLen = pLen;\n            }\n        }\n        if (seqPartialLen === undefined) {\n            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n            seqPartialLen = {\n                clientId,\n                seglen: seqSeglen,\n                seq,\n            };\n            partialLengths.push(seqPartialLen);\n        }\n        else {\n            seqPartialLen.seglen = seqSeglen;\n            // Assert client id matches\n        }\n        if (penultPartialLen !== undefined) {\n            seqPartialLen.len = seqPartialLen.seglen + penultPartialLen.len;\n        }\n        else {\n            seqPartialLen.len = seqPartialLen.seglen;\n        }\n    }\n    // Assume: seq is latest sequence number; no structural change to sub-tree, but a segment\n    // with sequence number seq has been added within the sub-tree\n    // TODO: assert client id matches\n    update(mergeTree, node, seq, clientId, collabWindow) {\n        let seqSeglen = 0;\n        let segCount = 0;\n        // Compute length for seq across children\n        for (let i = 0; i < node.childCount; i++) {\n            const child = node.children[i];\n            if (!child.isLeaf()) {\n                const childBlock = child;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const branchPartialLengths = childBlock.partialLengths;\n                const partialLengths = branchPartialLengths.partialLengths;\n                const seqIndex = latestLEQ(partialLengths, seq);\n                if (seqIndex >= 0) {\n                    const leqPartial = partialLengths[seqIndex];\n                    if (leqPartial.seq === seq) {\n                        seqSeglen += leqPartial.seglen;\n                    }\n                }\n                segCount += branchPartialLengths.segmentCount;\n            }\n            else {\n                const segment = child;\n                const removalInfo = mergeTree.getRemovalInfo(segment);\n                if (segment.seq === seq) {\n                    if (removalInfo.removedSeq !== seq) {\n                        seqSeglen += segment.cachedLength;\n                    }\n                }\n                else {\n                    if (removalInfo.removedSeq === seq) {\n                        seqSeglen -= segment.cachedLength;\n                    }\n                }\n                segCount++;\n            }\n        }\n        this.segmentCount = segCount;\n        PartialSequenceLengths.addSeq(this.partialLengths, seq, seqSeglen, clientId);\n        if (this.clientSeqNumbers[clientId] === undefined) {\n            this.clientSeqNumbers[clientId] = [];\n        }\n        PartialSequenceLengths.addSeq(this.clientSeqNumbers[clientId], seq, seqSeglen);\n        //    console.log(this.toString());\n        if (PartialSequenceLengths.options.zamboni) {\n            this.zamboni(collabWindow);\n        }\n        if (PartialSequenceLengths.options.verify) {\n            this.verify();\n        }\n        //   console.log('ZZZ');\n        //   console.log(this.toString());\n    }\n    getPartialLength(refSeq, clientId) {\n        let pLen = this.minLength;\n        const seqIndex = latestLEQ(this.partialLengths, refSeq);\n        const cliLatestindex = this.cliLatest(clientId);\n        const cliSeq = this.clientSeqNumbers[clientId];\n        if (seqIndex >= 0) {\n            // Add the partial length up to refSeq\n            pLen += this.partialLengths[seqIndex].len;\n            if (cliLatestindex >= 0) {\n                const cliLatest = cliSeq[cliLatestindex];\n                if (cliLatest.seq > refSeq) {\n                    // The client has local edits after refSeq, add in the length adjustments\n                    pLen += cliLatest.len;\n                    const precedingCliIndex = this.cliLatestLEQ(clientId, refSeq);\n                    if (precedingCliIndex >= 0) {\n                        pLen -= cliSeq[precedingCliIndex].len;\n                    }\n                }\n            }\n        }\n        else {\n            // RefSeq is before any of the partial lengths\n            // so just add in all local edits of that client (which should all be after the refSeq)\n            if (cliLatestindex >= 0) {\n                const cliLatest = cliSeq[cliLatestindex];\n                pLen += cliLatest.len;\n            }\n        }\n        return pLen;\n    }\n    toString(glc, indentCount = 0) {\n        let buf = \"\";\n        for (const partial of this.partialLengths) {\n            buf += `(${partial.seq},${partial.len}) `;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-for-in-array, no-restricted-syntax\n        for (const clientId in this.clientSeqNumbers) {\n            if (this.clientSeqNumbers[clientId].length > 0) {\n                buf += `Client `;\n                if (glc) {\n                    buf += `${glc(+clientId)}`;\n                }\n                else {\n                    buf += `${clientId}`;\n                }\n                buf += \"[\";\n                for (const partial of this.clientSeqNumbers[clientId]) {\n                    buf += `(${partial.seq},${partial.len})`;\n                }\n                buf += \"]\";\n            }\n        }\n        buf = `min(seq ${this.minSeq}): ${this.minLength}; sc: ${this.segmentCount};${buf}`;\n        return buf;\n    }\n    // Clear away partial sums for sequence numbers earlier than the current window\n    zamboni(segmentWindow) {\n        function copyDown(partialLengths) {\n            const mindex = latestLEQ(partialLengths, segmentWindow.minSeq);\n            let minLength = 0;\n            // console.log(`mindex ${mindex}`);\n            if (mindex >= 0) {\n                minLength = partialLengths[mindex].len;\n                const seqCount = partialLengths.length;\n                if (mindex <= (seqCount - 1)) {\n                    // Still some entries remaining\n                    const remainingCount = (seqCount - mindex) - 1;\n                    // Copy down\n                    for (let i = 0; i < remainingCount; i++) {\n                        partialLengths[i] = partialLengths[i + mindex + 1];\n                        partialLengths[i].len -= minLength;\n                    }\n                    partialLengths.length = remainingCount;\n                }\n            }\n            return minLength;\n        }\n        this.minLength += copyDown(this.partialLengths);\n        // eslint-disable-next-line @typescript-eslint/no-for-in-array, guard-for-in, no-restricted-syntax\n        for (const clientId in this.clientSeqNumbers) {\n            const cliPartials = this.clientSeqNumbers[clientId];\n            if (cliPartials) {\n                copyDown(cliPartials);\n            }\n        }\n    }\n    addClientSeqNumber(clientId, seq, seglen) {\n        if (this.clientSeqNumbers[clientId] === undefined) {\n            this.clientSeqNumbers[clientId] = [];\n        }\n        const cli = this.clientSeqNumbers[clientId];\n        let pLen = seglen;\n        if (cli.length > 0) {\n            pLen += cli[cli.length - 1].len;\n        }\n        cli.push({ seq, len: pLen, seglen });\n    }\n    // Assumes sequence number already coalesced\n    addClientSeqNumberFromPartial(partialLength) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.addClientSeqNumber(partialLength.clientId, partialLength.seq, partialLength.seglen);\n        if (partialLength.overlapRemoveClients) {\n            partialLength.overlapRemoveClients.map((oc) => {\n                this.addClientSeqNumber(oc.data.clientId, partialLength.seq, oc.data.seglen);\n                return true;\n            });\n        }\n    }\n    cliLatestLEQ(clientId, refSeq) {\n        const cliSeqs = this.clientSeqNumbers[clientId];\n        if (cliSeqs) {\n            return latestLEQ(cliSeqs, refSeq);\n        }\n        else {\n            return -1;\n        }\n    }\n    cliLatest(clientId) {\n        const cliSeqs = this.clientSeqNumbers[clientId];\n        if (cliSeqs && (cliSeqs.length > 0)) {\n            return cliSeqs.length - 1;\n        }\n        else {\n            return -1;\n        }\n    }\n    // Debug only\n    verifyPartialLengths(partialLengths, clientPartials) {\n        if (partialLengths.length === 0) {\n            return 0;\n        }\n        let lastSeqNum = 0;\n        let accumSegLen = 0;\n        let count = 0;\n        for (const partialLength of partialLengths) {\n            // Count total number of partial length\n            count++;\n            // Sequence number should be larger or equal to minseq\n            assert(this.minSeq <= partialLength.seq, 0x054 /* \"Sequence number less than minSeq!\" */);\n            // Sequence number should be sorted\n            assert(lastSeqNum < partialLength.seq, 0x055 /* \"Sequence number is not sorted!\" */);\n            lastSeqNum = partialLength.seq;\n            // Len is a accumulation of all the seglen adjustments\n            accumSegLen += partialLength.seglen;\n            if (accumSegLen !== partialLength.len) {\n                assert(false, 0x056 /* \"Unexpected total for accumulation of all seglen adjustments!\" */);\n            }\n            if (clientPartials) {\n                // Client partials used to track local edits so we can account for them some refSeq.\n                // But the information we keep track of are since minSeq, so we keep track of more history\n                // then needed, and some of them doesn't make sense to be used for length calculations\n                // e.g. if you have this sequence, where the minSeq is #5 because of other clients\n                //    seq 10: client 1: insert seg #1\n                //    seq 11: client 2: delete seg #2 refseq: 10\n                // minLength is 0, we would have keep a record of seglen: -1 for clientPartialLengths for client 2\n                // So if you ask for partial length for client 2 @ seq 5, we will have return -1.\n                // However, that combination is invalid, since we should never see any ops with refseq < 10 for\n                // client 2 after seq 11.\n            }\n            else {\n                // Len adjustment should not make length negative\n                if (this.minLength + partialLength.len < 0) {\n                    assert(false, 0x057 /* \"Negative length after length adjustment!\" */);\n                }\n            }\n            if (partialLength.overlapRemoveClients) {\n                // Only the flat partialLengths can have overlapRemoveClients, the per client view shouldn't\n                assert(!clientPartials, 0x058 /* \"Both overlapRemoveClients and clientPartials are set!\" */);\n                // Each overlap client count as one\n                count += partialLength.overlapRemoveClients.size();\n            }\n        }\n        return count;\n    }\n    verify() {\n        if (this.clientSeqNumbers) {\n            let cliCount = 0;\n            for (const cliSeq of this.clientSeqNumbers) {\n                if (cliSeq) {\n                    cliCount += this.verifyPartialLengths(cliSeq, true);\n                }\n            }\n            // If we have client view, we should have the flat view\n            assert(!!this.partialLengths, 0x059 /* \"Client view exists but flat view does not!\" */);\n            const flatCount = this.verifyPartialLengths(this.partialLengths, false);\n            // The number of partial lengths on the client view and flat view should be the same\n            assert(flatCount === cliCount, 0x05a /* \"Mismatch between number of partial lengths on client and flat views!\" */);\n        }\n        else {\n            // If we don't have a client view, we shouldn't have the flat view either\n            assert(!this.partialLengths, 0x05b /* \"Flat view exists but client view does not!\" */);\n        }\n    }\n}\nPartialSequenceLengths.options = {\n    verify: false,\n    zamboni: true,\n};\n//# sourceMappingURL=partialLengths.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nexport function combine(combiningInfo, currentValue, newValue, seq) {\n    let _currentValue = currentValue;\n    if (_currentValue === undefined) {\n        _currentValue = combiningInfo.defaultValue;\n    }\n    // Fixed set of operations for now\n    /* eslint-disable default-case */\n    switch (combiningInfo.name) {\n        case \"incr\":\n            _currentValue += newValue;\n            if (combiningInfo.minValue) {\n                if (_currentValue < combiningInfo.minValue) {\n                    _currentValue = combiningInfo.minValue;\n                }\n            }\n            break;\n        case \"consensus\":\n            if (_currentValue === undefined) {\n                const cv = {\n                    value: newValue,\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    seq: seq,\n                };\n                _currentValue = cv;\n            }\n            else {\n                const cv = _currentValue;\n                if (cv.seq === -1) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    cv.seq = seq;\n                }\n            }\n            break;\n    }\n    /* eslint-enable default-case */\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return _currentValue;\n}\nexport function matchProperties(a, b) {\n    if (a) {\n        if (!b) {\n            return false;\n        }\n        else {\n            // For now, straightforward; later use hashing\n            // eslint-disable-next-line no-restricted-syntax\n            for (const key in a) {\n                if (b[key] === undefined) {\n                    return false;\n                }\n                else if (typeof b[key] === \"object\") {\n                    if (!matchProperties(a[key], b[key])) {\n                        return false;\n                    }\n                }\n                else if (b[key] !== a[key]) {\n                    return false;\n                }\n            }\n            // eslint-disable-next-line no-restricted-syntax\n            for (const key in b) {\n                if (a[key] === undefined) {\n                    return false;\n                }\n            }\n        }\n    }\n    else {\n        if (b) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function extend(base, extension, combiningOp, seq) {\n    if (extension !== undefined) {\n        if ((typeof extension !== \"object\")) {\n            console.log(`oh my ${extension}`);\n        }\n        // eslint-disable-next-line guard-for-in, no-restricted-syntax\n        for (const key in extension) {\n            const v = extension[key];\n            if (v === null) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete base[key];\n            }\n            else {\n                if (combiningOp && (combiningOp.name !== \"rewrite\")) {\n                    base[key] = combine(combiningOp, base[key], v, seq);\n                }\n                else {\n                    base[key] = v;\n                }\n            }\n        }\n    }\n    return base;\n}\nexport function clone(extension) {\n    if (extension === undefined) {\n        return undefined;\n    }\n    const cloneMap = createMap();\n    // eslint-disable-next-line guard-for-in, no-restricted-syntax\n    for (const key in extension) {\n        const v = extension[key];\n        if (v !== null) {\n            cloneMap[key] = v;\n        }\n    }\n    return cloneMap;\n}\nexport function addProperties(oldProps, newProps, op, seq) {\n    let _oldProps = oldProps;\n    if ((!_oldProps) || (op && (op.name === \"rewrite\"))) {\n        _oldProps = createMap();\n    }\n    extend(_oldProps, newProps, op, seq);\n    return _oldProps;\n}\nexport function extendIfUndefined(base, extension) {\n    if (extension !== undefined) {\n        if ((typeof extension !== \"object\")) {\n            console.log(`oh my ${extension}`);\n        }\n        // eslint-disable-next-line no-restricted-syntax\n        for (const key in extension) {\n            if (base[key] === undefined) {\n                base[key] = extension[key];\n            }\n        }\n    }\n    return base;\n}\n// Create a MapLike with good performance.\nexport function createMap() {\n    const map = Object.create(null);\n    // Using 'delete' on an object causes V8 to put the object in dictionary mode.\n    // This disables creation of hidden classes, which are expensive when an object is\n    // constantly changing shape.\n    // eslint-disable-next-line @typescript-eslint/dot-notation\n    map[\"__\"] = undefined;\n    // eslint-disable-next-line @typescript-eslint/dot-notation, @typescript-eslint/no-dynamic-delete\n    delete map[\"__\"];\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return map;\n}\n//# sourceMappingURL=properties.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { ListMakeHead } from \"./collections\";\nexport class SegmentGroupCollection {\n    constructor(segment) {\n        this.segment = segment;\n        this.segmentGroups = ListMakeHead();\n    }\n    get size() {\n        return this.segmentGroups.count();\n    }\n    get empty() {\n        return this.segmentGroups.empty();\n    }\n    enqueue(segmentGroup) {\n        this.segmentGroups.enqueue(segmentGroup);\n        segmentGroup.segments.push(this.segment);\n    }\n    dequeue() {\n        return this.segmentGroups.dequeue();\n    }\n    clear() {\n        this.segmentGroups.clear();\n    }\n    copyTo(segment) {\n        this.segmentGroups.walk((sg) => segment.segmentGroups.enqueue(sg));\n    }\n}\n//# sourceMappingURL=segmentGroupCollection.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { UnassignedSequenceNumber } from \"./constants\";\nimport * as Properties from \"./properties\";\nexport class SegmentPropertiesManager {\n    constructor(segment) {\n        this.segment = segment;\n        this.pendingRewriteCount = 0;\n    }\n    ackPendingProperties(annotateOp) {\n        var _a, _b;\n        if (annotateOp.combiningOp && annotateOp.combiningOp.name === \"rewrite\") {\n            this.pendingRewriteCount--;\n        }\n        for (const key of Object.keys(annotateOp.props)) {\n            if (((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) !== undefined) {\n                assert(this.pendingKeyUpdateCount[key] > 0, 0x05c /* \"Trying to update more annotate props than do exist!\" */);\n                this.pendingKeyUpdateCount[key]--;\n                if (((_b = this.pendingKeyUpdateCount) === null || _b === void 0 ? void 0 : _b[key]) === 0) {\n                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                    delete this.pendingKeyUpdateCount[key];\n                }\n            }\n        }\n    }\n    addProperties(newProps, op, seq, collabWindow) {\n        var _a;\n        if (!this.segment.properties) {\n            this.segment.properties = Properties.createMap();\n            this.pendingKeyUpdateCount = Properties.createMap();\n        }\n        const collaborating = collabWindow && collabWindow.collaborating;\n        // There are outstanding local rewrites, so block all non-local changes\n        if (this.pendingRewriteCount > 0 && seq !== UnassignedSequenceNumber && collaborating) {\n            return undefined;\n        }\n        const rewrite = (op && op.name === \"rewrite\");\n        const combiningOp = !rewrite ? op ? op : undefined : undefined;\n        const shouldModifyKey = (key) => {\n            var _a;\n            if (seq === UnassignedSequenceNumber\n                || ((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) === undefined\n                || combiningOp) {\n                return true;\n            }\n            return false;\n        };\n        const deltas = {};\n        if (rewrite) {\n            if (collaborating && seq === UnassignedSequenceNumber) {\n                this.pendingRewriteCount++;\n            }\n            // We are re-writting so delete all the properties\n            // not in the new props\n            for (const key of Object.keys(this.segment.properties)) {\n                if (!newProps[key] && shouldModifyKey(key)) {\n                    deltas[key] = this.segment.properties[key];\n                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                    delete this.segment.properties[key];\n                }\n            }\n        }\n        for (const key of Object.keys(newProps)) {\n            if (collaborating) {\n                if (seq === UnassignedSequenceNumber) {\n                    if (((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) === undefined) {\n                        this.pendingKeyUpdateCount[key] = 0;\n                    }\n                    this.pendingKeyUpdateCount[key]++;\n                }\n                else if (!shouldModifyKey(key)) {\n                    continue;\n                }\n            }\n            const previousValue = this.segment.properties[key];\n            // The delta should be null if undefined, as thats how we encode delete\n            deltas[key] = (previousValue === undefined) ? null : previousValue;\n            let newValue;\n            if (combiningOp) {\n                newValue = Properties.combine(combiningOp, previousValue, newValue, seq);\n            }\n            else {\n                newValue = newProps[key];\n            }\n            if (newValue === null) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete this.segment.properties[key];\n            }\n            else {\n                this.segment.properties[key] = newValue;\n            }\n        }\n        return deltas;\n    }\n    copyTo(leafSegment) {\n        if (this.segment.properties) {\n            leafSegment.properties = Properties.createMap();\n            for (const key of Object.keys(this.segment.properties)) {\n                leafSegment.properties[key] = this.segment.properties[key];\n            }\n            if (this.segment.propertyManager) {\n                leafSegment.propertyManager = new SegmentPropertiesManager(leafSegment);\n                leafSegment.propertyManager.pendingRewriteCount = this.pendingRewriteCount;\n                leafSegment.propertyManager.pendingKeyUpdateCount = Properties.createMap();\n                for (const key of Object.keys(this.pendingKeyUpdateCount)) {\n                    leafSegment.propertyManager.pendingKeyUpdateCount[key] = this.pendingKeyUpdateCount[key];\n                }\n            }\n        }\n    }\n    hasPendingProperties() {\n        return this.pendingRewriteCount > 0 || Object.keys(this.pendingKeyUpdateCount).length > 0;\n    }\n}\n//# sourceMappingURL=segmentPropertiesManager.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { SnapshotLegacy } from \"./snapshotlegacy\";\n/**\n * Returns true if the given 'spec' is an IJSONSegmentWithMergeInfo.\n */\nexport function hasMergeInfo(spec) {\n    return !!spec && typeof spec === \"object\" && \"json\" in spec;\n}\nexport function serializeAsMinSupportedVersion(path, chunk, logger, options, serializer, bind) {\n    let targetChuck;\n    if (chunk.version !== undefined) {\n        logger.send({\n            eventName: \"MergeTreeChunk:serializeAsMinSupportedVersion\",\n            category: \"generic\",\n            fromChunkVersion: chunk.version,\n            toChunkVersion: undefined,\n        });\n    }\n    switch (chunk.version) {\n        case undefined:\n            targetChuck = chunk;\n            targetChuck.headerMetadata = buildHeaderMetadataForLegecyChunk(path, targetChuck, options);\n            break;\n        case \"1\":\n            const chunkV1 = chunk;\n            const headerMetadata = path === SnapshotLegacy.header ? chunkV1.headerMetadata : undefined;\n            targetChuck = {\n                version: undefined,\n                chunkStartSegmentIndex: chunkV1.startIndex,\n                chunkLengthChars: chunkV1.length,\n                chunkSegmentCount: chunkV1.segmentCount,\n                segmentTexts: chunkV1.segments,\n                totalLengthChars: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.totalLength,\n                totalSegmentCount: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.totalSegmentCount,\n                chunkSequenceNumber: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.sequenceNumber,\n                chunkMinSequenceNumber: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.minSequenceNumber,\n                headerMetadata,\n            };\n            break;\n        default:\n            throw new Error(`Unsupported chunk path: ${path} version: ${chunk.version}`);\n    }\n    return serializer.stringify(targetChuck, bind);\n}\nexport function serializeAsMaxSupportedVersion(path, chunk, logger, options, serializer, bind) {\n    const targetChuck = toLatestVersion(path, chunk, logger, options);\n    return serializer.stringify(targetChuck, bind);\n}\nexport function toLatestVersion(path, chunk, logger, options) {\n    switch (chunk.version) {\n        case undefined: {\n            const chunkLegacy = chunk;\n            return {\n                version: \"1\",\n                length: chunkLegacy.chunkLengthChars,\n                segmentCount: chunkLegacy.chunkSegmentCount,\n                headerMetadata: buildHeaderMetadataForLegecyChunk(path, chunkLegacy, options),\n                segments: chunkLegacy.segmentTexts,\n                startIndex: chunkLegacy.chunkStartSegmentIndex,\n            };\n        }\n        case \"1\":\n            return chunk;\n        default:\n            throw new Error(`Unsupported chunk path: ${path} version: ${chunk.version}`);\n    }\n}\nfunction buildHeaderMetadataForLegecyChunk(path, chunk, options) {\n    if (path === SnapshotLegacy.header) {\n        if (chunk.headerMetadata !== undefined) {\n            return chunk.headerMetadata;\n        }\n        const chunkIds = [{ id: SnapshotLegacy.header }];\n        if (chunk.chunkLengthChars < chunk.totalLengthChars) {\n            chunkIds.push({ id: SnapshotLegacy.body });\n        }\n        return {\n            orderedChunkMetadata: chunkIds,\n            minSequenceNumber: chunk.chunkMinSequenceNumber,\n            sequenceNumber: chunk.chunkSequenceNumber,\n            totalLength: chunk.totalLengthChars,\n            totalSegmentCount: chunk.totalSegmentCount,\n        };\n    }\n    return undefined;\n}\n//# sourceMappingURL=snapshotChunks.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { assert, bufferToString } from \"@fluidframework/common-utils\";\nimport { ChildLogger } from \"@fluidframework/telemetry-utils\";\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { NonCollabClient, UniversalSequenceNumber } from \"./constants\";\nimport { hasMergeInfo, } from \"./snapshotChunks\";\nimport { SnapshotV1 } from \"./snapshotV1\";\nimport { SnapshotLegacy } from \"./snapshotlegacy\";\nexport class SnapshotLoader {\n    constructor(runtime, client, mergeTree, logger, serializer) {\n        this.runtime = runtime;\n        this.client = client;\n        this.mergeTree = mergeTree;\n        this.serializer = serializer;\n        this.specToSegment = (spec) => {\n            let seg;\n            if (hasMergeInfo(spec)) {\n                seg = this.client.specToSegment(spec.json);\n                // `specToSegment()` initializes `seg` with the LocalClientId.  Overwrite this with\n                // the `spec` client (if specified).  Otherwise overwrite with `NonCollabClient`.\n                seg.clientId = spec.client !== undefined\n                    ? this.client.getOrAddShortClientId(spec.client)\n                    : NonCollabClient;\n                seg.seq = spec.seq !== undefined\n                    ? spec.seq\n                    : UniversalSequenceNumber;\n                if (spec.removedSeq !== undefined) {\n                    seg.removedSeq = spec.removedSeq;\n                }\n                if (spec.removedClient !== undefined) {\n                    seg.removedClientId = this.client.getOrAddShortClientId(spec.removedClient);\n                }\n            }\n            else {\n                seg = this.client.specToSegment(spec);\n                seg.seq = UniversalSequenceNumber;\n                // `specToSegment()` initializes `seg` with the LocalClientId.  We must overwrite this with\n                // `NonCollabClient`.\n                seg.clientId = NonCollabClient;\n            }\n            return seg;\n        };\n        this.logger = ChildLogger.create(logger, \"SnapshotLoader\");\n    }\n    async initialize(services) {\n        const headerLoadedP = services.readBlob(SnapshotLegacy.header).then((header) => {\n            assert(!!header, 0x05f /* \"Missing blob header on legacy snapshot!\" */);\n            return this.loadHeader(bufferToString(header, \"utf8\"));\n        });\n        const catchupOpsP = this.loadBodyAndCatchupOps(headerLoadedP, services);\n        catchupOpsP.catch((err) => this.logger.sendErrorEvent({ eventName: \"CatchupOpsLoadFailure\" }, err));\n        await headerLoadedP;\n        return { catchupOpsP };\n    }\n    async loadBodyAndCatchupOps(headerChunkP, services) {\n        const blobsP = services.list(\"\");\n        const headerChunk = await headerChunkP;\n        // TODO we shouldn't need to wait on the body being complete to finish initialization.\n        // To fully support this we need to be able to process inbound ops for pending segments.\n        await this.loadBody(headerChunk, services);\n        const blobs = await blobsP;\n        if (blobs.length === headerChunk.headerMetadata.orderedChunkMetadata.length + 1) {\n            headerChunk.headerMetadata.orderedChunkMetadata.forEach((md) => blobs.splice(blobs.indexOf(md.id), 1));\n            assert(blobs.length === 1, 0x060 /* `There should be only one blob with catch up ops: ${blobs.length}` */);\n            // TODO: The 'Snapshot.catchupOps' tree entry is purely for backwards compatibility.\n            //       (See https://github.com/microsoft/FluidFramework/issues/84)\n            return this.loadCatchupOps(services.readBlob(blobs[0]));\n        }\n        else if (blobs.length !== headerChunk.headerMetadata.orderedChunkMetadata.length) {\n            throw new Error(\"Unexpected blobs in snapshot\");\n        }\n        return [];\n    }\n    loadHeader(header) {\n        var _a;\n        const chunk = SnapshotV1.processChunk(SnapshotLegacy.header, header, this.logger, this.mergeTree.options, this.serializer);\n        const segs = chunk.segments.map(this.specToSegment);\n        this.mergeTree.reloadFromSegments(segs);\n        if (chunk.headerMetadata === undefined) {\n            throw new Error(\"header metadata not available\");\n        }\n        // If we load a detached container from snapshot, then we don't supply a default clientId\n        // because we don't want to start collaboration.\n        if (this.runtime.attachState !== AttachState.Detached) {\n            // specify a default client id, \"snapshot\" here as we\n            // should enter collaboration/op sending mode if we load\n            // a snapshot in any case (summary or attach message)\n            // once we get a client id this will be called with that\n            // clientId in the connected event\n            this.client.startOrUpdateCollaboration((_a = this.runtime.clientId) !== null && _a !== void 0 ? _a : \"snapshot\", \n            // TODO: Make 'minSeq' non-optional once the new snapshot format becomes the default?\n            //       (See https://github.com/microsoft/FluidFramework/issues/84)\n            /* minSeq: */ chunk.headerMetadata.minSequenceNumber !== undefined\n                ? chunk.headerMetadata.minSequenceNumber\n                : chunk.headerMetadata.sequenceNumber, \n            /* currentSeq: */ chunk.headerMetadata.sequenceNumber);\n        }\n        return chunk;\n    }\n    async loadBody(chunk1, services) {\n        assert(chunk1.length <= chunk1.headerMetadata.totalLength, 0x061 /* \"Mismatch in totalLength\" */);\n        assert(chunk1.segmentCount <= chunk1.headerMetadata.totalSegmentCount, 0x062 /* \"Mismatch in totalSegmentCount\" */);\n        if (chunk1.segmentCount === chunk1.headerMetadata.totalSegmentCount) {\n            return;\n        }\n        const segs = [];\n        let lengthSofar = chunk1.length;\n        for (let chunkIndex = 1; chunkIndex < chunk1.headerMetadata.orderedChunkMetadata.length; chunkIndex++) {\n            const chunk = await SnapshotV1.loadChunk(services, chunk1.headerMetadata.orderedChunkMetadata[chunkIndex].id, this.logger, this.mergeTree.options, this.serializer);\n            lengthSofar += chunk.length;\n            // Deserialize each chunk segment and append it to the end of the MergeTree.\n            segs.push(...chunk.segments.map(this.specToSegment));\n        }\n        assert(lengthSofar === chunk1.headerMetadata.totalLength, 0x063 /* \"Mismatch in totalLength\" */);\n        assert(chunk1.segmentCount + segs.length === chunk1.headerMetadata.totalSegmentCount, 0x064 /* \"Mismatch in totalSegmentCount\" */);\n        // Helper to insert segments at the end of the MergeTree.\n        const mergeTree = this.mergeTree;\n        const append = (segments, cli, seq) => {\n            mergeTree.insertSegments(mergeTree.root.cachedLength, segments, \n            /* refSeq: */ UniversalSequenceNumber, cli, seq, undefined);\n        };\n        // Helpers to batch-insert segments that are below the min seq\n        const batch = [];\n        const flushBatch = () => {\n            if (batch.length > 0) {\n                append(batch, NonCollabClient, UniversalSequenceNumber);\n            }\n        };\n        for (const seg of segs) {\n            const cli = seg.clientId;\n            const seq = seg.seq;\n            // If the segment can be batch inserted, add it to the 'batch' array.  Otherwise, flush\n            // any batched segments and then insert the current segment individually.\n            if (cli === NonCollabClient && seq === UniversalSequenceNumber) {\n                batch.push(seg);\n            }\n            else {\n                flushBatch();\n                append([seg], cli, seq);\n            }\n        }\n        flushBatch();\n    }\n    /**\n     * If loading from a snapshot, get the catchup messages.\n     * @param rawMessages - The messages in original encoding\n     * @returns The decoded messages, but handles aren't parsed.  Matches the format that will be passed in\n     * SharedObject.processCore.\n     */\n    async loadCatchupOps(rawMessages) {\n        return JSON.parse(bufferToString(await rawMessages, \"utf8\"));\n    }\n}\n//# sourceMappingURL=snapshotLoader.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, bufferToString } from \"@fluidframework/common-utils\";\nimport { ChildLogger } from \"@fluidframework/telemetry-utils\";\nimport { FileMode, TreeEntry, } from \"@fluidframework/protocol-definitions\";\nimport { UnassignedSequenceNumber } from \"./constants\";\nimport * as Properties from \"./properties\";\nimport { toLatestVersion, serializeAsMaxSupportedVersion, } from \"./snapshotChunks\";\nimport { SnapshotLegacy } from \"./snapshotlegacy\";\nexport class SnapshotV1 {\n    constructor(mergeTree, logger, filename, onCompletion) {\n        var _a, _b;\n        this.mergeTree = mergeTree;\n        this.filename = filename;\n        this.onCompletion = onCompletion;\n        this.logger = ChildLogger.create(logger, \"Snapshot\");\n        this.chunkSize = (_b = (_a = mergeTree === null || mergeTree === void 0 ? void 0 : mergeTree.options) === null || _a === void 0 ? void 0 : _a.mergeTreeSnapshotChunkSize) !== null && _b !== void 0 ? _b : SnapshotV1.chunkSize;\n        const { currentSeq, minSeq } = mergeTree.getCollabWindow();\n        this.header = {\n            minSequenceNumber: minSeq,\n            sequenceNumber: currentSeq,\n            orderedChunkMetadata: [],\n            totalLength: 0,\n            totalSegmentCount: 0,\n        };\n        this.segments = [];\n        this.segmentLengths = [];\n    }\n    getSeqLengthSegs(allSegments, allLengths, approxSequenceLength, startIndex = 0) {\n        const segments = [];\n        let length = 0;\n        let segmentCount = 0;\n        while ((length < approxSequenceLength) && ((startIndex + segmentCount) < allSegments.length)) {\n            const pseg = allSegments[startIndex + segmentCount];\n            segments.push(pseg);\n            length += allLengths[startIndex + segmentCount];\n            segmentCount++;\n        }\n        return {\n            version: \"1\",\n            segmentCount,\n            length,\n            segments,\n            startIndex,\n            headerMetadata: undefined,\n        };\n    }\n    /**\n     * Emits the snapshot to an ITree. If provided the optional IFluidSerializer will be used when serializing\n     * the summary data rather than JSON.stringify.\n     */\n    emit(serializer, bind) {\n        const chunks = [];\n        this.header.totalSegmentCount = 0;\n        this.header.totalLength = 0;\n        do {\n            const chunk = this.getSeqLengthSegs(this.segments, this.segmentLengths, this.chunkSize, this.header.totalSegmentCount);\n            chunks.push(chunk);\n            this.header.totalSegmentCount += chunk.segmentCount;\n            this.header.totalLength += chunk.length;\n        } while (this.header.totalSegmentCount < this.segments.length);\n        // The do while loop should have added at least one chunk\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const headerChunk = chunks.shift();\n        headerChunk.headerMetadata = this.header;\n        headerChunk.headerMetadata.orderedChunkMetadata = [{ id: SnapshotLegacy.header }];\n        const entries = chunks.map((chunk, index) => {\n            const id = `${SnapshotLegacy.body}_${index}`;\n            this.header.orderedChunkMetadata.push({ id });\n            return {\n                mode: FileMode.File,\n                path: id,\n                type: TreeEntry.Blob,\n                value: {\n                    contents: serializeAsMaxSupportedVersion(id, chunk, this.logger, this.mergeTree.options, serializer, bind),\n                    encoding: \"utf-8\",\n                },\n            };\n        });\n        const tree = {\n            entries: [\n                {\n                    mode: FileMode.File,\n                    path: SnapshotLegacy.header,\n                    type: TreeEntry.Blob,\n                    value: {\n                        contents: serializeAsMaxSupportedVersion(SnapshotLegacy.header, headerChunk, this.logger, this.mergeTree.options, serializer, bind),\n                        encoding: \"utf-8\",\n                    },\n                },\n                ...entries,\n            ],\n        };\n        return tree;\n    }\n    extractSync() {\n        const mergeTree = this.mergeTree;\n        const minSeq = this.header.minSequenceNumber;\n        // Helper to add the given `MergeTreeChunkV0SegmentSpec` to the snapshot.\n        const pushSegRaw = (json, length) => {\n            this.segments.push(json);\n            this.segmentLengths.push(length);\n        };\n        // Helper to serialize the given `segment` and add it to the snapshot (if a segment is provided).\n        const pushSeg = (segment) => {\n            if (segment) {\n                pushSegRaw(segment.toJSONObject(), segment.cachedLength);\n            }\n        };\n        let prev;\n        const extractSegment = (segment) => {\n            // Elide segments that do not need to be included in the snapshot.  A segment may be elided if\n            // either condition is true:\n            //   a) The segment has not yet been ACKed.  We do not need to snapshot unACKed segments because\n            //      there is a pending insert op that will deliver the segment on reconnection.\n            //   b) The segment was removed at or below the MSN.  Pending ops can no longer reference this\n            //      segment, and therefore we can discard it.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if (segment.seq === UnassignedSequenceNumber || segment.removedSeq <= minSeq) {\n                return true;\n            }\n            // Next determine if the snapshot needs to preserve information required for merging the segment\n            // (seq, client, etc.)  This information is only needed if the segment is above the MSN (and doesn't\n            // have a pending remove.)\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if ((segment.seq <= minSeq) // Segment is below the MSN, and...\n                && (segment.removedSeq === undefined // .. Segment has not been removed, or...\n                    || segment.removedSeq === UnassignedSequenceNumber) // .. Removal op to be delivered on reconnect\n            ) {\n                // This segment is below the MSN, which means that future ops will not reference it.  Attempt to\n                // coalesce the new segment with the previous (if any).\n                if (!prev) {\n                    // We do not have a previous candidate for coalescing.  Make the current segment the new candidate.\n                    prev = segment;\n                }\n                else if (prev.canAppend(segment) && Properties.matchProperties(prev.properties, segment.properties)) {\n                    // We have a compatible pair.  Replace `prev` with the coalesced segment.  Clone to avoid\n                    // modifying the segment instances currently in the MergeTree.\n                    prev = prev.clone();\n                    prev.append(segment.clone());\n                }\n                else {\n                    // The segment pair could not be coalesced.  Record the `prev` segment in the snapshot\n                    // and make the current segment the new candidate for coalescing.\n                    pushSeg(prev);\n                    prev = segment;\n                }\n            }\n            else {\n                // This segment needs to preserve it's metadata as it may be referenced by future ops.  It's ineligible\n                // for coalescing, so emit the 'prev' segment now (if any).\n                pushSeg(prev);\n                prev = undefined;\n                const raw = { json: segment.toJSONObject() };\n                // If the segment insertion is above the MSN, record the insertion merge info.\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                if (segment.seq > minSeq) {\n                    raw.seq = segment.seq;\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    raw.client = mergeTree.getLongClientId(segment.clientId);\n                }\n                // We have already dispensed with removed segments below the MSN and removed segments with unassigned\n                // sequence numbers.  Any remaining removal info should be preserved.\n                if (segment.removedSeq !== undefined) {\n                    assert(segment.removedSeq !== UnassignedSequenceNumber && segment.removedSeq > minSeq, 0x065 /* \"On removal info preservation, segment has invalid removed sequence number!\" */);\n                    raw.removedSeq = segment.removedSeq;\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    raw.removedClient = mergeTree.getLongClientId(segment.removedClientId);\n                }\n                // Sanity check that we are preserving either the seq < minSeq or a removed segment's info.\n                assert(raw.seq !== undefined && raw.client !== undefined\n                    || raw.removedSeq !== undefined && raw.removedClient !== undefined, 0x066 /* \"Corrupted preservation of segment metadata!\" */);\n                // Record the segment with it's required metadata.\n                pushSegRaw(raw, segment.cachedLength);\n            }\n            return true;\n        };\n        mergeTree.walkAllSegments(mergeTree.root, extractSegment, this);\n        // If the last segment in the walk was coalescable, push it now.\n        pushSeg(prev);\n        return this.segments;\n    }\n    static async loadChunk(storage, path, logger, options, serializer) {\n        const blob = await storage.readBlob(path);\n        const chunkAsString = bufferToString(blob, \"utf8\");\n        return SnapshotV1.processChunk(path, chunkAsString, logger, options, serializer);\n    }\n    static processChunk(path, chunk, logger, options, serializer) {\n        const chunkObj = serializer ? serializer.parse(chunk) : JSON.parse(chunk);\n        return toLatestVersion(path, chunkObj, logger, options);\n    }\n}\n// Split snapshot into two entries - headers (small) and body (overflow) for faster loading initial content\n// Please note that this number has no direct relationship to anything other than size of raw text (characters).\n// As we produce json for the blob (and then send over the wire compressed), this number\n// is really hard to correlate with any actual metric that matters (like bytes over the wire).\n// For test with small number of chunks it would be closer to blob size,\n// for very chunky text, blob size can easily be 4x-8x of that number.\nSnapshotV1.chunkSize = 10000;\n//# sourceMappingURL=snapshotV1.js.map","/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { ChildLogger } from \"@fluidframework/telemetry-utils\";\nimport { FileMode, TreeEntry } from \"@fluidframework/protocol-definitions\";\nimport { NonCollabClient, UnassignedSequenceNumber } from \"./constants\";\nimport * as Properties from \"./properties\";\nimport { serializeAsMinSupportedVersion, } from \"./snapshotChunks\";\nexport class SnapshotLegacy {\n    constructor(mergeTree, logger, filename, onCompletion) {\n        var _a, _b;\n        this.mergeTree = mergeTree;\n        this.filename = filename;\n        this.onCompletion = onCompletion;\n        this.logger = ChildLogger.create(logger, \"Snapshot\");\n        this.chunkSize = (_b = (_a = mergeTree === null || mergeTree === void 0 ? void 0 : mergeTree.options) === null || _a === void 0 ? void 0 : _a.mergeTreeSnapshotChunkSize) !== null && _b !== void 0 ? _b : SnapshotLegacy.sizeOfFirstChunk;\n    }\n    getSeqLengthSegs(allSegments, allLengths, approxSequenceLength, startIndex = 0) {\n        const segs = [];\n        let sequenceLength = 0;\n        let segCount = 0;\n        while ((sequenceLength < approxSequenceLength) && ((startIndex + segCount) < allSegments.length)) {\n            const pseg = allSegments[startIndex + segCount];\n            segs.push(pseg);\n            sequenceLength += allLengths[startIndex + segCount];\n            segCount++;\n        }\n        return {\n            version: undefined,\n            chunkStartSegmentIndex: startIndex,\n            chunkSegmentCount: segCount,\n            chunkLengthChars: sequenceLength,\n            totalLengthChars: this.header.segmentsTotalLength,\n            totalSegmentCount: allSegments.length,\n            chunkSequenceNumber: this.header.seq,\n            segmentTexts: segs,\n        };\n    }\n    /**\n     * Emits the snapshot to an ITree. If provided the optional IFluidSerializer will be used when serializing\n     * the summary data rather than JSON.stringify.\n     */\n    emit(catchUpMsgs, serializer, bind) {\n        var _a, _b;\n        const chunk1 = this.getSeqLengthSegs(this.segments, this.segmentLengths, this.chunkSize);\n        let length = chunk1.chunkLengthChars;\n        let segments = chunk1.chunkSegmentCount;\n        const tree = {\n            entries: [\n                {\n                    mode: FileMode.File,\n                    path: SnapshotLegacy.header,\n                    type: TreeEntry.Blob,\n                    value: {\n                        contents: serializeAsMinSupportedVersion(SnapshotLegacy.header, chunk1, this.logger, this.mergeTree.options, serializer, bind),\n                        encoding: \"utf-8\",\n                    },\n                },\n            ],\n        };\n        if (chunk1.chunkSegmentCount < chunk1.totalSegmentCount) {\n            const chunk2 = this.getSeqLengthSegs(this.segments, this.segmentLengths, this.header.segmentsTotalLength, chunk1.chunkSegmentCount);\n            length += chunk2.chunkLengthChars;\n            segments += chunk2.chunkSegmentCount;\n            tree.entries.push({\n                mode: FileMode.File,\n                path: SnapshotLegacy.body,\n                type: TreeEntry.Blob,\n                value: {\n                    contents: serializeAsMinSupportedVersion(SnapshotLegacy.body, chunk2, this.logger, this.mergeTree.options, serializer, bind),\n                    encoding: \"utf-8\",\n                },\n            });\n        }\n        assert(length === this.header.segmentsTotalLength, 0x05d /* \"emit: mismatch in segmentsTotalLength\" */);\n        assert(segments === chunk1.totalSegmentCount, 0x05e /* \"emit: mismatch in totalSegmentCount\" */);\n        if (catchUpMsgs !== undefined && catchUpMsgs.length > 0) {\n            tree.entries.push({\n                mode: FileMode.File,\n                path: (_b = (_a = this.mergeTree.options) === null || _a === void 0 ? void 0 : _a.catchUpBlobName) !== null && _b !== void 0 ? _b : SnapshotLegacy.catchupOps,\n                type: TreeEntry.Blob,\n                value: {\n                    contents: serializer ? serializer.stringify(catchUpMsgs, bind) : JSON.stringify(catchUpMsgs),\n                    encoding: \"utf-8\",\n                },\n            });\n        }\n        return tree;\n    }\n    extractSync() {\n        const collabWindow = this.mergeTree.getCollabWindow();\n        this.seq = collabWindow.minSeq;\n        this.header = {\n            segmentsTotalLength: this.mergeTree.getLength(this.mergeTree.collabWindow.minSeq, NonCollabClient),\n            seq: this.mergeTree.collabWindow.minSeq,\n        };\n        const segs = [];\n        let prev;\n        const extractSegment = \n        // eslint-disable-next-line max-len\n        (segment, pos, refSeq, clientId, start, end) => {\n            // eslint-disable-next-line eqeqeq\n            if ((segment.seq != UnassignedSequenceNumber) && (segment.seq <= this.seq) &&\n                // eslint-disable-next-line eqeqeq\n                ((segment.removedSeq === undefined) || (segment.removedSeq == UnassignedSequenceNumber) ||\n                    (segment.removedSeq > this.seq))) {\n                if (prev && prev.canAppend(segment)\n                    && Properties.matchProperties(prev.properties, segment.properties)) {\n                    prev = prev.clone();\n                    prev.append(segment.clone());\n                }\n                else {\n                    if (prev) {\n                        segs.push(prev);\n                    }\n                    prev = segment;\n                }\n            }\n            return true;\n        };\n        this.mergeTree.map({ leaf: extractSegment }, this.seq, NonCollabClient, undefined);\n        if (prev) {\n            segs.push(prev);\n        }\n        this.segments = [];\n        this.segmentLengths = [];\n        let totalLength = 0;\n        segs.map((segment) => {\n            totalLength += segment.cachedLength;\n            this.segments.push(segment.toJSONObject());\n            this.segmentLengths.push(segment.cachedLength);\n        });\n        // We observed this.header.segmentsTotalLength < totalLength to happen in some cases\n        // When this condition happens, we might not write out all segments in getSeqLengthSegs()\n        // when writing out \"body\". Issue #1995 tracks following up on the core of the problem.\n        // In the meantime, this code makes sure we will write out all segments properly\n        // eslint-disable-next-line eqeqeq\n        if (this.header.segmentsTotalLength != totalLength) {\n            this.logger.sendErrorEvent({\n                eventName: \"SegmentsTotalLengthMismatch\",\n                totalLength,\n                segmentsTotalLength: this.header.segmentsTotalLength,\n            });\n            this.header.segmentsTotalLength = totalLength;\n        }\n        return this.segments;\n    }\n}\nSnapshotLegacy.header = \"header\";\nSnapshotLegacy.body = \"body\";\nSnapshotLegacy.catchupOps = \"catchupOps\";\n// Split snapshot into two entries - headers (small) and body (overflow) for faster loading initial content\n// Please note that this number has no direct relationship to anything other than size of raw text (characters).\n// As we produce json for the blob (and then send over the wire compressed), this number\n// is really hard to correlate with any actual metric that matters (like bytes over the wire).\n// For test with small number of chunks it would be closer to blob size,\n// for very chunky text, blob size can easily be 4x-8x of that number.\nSnapshotLegacy.sizeOfFirstChunk = 10000;\n//# sourceMappingURL=snapshotlegacy.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Stores a unique and sorted set of segments, or objects with segments\n *\n * This differs from a normal sorted set in that the keys are not fixed.\n * The segments are sorted via their ordinals which can change as the merge tree is modified.\n * Eventhough the values of the ordinals can change their ordering and uniqueness cannot, so the order of a set of\n * segments ordered by their ordinals will always have the same order even if the ordinal values on\n * the segments changes. This invarient allows ensure the segments stay ordered and unique, and that new segments\n * can be inserted into that order.\n */\nexport class SortedSegmentSet {\n    constructor() {\n        this.oridinalSortedItems = [];\n    }\n    get size() {\n        return this.oridinalSortedItems.length;\n    }\n    get items() {\n        return this.oridinalSortedItems;\n    }\n    addOrUpdate(newItem, update) {\n        const postition = this.findOrdinalPosition(this.getOrdinal(newItem));\n        if (postition.exists) {\n            if (update) {\n                update(this.oridinalSortedItems[postition.index], newItem);\n            }\n        }\n        else {\n            this.oridinalSortedItems.splice(postition.index, 0, newItem);\n        }\n    }\n    remove(item) {\n        const position = this.findOrdinalPosition(this.getOrdinal(item));\n        if (position.exists) {\n            this.oridinalSortedItems.splice(position.index, 1);\n            return true;\n        }\n        return false;\n    }\n    has(item) {\n        const position = this.findOrdinalPosition(this.getOrdinal(item));\n        return position.exists;\n    }\n    getOrdinal(item) {\n        const maybeObject = item;\n        if (maybeObject && maybeObject.segment) {\n            return maybeObject.segment.ordinal;\n        }\n        const maybeSegment = item;\n        return maybeSegment.ordinal;\n    }\n    findOrdinalPosition(ordinal, start, end) {\n        if (this.oridinalSortedItems.length === 0) {\n            return { exists: false, index: 0 };\n        }\n        if (start === undefined || end === undefined) {\n            return this.findOrdinalPosition(ordinal, 0, this.oridinalSortedItems.length - 1);\n        }\n        const index = start + Math.floor((end - start) / 2);\n        if (this.getOrdinal(this.oridinalSortedItems[index]) > ordinal) {\n            if (start === index) {\n                return { exists: false, index };\n            }\n            return this.findOrdinalPosition(ordinal, start, index - 1);\n        }\n        else if (this.getOrdinal(this.oridinalSortedItems[index]) < ordinal) {\n            if (index === end) {\n                return { exists: false, index: index + 1 };\n            }\n            return this.findOrdinalPosition(ordinal, index + 1, end);\n        }\n        return { exists: true, index };\n    }\n}\n//# sourceMappingURL=sortedSegmentSet.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { BaseSegment, glc, MergeTree } from \"./mergeTree\";\nimport { LocalReferenceCollection } from \"./localReference\";\nexport class TextSegment extends BaseSegment {\n    constructor(text) {\n        super();\n        this.text = text;\n        this.type = TextSegment.type;\n        this.cachedLength = text.length;\n    }\n    static is(segment) {\n        return segment.type === TextSegment.type;\n    }\n    static make(text, props) {\n        const tseg = new TextSegment(text);\n        if (props) {\n            tseg.addProperties(props);\n        }\n        return tseg;\n    }\n    static fromJSONObject(spec) {\n        if (typeof spec === \"string\") {\n            return new TextSegment(spec);\n        }\n        else if (spec && typeof spec === \"object\" && \"text\" in spec) {\n            const textSpec = spec;\n            return TextSegment.make(textSpec.text, textSpec.props);\n        }\n        return undefined;\n    }\n    toJSONObject() {\n        // To reduce snapshot/ops size, we serialize a TextSegment as a plain 'string' if it is\n        // not annotated.\n        return this.properties\n            ? { text: this.text, props: this.properties }\n            : this.text;\n    }\n    clone(start = 0, end) {\n        const text = this.text.substring(start, end);\n        const b = TextSegment.make(text, this.properties);\n        this.cloneInto(b);\n        return b;\n    }\n    canAppend(segment) {\n        return !this.text.endsWith(\"\\n\")\n            && TextSegment.is(segment)\n            && (this.cachedLength <= MergeTree.TextSegmentGranularity ||\n                segment.cachedLength <= MergeTree.TextSegmentGranularity);\n    }\n    toString() {\n        return this.text;\n    }\n    append(segment) {\n        if (TextSegment.is(segment)) {\n            // Note: Must call 'appendLocalRefs' before modifying this segment's length as\n            // 'this.cachedLength' is used to adjust the offsets of the local refs.\n            LocalReferenceCollection.append(this, segment);\n            this.text += segment.text;\n            this.cachedLength = this.text.length;\n        }\n        else {\n            throw new Error(\"can only append text segment\");\n        }\n    }\n    // TODO: retain removed text for undo\n    // returns true if entire string removed\n    removeRange(start, end) {\n        let remnantString = \"\";\n        const len = this.text.length;\n        if (start > 0) {\n            remnantString += this.text.substring(0, start);\n        }\n        if (end < len) {\n            remnantString += this.text.substring(end);\n        }\n        this.text = remnantString;\n        this.cachedLength = remnantString.length;\n        return (remnantString.length === 0);\n    }\n    createSplitSegmentAt(pos) {\n        if (pos > 0) {\n            const remainingText = this.text.substring(pos);\n            this.text = this.text.substring(0, pos);\n            this.cachedLength = this.text.length;\n            const leafSegment = new TextSegment(remainingText);\n            return leafSegment;\n        }\n    }\n}\nTextSegment.type = \"TextSegment\";\nfunction isTextAndMarkerAccumulator(accum) {\n    return accum.parallelArrays === true;\n}\nexport class MergeTreeTextHelper {\n    constructor(mergeTree) {\n        this.mergeTree = mergeTree;\n        this.gatherText = (segment, pos, refSeq, clientId, start, end, accumText) => {\n            let _start = start;\n            if (TextSegment.is(segment)) {\n                if (MergeTree.traceGatherText) {\n                    console.log(\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    `@cli ${this.mergeTree.getLongClientId(this.mergeTree.collabWindow.clientId)} ` +\n                        `gather seg seq ${segment.seq} rseq ${segment.removedSeq} text ${segment.text}`);\n                }\n                let beginTags = \"\";\n                let endTags = \"\";\n                if (isTextAndMarkerAccumulator(accumText)) {\n                    // TODO: let clients pass in function to get tag\n                    const tags = [];\n                    const initTags = [];\n                    if (segment.properties && (segment.properties[\"font-weight\"])) {\n                        tags.push(\"b\");\n                    }\n                    if (segment.properties && (segment.properties[\"text-decoration\"])) {\n                        tags.push(\"u\");\n                    }\n                    const remTags = [];\n                    if (tags.length > 0) {\n                        for (const tag of tags) {\n                            if (!accumText.tagsInProgress.includes(tag)) {\n                                beginTags += `<${tag}>`;\n                                initTags.push(tag);\n                            }\n                        }\n                        for (const accumTag of accumText.tagsInProgress) {\n                            if (!tags.includes(accumTag)) {\n                                endTags += `</${accumTag}>`;\n                                remTags.push(accumTag);\n                            }\n                        }\n                        for (const initTag of initTags.reverse()) {\n                            accumText.tagsInProgress.push(initTag);\n                        }\n                    }\n                    else {\n                        for (const accumTag of accumText.tagsInProgress) {\n                            endTags += `</${accumTag}>`;\n                            remTags.push(accumTag);\n                        }\n                    }\n                    for (const remTag of remTags) {\n                        const remdex = accumText.tagsInProgress.indexOf(remTag);\n                        if (remdex >= 0) {\n                            accumText.tagsInProgress.splice(remdex, 1);\n                        }\n                    }\n                }\n                accumText.textSegment.text += endTags;\n                accumText.textSegment.text += beginTags;\n                if ((_start <= 0) && (end >= segment.text.length)) {\n                    accumText.textSegment.text += segment.text;\n                }\n                else {\n                    if (_start < 0) {\n                        _start = 0;\n                    }\n                    if (end >= segment.text.length) {\n                        accumText.textSegment.text += segment.text.substring(_start);\n                    }\n                    else {\n                        accumText.textSegment.text += segment.text.substring(_start, end);\n                    }\n                }\n            }\n            else {\n                if (accumText.placeholder && (accumText.placeholder.length > 0)) {\n                    if (accumText.placeholder === \"*\") {\n                        const marker = segment;\n                        accumText.textSegment.text += `\\n${marker.toString()}`;\n                    }\n                    else {\n                        for (let i = 0; i < segment.cachedLength; i++) {\n                            accumText.textSegment.text += accumText.placeholder;\n                        }\n                    }\n                }\n                else if (isTextAndMarkerAccumulator(accumText)) {\n                    const marker = segment;\n                    if (marker.hasTileLabel(accumText.parallelMarkerLabel)) {\n                        accumText.parallelMarkers.push(marker);\n                        accumText.parallelText.push(accumText.textSegment.text);\n                        accumText.textSegment.text = \"\";\n                    }\n                }\n            }\n            return true;\n        };\n    }\n    getTextAndMarkers(refSeq, clientId, label, start, end) {\n        const range = this.getValidRange(start, end, refSeq, clientId);\n        const accum = {\n            parallelArrays: true,\n            parallelMarkerLabel: label,\n            parallelMarkers: [],\n            parallelText: [],\n            tagsInProgress: [],\n            textSegment: new TextSegment(\"\"),\n        };\n        if (MergeTree.traceGatherText) {\n            console.log(`get text on cli ${glc(this.mergeTree, this.mergeTree.collabWindow.clientId)} ` +\n                `ref cli ${glc(this.mergeTree, clientId)} refSeq ${refSeq}`);\n        }\n        this.mergeTree.mapRange({ leaf: this.gatherText }, refSeq, clientId, accum, range.start, range.end);\n        return { parallelText: accum.parallelText, parallelMarkers: accum.parallelMarkers };\n    }\n    getText(refSeq, clientId, placeholder = \"\", start, end) {\n        const range = this.getValidRange(start, end, refSeq, clientId);\n        const accum = { textSegment: new TextSegment(\"\"), placeholder };\n        if (MergeTree.traceGatherText) {\n            console.log(`get text on cli ${glc(this.mergeTree, this.mergeTree.collabWindow.clientId)} ` +\n                `ref cli ${glc(this.mergeTree, clientId)} refSeq ${refSeq}`);\n        }\n        this.mergeTree.mapRange({ leaf: this.gatherText }, refSeq, clientId, accum, range.start, range.end);\n        return accum.textSegment.text;\n    }\n    getValidRange(start, end, refSeq, clientId) {\n        const range = {\n            end: end !== null && end !== void 0 ? end : this.mergeTree.getLength(refSeq, clientId),\n            start: start !== null && start !== void 0 ? start : 0,\n        };\n        return range;\n    }\n}\n//# sourceMappingURL=textSegment.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { FileMode, TreeEntry, } from \"@fluidframework/protocol-definitions\";\nimport { unreachableCase } from \"@fluidframework/common-utils\";\n/**\n * Take a summary object and returns its git mode.\n *\n * @param value - summary object\n * @returns the git mode of summary object\n */\nexport function getGitMode(value) {\n    const type = value.type === 3 /* Handle */ ? value.handleType : value.type;\n    switch (type) {\n        case 2 /* Blob */:\n        case 4 /* Attachment */:\n            return FileMode.File;\n        case 1 /* Tree */:\n            return FileMode.Directory;\n        default:\n            unreachableCase(type, `Unknown type: ${type}`);\n    }\n}\n/**\n * Take a summary object and returns its type.\n *\n * @param value - summary object\n * @returns the type of summary object\n */\nexport function getGitType(value) {\n    const type = value.type === 3 /* Handle */ ? value.handleType : value.type;\n    switch (type) {\n        case 2 /* Blob */:\n        case 4 /* Attachment */:\n            return \"blob\";\n        case 1 /* Tree */:\n            return \"tree\";\n        default:\n            unreachableCase(type, `Unknown type: ${type}`);\n    }\n}\n/**\n * Build a tree hierarchy base on a flat tree\n *\n * @param flatTree - a flat tree\n * @param blobsShaToPathCache - Map with blobs sha as keys and values as path of the blob.\n * @returns the hierarchical tree\n */\nexport function buildHierarchy(flatTree, blobsShaToPathCache = new Map()) {\n    const lookup = {};\n    const root = { id: flatTree.sha, blobs: {}, commits: {}, trees: {} };\n    lookup[\"\"] = root;\n    for (const entry of flatTree.tree) {\n        const lastIndex = entry.path.lastIndexOf(\"/\");\n        const entryPathDir = entry.path.slice(0, Math.max(0, lastIndex));\n        const entryPathBase = entry.path.slice(lastIndex + 1);\n        // The flat output is breadth-first so we can assume we see tree nodes prior to their contents\n        const node = lookup[entryPathDir];\n        // Add in either the blob or tree\n        if (entry.type === \"tree\") {\n            const newTree = { id: entry.sha, blobs: {}, commits: {}, trees: {} };\n            node.trees[decodeURIComponent(entryPathBase)] = newTree;\n            lookup[entry.path] = newTree;\n        }\n        else if (entry.type === \"blob\") {\n            node.blobs[decodeURIComponent(entryPathBase)] = entry.sha;\n            blobsShaToPathCache.set(entry.sha, `/${entry.path}`);\n        }\n        else if (entry.type === \"commit\") {\n            node.commits[decodeURIComponent(entryPathBase)] = entry.sha;\n        }\n    }\n    return root;\n}\n/**\n * Basic implementation of a blob ITreeEntry\n */\nexport class BlobTreeEntry {\n    /**\n     * Creates a blob ITreeEntry\n     * @param path - path of entry\n     * @param contents - blob contents\n     * @param encoding - encoding of contents; defaults to utf-8\n     */\n    constructor(path, contents, encoding = \"utf-8\") {\n        this.path = path;\n        this.mode = FileMode.File;\n        this.type = TreeEntry.Blob;\n        this.value = { contents, encoding };\n    }\n}\n/**\n * Basic implementation of a commit ITreeEntry\n */\nexport class CommitTreeEntry {\n    /**\n     * Creates a commit ITreeEntry\n     * @param path - path of entry\n     * @param value - commit value\n     */\n    constructor(path, value) {\n        this.path = path;\n        this.value = value;\n        this.mode = FileMode.Commit;\n        this.type = TreeEntry.Commit;\n    }\n}\n/**\n * Basic implementation of a tree ITreeEntry\n */\nexport class TreeTreeEntry {\n    /**\n     * Creates a tree ITreeEntry\n     * @param path - path of entry\n     * @param value - subtree\n     */\n    constructor(path, value) {\n        this.path = path;\n        this.value = value;\n        this.mode = FileMode.Directory;\n        this.type = TreeEntry.Tree;\n    }\n}\n/**\n * Basic implementation of an attachment ITreeEntry\n */\nexport class AttachmentTreeEntry {\n    /**\n     * Creates an attachment ITreeEntry\n     * @param path - path of entry\n     * @param id - id of external blob attachment\n     */\n    constructor(path, id) {\n        this.path = path;\n        this.id = id;\n        this.mode = FileMode.File;\n        this.type = TreeEntry.Attachment;\n        this.value = { id };\n    }\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function addBlobToTree(tree, blobName, content) {\n    tree.entries.push({\n        mode: FileMode.File,\n        path: blobName,\n        type: TreeEntry.Blob,\n        value: {\n            contents: JSON.stringify(content),\n            encoding: \"utf-8\",\n        },\n    });\n}\n//# sourceMappingURL=blobs.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { MessageType, } from \"@fluidframework/protocol-definitions\";\nimport { Quorum } from \"./quorum\";\nexport function isSystemMessage(message) {\n    switch (message.type) {\n        case MessageType.ClientJoin:\n        case MessageType.ClientLeave:\n        case MessageType.Propose:\n        case MessageType.Reject:\n        case MessageType.NoOp:\n        case MessageType.NoClient:\n        case MessageType.Summarize:\n        case MessageType.SummaryAck:\n        case MessageType.SummaryNack:\n            return true;\n        default:\n            return false;\n    }\n}\n/**\n * Handles protocol specific ops.\n */\nexport class ProtocolOpHandler {\n    constructor(minimumSequenceNumber, sequenceNumber, term, members, proposals, values, sendProposal, sendReject) {\n        this.minimumSequenceNumber = minimumSequenceNumber;\n        this.sequenceNumber = sequenceNumber;\n        this.term = term !== null && term !== void 0 ? term : 1;\n        this.quorum = new Quorum(minimumSequenceNumber, members, proposals, values, sendProposal, sendReject);\n    }\n    close() {\n        this.quorum.close();\n    }\n    processMessage(message, local) {\n        let immediateNoOp = false;\n        switch (message.type) {\n            case MessageType.ClientJoin:\n                const systemJoinMessage = message;\n                const join = JSON.parse(systemJoinMessage.data);\n                const member = {\n                    client: join.detail,\n                    sequenceNumber: systemJoinMessage.sequenceNumber,\n                };\n                this.quorum.addMember(join.clientId, member);\n                break;\n            case MessageType.ClientLeave:\n                const systemLeaveMessage = message;\n                const clientId = JSON.parse(systemLeaveMessage.data);\n                this.quorum.removeMember(clientId);\n                break;\n            case MessageType.Propose:\n                const proposal = message.contents;\n                this.quorum.addProposal(proposal.key, proposal.value, message.sequenceNumber, local, message.clientSequenceNumber);\n                // On a quorum proposal, immediately send a response to expedite the approval.\n                immediateNoOp = true;\n                break;\n            case MessageType.Reject:\n                const sequenceNumber = message.contents;\n                this.quorum.rejectProposal(message.clientId, sequenceNumber);\n                break;\n            default:\n        }\n        // Update tracked sequence numbers\n        this.minimumSequenceNumber = message.minimumSequenceNumber;\n        this.sequenceNumber = message.sequenceNumber;\n        // Notify the quorum of the MSN from the message. We rely on it to handle duplicate values but may\n        // want to move that logic to this class.\n        immediateNoOp = this.quorum.updateMinimumSequenceNumber(message) || immediateNoOp;\n        return { immediateNoOp };\n    }\n    getProtocolState() {\n        const quorumSnapshot = this.quorum.snapshot();\n        return {\n            members: quorumSnapshot.members,\n            minimumSequenceNumber: this.minimumSequenceNumber,\n            proposals: quorumSnapshot.proposals,\n            sequenceNumber: this.sequenceNumber,\n            values: quorumSnapshot.values,\n        };\n    }\n}\n//# sourceMappingURL=protocol.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n// eslint-disable-next-line import/no-internal-modules\nimport cloneDeep from \"lodash/cloneDeep\";\nimport { assert, Deferred, doIfNotDisposed, EventForwarder, TypedEventEmitter } from \"@fluidframework/common-utils\";\n/**\n * Appends a deferred and rejection count to a sequenced proposal. For locally generated promises this allows us to\n * attach a Deferred which we will resolve once the proposal is either accepted or rejected.\n */\nclass PendingProposal {\n    constructor(sendReject, sequenceNumber, key, value, rejections, deferred) {\n        this.sendReject = sendReject;\n        this.sequenceNumber = sequenceNumber;\n        this.key = key;\n        this.value = value;\n        this.deferred = deferred;\n        this.canReject = true;\n        this.rejections = new Set(rejections);\n    }\n    reject() {\n        if (!this.canReject) {\n            throw new Error(\"Can no longer reject this proposal\");\n        }\n        this.sendReject(this.sequenceNumber);\n    }\n    get rejectionDisabled() {\n        return !this.canReject;\n    }\n    disableRejection() {\n        this.canReject = false;\n    }\n    addRejection(clientId) {\n        assert(!this.rejections.has(clientId), 0x1cd /* `!this.rejections.has(${clientId})` */);\n        this.rejections.add(clientId);\n    }\n}\n/**\n * A quorum represents all clients currently within the collaboration window. As well as the values\n * they have agreed upon and any pending proposals.\n */\nexport class Quorum extends TypedEventEmitter {\n    constructor(minimumSequenceNumber, members, proposals, values, sendProposal, sendReject) {\n        super();\n        this.minimumSequenceNumber = minimumSequenceNumber;\n        this.sendProposal = sendProposal;\n        this.sendReject = sendReject;\n        this.isDisposed = false;\n        // Locally generated proposals\n        this.localProposals = new Map();\n        this.members = new Map(members);\n        this.proposals = new Map(proposals.map(([, proposal, rejections]) => {\n            return [\n                proposal.sequenceNumber,\n                new PendingProposal(this.sendReject, proposal.sequenceNumber, proposal.key, proposal.value, rejections),\n            ];\n        }));\n        this.values = new Map(values);\n        this.pendingCommit = new Map(values\n            .filter((value) => value[1].commitSequenceNumber === -1));\n    }\n    get disposed() { return this.isDisposed; }\n    close() {\n        this.removeAllListeners();\n    }\n    snapshot() {\n        const serializedProposals = Array.from(this.proposals).map(([sequenceNumber, proposal]) => [\n            sequenceNumber,\n            { sequenceNumber, key: proposal.key, value: proposal.value },\n            Array.from(proposal.rejections)\n        ]);\n        const snapshot = {\n            members: [...this.members],\n            proposals: serializedProposals,\n            values: [...this.values],\n        };\n        return cloneDeep(snapshot);\n    }\n    /**\n     * Returns whether the quorum has achieved a consensus for the given key.\n     */\n    has(key) {\n        return this.values.has(key);\n    }\n    /**\n     * Returns the consensus value for the given key\n     */\n    get(key) {\n        const keyMap = this.values.get(key);\n        if (keyMap !== undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return keyMap.value;\n        }\n    }\n    /**\n     * Returns additional data about the approved consensus value\n     */\n    getApprovalData(key) {\n        const proposal = this.values.get(key);\n        return proposal ? cloneDeep(proposal) : undefined;\n    }\n    /**\n     * Adds a new client to the quorum\n     */\n    addMember(clientId, details) {\n        assert(!this.members.has(clientId), 0x1ce /* `!this.members.has(${clientId})` */);\n        this.members.set(clientId, details);\n        this.emit(\"addMember\", clientId, details);\n    }\n    /**\n     * Removes a client from the quorum\n     */\n    removeMember(clientId) {\n        assert(this.members.has(clientId), 0x1cf /* `this.members.has(${clientId})` */);\n        this.members.delete(clientId);\n        this.emit(\"removeMember\", clientId);\n    }\n    /**\n     * Retrieves all the members in the quorum\n     */\n    getMembers() {\n        return new Map(this.members);\n    }\n    /**\n     * Retrieves a specific member of the quorum\n     */\n    getMember(clientId) {\n        return this.members.get(clientId);\n    }\n    /**\n     * Proposes a new value. Returns a promise that will resolve when the proposal is either accepted or rejected.\n     *\n     * TODO: Right now we will only submit proposals for connected clients and not attempt to resubmit on any\n     * nack/disconnect. The correct answer for this should become more clear as we build scenarios on top of the loader.\n     */\n    async propose(key, value) {\n        const clientSequenceNumber = this.sendProposal(key, value);\n        if (clientSequenceNumber < 0) {\n            this.emit(\"error\", { eventName: \"ProposalInDisconnectedState\", key });\n            return Promise.reject(new Error(\"Can't proposal in disconnected state\"));\n        }\n        const deferred = new Deferred();\n        this.localProposals.set(clientSequenceNumber, deferred);\n        return deferred.promise;\n    }\n    /**\n     * Begins tracking a new proposal\n     */\n    addProposal(key, value, sequenceNumber, local, clientSequenceNumber) {\n        assert(!this.proposals.has(sequenceNumber), 0x1d0 /* `!this.proposals.has(${sequenceNumber})` */);\n        assert(!local || this.localProposals.has(clientSequenceNumber), 0x1d1 /* `!${local} || this.localProposals.has(${clientSequenceNumber})` */);\n        const proposal = new PendingProposal(this.sendReject, sequenceNumber, key, value, [], local ? this.localProposals.get(clientSequenceNumber) : undefined);\n        this.proposals.set(sequenceNumber, proposal);\n        // Emit the event - which will also provide clients an opportunity to reject the proposal. We require\n        // clients to make a rejection decision at the time of receiving the proposal and so disable rejecting it\n        // after we have emitted the event.\n        this.emit(\"addProposal\", proposal);\n        proposal.disableRejection();\n        if (local) {\n            this.localProposals.delete(clientSequenceNumber);\n        }\n    }\n    /**\n     * Rejects the given proposal\n     */\n    rejectProposal(clientId, sequenceNumber) {\n        // Proposals require unanimous approval so any rejection results in a rejection of the proposal. For error\n        // detection we will keep a rejected proposal in the pending list until the MSN advances so that we can\n        // track the total number of rejections.\n        assert(this.proposals.has(sequenceNumber), 0x1d2 /* `this.proposals.has(${sequenceNumber})` */);\n        const proposal = this.proposals.get(sequenceNumber);\n        if (proposal !== undefined) {\n            proposal.addRejection(clientId);\n        }\n        // We will emit approval and rejection messages once the MSN advances past the sequence number of the\n        // proposal. This will allow us to convey all clients who rejected the proposal.\n        return;\n    }\n    /**\n     * Updates the minimum sequence number. If the MSN advances past the sequence number for any proposal without\n     * a rejection then it becomes an accepted consensus value.  If the MSN advances past the sequence number\n     * that the proposal was accepted, then it becomes a committed consensus value.\n     * Returns true if immediate no-op is required.\n     */\n    updateMinimumSequenceNumber(message) {\n        const value = message.minimumSequenceNumber;\n        if (this.minimumSequenceNumber !== undefined) {\n            if (value < this.minimumSequenceNumber) {\n                this.emit(\"error\", {\n                    currentValue: this.minimumSequenceNumber,\n                    eventName: \"QuorumMinSeqNumberError\",\n                    newValue: value,\n                });\n            }\n            if (value <= this.minimumSequenceNumber) {\n                return false;\n            }\n        }\n        this.minimumSequenceNumber = value;\n        let immediateNoOp = false;\n        // Accept proposals and reject proposals whose sequenceNumber is <= the minimumSequenceNumber\n        // Return a sorted list of approved proposals. We sort so that we apply them in their sequence number order\n        // TODO this can be optimized if necessary to avoid the linear search+sort\n        const completed = [];\n        for (const [sequenceNumber, proposal] of this.proposals) {\n            if (sequenceNumber <= this.minimumSequenceNumber) {\n                completed.push(proposal);\n            }\n        }\n        completed.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n        for (const proposal of completed) {\n            const approved = proposal.rejections.size === 0;\n            // If it was a local proposal - resolve the promise\n            if (proposal.deferred) {\n                // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                approved\n                    ? proposal.deferred.resolve()\n                    : proposal.deferred.reject(`Rejected by ${Array.from(proposal.rejections)}`);\n            }\n            if (approved) {\n                const committedProposal = {\n                    approvalSequenceNumber: message.sequenceNumber,\n                    commitSequenceNumber: -1,\n                    key: proposal.key,\n                    sequenceNumber: proposal.sequenceNumber,\n                    value: proposal.value,\n                };\n                // TODO do we want to notify when a proposal doesn't make it to the commit phase - i.e. because\n                // a new proposal was made before it made it to the committed phase? For now we just will never\n                // emit this message\n                this.values.set(committedProposal.key, committedProposal);\n                this.pendingCommit.set(committedProposal.key, committedProposal);\n                // Send no-op on approval to expedite commit\n                // accept means that all clients have seen the proposal and nobody has rejected it\n                // commit means that all clients have seen that the proposal was accepted by everyone\n                immediateNoOp = true;\n                this.emit(\"approveProposal\", committedProposal.sequenceNumber, committedProposal.key, committedProposal.value, committedProposal.approvalSequenceNumber);\n            }\n            else {\n                this.emit(\"rejectProposal\", proposal.sequenceNumber, proposal.key, proposal.value, Array.from(proposal.rejections));\n            }\n            this.proposals.delete(proposal.sequenceNumber);\n        }\n        // Move values to the committed stage and notify\n        if (this.pendingCommit.size > 0) {\n            Array.from(this.pendingCommit.values())\n                .filter((pendingCommit) => pendingCommit.approvalSequenceNumber <= value)\n                .sort((a, b) => a.sequenceNumber - b.sequenceNumber)\n                .forEach((pendingCommit) => {\n                pendingCommit.commitSequenceNumber = message.sequenceNumber;\n                this.emit(\"commitProposal\", pendingCommit.sequenceNumber, pendingCommit.key, pendingCommit.value, pendingCommit.approvalSequenceNumber, pendingCommit.commitSequenceNumber);\n                this.pendingCommit.delete(pendingCommit.key);\n            });\n        }\n        return immediateNoOp;\n    }\n    setConnectionState(connected, clientId) {\n        if (!connected) {\n            this.localProposals.forEach((deferral) => {\n                deferral.reject(new Error(\"Client got disconnected\"));\n            });\n            this.localProposals.clear();\n        }\n    }\n    dispose() {\n        throw new Error(\"Not implemented.\");\n        this.isDisposed = true;\n    }\n}\n/**\n * Proxies Quorum events.\n */\nexport class QuorumProxy extends EventForwarder {\n    constructor(quorum) {\n        super(quorum);\n        this.propose = doIfNotDisposed(this, quorum.propose.bind(quorum));\n        this.has = doIfNotDisposed(this, quorum.has.bind(quorum));\n        this.get = doIfNotDisposed(this, quorum.get.bind(quorum));\n        this.getApprovalData = doIfNotDisposed(this, quorum.getApprovalData.bind(quorum));\n        this.getMembers = doIfNotDisposed(this, quorum.getMembers.bind(quorum));\n        this.getMember = doIfNotDisposed(this, quorum.getMember.bind(quorum));\n    }\n}\n//# sourceMappingURL=quorum.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nexport var MessageType;\n(function (MessageType) {\n    // Empty operation message. Used to send an updated reference sequence number.\n    MessageType[\"NoOp\"] = \"noop\";\n    // System message sent to indicate a new client has joined the collaboration\n    MessageType[\"ClientJoin\"] = \"join\";\n    // System message sent to indicate a client has left the collaboration\n    MessageType[\"ClientLeave\"] = \"leave\";\n    // Proposes a new consensus value\n    MessageType[\"Propose\"] = \"propose\";\n    // Message used to reject a pending proposal\n    MessageType[\"Reject\"] = \"reject\";\n    // Summary op\n    MessageType[\"Summarize\"] = \"summarize\";\n    // Summary op written\n    MessageType[\"SummaryAck\"] = \"summaryAck\";\n    // Summary op write failure\n    MessageType[\"SummaryNack\"] = \"summaryNack\";\n    // Channel operation.\n    MessageType[\"Operation\"] = \"op\";\n    // Forced snapshot\n    MessageType[\"Save\"] = \"saveOp\";\n    // Message to indicate the need of a remote agent for a document.\n    MessageType[\"RemoteHelp\"] = \"remoteHelp\";\n    // Message to indicate that no active clients are present.\n    MessageType[\"NoClient\"] = \"noClient\";\n    // Message to indicate successful round trip.\n    MessageType[\"RoundTrip\"] = \"tripComplete\";\n    // Service specific control messages that are never sequenced.\n    MessageType[\"Control\"] = \"control\";\n})(MessageType || (MessageType = {}));\n/**\n * Type of the Nack.\n * InvalidScopeError: Client's token is not valid for the intended op.\n * ThrottlingError: Retryable after retryAfter number.\n * BadRequestError: Clients op is invalid and should retry immediately with a valid op.\n * LimitExceededError: Service is having issues. Client should not retry.\n */\nexport var NackErrorType;\n(function (NackErrorType) {\n    NackErrorType[\"ThrottlingError\"] = \"ThrottlingError\";\n    NackErrorType[\"InvalidScopeError\"] = \"InvalidScopeError\";\n    NackErrorType[\"BadRequestError\"] = \"BadRequestError\";\n    NackErrorType[\"LimitExceededError\"] = \"LimitExceededError\";\n})(NackErrorType || (NackErrorType = {}));\n//# sourceMappingURL=protocol.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nexport var ScopeType;\n(function (ScopeType) {\n    ScopeType[\"DocRead\"] = \"doc:read\";\n    ScopeType[\"DocWrite\"] = \"doc:write\";\n    ScopeType[\"SummaryWrite\"] = \"summary:write\";\n})(ScopeType || (ScopeType = {}));\n//# sourceMappingURL=scopes.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nexport var FileMode;\n(function (FileMode) {\n    FileMode[\"File\"] = \"100644\";\n    FileMode[\"Executable\"] = \"100755\";\n    FileMode[\"Directory\"] = \"040000\";\n    FileMode[\"Commit\"] = \"160000\";\n    FileMode[\"Symlink\"] = \"120000\";\n})(FileMode || (FileMode = {}));\n/**\n * Type of entries that can be stored in a tree\n */\nexport var TreeEntry;\n(function (TreeEntry) {\n    TreeEntry[\"Blob\"] = \"Blob\";\n    TreeEntry[\"Commit\"] = \"Commit\";\n    TreeEntry[\"Tree\"] = \"Tree\";\n    TreeEntry[\"Attachment\"] = \"Attachment\";\n})(TreeEntry || (TreeEntry = {}));\n//# sourceMappingURL=storage.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, bufferToString, unreachableCase } from \"@fluidframework/common-utils\";\nimport { FileMode, MessageType, TreeEntry, } from \"@fluidframework/protocol-definitions\";\nimport { SharedObject } from \"@fluidframework/shared-object-base\";\nimport { ConsensusRegisterCollectionFactory } from \"./consensusRegisterCollectionFactory\";\nimport { debug } from \"./debug\";\nimport { ReadPolicy } from \"./interfaces\";\nconst newLocalRegister = (sequenceNumber, value) => ({\n    sequenceNumber,\n    value: {\n        type: \"Plain\",\n        value,\n    },\n});\n/** Distinguish between incoming op formats so we know which type it is */\nconst incomingOpMatchesCurrentFormat = (op) => \"serializedValue\" in op;\nconst snapshotFileName = \"header\";\n/**\n * Implementation of a consensus register collection\n */\nexport class ConsensusRegisterCollection extends SharedObject {\n    /**\n     * Constructs a new consensus register collection. If the object is non-local an id and service interfaces will\n     * be provided\n     */\n    constructor(id, runtime, attributes) {\n        super(id, runtime, attributes);\n        this.data = new Map();\n    }\n    /**\n     * Create a new consensus register collection\n     *\n     * @param runtime - data store runtime the new consensus register collection belongs to\n     * @param id - optional name of the consensus register collection\n     * @returns newly create consensus register collection (but not attached yet)\n     */\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    static create(runtime, id) {\n        return runtime.createChannel(id, ConsensusRegisterCollectionFactory.Type);\n    }\n    /**\n     * Get a factory for ConsensusRegisterCollection to register with the data store.\n     *\n     * @returns a factory that creates and load ConsensusRegisterCollection\n     */\n    static getFactory() {\n        return new ConsensusRegisterCollectionFactory();\n    }\n    /**\n     * Creates a new register or writes a new value.\n     * Returns a promise that will resolve when the write is acked.\n     *\n     * @returns Promise<true> if write was non-concurrent\n     */\n    async write(key, value) {\n        const serializedValue = this.stringify(value, this.serializer);\n        if (!this.isAttached()) {\n            // JSON-roundtrip value for local writes to match the behavior of going through the wire\n            this.processInboundWrite(key, this.parse(serializedValue, this.serializer), 0, 0, true);\n            return true;\n        }\n        const message = {\n            key,\n            type: \"write\",\n            serializedValue,\n            refSeq: this.runtime.deltaManager.lastSequenceNumber,\n        };\n        return this.newAckBasedPromise((resolve) => {\n            // Send the resolve function as the localOpMetadata. This will be provided back to us when the\n            // op is ack'd.\n            this.submitLocalMessage(message, resolve);\n            // If we fail due to runtime being disposed, it's better to return false then unhandled exception.\n        }).catch((error) => false);\n    }\n    /**\n     * Returns the most recent local value of a register.\n     * @param key - The key to read\n     * @param readPolicy - The ReadPolicy to apply. Defaults to Atomic.\n     */\n    read(key, readPolicy = ReadPolicy.Atomic) {\n        if (readPolicy === ReadPolicy.Atomic) {\n            return this.readAtomic(key);\n        }\n        const versions = this.readVersions(key);\n        if (versions !== undefined) {\n            // We don't support deletion. So there should be at least one value.\n            assert(versions.length > 0, 0x06c /* \"Value should be undefined or non-empty\" */);\n            return versions[versions.length - 1];\n        }\n    }\n    readVersions(key) {\n        const data = this.data.get(key);\n        return data === null || data === void 0 ? void 0 : data.versions.map((element) => element.value.value);\n    }\n    keys() {\n        return [...this.data.keys()];\n    }\n    snapshotCore(serializer) {\n        const dataObj = {};\n        this.data.forEach((v, k) => { dataObj[k] = v; });\n        const tree = {\n            entries: [\n                {\n                    mode: FileMode.File,\n                    path: snapshotFileName,\n                    type: TreeEntry.Blob,\n                    value: {\n                        contents: this.stringify(dataObj, serializer),\n                        encoding: \"utf-8\",\n                    },\n                },\n            ],\n        };\n        return tree;\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n     */\n    async loadCore(storage) {\n        var _a;\n        const blob = await storage.readBlob(snapshotFileName);\n        const header = bufferToString(blob, \"utf8\");\n        const dataObj = this.parse(header, this.serializer);\n        for (const key of Object.keys(dataObj)) {\n            assert(((_a = dataObj[key].atomic) === null || _a === void 0 ? void 0 : _a.value.type) !== \"Shared\", \n            // eslint-disable-next-line max-len\n            0x06d /* \"SharedObjects contained in ConsensusRegisterCollection can no longer be deserialized as of 0.17\" */);\n            this.data.set(key, dataObj[key]);\n        }\n    }\n    registerCore() { }\n    onDisconnect() {\n        debug(`ConsensusRegisterCollection ${this.id} is now disconnected`);\n    }\n    processCore(message, local, localOpMetadata) {\n        if (message.type === MessageType.Operation) {\n            const op = message.contents;\n            switch (op.type) {\n                case \"write\": {\n                    // backward compatibility: File at rest written with runtime <= 0.13 do not have refSeq\n                    // when the refSeq property didn't exist\n                    if (op.refSeq === undefined) {\n                        op.refSeq = message.referenceSequenceNumber;\n                    }\n                    // Message can be delivered with delay - e.g. resubmitted on reconnect.\n                    // Use the refSeq from when the op was created, not when it was transmitted\n                    const refSeqWhenCreated = op.refSeq;\n                    assert(refSeqWhenCreated <= message.referenceSequenceNumber, 0x06e /* \"Message's reference sequence number < op's reference sequence number!\" */);\n                    const value = incomingOpMatchesCurrentFormat(op)\n                        ? this.parse(op.serializedValue, this.serializer)\n                        : op.value.value;\n                    const winner = this.processInboundWrite(op.key, value, refSeqWhenCreated, message.sequenceNumber, local);\n                    if (local) {\n                        // Resolve the pending promise for this operation now that we have received an ack for it.\n                        const resolve = localOpMetadata;\n                        resolve(winner);\n                    }\n                    break;\n                }\n                default: unreachableCase(op.type);\n            }\n        }\n    }\n    readAtomic(key) {\n        const data = this.data.get(key);\n        return data === null || data === void 0 ? void 0 : data.atomic.value.value;\n    }\n    /**\n     * Process an inbound write op\n     * @param key - Key that was written to\n     * @param value - Incoming value\n     * @param refSeq - RefSeq at the time of write on the remote client\n     * @param sequenceNumber - Sequence Number of this write op\n     * @param local - Did this write originate on this client\n     */\n    processInboundWrite(key, value, refSeq, sequenceNumber, local) {\n        let data = this.data.get(key);\n        // Atomic update if it's a new register or the write was not concurrent,\n        // meaning our state was known to the remote client at the time of write\n        const winner = data === undefined || refSeq >= data.atomic.sequenceNumber;\n        if (winner) {\n            const atomicUpdate = newLocalRegister(sequenceNumber, value);\n            if (data === undefined) {\n                data = {\n                    atomic: atomicUpdate,\n                    versions: [],\n                };\n                this.data.set(key, data);\n            }\n            else {\n                data.atomic = atomicUpdate;\n            }\n        }\n        else {\n            assert(!!data, 0x06f /* \"data missing for non-atomic inbound update!\" */);\n        }\n        // Remove versions that were known to the remote client at the time of write\n        while (data.versions.length > 0 && refSeq >= data.versions[0].sequenceNumber) {\n            data.versions.shift();\n        }\n        const versionUpdate = newLocalRegister(sequenceNumber, value);\n        // Asserts for data integrity\n        if (!this.isAttached()) {\n            assert(refSeq === 0 && sequenceNumber === 0, 0x070 /* \"sequence numbers are expected to be 0 when unattached\" */);\n        }\n        else if (data.versions.length > 0) {\n            assert(sequenceNumber > data.versions[data.versions.length - 1].sequenceNumber, 0x071 /* \"Versions should naturally be ordered by sequenceNumber\" */);\n        }\n        // Push the new element.\n        data.versions.push(versionUpdate);\n        // Raise events at the end, to avoid reentrancy issues\n        if (winner) {\n            this.emit(\"atomicChanged\", key, value, local);\n        }\n        this.emit(\"versionChanged\", key, value, local);\n        return winner;\n    }\n    stringify(value, serializer) {\n        return serializer.stringify(value, this.handle);\n    }\n    parse(content, serializer) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return serializer.parse(content);\n    }\n    applyStashedOp() {\n        // empty implementation\n        return () => { };\n    }\n}\n//# sourceMappingURL=consensusRegisterCollection.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { ConsensusRegisterCollection } from \"./consensusRegisterCollection\";\nimport { pkgVersion } from \"./packageVersion\";\n/**\n * The factory that defines the consensus queue\n */\nexport class ConsensusRegisterCollectionFactory {\n    get type() {\n        return ConsensusRegisterCollectionFactory.Type;\n    }\n    get attributes() {\n        return ConsensusRegisterCollectionFactory.Attributes;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n     */\n    async load(runtime, id, services, attributes) {\n        const collection = new ConsensusRegisterCollection(id, runtime, attributes);\n        await collection.load(services);\n        return collection;\n    }\n    create(document, id) {\n        const collection = new ConsensusRegisterCollection(id, document, ConsensusRegisterCollectionFactory.Attributes);\n        collection.initializeLocal();\n        return collection;\n    }\n}\nConsensusRegisterCollectionFactory.Type = \"https://graph.microsoft.com/types/consensus-register-collection\";\nConsensusRegisterCollectionFactory.Attributes = {\n    type: ConsensusRegisterCollectionFactory.Type,\n    snapshotFormatVersion: \"0.1\",\n    packageVersion: pkgVersion,\n};\n//# sourceMappingURL=consensusRegisterCollectionFactory.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport registerDebug from \"debug\";\nimport { pkgName, pkgVersion } from \"./packageVersion\";\nexport const debug = registerDebug(\"fluid:consensus-register-collection\");\ndebug(`Package: ${pkgName} - Version: ${pkgVersion}`);\n//# sourceMappingURL=debug.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Read policies used when reading the map value.\n */\nexport var ReadPolicy;\n(function (ReadPolicy) {\n    // On a concurrent update, returns the first agreed upon value amongst all clients.\n    ReadPolicy[ReadPolicy[\"Atomic\"] = 0] = \"Atomic\";\n    // Last writer wins. Simply returns the last written value.\n    ReadPolicy[ReadPolicy[\"LWW\"] = 1] = \"LWW\";\n})(ReadPolicy || (ReadPolicy = {}));\n//# sourceMappingURL=interfaces.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n *\n * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n */\nexport const pkgName = \"@fluidframework/register-collection\";\nexport const pkgVersion = \"0.37.4\";\n//# sourceMappingURL=packageVersion.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\n/**\n * @deprecated - please avoid adding new references to this API!\n * It exposes internal container guts to external world, which is not ideal.\n * It also relies heavily on internal routing schema (formation of handle URIs) which will change in future\n * And last, but not least, it does not allow any policy to be implemented around GC of data stores exposed\n * through internal URIs. I.e. if there are no other references to such objects, they will be GC'd and\n * external links would get broken. Maybe that's what is needed in some cases, but better, more centralized\n * handling of external URI to internal handle is required (in future, we will support weak handle references,\n * that will allow any GC policy to be implemented by container authors.)\n */\nexport const innerRequestHandler = async (request, runtime) => runtime.IFluidHandleContext.resolveHandle(request);\nexport const createFluidObjectResponse = (fluidObject) => {\n    return { status: 200, mimeType: \"fluid/object\", value: fluidObject };\n};\nclass LegacyUriHandle {\n    constructor(absolutePath, runtime) {\n        this.absolutePath = absolutePath;\n        this.runtime = runtime;\n        this.isAttached = true;\n    }\n    get IFluidHandle() { return this; }\n    attachGraph() {\n        assert(false, 0x0ca /* \"Trying to use legacy graph attach!\" */);\n    }\n    async get() {\n        const response = await this.runtime.IFluidHandleContext.resolveHandle({ url: this.absolutePath });\n        if (response.status === 200 && response.mimeType === \"fluid/object\") {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return response.value;\n        }\n        throw new Error(`Failed to resolve container path ${this.absolutePath}`);\n    }\n    bind(handle) {\n        throw new Error(\"Cannot bind to LegacyUriHandle\");\n    }\n}\n// eslint-disable-next-line prefer-arrow/prefer-arrow-functions\nexport function handleFromLegacyUri(uri, runtime) {\n    return new LegacyUriHandle(uri, runtime);\n}\n//# sourceMappingURL=requestHandlers.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { RequestParser, create404Response } from \"@fluidframework/runtime-utils\";\n/**\n  * The RuntimeRequestHandlerBuilder creates a runtime request handler based on request handlers.\n  * The provided handlers sequentially applied until one is able to satisfy the request.\n  */\nexport class RuntimeRequestHandlerBuilder {\n    constructor() {\n        this.handlers = [];\n    }\n    pushHandler(...handlers) {\n        if (handlers !== undefined) {\n            this.handlers.push(...handlers);\n        }\n    }\n    async handleRequest(request, runtime) {\n        const parser = RequestParser.create(request);\n        for (const handler of this.handlers) {\n            const response = await handler(parser, runtime);\n            if (response !== undefined) {\n                return response;\n            }\n        }\n        return create404Response(request);\n    }\n}\nexport function buildRuntimeRequestHandler(...handlers) {\n    const builder = new RuntimeRequestHandlerBuilder();\n    builder.pushHandler(...handlers);\n    return async (request, runtime) => builder.handleRequest(request, runtime);\n}\n//# sourceMappingURL=runtimeRequestHandlerBuilder.js.map","\"use strict\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlushMode = void 0;\n/**\n * Runtime flush mode handling\n */\nvar FlushMode;\n(function (FlushMode) {\n    /**\n     * In automatic flush mode the runtime will immediately send all operations to the driver layer.\n     */\n    FlushMode[FlushMode[\"Automatic\"] = 0] = \"Automatic\";\n    /**\n     * When in manual flush mode the runtime will buffer operations in the current turn and send them as a single\n     * batch at the end of the turn. The flush call on the runtime can be used to force send the current batch.\n     */\n    FlushMode[FlushMode[\"Manual\"] = 1] = \"Manual\";\n})(FlushMode = exports.FlushMode || (exports.FlushMode = {}));\n//# sourceMappingURL=dataStoreContext.js.map","\"use strict\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IFluidDataStoreFactory = void 0;\nexports.IFluidDataStoreFactory = \"IFluidDataStoreFactory\";\n//# sourceMappingURL=dataStoreFactory.js.map","\"use strict\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IFluidDataStoreRegistry = void 0;\nexports.IFluidDataStoreRegistry = \"IFluidDataStoreRegistry\";\n//# sourceMappingURL=dataStoreRegistry.js.map","\"use strict\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.gcBlobKey = void 0;\n// The key to use for storing garbage collection blob in summary.\nexports.gcBlobKey = \"gc\";\n//# sourceMappingURL=garbageCollection.js.map","\"use strict\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./dataStoreFactory\"), exports);\n__exportStar(require(\"./dataStoreRegistry\"), exports);\n__exportStar(require(\"./dataStoreContext\"), exports);\n__exportStar(require(\"./garbageCollection\"), exports);\n__exportStar(require(\"./protocol\"), exports);\n__exportStar(require(\"./summary\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=protocol.js.map","\"use strict\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.channelsTreeName = exports.CreateSummarizerNodeSource = void 0;\nvar CreateSummarizerNodeSource;\n(function (CreateSummarizerNodeSource) {\n    CreateSummarizerNodeSource[CreateSummarizerNodeSource[\"FromSummary\"] = 0] = \"FromSummary\";\n    CreateSummarizerNodeSource[CreateSummarizerNodeSource[\"FromAttach\"] = 1] = \"FromAttach\";\n    CreateSummarizerNodeSource[CreateSummarizerNodeSource[\"Local\"] = 2] = \"Local\";\n})(CreateSummarizerNodeSource = exports.CreateSummarizerNodeSource || (exports.CreateSummarizerNodeSource = {}));\nexports.channelsTreeName = \".channels\";\n//# sourceMappingURL=summary.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Generates the absolute path for an IFluidHandleContext given its path and its parent routeContext.\n */\nexport function generateHandleContextPath(path, routeContext) {\n    let result;\n    if (path === \"\") {\n        // The `path` is empty.\n        // If the routeContext does not exist, this is the root and it shouldn't have an absolute path.\n        // If the routeContext exists, the absolute path is the same as that of the routeContext.\n        result = routeContext === undefined ? \"\" : routeContext.absolutePath;\n    }\n    else {\n        // If the routeContext does not exist, path is the absolute path.\n        // If the routeContext exists, absolute path is routeContext's absolute path plus the path.\n        result = routeContext === undefined ? `/${path}` : `${routeContext.absolutePath}/${path}`;\n    }\n    return result;\n}\n//# sourceMappingURL=dataStoreHandleContextUtils.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nexport function getStack() {\n    const err = new Error();\n    if (err.stack !== undefined) {\n        return err.stack;\n    }\n    try {\n        throw err;\n    }\n    catch (err2) {\n        return err2.stack;\n    }\n}\nexport function exceptionToResponse(err) {\n    var _a;\n    const status = 500;\n    // eslint-disable-next-line no-null/no-null\n    if (err !== null && typeof err === \"object\" && err.errorFromRequestFluidObject === true) {\n        const responseErr = err;\n        return {\n            mimeType: \"text/plain\",\n            status: responseErr.code,\n            value: responseErr.message,\n            stack: (_a = responseErr.stack) !== null && _a !== void 0 ? _a : getStack(),\n        };\n    }\n    return {\n        mimeType: \"text/plain\",\n        status,\n        value: `${err}`,\n        stack: getStack(),\n    };\n}\nexport function responseToException(response, request) {\n    const message = response.value;\n    const err = new Error(message);\n    const responseErr = err;\n    responseErr.errorFromRequestFluidObject = true;\n    responseErr.message = message;\n    responseErr.code = response.status;\n    if (response.stack !== undefined) {\n        try {\n            // not clear if all browsers allow overwriting stack\n            responseErr.stack = response.stack;\n        }\n        catch (err2) { }\n    }\n    return err;\n}\nexport async function requestFluidObject(router, url) {\n    const request = typeof url === \"string\" ? { url } : url;\n    const response = await router.request(request);\n    if (response.status !== 200 || response.mimeType !== \"fluid/object\") {\n        throw responseToException(response, request);\n    }\n    assert(response.value, 0x19a /* \"Invalid response value for Fluid object request\" */);\n    return response.value;\n}\nexport const create404Response = (request) => createResponseError(404, \"not found\", request);\nexport function createResponseError(status, value, request) {\n    assert(status !== 200, 0x19b /* \"Cannot not create response error on 200 status\" */);\n    return {\n        mimeType: \"text/plain\",\n        status,\n        value: request.url === undefined ? value : `${value}: ${request.url}`,\n        stack: getStack(),\n    };\n}\n// eslint-disable-next-line prefer-arrow/prefer-arrow-functions\nexport function createDataStoreFactory(type, factory) {\n    return {\n        type,\n        get IFluidDataStoreFactory() { return this; },\n        get IFluidDataStoreRegistry() { return this; },\n        instantiateDataStore: async (context) => (await factory).instantiateDataStore(context),\n        get: async (name) => { var _a; return (_a = (await factory).IFluidDataStoreRegistry) === null || _a === void 0 ? void 0 : _a.get(name); },\n    };\n}\n//# sourceMappingURL=dataStoreHelpers.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\n/**\n * Returns a new IChannelStorageService that resolves the given `path` as root.\n */\nexport class ObjectStoragePartition {\n    constructor(storage, path) {\n        this.storage = storage;\n        this.path = path;\n        // `path` must not include the trailing separator.\n        assert(!path.endsWith(\"/\"), 0x19c /* \"storage service path has trailing separator\" */);\n    }\n    async readBlob(path) {\n        return this.storage.readBlob(`${this.path}/${path}`);\n    }\n    async contains(path) {\n        return this.storage.contains(`${this.path}/${path}`);\n    }\n    async list(path) {\n        return this.storage.list(`${this.path}/${path}`);\n    }\n}\n//# sourceMappingURL=objectstoragepartition.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nexport function getNormalizedObjectStoragePathParts(path) {\n    let normalizePath = path;\n    if (normalizePath.startsWith(\"/\")) {\n        normalizePath = normalizePath.substr(1);\n    }\n    if (normalizePath.endsWith(\"/\")) {\n        normalizePath = normalizePath.substr(0, normalizePath.length - 1);\n    }\n    if (normalizePath.length > 0) {\n        return normalizePath.split(\"/\");\n    }\n    return [];\n}\nexport async function listBlobsAtTreePath(inputTree, path) {\n    const pathParts = getNormalizedObjectStoragePathParts(path);\n    let tree = inputTree;\n    while ((tree === null || tree === void 0 ? void 0 : tree.entries) !== undefined && pathParts.length > 0) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const part = pathParts.shift();\n        const index = tree.entries.findIndex((value) => {\n            if (value.type === \"Tree\" && value.path === part) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        });\n        if (index === -1) {\n            tree = undefined;\n        }\n        else {\n            const treeEntry = tree.entries[index];\n            tree = treeEntry.value;\n        }\n    }\n    if ((tree === null || tree === void 0 ? void 0 : tree.entries) === undefined || pathParts.length !== 0) {\n        throw new Error(\"path does not exist\");\n    }\n    return tree.entries.filter((e) => e.type === \"Blob\").map((e) => e.path);\n}\n//# sourceMappingURL=objectstorageutils.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { create404Response, exceptionToResponse, responseToException } from \"./dataStoreHelpers\";\n/**\n * This handle is used to dynamically load a Fluid object on a remote client and is created on parsing a serialized\n * FluidObjectHandle.\n * This class is used to generate an IFluidHandle when de-serializing any all handles (including handles to DDSs, custom\n * objects) that are stored in SharedObjects. The Data Store or SharedObject corresponding to the IFluidHandle can be\n * retrieved by calling `get` on it.\n */\nexport class RemoteFluidObjectHandle {\n    /**\n     * Creates a new RemoteFluidObjectHandle when parsing an IFluidHandle.\n     * @param absolutePath - The absolute path to the handle from the container runtime.\n     * @param routeContext - The root IFluidHandleContext that has a route to this handle.\n     */\n    constructor(absolutePath, routeContext) {\n        this.absolutePath = absolutePath;\n        this.routeContext = routeContext;\n        this.isAttached = true;\n        assert(absolutePath.startsWith(\"/\"), 0x19d /* \"Handles should always have absolute paths\" */);\n    }\n    get IFluidRouter() { return this; }\n    get IFluidHandleContext() { return this; }\n    get IFluidHandle() { return this; }\n    /**\n     * @deprecated - This returns the absolute path.\n     */\n    get path() {\n        return this.absolutePath;\n    }\n    async get() {\n        if (this.objectP === undefined) {\n            const request = { url: this.absolutePath };\n            this.objectP = this.routeContext.resolveHandle(request)\n                .then((response) => {\n                if (response.mimeType === \"fluid/object\") {\n                    return response.value;\n                }\n                throw responseToException(response, request);\n            });\n        }\n        return this.objectP;\n    }\n    attachGraph() {\n        return;\n    }\n    bind(handle) {\n        handle.attachGraph();\n    }\n    async request(request) {\n        try {\n            const object = await this.get();\n            const router = object.IFluidRouter;\n            return router !== undefined\n                ? router.request(request)\n                : create404Response(request);\n        }\n        catch (error) {\n            return exceptionToResponse(error);\n        }\n    }\n}\n//# sourceMappingURL=remoteObjectHandle.js.map","/**\n * The Request Parser takes an IRequest provides parsing and sub request creation\n */\nexport class RequestParser {\n    constructor(request) {\n        this.request = request;\n        const queryStartIndex = this.request.url.indexOf(\"?\");\n        if (queryStartIndex >= 0) {\n            this.query = this.request.url.substring(queryStartIndex);\n        }\n        else {\n            this.query = \"\";\n        }\n    }\n    /**\n     * Splits the path of the url and decodes each path part\n     * @param url - the url to get path parts of\n     */\n    static getPathParts(url) {\n        const queryStartIndex = url.indexOf(\"?\");\n        return url\n            .substring(0, queryStartIndex < 0 ? url.length : queryStartIndex)\n            .split(\"/\")\n            .reduce((pv, cv) => {\n            if (cv !== undefined && cv.length > 0) {\n                pv.push(decodeURIComponent(cv));\n            }\n            return pv;\n        }, []);\n    }\n    static create(request) {\n        // Perf optimizations.\n        if (request instanceof RequestParser) {\n            return request;\n        }\n        return new RequestParser(request);\n    }\n    get url() {\n        return this.request.url;\n    }\n    get headers() {\n        return this.request.headers;\n    }\n    /**\n     * Returns the decoded path parts of the request's url\n     */\n    get pathParts() {\n        if (this.requestPathParts === undefined) {\n            this.requestPathParts = RequestParser.getPathParts(this.url);\n        }\n        return this.requestPathParts;\n    }\n    /**\n     * Returns true if it's a terminating path, i.e. no more elements after `elements` entries and empty query.\n     * @param elements - number of elements in path\n     */\n    isLeaf(elements) {\n        return this.query === \"\" && this.pathParts.length === elements;\n    }\n    /**\n     * Creates a sub request starting at a specific path part of this request's url\n     * The sub request url always has a leading slash, and always include query params if original url has any\n     * e.g. original url is /a/b/?queryParams, createSubRequest(0) is /a/b/?queryParams\n     * createSubRequest(1) is /b/?queryParams\n     * createSubRequest(2) is /?queryParams\n     * createSubRequest(n) where n is bigger than parts length, e.g. 2, or n is less than 0 will throw an exception\n     *\n     * note: query params are not counted towards path parts.\n     *\n     * @param startingPathIndex - The index of the first path part of the sub request\n     */\n    createSubRequest(startingPathIndex) {\n        const pathLen = this.pathParts.length;\n        if (startingPathIndex < 0 || startingPathIndex > pathLen) {\n            throw new Error(\"incorrect sub-request\");\n        }\n        if (startingPathIndex === pathLen && this.url.includes(\"?\")) {\n            return {\n                url: `/${this.query}`,\n                headers: this.headers,\n            };\n        }\n        const path = `/${this.pathParts.slice(startingPathIndex).join(\"/\")}`;\n        return {\n            url: this.query === \"\" ? path : `${path}/${this.query}`,\n            headers: this.headers,\n        };\n    }\n}\n//# sourceMappingURL=requestParser.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { RemoteFluidObjectHandle } from \"./remoteObjectHandle\";\nimport { generateHandleContextPath } from \"./dataStoreHandleContextUtils\";\nimport { isSerializedHandle } from \"./utils\";\n/**\n * Data Store serializer implementation\n */\nexport class FluidSerializer {\n    constructor(context) {\n        this.context = context;\n        this.root = this.context;\n        while (this.root.routeContext !== undefined) {\n            this.root = this.root.routeContext;\n        }\n    }\n    get IFluidSerializer() { return this; }\n    replaceHandles(input, bind) {\n        // If the given 'input' cannot contain handles, return it immediately.  Otherwise,\n        // return the result of 'recursivelyReplaceHandles()'.\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions,@typescript-eslint/no-unsafe-return\n        return !!input && typeof input === \"object\"\n            ? this.recursivelyReplaceHandles(input, bind)\n            : input;\n    }\n    stringify(input, bind) {\n        return JSON.stringify(input, (key, value) => {\n            // If the current 'value' is not a handle, return it unmodified.  Otherwise,\n            // return the result of 'serializeHandle'.\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            const handle = !!value && value.IFluidHandle;\n            // TODO - understand why handle === false in some of our tests\n            // eslint-disable-next-line max-len\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions,@typescript-eslint/no-unsafe-return\n            return handle\n                ? this.serializeHandle(handle, bind)\n                : value;\n        });\n    }\n    // Parses the serialized data - context must match the context with which the JSON was stringified\n    parse(input) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return JSON.parse(input, (key, value) => {\n            if (!isSerializedHandle(value)) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return value;\n            }\n            // Old documents may have handles with relative path in their summaries. Convert these to absolute\n            // paths. This will ensure that future summaries will have absolute paths for these handles.\n            const absolutePath = value.url.startsWith(\"/\")\n                ? value.url\n                : generateHandleContextPath(value.url, this.context);\n            return new RemoteFluidObjectHandle(absolutePath, this.root);\n        });\n    }\n    // Invoked by `replaceHandles()` for non-null objects to recursively replace IFluidHandle references\n    // with serialized handles (cloning as-needed to avoid mutating the original `input` object.)\n    recursivelyReplaceHandles(input, bind) {\n        // If the current input is an IFluidHandle instance, replace this leaf in the object graph with\n        // the handle's serialized from.\n        // Note: Caller is responsible for ensuring that `input` is a non-null object.\n        const handle = input.IFluidHandle;\n        if (handle !== undefined) {\n            return this.serializeHandle(handle, bind);\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        let clone;\n        for (const key of Object.keys(input)) {\n            const value = input[key];\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            if (!!value && typeof value === \"object\") {\n                // Note: Except for IFluidHandle, `input` must not contain circular references (as object must\n                //       be JSON serializable.)  Therefore, guarding against infinite recursion here would only\n                //       lead to a later error when attempting to stringify().\n                const replaced = this.recursivelyReplaceHandles(value, bind);\n                // If the `replaced` object is different than the original `value` then the subgraph contained one\n                // or more handles.  If this happens, we need to return a clone of the `input` object where the\n                // current property is replaced by the `replaced` value.\n                if (replaced !== value) {\n                    // Lazily create a shallow clone of the `input` object if we haven't done so already.\n                    clone = clone !== null && clone !== void 0 ? clone : (Array.isArray(input)\n                        ? [...input]\n                        : Object.assign({}, input));\n                    // Overwrite the current property `key` in the clone with the `replaced` value.\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    clone[key] = replaced;\n                }\n            }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return clone !== null && clone !== void 0 ? clone : input;\n    }\n    serializeHandle(handle, bind) {\n        bind.bind(handle);\n        return {\n            type: \"__fluid_handle__\",\n            url: handle.absolutePath,\n        };\n    }\n}\n//# sourceMappingURL=serializer.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { CreateSummarizerNodeSource, } from \"@fluidframework/runtime-definitions\";\nimport { assert, unreachableCase } from \"@fluidframework/common-utils\";\nimport { mergeStats, convertToSummaryTree, calculateStats } from \"../summaryUtils\";\nimport { decodeSummary, encodeSummary, EscapedPath, parseSummaryForSubtrees, parseSummaryTreeForSubtrees, seqFromTree, SummaryNode, } from \"./summarizerNodeUtils\";\n/**\n * Encapsulates the summarizing work and state of an individual tree node in the\n * summary tree. It tracks changes and allows for optimizations when unchanged, or\n * can allow for fallback summaries to be generated when an error is encountered.\n * Usage is for the root node to call startSummary first to begin tracking a WIP\n * (work in progress) summary. Then all nodes will call summarize to summaries their\n * individual parts. Once completed and uploaded to storage, the root node will call\n * completeSummary or clearSummary to clear the WIP summary tracking state if something\n * went wrong. The SummarizerNodes will track all pending summaries that have been\n * recorded by the completeSummary call. When one of them is acked, the root node should\n * call refreshLatestSummary to inform the tree of SummarizerNodes of the new baseline\n * latest successful summary.\n */\nexport class SummarizerNode {\n    /**\n     * Do not call constructor directly.\n     * Use createRootSummarizerNode to create root node, or createChild to create child nodes.\n     */\n    constructor(defaultLogger, summarizeInternalFn, config, _changeSequenceNumber, \n    /** Undefined means created without summary */\n    latestSummary, initialSummary, wipSummaryLogger) {\n        var _a;\n        this.defaultLogger = defaultLogger;\n        this.summarizeInternalFn = summarizeInternalFn;\n        this._changeSequenceNumber = _changeSequenceNumber;\n        this.latestSummary = latestSummary;\n        this.initialSummary = initialSummary;\n        this.wipSummaryLogger = wipSummaryLogger;\n        this.children = new Map();\n        this.pendingSummaries = new Map();\n        this.outstandingOps = [];\n        this.wipSkipRecursion = false;\n        this.canReuseHandle = (_a = config.canReuseHandle) !== null && _a !== void 0 ? _a : true;\n        // BUGBUG: Seeing issues with differential summaries.\n        // this will disable them, and throw instead\n        // while we continue to investigate\n        this.throwOnError = true; // config.throwOnFailure ?? false;\n        this.trackingSequenceNumber = this._changeSequenceNumber;\n    }\n    /**\n     * The reference sequence number of the most recent acked summary.\n     * Returns 0 if there is not yet an acked summary.\n     */\n    get referenceSequenceNumber() {\n        var _a, _b;\n        return (_b = (_a = this.latestSummary) === null || _a === void 0 ? void 0 : _a.referenceSequenceNumber) !== null && _b !== void 0 ? _b : 0;\n    }\n    startSummary(referenceSequenceNumber, summaryLogger) {\n        assert(this.wipSummaryLogger === undefined, 0x19f /* \"wipSummaryLogger should not be set yet in startSummary\" */);\n        assert(this.wipReferenceSequenceNumber === undefined, 0x1a0 /* \"Already tracking a summary\" */);\n        this.wipSummaryLogger = summaryLogger;\n        for (const child of this.children.values()) {\n            child.startSummary(referenceSequenceNumber, this.wipSummaryLogger);\n        }\n        this.wipReferenceSequenceNumber = referenceSequenceNumber;\n    }\n    async summarize(fullTree) {\n        assert(this.isTrackingInProgress(), 0x1a1 /* \"summarize should not be called when not tracking the summary\" */);\n        assert(this.wipSummaryLogger !== undefined, 0x1a2 /* \"wipSummaryLogger should have been set in startSummary or ctor\" */);\n        // Try to reuse the tree if unchanged\n        if (this.canReuseHandle && !fullTree && !this.hasChanged()) {\n            const latestSummary = this.latestSummary;\n            if (latestSummary !== undefined) {\n                this.wipLocalPaths = {\n                    localPath: latestSummary.localPath,\n                    additionalPath: latestSummary.additionalPath,\n                };\n                this.wipSkipRecursion = true;\n                const stats = mergeStats();\n                stats.handleNodeCount++;\n                return {\n                    summary: {\n                        type: 3 /* Handle */,\n                        handle: latestSummary.fullPath.path,\n                        handleType: 1 /* Tree */,\n                    },\n                    stats,\n                };\n            }\n        }\n        try {\n            const result = await this.summarizeInternalFn(fullTree);\n            this.wipLocalPaths = { localPath: EscapedPath.create(result.id) };\n            if (result.pathPartsForChildren !== undefined) {\n                this.wipLocalPaths.additionalPath = EscapedPath.createAndConcat(result.pathPartsForChildren);\n            }\n            return { summary: result.summary, stats: result.stats };\n        }\n        catch (error) {\n            if (this.throwOnError || this.trackingSequenceNumber < this._changeSequenceNumber) {\n                throw error;\n            }\n            const latestSummary = this.latestSummary;\n            const initialSummary = this.initialSummary;\n            let encodeParam;\n            let localPath;\n            if (latestSummary !== undefined) {\n                // Create using handle of latest acked summary\n                encodeParam = {\n                    fromSummary: true,\n                    summaryNode: latestSummary,\n                };\n                localPath = latestSummary.localPath;\n            }\n            else if ((initialSummary === null || initialSummary === void 0 ? void 0 : initialSummary.summary) !== undefined) {\n                // Create using initial summary from attach op\n                encodeParam = {\n                    fromSummary: false,\n                    initialSummary: initialSummary.summary,\n                };\n                localPath = EscapedPath.create(initialSummary.id);\n            }\n            else {\n                // No base summary to reference\n                throw error;\n            }\n            this.wipSummaryLogger.sendErrorEvent({\n                eventName: \"SummarizingWithBasePlusOps\",\n            }, error);\n            const summary = encodeSummary(encodeParam, this.outstandingOps);\n            this.wipLocalPaths = {\n                localPath,\n                additionalPath: summary.additionalPath,\n            };\n            this.wipSkipRecursion = true;\n            return { summary: summary.summary, stats: summary.stats };\n        }\n    }\n    /**\n     * Complete the WIP summary for the given proposalHandle\n     */\n    completeSummary(proposalHandle) {\n        this.completeSummaryCore(proposalHandle, undefined, false);\n    }\n    /**\n     * Recursive implementation for completeSummary, with additional internal-only parameters\n     */\n    completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion) {\n        assert(this.wipSummaryLogger !== undefined, 0x1a3 /* \"wipSummaryLogger should have been set in startSummary or ctor\" */);\n        assert(this.wipReferenceSequenceNumber !== undefined, 0x1a4 /* \"Not tracking a summary\" */);\n        let localPathsToUse = this.wipLocalPaths;\n        if (parentSkipRecursion) {\n            const latestSummary = this.latestSummary;\n            if (latestSummary !== undefined) {\n                // This case the parent node created a failure summary or was reused.\n                // This node and all children should only try to reference their path\n                // by its last known good state in the actual summary tree.\n                // If parent fails or is reused, the child summarize is not called so\n                // it did not get a chance to change its paths.\n                // In this case, essentially only propagate the new summary ref seq num.\n                localPathsToUse = {\n                    localPath: latestSummary.localPath,\n                    additionalPath: latestSummary.additionalPath,\n                };\n            }\n            else {\n                // This case the child is added after the latest non-failure summary.\n                // This node and all children should consider themselves as still not\n                // having a successful summary yet.\n                // We cannot \"reuse\" this node if unchanged since that summary, because\n                // handles will be unable to point to that node. It never made it to the\n                // tree itself, and only exists as an attach op in the _outstandingOps.\n                this.clearSummary();\n                return;\n            }\n        }\n        // This should come from wipLocalPaths in normal cases, or from the latestSummary\n        // if parentIsFailure or parentIsReused is true.\n        // If there is no latestSummary, clearSummary and return before reaching this code.\n        assert(!!localPathsToUse, 0x1a5 /* \"Tracked summary local paths not set\" */);\n        const summary = new SummaryNode(Object.assign(Object.assign({}, localPathsToUse), { referenceSequenceNumber: this.wipReferenceSequenceNumber, basePath: parentPath }));\n        const fullPathForChildren = summary.fullPathForChildren;\n        for (const child of this.children.values()) {\n            child.completeSummaryCore(proposalHandle, fullPathForChildren, this.wipSkipRecursion || parentSkipRecursion);\n        }\n        // Note that this overwrites existing pending summary with\n        // the same proposalHandle. If proposalHandle is something like\n        // a hash or unique identifier, this should be fine. If storage\n        // can return the same proposalHandle for a different summary,\n        // this should still be okay, because we should be proposing the\n        // newer one later which would have to overwrite the previous one.\n        this.pendingSummaries.set(proposalHandle, summary);\n        this.clearSummary();\n    }\n    clearSummary() {\n        this.wipReferenceSequenceNumber = undefined;\n        this.wipLocalPaths = undefined;\n        this.wipSkipRecursion = false;\n        this.wipSummaryLogger = undefined;\n        for (const child of this.children.values()) {\n            child.clearSummary();\n        }\n    }\n    async refreshLatestSummary(proposalHandle, getSnapshot, readAndParseBlob, correlatedSummaryLogger) {\n        if (proposalHandle !== undefined) {\n            const maybeSummaryNode = this.pendingSummaries.get(proposalHandle);\n            if (maybeSummaryNode !== undefined) {\n                this.refreshLatestSummaryFromPending(proposalHandle, maybeSummaryNode.referenceSequenceNumber);\n                return;\n            }\n        }\n        const snapshotTree = await getSnapshot();\n        const referenceSequenceNumber = await seqFromTree(snapshotTree, readAndParseBlob);\n        await this.refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, undefined, EscapedPath.create(\"\"), correlatedSummaryLogger, readAndParseBlob);\n    }\n    refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber) {\n        const summaryNode = this.pendingSummaries.get(proposalHandle);\n        if (summaryNode === undefined) {\n            // This should only happen if parent skipped recursion AND no prior summary existed.\n            assert(this.latestSummary === undefined, 0x1a6 /* \"Not found pending summary, but this node has previously completed a summary\" */);\n            return;\n        }\n        else {\n            assert(referenceSequenceNumber === summaryNode.referenceSequenceNumber, \n            // eslint-disable-next-line max-len\n            0x1a7 /* `Pending summary reference sequence number should be consistent: ${summaryNode.referenceSequenceNumber} != ${referenceSequenceNumber}` */);\n            // Clear earlier pending summaries\n            this.pendingSummaries.delete(proposalHandle);\n        }\n        this.refreshLatestSummaryCore(referenceSequenceNumber);\n        this.latestSummary = summaryNode;\n        // Propagate update to all child nodes\n        for (const child of this.children.values()) {\n            child.refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber);\n        }\n    }\n    async refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob) {\n        // Possible re-entrancy. If we have already seen a summary later than this one, ignore it.\n        if (this.referenceSequenceNumber >= referenceSequenceNumber) {\n            return;\n        }\n        this.refreshLatestSummaryCore(referenceSequenceNumber);\n        const { baseSummary, pathParts } = decodeSummary(snapshotTree, correlatedSummaryLogger);\n        this.latestSummary = new SummaryNode({\n            referenceSequenceNumber,\n            basePath,\n            localPath,\n        });\n        const { childrenTree, childrenPathPart } = parseSummaryForSubtrees(baseSummary);\n        if (childrenPathPart !== undefined) {\n            pathParts.push(childrenPathPart);\n        }\n        if (pathParts.length > 0) {\n            this.latestSummary.additionalPath = EscapedPath.createAndConcat(pathParts);\n        }\n        // Propagate update to all child nodes\n        const pathForChildren = this.latestSummary.fullPathForChildren;\n        await Promise.all(Array.from(this.children)\n            .filter(([id]) => {\n            // Assuming subtrees missing from snapshot are newer than the snapshot,\n            // but might be nice to assert this using earliest seq for node.\n            return childrenTree.trees[id] !== undefined;\n        }).map(async ([id, child]) => {\n            return child.refreshLatestSummaryFromSnapshot(referenceSequenceNumber, childrenTree.trees[id], pathForChildren, EscapedPath.create(id), correlatedSummaryLogger, readAndParseBlob);\n        }));\n    }\n    refreshLatestSummaryCore(referenceSequenceNumber) {\n        for (const [key, value] of this.pendingSummaries) {\n            if (value.referenceSequenceNumber < referenceSequenceNumber) {\n                this.pendingSummaries.delete(key);\n            }\n        }\n        // Clear earlier outstanding ops\n        while (this.outstandingOps.length > 0\n            && this.outstandingOps[0].sequenceNumber <= referenceSequenceNumber) {\n            this.outstandingOps.shift();\n        }\n    }\n    loadBaseSummaryWithoutDifferential(snapshot) {\n        // Check base summary to see if it has any additional path parts\n        // separating child SummarizerNodes. Checks for .channels subtrees.\n        const { childrenPathPart } = parseSummaryForSubtrees(snapshot);\n        if (childrenPathPart !== undefined && this.latestSummary !== undefined) {\n            this.latestSummary.additionalPath = EscapedPath.create(childrenPathPart);\n        }\n    }\n    async loadBaseSummary(snapshot, readAndParseBlob) {\n        const decodedSummary = decodeSummary(snapshot, this.defaultLogger);\n        const outstandingOps = await decodedSummary.getOutstandingOps(readAndParseBlob);\n        const { childrenPathPart } = parseSummaryForSubtrees(decodedSummary.baseSummary);\n        if (childrenPathPart !== undefined) {\n            decodedSummary.pathParts.push(childrenPathPart);\n        }\n        if (decodedSummary.pathParts.length > 0 && this.latestSummary !== undefined) {\n            this.latestSummary.additionalPath = EscapedPath.createAndConcat(decodedSummary.pathParts);\n        }\n        // Defensive assertion: tracking number should already exceed this number.\n        // This is probably a little excessive; can remove when stable.\n        if (outstandingOps.length > 0) {\n            const newOpsLatestSeq = outstandingOps[outstandingOps.length - 1].sequenceNumber;\n            assert(newOpsLatestSeq <= this.trackingSequenceNumber, 0x1a9 /* \"When loading base summary, expected outstanding ops <= tracking sequence number\" */);\n        }\n        return {\n            baseSummary: decodedSummary.baseSummary,\n            outstandingOps,\n        };\n    }\n    recordChange(op) {\n        const lastOp = this.outstandingOps[this.outstandingOps.length - 1];\n        if (lastOp !== undefined) {\n            assert(lastOp.sequenceNumber < op.sequenceNumber, 0x1aa /* `Out of order change recorded: ${lastOp.sequenceNumber} > ${op.sequenceNumber}` */);\n        }\n        this.invalidate(op.sequenceNumber);\n        this.trackingSequenceNumber = op.sequenceNumber;\n        this.outstandingOps.push(op);\n    }\n    invalidate(sequenceNumber) {\n        if (sequenceNumber > this._changeSequenceNumber) {\n            this._changeSequenceNumber = sequenceNumber;\n        }\n    }\n    /**\n     * True if a change has been recorded with sequence number exceeding\n     * the latest successfully acked summary reference sequence number.\n     * False implies that the previous summary can be reused.\n     */\n    hasChanged() {\n        return this._changeSequenceNumber > this.referenceSequenceNumber;\n    }\n    createChild(\n    /** Summarize function */\n    summarizeInternalFn, \n    /** Initial id or path part of this node */\n    id, \n    /**\n     * Information needed to create the node.\n     * If it is from a base summary, it will assert that a summary has been seen.\n     * Attach information if it is created from an attach op.\n     */\n    createParam, config = {}) {\n        assert(!this.children.has(id), 0x1ab /* \"Create SummarizerNode child already exists\" */);\n        const createDetails = this.getCreateDetailsForChild(id, createParam);\n        const child = new SummarizerNode(this.defaultLogger, summarizeInternalFn, config, createDetails.changeSequenceNumber, createDetails.latestSummary, createDetails.initialSummary, this.wipSummaryLogger);\n        // There may be additional state that has to be updated in this child. For example, if a summary is being\n        // tracked, the child's summary tracking state needs to be updated too.\n        this.maybeUpdateChildState(child);\n        this.children.set(id, child);\n        return child;\n    }\n    getChild(id) {\n        return this.children.get(id);\n    }\n    /**\n     * Returns the details needed to create a child node.\n     * @param id - Initial id or path part of the child node.\n     * @param createParam - Information needed to create the node.\n     * @returns the details needed to create the child node.\n     */\n    getCreateDetailsForChild(id, createParam) {\n        var _a;\n        let initialSummary;\n        let latestSummary;\n        let changeSequenceNumber;\n        const parentLatestSummary = this.latestSummary;\n        switch (createParam.type) {\n            case CreateSummarizerNodeSource.FromAttach: {\n                if (parentLatestSummary !== undefined\n                    && createParam.sequenceNumber <= parentLatestSummary.referenceSequenceNumber) {\n                    // Prioritize latest summary if it was after this node was attached.\n                    latestSummary = parentLatestSummary.createForChild(id);\n                }\n                else {\n                    const summary = convertToSummaryTree(createParam.snapshot);\n                    initialSummary = {\n                        sequenceNumber: createParam.sequenceNumber,\n                        id,\n                        summary,\n                    };\n                }\n                changeSequenceNumber = createParam.sequenceNumber;\n                break;\n            }\n            case CreateSummarizerNodeSource.FromSummary: {\n                if (this.initialSummary === undefined) {\n                    assert(!!parentLatestSummary, 0x1ac /* \"Cannot create child from summary if parent does not have latest summary\" */);\n                }\n                // fallthrough to local\n            }\n            case CreateSummarizerNodeSource.Local: {\n                const parentInitialSummary = this.initialSummary;\n                if (parentInitialSummary !== undefined) {\n                    let childSummary;\n                    if (parentInitialSummary.summary !== undefined) {\n                        const { childrenTree } = parseSummaryTreeForSubtrees(parentInitialSummary.summary.summary);\n                        assert(childrenTree.type === 1 /* Tree */, 0x1d6 /* \"Parent summary object is not a tree\" */);\n                        childSummary = childrenTree.tree[id];\n                    }\n                    if (createParam.type === CreateSummarizerNodeSource.FromSummary) {\n                        // Locally created would not have differential subtree.\n                        assert(!!childSummary, 0x1ad /* \"Missing child summary tree\" */);\n                    }\n                    let childSummaryWithStats;\n                    if (childSummary !== undefined) {\n                        assert(childSummary.type === 1 /* Tree */, 0x1ae /* \"Child summary object is not a tree\" */);\n                        childSummaryWithStats = {\n                            summary: childSummary,\n                            stats: calculateStats(childSummary),\n                        };\n                    }\n                    initialSummary = {\n                        sequenceNumber: parentInitialSummary.sequenceNumber,\n                        id,\n                        summary: childSummaryWithStats,\n                    };\n                }\n                latestSummary = parentLatestSummary === null || parentLatestSummary === void 0 ? void 0 : parentLatestSummary.createForChild(id);\n                changeSequenceNumber = (_a = parentLatestSummary === null || parentLatestSummary === void 0 ? void 0 : parentLatestSummary.referenceSequenceNumber) !== null && _a !== void 0 ? _a : -1;\n                break;\n            }\n            default: {\n                const type = createParam.type;\n                unreachableCase(createParam, `Unexpected CreateSummarizerNodeSource: ${type}`);\n            }\n        }\n        return {\n            initialSummary,\n            latestSummary,\n            changeSequenceNumber,\n        };\n    }\n    /**\n     * Updates the state of the child if required. For example, if a summary is currently being  tracked, the child's\n     * summary tracking state needs to be updated too.\n     * @param child - The child node whose state is to be updated.\n     */\n    maybeUpdateChildState(child) {\n        // If we are tracking a summary, this child was created after the tracking started. So, we need to update the\n        // child's tracking state as well.\n        if (this.isTrackingInProgress()) {\n            child.wipReferenceSequenceNumber = this.wipReferenceSequenceNumber;\n        }\n    }\n    /**\n     * Tells whether summary tracking is in progress. True if \"startSummary\" API is called before summarize.\n     */\n    isTrackingInProgress() {\n        return this.wipReferenceSequenceNumber !== undefined;\n    }\n}\n/**\n * Creates a root summarizer node.\n * @param logger - Logger to use within SummarizerNode\n * @param summarizeInternalFn - Function to generate summary\n * @param changeSequenceNumber - Sequence number of latest change to new node/subtree\n * @param referenceSequenceNumber - Reference sequence number of last acked summary,\n * or undefined if not loaded from summary\n * @param config - Configure behavior of summarizer node\n */\nexport const createRootSummarizerNode = (logger, summarizeInternalFn, changeSequenceNumber, referenceSequenceNumber, config = {}) => new SummarizerNode(logger, summarizeInternalFn, config, changeSequenceNumber, referenceSequenceNumber === undefined ? undefined : SummaryNode.createForRoot(referenceSequenceNumber));\n//# sourceMappingURL=summarizerNode.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { channelsTreeName } from \"@fluidframework/runtime-definitions\";\nimport { SummaryTreeBuilder } from \"../summaryUtils\";\nconst baseSummaryTreeKey = \"_baseSummary\";\nconst outstandingOpsBlobKey = \"_outstandingOps\";\nconst maxDecodeDepth = 100;\n/**\n * Fetches the sequence number of the snapshot tree by examining the protocol.\n * @param tree - snapshot tree to examine\n * @param readAndParseBlob - function to read blob contents from storage\n * and parse the result from JSON.\n */\nexport async function seqFromTree(tree, readAndParseBlob) {\n    const attributesHash = tree.trees[\".protocol\"].blobs.attributes;\n    const attrib = await readAndParseBlob(attributesHash);\n    return attrib.sequenceNumber;\n}\n/** Path for nodes in a tree with escaped special characters */\nexport class EscapedPath {\n    constructor(path) {\n        this.path = path;\n    }\n    static create(path) {\n        return new EscapedPath(encodeURIComponent(path));\n    }\n    static createAndConcat(pathParts) {\n        var _a;\n        let ret = EscapedPath.create((_a = pathParts[0]) !== null && _a !== void 0 ? _a : \"\");\n        for (let i = 1; i < pathParts.length; i++) {\n            ret = ret.concat(EscapedPath.create(pathParts[i]));\n        }\n        return ret;\n    }\n    toString() {\n        return this.path;\n    }\n    concat(path) {\n        return new EscapedPath(`${this.path}/${path.path}`);\n    }\n}\n/** Information about a summary relevant to a specific node in the tree */\nexport class SummaryNode {\n    constructor(summary) {\n        this.summary = summary;\n    }\n    /** Creates an instance that is valid for the root with specific basePath and localPath */\n    static createForRoot(referenceSequenceNumber) {\n        return new SummaryNode({\n            referenceSequenceNumber,\n            basePath: undefined,\n            localPath: EscapedPath.create(\"\"),\n        });\n    }\n    /** Summary reference sequence number, i.e. last sequence number seen when it was created */\n    get referenceSequenceNumber() {\n        return this.summary.referenceSequenceNumber;\n    }\n    /** Full path to parent node, or undefined if this is the root */\n    get basePath() {\n        return this.summary.basePath;\n    }\n    /** Relative path to this node from its parent node */\n    get localPath() {\n        return this.summary.localPath;\n    }\n    /** Relative path from this node to its node innermost base summary */\n    get additionalPath() {\n        return this.summary.additionalPath;\n    }\n    set additionalPath(additionalPath) {\n        this.summary.additionalPath = additionalPath;\n    }\n    /** Gets the full path to this node, to be used when sending a handle */\n    get fullPath() {\n        var _a, _b;\n        return (_b = (_a = this.basePath) === null || _a === void 0 ? void 0 : _a.concat(this.localPath)) !== null && _b !== void 0 ? _b : this.localPath;\n    }\n    /**\n     * Gets the full path to this node's innermost base summary.\n     * The children nodes can use this as their basePath to determine their path.\n     */\n    get fullPathForChildren() {\n        return this.additionalPath !== undefined\n            ? this.fullPath.concat(this.additionalPath)\n            : this.fullPath;\n    }\n    /**\n     * Creates a new node within the same summary for a child of this node.\n     * @param id - id of the child node\n     */\n    createForChild(id) {\n        return new SummaryNode({\n            referenceSequenceNumber: this.referenceSequenceNumber,\n            basePath: this.fullPathForChildren,\n            localPath: EscapedPath.create(id),\n        });\n    }\n}\n/**\n * Checks if the snapshot is created by referencing a previous successful\n * summary plus outstanding ops. If so, it will recursively \"decode\" it until\n * it gets to the last successful summary (the base summary) and returns that\n * as well as a function for fetching the outstanding ops. Also returns the\n * full path to the previous base summary for child summarizer nodes to use as\n * their base path when necessary.\n * @param snapshot - snapshot tree to decode\n */\nexport function decodeSummary(snapshot, logger) {\n    let baseSummary = snapshot;\n    const pathParts = [];\n    const opsBlobs = [];\n    for (let i = 0;; i++) {\n        if (i > maxDecodeDepth) {\n            logger.sendTelemetryEvent({\n                eventName: \"DecodeSummaryMaxDepth\",\n                maxDecodeDepth,\n            });\n        }\n        const outstandingOpsBlob = baseSummary.blobs[outstandingOpsBlobKey];\n        const newBaseSummary = baseSummary.trees[baseSummaryTreeKey];\n        if (outstandingOpsBlob === undefined && newBaseSummary === undefined) {\n            return {\n                baseSummary,\n                pathParts,\n                async getOutstandingOps(readAndParseBlob) {\n                    let outstandingOps = [];\n                    for (const opsBlob of opsBlobs) {\n                        const newOutstandingOps = await readAndParseBlob(opsBlob);\n                        if (outstandingOps.length > 0 && newOutstandingOps.length > 0) {\n                            const latestSeq = outstandingOps[outstandingOps.length - 1].sequenceNumber;\n                            const newEarliestSeq = newOutstandingOps[0].sequenceNumber;\n                            if (newEarliestSeq <= latestSeq) {\n                                logger.sendTelemetryEvent({\n                                    eventName: \"DuplicateOutstandingOps\",\n                                    category: \"generic\",\n                                    // eslint-disable-next-line max-len\n                                    message: `newEarliestSeq <= latestSeq in decodeSummary: ${newEarliestSeq} <= ${latestSeq}`,\n                                });\n                                while (newOutstandingOps.length > 0\n                                    && newOutstandingOps[0].sequenceNumber <= latestSeq) {\n                                    newOutstandingOps.shift();\n                                }\n                            }\n                        }\n                        outstandingOps = outstandingOps.concat(newOutstandingOps);\n                    }\n                    return outstandingOps;\n                },\n            };\n        }\n        assert(!!outstandingOpsBlob, 0x1af /* \"Outstanding ops blob missing, but base summary tree exists\" */);\n        assert(newBaseSummary !== undefined, 0x1b0 /* \"Base summary tree missing, but outstanding ops blob exists\" */);\n        baseSummary = newBaseSummary;\n        pathParts.push(baseSummaryTreeKey);\n        opsBlobs.unshift(outstandingOpsBlob);\n    }\n}\n/**\n * Creates a summary tree which is a handle of the previous successfully acked summary\n * and a blob of the outstanding ops since that summary. If there is no acked summary yet,\n * it will create with the tree found in the initial attach op and the blob of outstanding ops.\n * @param summaryParam - information about last acked summary and paths to encode if from summary,\n * otherwise the initial summary from the attach op.\n * @param outstandingOps - outstanding ops since last acked summary\n */\nexport function encodeSummary(summaryParam, outstandingOps) {\n    let additionalPath = EscapedPath.create(baseSummaryTreeKey);\n    const builder = new SummaryTreeBuilder();\n    builder.addBlob(outstandingOpsBlobKey, JSON.stringify(outstandingOps));\n    if (summaryParam.fromSummary) {\n        // Create using handle of latest acked summary\n        const summaryNode = summaryParam.summaryNode;\n        if (summaryNode.additionalPath !== undefined) {\n            additionalPath = additionalPath.concat(summaryNode.additionalPath);\n        }\n        builder.addHandle(baseSummaryTreeKey, 1 /* Tree */, summaryNode.fullPath.path);\n    }\n    else {\n        // Create using initial summary from attach op\n        builder.addWithStats(baseSummaryTreeKey, summaryParam.initialSummary);\n    }\n    const summary = builder.getSummaryTree();\n    return Object.assign(Object.assign({}, summary), { additionalPath });\n}\n/**\n * Checks if the summary contains .channels subtree where the children subtrees\n * would be located if exists.\n * @param baseSummary - summary to check\n */\nexport function parseSummaryForSubtrees(baseSummary) {\n    // New versions of snapshots have child nodes isolated in .channels subtree\n    const channelsSubtree = baseSummary.trees[channelsTreeName];\n    if (channelsSubtree !== undefined) {\n        return {\n            childrenTree: channelsSubtree,\n            childrenPathPart: channelsTreeName,\n        };\n    }\n    return {\n        childrenTree: baseSummary,\n        childrenPathPart: undefined,\n    };\n}\n/**\n * Checks if the summary contains .channels subtree where the children subtrees\n * would be located if exists.\n * @param baseSummary - summary to check\n */\nexport function parseSummaryTreeForSubtrees(summary) {\n    // New versions of snapshots have child nodes isolated in .channels subtree\n    const channelsSubtree = summary.tree[channelsTreeName];\n    if (channelsSubtree !== undefined) {\n        return {\n            childrenTree: channelsSubtree,\n            childrenPathPart: channelsTreeName,\n        };\n    }\n    return {\n        childrenTree: summary,\n        childrenPathPart: undefined,\n    };\n}\n//# sourceMappingURL=summarizerNodeUtils.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, LazyPromise } from \"@fluidframework/common-utils\";\nimport { cloneGCData } from \"@fluidframework/garbage-collector\";\nimport { gcBlobKey, } from \"@fluidframework/runtime-definitions\";\nimport { SummarizerNode } from \"./summarizerNode\";\nimport { SummaryNode, } from \"./summarizerNodeUtils\";\n// Extend SummaryNode to add used routes tracking to it.\nclass SummaryNodeWithGC extends SummaryNode {\n    constructor(serializedUsedRoutes, summary) {\n        super(summary);\n        this.serializedUsedRoutes = serializedUsedRoutes;\n    }\n}\n/**\n * Extends the functionality of SummarizerNode to manage this node's garbage collection data:\n * - Adds a new API `getGCData` to return GC data of this node.\n * - Caches the result of `getGCData` to be used if nothing changes between summaries.\n * - Adds GC data to the result of summarize.\n * - Manages the used routes of this node. These are used to identify if this node is referenced in the document\n *   and to determine if the node's used state changed since last summary.\n * - Adds trackState param to summarize. If trackState is false, it bypasses the SummarizerNode and calls\n *   directly into summarizeInternal method.\n */\nexport class SummarizerNodeWithGC extends SummarizerNode {\n    /**\n     * Do not call constructor directly.\n     * Use createRootSummarizerNodeWithGC to create root node, or createChild to create child nodes.\n     */\n    constructor(logger, summarizeFn, config, changeSequenceNumber, \n    /** Undefined means created without summary */\n    latestSummary, initialSummary, wipSummaryLogger, getGCDataFn, getInitialGCSummaryDetailsFn) {\n        super(logger, async (fullTree) => this.summarizeInternal(fullTree, true /* trackState */), config, changeSequenceNumber, latestSummary, initialSummary, wipSummaryLogger);\n        this.summarizeFn = summarizeFn;\n        this.getGCDataFn = getGCDataFn;\n        // Set used routes to have self route by default. This makes the node referenced by default. This is done to ensure\n        // that this node is not marked as collected when running GC has been disabled. Once, the option to disable GC is\n        // removed (from runGC flag in IContainerRuntimeOptions), this should be changed to be have no routes by default.\n        this._usedRoutes = [\"\"];\n        this.gcDisabled = config.gcDisabled === true;\n        this.gcDetailsInInitialSummaryP = new LazyPromise(async () => {\n            // back-compat: 0.32. getInitialGCSummaryDetailsFn() returns undefined in 0.31. Remove undefined check\n            // when N > 34.\n            const gcSummaryDetails = await (getInitialGCSummaryDetailsFn === null || getInitialGCSummaryDetailsFn === void 0 ? void 0 : getInitialGCSummaryDetailsFn());\n            return gcSummaryDetails !== null && gcSummaryDetails !== void 0 ? gcSummaryDetails : { usedRoutes: [] };\n        });\n    }\n    get usedRoutes() {\n        return this._usedRoutes;\n    }\n    /**\n     * Loads state from this node's initial GC summary details. This contains the following data from the last summary\n     * seen by the server for this client:\n     * - usedRoutes: This is used to figure out if the used state of this node changed since last summary.\n     * - gcData: The garbage collection data of this node that is required for running GC.\n     */\n    async loadInitialGCSummaryDetails() {\n        // If referenceUsedRoutes is not undefined, don't do anything because we have already initialized.\n        if (this.referenceUsedRoutes === undefined) {\n            const gcDetailsInInitialSummary = await this.gcDetailsInInitialSummaryP;\n            this.referenceUsedRoutes = gcDetailsInInitialSummary.usedRoutes;\n            // If the GC details has GC data, initialize our GC data from it.\n            if (gcDetailsInInitialSummary.gcData !== undefined) {\n                this.gcData = cloneGCData(gcDetailsInInitialSummary.gcData);\n            }\n        }\n    }\n    async summarize(fullTree, trackState = true) {\n        // Load GC details from the initial summary, if it's not already loaded. If this is the first time this node is\n        // being summarized, the used routes in it are needed to find out if this node has changed since last summary.\n        // If it hasn't changed, the GC data in it needs to be returned as part of the summary.\n        await this.loadInitialGCSummaryDetails();\n        // If GC is not disabled and we are tracking a summary, GC should have run and updated the used routes for this\n        //  summary by calling updateUsedRoutes which sets wipSerializedUsedRoutes.\n        if (!this.gcDisabled && this.isTrackingInProgress()) {\n            assert(this.wipSerializedUsedRoutes !== undefined, 0x1b1 /* \"wip used routes should be set if tracking a summary\" */);\n        }\n        // If trackState is true, get summary from base summarizer node which tracks summary state.\n        // If trackState is false, get summary from summarizeInternal.\n        if (trackState) {\n            const summarizeResult = await super.summarize(fullTree);\n            // If there is no cached GC data, return empty data in summarize result. It is the caller's responsibility\n            // to ensure that GC data is available by calling getGCData before calling summarize.\n            const gcData = this.gcData !== undefined ? cloneGCData(this.gcData) : { gcNodes: {} };\n            return Object.assign(Object.assign({}, summarizeResult), { gcData });\n        }\n        else {\n            return this.summarizeInternal(fullTree, trackState);\n        }\n    }\n    async summarizeInternal(fullTree, trackState) {\n        const summarizeResult = await this.summarizeFn(fullTree, trackState);\n        this.gcData = cloneGCData(summarizeResult.gcData);\n        return summarizeResult;\n    }\n    /**\n     * Returns the GC data of this node. If nothing has changed since last summary, it tries to reuse the data from\n     * the previous summary. Else, it gets new GC data from the underlying Fluid object.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCData(fullGC = false) {\n        assert(!this.gcDisabled, 0x1b2 /* \"Getting GC data should not be called when GC is disabled!\" */);\n        assert(this.getGCDataFn !== undefined, 0x1b3 /* \"GC data cannot be retrieved without getGCDataFn\" */);\n        // Load GC details from the initial summary, if not already loaded. If this is the first time this function is\n        // called and the node's data has not changed since last summary, the GC data in initial details is returned.\n        await this.loadInitialGCSummaryDetails();\n        // If there is no new data since last summary and we have GC data from the previous run, return it. We may not\n        // have data from previous GC run for clients with older summary format before GC was added. They won't have\n        // GC details in their initial summary.\n        if (!fullGC && !this.hasDataChanged() && this.gcData !== undefined) {\n            return cloneGCData(this.gcData);\n        }\n        const gcData = await this.getGCDataFn(fullGC);\n        this.gcData = cloneGCData(gcData);\n        return gcData;\n    }\n    /**\n     * Called during the start of a summary. Updates the work-in-progress used routes.\n     */\n    startSummary(referenceSequenceNumber, summaryLogger) {\n        // If GC is disabled, skip setting wip used routes since we should not track GC state.\n        if (!this.gcDisabled) {\n            assert(this.wipSerializedUsedRoutes === undefined, 0x1b4 /* \"We should not already be tracking used routes when to track a new summary\" */);\n            // back-compat: 0.33 - This will be done in `updateUsedRoutes`. Older clients do not have that method, so\n            // keeping this one for now.\n            this.wipSerializedUsedRoutes = JSON.stringify(this.usedRoutes);\n        }\n        super.startSummary(referenceSequenceNumber, summaryLogger);\n    }\n    /**\n     * Called after summary has been uploaded to the server. Add the work-in-progress state to the pending\n     * summary queue. We track this until we get an ack from the server for this summary.\n     */\n    completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion) {\n        let wipSerializedUsedRoutes;\n        // If GC is disabled, don't set wip used routes.\n        if (!this.gcDisabled) {\n            wipSerializedUsedRoutes = this.wipSerializedUsedRoutes;\n            assert(wipSerializedUsedRoutes !== undefined, 0x1b5 /* \"We should have been tracking used routes\" */);\n        }\n        super.completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion);\n        // If GC is disabled, skip setting pending summary with GC state.\n        if (!this.gcDisabled) {\n            const summaryNode = this.pendingSummaries.get(proposalHandle);\n            if (summaryNode !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const summaryNodeWithGC = new SummaryNodeWithGC(wipSerializedUsedRoutes, summaryNode);\n                this.pendingSummaries.set(proposalHandle, summaryNodeWithGC);\n            }\n        }\n    }\n    /**\n     * Clears the work-in-progress state.\n     */\n    clearSummary() {\n        this.wipSerializedUsedRoutes = undefined;\n        super.clearSummary();\n    }\n    /**\n     * Called when we get an ack from the server for a summary we sent. Update the reference state of this node\n     * from the state in the pending summary queue.\n     */\n    refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber) {\n        // If GC is disabled, skip setting referenced used routes since we are not tracking GC state.\n        if (!this.gcDisabled) {\n            const summaryNode = this.pendingSummaries.get(proposalHandle);\n            if (summaryNode !== undefined) {\n                this.referenceUsedRoutes = JSON.parse(summaryNode.serializedUsedRoutes);\n            }\n        }\n        return super.refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber);\n    }\n    /**\n     * Called when we need to upload the reference state from the given summary. Read the GC blob and get the state\n     * to upload from it.\n     */\n    async refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob) {\n        // If GC is disabled, skip setting referenced used routes since we are not tracking GC state.\n        if (!this.gcDisabled) {\n            const gcDetailsBlob = snapshotTree.blobs[gcBlobKey];\n            if (gcDetailsBlob !== undefined) {\n                const gcDetails = await readAndParseBlob(gcDetailsBlob);\n                // Possible re-entrancy. If we have already seen a summary later than this one, ignore it.\n                if (this.referenceSequenceNumber >= referenceSequenceNumber) {\n                    return;\n                }\n                this.referenceUsedRoutes = gcDetails.usedRoutes;\n            }\n        }\n        return super.refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob);\n    }\n    /**\n     * Override the createChild method to return an instance of SummarizerNodeWithGC.\n     */\n    createChild(\n    /** Summarize function */\n    summarizeInternalFn, \n    /** Initial id or path part of this node */\n    id, \n    /**\n     * Information needed to create the node.\n     * If it is from a base summary, it will assert that a summary has been seen.\n     * Attach information if it is created from an attach op.\n     */\n    createParam, config = {}, getGCDataFn, getInitialGCSummaryDetailsFn) {\n        var _a;\n        assert(!this.children.has(id), 0x1b6 /* \"Create SummarizerNode child already exists\" */);\n        const createDetails = this.getCreateDetailsForChild(id, createParam);\n        const child = new SummarizerNodeWithGC(this.defaultLogger, summarizeInternalFn, Object.assign(Object.assign({}, config), { \n            // Propagate our gcDisabled state to the child if its not explicity specified in child's config.\n            gcDisabled: (_a = config.gcDisabled) !== null && _a !== void 0 ? _a : this.gcDisabled }), createDetails.changeSequenceNumber, createDetails.latestSummary, createDetails.initialSummary, this.wipSummaryLogger, getGCDataFn, getInitialGCSummaryDetailsFn);\n        // back-compat: 0.33 - If a child is created during summarize, its wip used routes will updated in\n        // `updateUsedRoutes` method. For older clients, do it here since that method does not exist.\n        // There may be additional state that has to be updated in this child. For example, if a summary is being\n        // tracked, the child's summary tracking state needs to be updated too.\n        this.maybeUpdateChildState(child);\n        this.children.set(id, child);\n        return child;\n    }\n    /**\n     * Override the getChild method to return an instance of SummarizerNodeWithGC.\n     */\n    getChild(id) {\n        return this.children.get(id);\n    }\n    isReferenced() {\n        return this.usedRoutes.includes(\"\") || this.usedRoutes.includes(\"/\");\n    }\n    updateUsedRoutes(usedRoutes) {\n        // Sort the given routes before updating. This will ensure that the routes compared in hasUsedStateChanged()\n        // are in the same order.\n        this._usedRoutes = usedRoutes.sort();\n        // If GC is not disabled and we are tracking a summary, update the work-in-progress used routes so that it can\n        // be tracked for this summary.\n        if (!this.gcDisabled && this.isTrackingInProgress()) {\n            this.wipSerializedUsedRoutes = JSON.stringify(this.usedRoutes);\n        }\n    }\n    /**\n     * Override the hasChanged method. If this node data or its used state changed, the node is considered changed.\n     */\n    hasChanged() {\n        return this.hasDataChanged() || this.hasUsedStateChanged();\n    }\n    /**\n     * This tells whether the data in this node has changed or not.\n     */\n    hasDataChanged() {\n        return super.hasChanged();\n    }\n    /**\n     * This tells whether the used state of this node has changed since last successful summary. If the used routes\n     * of this node changed, its used state is considered changed. Basically, if this node or any of its child nodes\n     * was previously used and became unused (or vice versa), its used state has changed.\n     */\n    hasUsedStateChanged() {\n        // If GC is disabled, we are not tracking used state, return false.\n        if (this.gcDisabled) {\n            return false;\n        }\n        return this.referenceUsedRoutes === undefined ||\n            JSON.stringify(this.usedRoutes) !== JSON.stringify(this.referenceUsedRoutes);\n    }\n    /**\n     * Updates the work-in-progress state of the child if summary is in progress.\n     * @param child - The child node to be updated.\n     */\n    maybeUpdateChildState(child) {\n        if (this.isTrackingInProgress()) {\n            // Update the child's work-in-progress used routes.\n            child.updateUsedRoutes(child.usedRoutes);\n        }\n        super.maybeUpdateChildState(child);\n    }\n}\n/**\n * Creates a root summarizer node with GC functionality built-in.\n * @param logger - Logger to use within SummarizerNode\n * @param summarizeInternalFn - Function to generate summary\n * @param changeSequenceNumber - Sequence number of latest change to new node/subtree\n * @param referenceSequenceNumber - Reference sequence number of last acked summary,\n * or undefined if not loaded from summary\n * @param config - Configure behavior of summarizer node\n * @param getGCDataFn - Function to get the GC data of this node\n * @param gcDetailsInInitialSummaryP - Function to get the initial GC details of this node\n */\nexport const createRootSummarizerNodeWithGC = (logger, summarizeInternalFn, changeSequenceNumber, referenceSequenceNumber, config = {}, getGCDataFn, getInitialGCSummaryDetailsFn) => new SummarizerNodeWithGC(logger, summarizeInternalFn, config, changeSequenceNumber, referenceSequenceNumber === undefined ? undefined : SummaryNode.createForRoot(referenceSequenceNumber), undefined /* initialSummary */, undefined /* wipSummaryLogger */, getGCDataFn, getInitialGCSummaryDetailsFn);\n//# sourceMappingURL=summarizerNodeWithGc.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, fromBase64ToUtf8, IsoBuffer, Uint8ArrayToString, unreachableCase, stringToBuffer, } from \"@fluidframework/common-utils\";\nimport { AttachmentTreeEntry, BlobTreeEntry, TreeTreeEntry } from \"@fluidframework/protocol-base\";\nimport { TreeEntry, } from \"@fluidframework/protocol-definitions\";\n/**\n * Combines summary stats by adding their totals together.\n * Returns empty stats if called without args.\n * @param stats - stats to merge\n */\nexport function mergeStats(...stats) {\n    const results = {\n        treeNodeCount: 0,\n        blobNodeCount: 0,\n        handleNodeCount: 0,\n        totalBlobSize: 0,\n    };\n    for (const stat of stats) {\n        results.treeNodeCount += stat.treeNodeCount;\n        results.blobNodeCount += stat.blobNodeCount;\n        results.handleNodeCount += stat.handleNodeCount;\n        results.totalBlobSize += stat.totalBlobSize;\n    }\n    return results;\n}\nexport function getBlobSize(content) {\n    if (typeof content === \"string\") {\n        return stringToBuffer(content, \"utf8\").byteLength;\n    }\n    else {\n        return content.byteLength;\n    }\n}\nfunction calculateStatsCore(summaryObject, stats) {\n    switch (summaryObject.type) {\n        case 1 /* Tree */: {\n            stats.treeNodeCount++;\n            for (const value of Object.values(summaryObject.tree)) {\n                calculateStatsCore(value, stats);\n            }\n            return;\n        }\n        case 3 /* Handle */: {\n            stats.handleNodeCount++;\n            return;\n        }\n        case 2 /* Blob */: {\n            stats.blobNodeCount++;\n            stats.totalBlobSize += getBlobSize(summaryObject.content);\n            return;\n        }\n        default: return;\n    }\n}\nexport function calculateStats(summary) {\n    const stats = mergeStats();\n    calculateStatsCore(summary, stats);\n    return stats;\n}\nexport function addBlobToSummary(summary, key, content) {\n    const blob = {\n        type: 2 /* Blob */,\n        content,\n    };\n    summary.summary.tree[key] = blob;\n    summary.stats.blobNodeCount++;\n    summary.stats.totalBlobSize += getBlobSize(content);\n}\nexport function addTreeToSummary(summary, key, summarizeResult) {\n    summary.summary.tree[key] = summarizeResult.summary;\n    summary.stats = mergeStats(summary.stats, summarizeResult.stats);\n}\nexport class SummaryTreeBuilder {\n    constructor() {\n        this.attachmentCounter = 0;\n        this.summaryTree = {};\n        this.summaryStats = mergeStats();\n        this.summaryStats.treeNodeCount++;\n    }\n    get summary() {\n        return {\n            type: 1 /* Tree */,\n            tree: Object.assign({}, this.summaryTree),\n        };\n    }\n    get stats() {\n        return Object.assign({}, this.summaryStats);\n    }\n    addBlob(key, content) {\n        // Prevent cloning by directly referencing underlying private properties\n        addBlobToSummary({\n            summary: {\n                type: 1 /* Tree */,\n                tree: this.summaryTree,\n            },\n            stats: this.summaryStats,\n        }, key, content);\n    }\n    addHandle(key, handleType, handle) {\n        this.summaryTree[key] = {\n            type: 3 /* Handle */,\n            handleType,\n            handle,\n        };\n        this.summaryStats.handleNodeCount++;\n    }\n    addWithStats(key, summarizeResult) {\n        this.summaryTree[key] = summarizeResult.summary;\n        this.summaryStats = mergeStats(this.summaryStats, summarizeResult.stats);\n    }\n    addAttachment(id) {\n        this.summaryTree[this.attachmentCounter++] = { id, type: 4 /* Attachment */ };\n    }\n    getSummaryTree() {\n        return { summary: this.summary, stats: this.stats };\n    }\n}\n/**\n * Converts snapshot ITree to ISummaryTree format and tracks stats.\n * @param snapshot - snapshot in ITree format\n * @param fullTree - true to never use handles, even if id is specified\n */\nexport function convertToSummaryTreeWithStats(snapshot, fullTree = false) {\n    const builder = new SummaryTreeBuilder();\n    for (const entry of snapshot.entries) {\n        switch (entry.type) {\n            case TreeEntry.Blob: {\n                const blob = entry.value;\n                let content;\n                if (blob.encoding === \"base64\") {\n                    content = IsoBuffer.from(blob.contents, \"base64\");\n                }\n                else {\n                    content = blob.contents;\n                }\n                builder.addBlob(entry.path, content);\n                break;\n            }\n            case TreeEntry.Tree: {\n                const subtree = convertToSummaryTree(entry.value, fullTree);\n                builder.addWithStats(entry.path, subtree);\n                break;\n            }\n            case TreeEntry.Attachment: {\n                const id = entry.value.id;\n                builder.addAttachment(id);\n                break;\n            }\n            case TreeEntry.Commit:\n                throw new Error(\"Should not have Commit TreeEntry in summary\");\n            default:\n                throw new Error(\"Unexpected TreeEntry type\");\n        }\n    }\n    return builder.getSummaryTree();\n}\n/**\n * Converts snapshot ITree to ISummaryTree format and tracks stats.\n * @param snapshot - snapshot in ITree format\n * @param fullTree - true to never use handles, even if id is specified\n */\nexport function convertToSummaryTree(snapshot, fullTree = false) {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (snapshot.id && !fullTree) {\n        const stats = mergeStats();\n        stats.handleNodeCount++;\n        return {\n            summary: {\n                handle: snapshot.id,\n                handleType: 1 /* Tree */,\n                type: 3 /* Handle */,\n            },\n            stats,\n        };\n    }\n    else {\n        return convertToSummaryTreeWithStats(snapshot, fullTree);\n    }\n}\n/**\n * Converts ISnapshotTree to ISummaryTree format and tracks stats. This snapshot tree was\n * was taken by serialize api in detached container.\n * @param snapshot - snapshot in ISnapshotTree format\n */\nexport function convertSnapshotTreeToSummaryTree(snapshot) {\n    assert(Object.keys(snapshot.commits).length === 0, 0x19e /* \"There should not be commit tree entries in snapshot\" */);\n    const builder = new SummaryTreeBuilder();\n    for (const [key, value] of Object.entries(snapshot.blobs)) {\n        // The entries in blobs are supposed to be blobPath -> blobId and blobId -> blobValue\n        // and we want to push blobPath to blobValue in tree entries.\n        if (snapshot.blobs[value] !== undefined) {\n            const decoded = fromBase64ToUtf8(snapshot.blobs[value]);\n            builder.addBlob(key, decoded);\n        }\n    }\n    for (const [key, tree] of Object.entries(snapshot.trees)) {\n        const subtree = convertSnapshotTreeToSummaryTree(tree);\n        builder.addWithStats(key, subtree);\n    }\n    return builder.getSummaryTree();\n}\n/**\n * Utility to convert serialized snapshot taken in detached container to format where we can use it to\n * attach the container.\n * @param serializedSnapshotTree - serialized snapshot tree to be converted to summary tree for attach.\n */\nexport function convertContainerToDriverSerializedFormat(serializedSnapshotTree) {\n    const snapshotTree = JSON.parse(serializedSnapshotTree);\n    const summaryTree = convertSnapshotTreeToSummaryTree(snapshotTree).summary;\n    const appSummaryTree = {\n        type: 1 /* Tree */,\n        tree: {},\n    };\n    const entries = Object.entries(summaryTree.tree);\n    for (const [key, subTree] of entries) {\n        if (key !== \".protocol\") {\n            appSummaryTree.tree[key] = subTree;\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete summaryTree.tree[key];\n        }\n    }\n    summaryTree.tree[\".app\"] = appSummaryTree;\n    return summaryTree;\n}\n/**\n * Converts ISummaryTree to ITree format. This is needed for back-compat while we get rid of snapshot.\n * @param summaryTree - summary tree in ISummaryTree format\n */\nexport function convertSummaryTreeToITree(summaryTree) {\n    const entries = [];\n    for (const [key, value] of Object.entries(summaryTree.tree)) {\n        switch (value.type) {\n            case 2 /* Blob */: {\n                let parsedContent;\n                let encoding = \"utf-8\";\n                if (typeof value.content === \"string\") {\n                    parsedContent = value.content;\n                }\n                else {\n                    parsedContent = Uint8ArrayToString(value.content, \"base64\");\n                    encoding = \"base64\";\n                }\n                entries.push(new BlobTreeEntry(key, parsedContent, encoding));\n                break;\n            }\n            case 1 /* Tree */: {\n                entries.push(new TreeTreeEntry(key, convertSummaryTreeToITree(value)));\n                break;\n            }\n            case 4 /* Attachment */: {\n                entries.push(new AttachmentTreeEntry(key, value.id));\n                break;\n            }\n            case 3 /* Handle */: {\n                throw new Error(\"Should not have Handle type in summary tree\");\n            }\n            default:\n                unreachableCase(value, \"Unexpected summary tree type\");\n        }\n    }\n    return {\n        entries,\n    };\n}\n//# sourceMappingURL=summaryUtils.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nexport const isSerializedHandle = (value) => (value === null || value === void 0 ? void 0 : value.type) === \"__fluid_handle__\";\n//# sourceMappingURL=utils.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport registerDebug from \"debug\";\nimport { pkgName, pkgVersion } from \"./packageVersion\";\nexport const debug = registerDebug(\"fluid:sequence\");\ndebug(`Package: ${pkgName} - Version: ${pkgVersion}`);\n//# sourceMappingURL=debug.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/* eslint-disable no-bitwise */\nimport { EventEmitter } from \"events\";\nimport * as MergeTree from \"@fluidframework/merge-tree\";\nexport class Interval {\n    constructor(start, end, props) {\n        this.start = start;\n        this.end = end;\n        if (props) {\n            this.addProperties(props);\n        }\n    }\n    getAdditionalPropertySets() {\n        return this.auxProps;\n    }\n    addPropertySet(props) {\n        if (this.auxProps === undefined) {\n            this.auxProps = [];\n        }\n        this.auxProps.push(props);\n    }\n    serialize(client) {\n        let seq = 0;\n        if (client) {\n            seq = client.getCurrentSeq();\n        }\n        const serializedInterval = {\n            end: this.end,\n            intervalType: 0,\n            sequenceNumber: seq,\n            start: this.start,\n        };\n        if (this.properties) {\n            serializedInterval.properties = this.properties;\n        }\n        return serializedInterval;\n    }\n    clone() {\n        return new Interval(this.start, this.end, this.properties);\n    }\n    compare(b) {\n        const startResult = this.start - b.start;\n        if (startResult === 0) {\n            return (this.end - b.end);\n        }\n        else {\n            return startResult;\n        }\n    }\n    overlaps(b) {\n        const result = (this.start < b.end) &&\n            (this.end >= b.start);\n        return result;\n    }\n    union(b) {\n        return new Interval(Math.min(this.start, b.start), Math.max(this.end, b.end), this.properties);\n    }\n    getProperties() {\n        return this.properties;\n    }\n    addProperties(newProps, op) {\n        this.properties = MergeTree.addProperties(this.properties, newProps, op);\n    }\n}\nexport class SequenceInterval {\n    constructor(start, end, intervalType, props) {\n        this.start = start;\n        this.end = end;\n        this.intervalType = intervalType;\n        if (props) {\n            this.addProperties(props);\n        }\n    }\n    serialize(client) {\n        const startPosition = this.start.toPosition();\n        const endPosition = this.end.toPosition();\n        const serializedInterval = {\n            end: endPosition,\n            intervalType: this.intervalType,\n            sequenceNumber: client.getCurrentSeq(),\n            start: startPosition,\n        };\n        if (this.properties) {\n            serializedInterval.properties = this.properties;\n        }\n        return serializedInterval;\n    }\n    clone() {\n        return new SequenceInterval(this.start, this.end, this.intervalType);\n    }\n    compare(b) {\n        const startResult = this.start.compare(b.start);\n        if (startResult === 0) {\n            return (this.end.compare(b.end));\n        }\n        else {\n            return startResult;\n        }\n    }\n    overlaps(b) {\n        const result = (this.start.compare(b.end) < 0) &&\n            (this.end.compare(b.start) >= 0);\n        if (this.checkMergeTree) {\n            this.checkOverlaps(b, result);\n        }\n        return result;\n    }\n    union(b) {\n        return new SequenceInterval(this.start.min(b.start), this.end.max(b.end), this.intervalType);\n    }\n    addProperties(newProps, op) {\n        this.properties = MergeTree.addProperties(this.properties, newProps, op);\n    }\n    overlapsPos(bstart, bend) {\n        const startPos = this.start.toPosition();\n        const endPos = this.start.toPosition();\n        return (endPos > bstart) && (startPos < bend);\n    }\n    checkOverlaps(b, result) {\n        const astart = this.start.toPosition();\n        const bstart = b.start.toPosition();\n        const aend = this.end.toPosition();\n        const bend = b.end.toPosition();\n        const checkResult = ((astart < bend) && (bstart < aend));\n        if (checkResult !== result) {\n            // eslint-disable-next-line max-len\n            console.log(`check mismatch: res ${result} ${this.start.segment === b.end.segment} ${b.start.segment === this.end.segment}`);\n            console.log(`as ${astart} ae ${aend} bs ${bstart} be ${bend}`);\n            console.log(`as ${MergeTree.ordinalToArray(this.start.segment.ordinal)}@${this.start.offset}`);\n            console.log(`ae ${MergeTree.ordinalToArray(this.end.segment.ordinal)}@${this.end.offset}`);\n            console.log(`bs ${MergeTree.ordinalToArray(b.start.segment.ordinal)}@${b.start.offset}`);\n            console.log(`be ${MergeTree.ordinalToArray(b.end.segment.ordinal)}@${b.end.offset}`);\n            console.log(this.checkMergeTree.nodeToString(b.start.segment.parent, \"\"));\n        }\n    }\n}\nfunction createPositionReference(client, pos, refType) {\n    const segoff = client.getContainingSegment(pos);\n    if (segoff && segoff.segment) {\n        const lref = new MergeTree.LocalReference(client, segoff.segment, segoff.offset, refType);\n        if (refType !== MergeTree.ReferenceType.Transient) {\n            client.addLocalReference(lref);\n        }\n        return lref;\n    }\n    return new MergeTree.LocalReference(client, undefined);\n}\nfunction createSequenceInterval(label, start, end, client, intervalType) {\n    let beginRefType = MergeTree.ReferenceType.RangeBegin;\n    let endRefType = MergeTree.ReferenceType.RangeEnd;\n    if (intervalType === MergeTree.IntervalType.Nest) {\n        beginRefType = MergeTree.ReferenceType.NestBegin;\n        endRefType = MergeTree.ReferenceType.NestEnd;\n    }\n    else if (intervalType === MergeTree.IntervalType.Transient) {\n        beginRefType = MergeTree.ReferenceType.Transient;\n        endRefType = MergeTree.ReferenceType.Transient;\n    }\n    // TODO: Should SlideOnRemove be the default behavior?\n    if (intervalType & MergeTree.IntervalType.SlideOnRemove) {\n        beginRefType |= MergeTree.ReferenceType.SlideOnRemove;\n        endRefType |= MergeTree.ReferenceType.SlideOnRemove;\n    }\n    const startLref = createPositionReference(client, start, beginRefType);\n    const endLref = createPositionReference(client, end, endRefType);\n    if (startLref && endLref) {\n        startLref.pairedRef = endLref;\n        endLref.pairedRef = startLref;\n        const rangeProp = {\n            [MergeTree.reservedRangeLabelsKey]: [label],\n        };\n        startLref.addProperties(rangeProp);\n        endLref.addProperties(rangeProp);\n        const ival = new SequenceInterval(startLref, endLref, intervalType, rangeProp);\n        return ival;\n    }\n}\nexport function defaultIntervalConflictResolver(a, b) {\n    a.addPropertySet(b.properties);\n    return a;\n}\nexport function createIntervalIndex(conflict) {\n    const helpers = {\n        compareEnds: compareIntervalEnds,\n        create: createInterval,\n    };\n    const lc = new LocalIntervalCollection(undefined, \"\", helpers);\n    if (conflict) {\n        lc.addConflictResolver(conflict);\n    }\n    else {\n        lc.addConflictResolver(defaultIntervalConflictResolver);\n    }\n    return lc;\n}\nexport class LocalIntervalCollection {\n    constructor(client, label, helpers) {\n        this.client = client;\n        this.label = label;\n        this.helpers = helpers;\n        this.intervalTree = new MergeTree.IntervalTree();\n        this.endIntervalTree =\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            new MergeTree.RedBlackTree(helpers.compareEnds);\n    }\n    addConflictResolver(conflictResolver) {\n        this.conflictResolver = conflictResolver;\n        this.endConflictResolver =\n            (key, currentKey) => {\n                const ival = this.conflictResolver(key, currentKey);\n                return {\n                    data: ival,\n                    key: ival,\n                };\n            };\n    }\n    map(fn) {\n        this.intervalTree.map(fn);\n    }\n    findOverlappingIntervals(startPosition, endPosition) {\n        if (!this.intervalTree.intervals.isEmpty()) {\n            const transientInterval = this.helpers.create(\"transient\", startPosition, endPosition, this.client, MergeTree.IntervalType.Transient);\n            const overlappingIntervalNodes = this.intervalTree.match(transientInterval);\n            return overlappingIntervalNodes.map((node) => node.key);\n        }\n        else {\n            return [];\n        }\n    }\n    previousInterval(pos) {\n        const transientInterval = this.helpers.create(\"transient\", pos, pos, this.client, MergeTree.IntervalType.Transient);\n        const rbNode = this.endIntervalTree.floor(transientInterval);\n        if (rbNode) {\n            return rbNode.data;\n        }\n    }\n    nextInterval(pos) {\n        const transientInterval = this.helpers.create(\"transient\", pos, pos, this.client, MergeTree.IntervalType.Transient);\n        const rbNode = this.endIntervalTree.ceil(transientInterval);\n        if (rbNode) {\n            return rbNode.data;\n        }\n    }\n    removeInterval(startPosition, endPosition) {\n        const transientInterval = this.helpers.create(\"transient\", startPosition, endPosition, this.client, MergeTree.IntervalType.Transient);\n        this.intervalTree.remove(transientInterval);\n        this.endIntervalTree.remove(transientInterval);\n        return transientInterval;\n    }\n    createInterval(start, end, intervalType) {\n        return this.helpers.create(this.label, start, end, this.client, intervalType);\n    }\n    // TODO: remove interval, handle duplicate intervals\n    addInterval(start, end, intervalType, props) {\n        const interval = this.createInterval(start, end, intervalType);\n        if (interval) {\n            interval.addProperties(props);\n            if (this.label && (this.label.length > 0)) {\n                interval.properties[MergeTree.reservedRangeLabelsKey] = [this.label];\n            }\n            this.intervalTree.put(interval, this.conflictResolver);\n            this.endIntervalTree.put(interval, interval, this.endConflictResolver);\n        }\n        return interval;\n    }\n    serialize() {\n        const client = this.client;\n        const intervals = this.intervalTree.intervals.keys();\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return intervals.map((interval) => interval.serialize(client));\n    }\n}\nconst compareSequenceIntervalEnds = (a, b) => a.end.compare(b.end);\nclass SequenceIntervalCollectionFactory {\n    load(emitter, raw = []) {\n        const helpers = {\n            compareEnds: compareSequenceIntervalEnds,\n            create: createSequenceInterval,\n        };\n        return new IntervalCollection(helpers, true, emitter, raw);\n    }\n    store(value) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return value.serializeInternal();\n    }\n}\nexport class SequenceIntervalCollectionValueType {\n    get name() {\n        return SequenceIntervalCollectionValueType.Name;\n    }\n    get factory() {\n        return SequenceIntervalCollectionValueType._factory;\n    }\n    get ops() {\n        return SequenceIntervalCollectionValueType._ops;\n    }\n}\nSequenceIntervalCollectionValueType.Name = \"sharedStringIntervalCollection\";\nSequenceIntervalCollectionValueType._factory = new SequenceIntervalCollectionFactory();\nSequenceIntervalCollectionValueType._ops = new Map([[\n        \"add\",\n        {\n            process: (value, params, local, op) => {\n                // Local ops were applied when the message was created\n                if (local) {\n                    return;\n                }\n                value.addInternal(params, local, op);\n            },\n        },\n    ],\n    [\n        \"delete\",\n        {\n            process: (value, params, local, op) => {\n                if (local) {\n                    return;\n                }\n                value.deleteInterval(params, local, op);\n            },\n        },\n    ]]);\nconst compareIntervalEnds = (a, b) => a.end - b.end;\nfunction createInterval(label, start, end, client) {\n    let rangeProp;\n    if (label && (label.length > 0)) {\n        rangeProp = {\n            [MergeTree.reservedRangeLabelsKey]: [label],\n        };\n    }\n    return new Interval(start, end, rangeProp);\n}\nclass IntervalCollectionFactory {\n    load(emitter, raw = []) {\n        const helpers = {\n            compareEnds: compareIntervalEnds,\n            create: createInterval,\n        };\n        const collection = new IntervalCollection(helpers, false, emitter, raw);\n        collection.attachGraph(undefined, \"\");\n        return collection;\n    }\n    store(value) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return value.serializeInternal();\n    }\n}\nexport class IntervalCollectionValueType {\n    get name() {\n        return IntervalCollectionValueType.Name;\n    }\n    get factory() {\n        return IntervalCollectionValueType._factory;\n    }\n    get ops() {\n        return IntervalCollectionValueType._ops;\n    }\n}\nIntervalCollectionValueType.Name = \"sharedIntervalCollection\";\nIntervalCollectionValueType._factory = new IntervalCollectionFactory();\nIntervalCollectionValueType._ops = new Map([[\n        \"add\",\n        {\n            process: (value, params, local, op) => {\n                // Local ops were applied when the message was created\n                if (local) {\n                    return;\n                }\n                value.addInternal(params, local, op);\n            },\n        },\n    ],\n    [\n        \"delete\",\n        {\n            process: (value, params, local, op) => {\n                if (local) {\n                    return;\n                }\n                value.deleteInterval(params, local, op);\n            },\n        },\n    ]]);\nexport class IntervalCollectionView extends EventEmitter {\n    constructor(client, savedSerializedIntervals, label, helpers, emitter) {\n        super();\n        this.client = client;\n        this.emitter = emitter;\n        // Instantiate the local interval collection based on the saved intervals\n        this.localCollection = new LocalIntervalCollection(client, label, helpers);\n        if (savedSerializedIntervals) {\n            for (const serializedInterval of savedSerializedIntervals) {\n                this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties);\n            }\n        }\n    }\n    attachDeserializer(onDeserialize) {\n        this.attachDeserializerCore(onDeserialize);\n    }\n    addConflictResolver(conflictResolver) {\n        this.localCollection.addConflictResolver(conflictResolver);\n    }\n    findOverlappingIntervals(startPosition, endPosition) {\n        return this.localCollection.findOverlappingIntervals(startPosition, endPosition);\n    }\n    map(fn) {\n        this.localCollection.map(fn);\n    }\n    previousInterval(pos) {\n        return this.localCollection.previousInterval(pos);\n    }\n    nextInterval(pos) {\n        return this.localCollection.nextInterval(pos);\n    }\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    add(start, end, intervalType, props) {\n        let seq = 0;\n        if (this.client) {\n            seq = this.client.getCurrentSeq();\n        }\n        const serializedInterval = {\n            end,\n            intervalType,\n            properties: props,\n            sequenceNumber: seq,\n            start,\n        };\n        this.addInternal(serializedInterval, true, undefined);\n    }\n    delete(start, end) {\n        let sequenceNumber = 0;\n        if (this.client) {\n            sequenceNumber = this.client.getCurrentSeq();\n        }\n        const serializedInterval = {\n            start,\n            end,\n            sequenceNumber,\n            intervalType: MergeTree.IntervalType.Transient,\n        };\n        this.deleteInterval(serializedInterval, true, undefined);\n    }\n    // TODO: error cases\n    addInternal(serializedInterval, local, op) {\n        const interval = this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties);\n        if (interval) {\n            // Local ops get submitted to the server. Remote ops have the deserializer run.\n            if (local) {\n                this.emitter.emit(\"add\", undefined, serializedInterval);\n            }\n            else {\n                if (this.onDeserialize) {\n                    this.onDeserialize(interval);\n                }\n            }\n        }\n        this.emit(\"addInterval\", interval, local, op);\n        return this;\n    }\n    deleteInterval(serializedInterval, local, op) {\n        const interval = this.localCollection.removeInterval(serializedInterval.start, serializedInterval.end);\n        if (interval) {\n            // Local ops get submitted to the server. Remote ops have the deserializer run.\n            if (local) {\n                this.emitter.emit(\"delete\", undefined, serializedInterval);\n            }\n            else {\n                if (this.onDeserialize) {\n                    this.onDeserialize(interval);\n                }\n            }\n        }\n        this.emit(\"deleteInterval\", interval, local, op);\n        return this;\n    }\n    serializeInternal() {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return this.localCollection.serialize();\n    }\n    attachDeserializerCore(onDeserialize) {\n        // If no deserializer is specified can skip all processing work\n        if (!onDeserialize) {\n            return;\n        }\n        // Start by storing the callbacks so that any subsequent modifications make use of them\n        this.onDeserialize = onDeserialize;\n        // Trigger the async prepare work across all values in the collection\n        this.localCollection.map((interval) => {\n            this.onDeserialize(interval);\n        });\n    }\n}\nexport class IntervalCollection {\n    constructor(helpers, requiresClient, emitter, serializedIntervals) {\n        this.helpers = helpers;\n        this.requiresClient = requiresClient;\n        this.emitter = emitter;\n        this.savedSerializedIntervals = serializedIntervals;\n    }\n    get attached() {\n        return !!this.view;\n    }\n    attachGraph(client, label) {\n        if (this.view) {\n            throw new Error(\"Only supports one Sequence attach\");\n        }\n        if ((client === undefined) && (this.requiresClient)) {\n            throw new Error(\"Client required for this collection\");\n        }\n        this.view = new IntervalCollectionView(client, this.savedSerializedIntervals, label, this.helpers, this.emitter);\n        this.savedSerializedIntervals = undefined;\n    }\n    add(startPosition, endPosition, intervalType, props) {\n        if (!this.view) {\n            throw new Error(\"attach must be called prior to adding intervals\");\n        }\n        this.view.add(startPosition, endPosition, intervalType, props);\n    }\n    delete(startPosition, endPosition) {\n        if (!this.view) {\n            throw new Error(\"attach must be called prior to deleting intervals\");\n        }\n        this.view.delete(startPosition, endPosition);\n    }\n    addConflictResolver(conflictResolver) {\n        this.view.addConflictResolver(conflictResolver);\n    }\n    async getView(onDeserialize) {\n        if (!this.view) {\n            return Promise.reject(new Error(\"attachSequence must be called prior to retrieving the view\"));\n        }\n        // Attach custom deserializers if specified\n        if (onDeserialize) {\n            this.view.attachDeserializer(onDeserialize);\n        }\n        return this.view;\n    }\n    addInternal(serializedInterval, local, op) {\n        if (!this.view) {\n            throw new Error(\"attachSequence must be called\");\n        }\n        return this.view.addInternal(serializedInterval, local, op);\n    }\n    deleteInterval(serializedInterval, local, op) {\n        if (!this.view) {\n            throw new Error(\"attach must be called prior to deleting intervals\");\n        }\n        this.view.deleteInterval(serializedInterval, local, op);\n    }\n    serializeInternal() {\n        if (!this.view) {\n            throw new Error(\"attachSequence must be called\");\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return this.view.serializeInternal();\n    }\n}\n//# sourceMappingURL=intervalCollection.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n *\n * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n */\nexport const pkgName = \"@fluidframework/sequence\";\nexport const pkgVersion = \"0.37.4\";\n//# sourceMappingURL=packageVersion.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { Deferred, bufferToString, assert } from \"@fluidframework/common-utils\";\nimport { ChildLogger } from \"@fluidframework/telemetry-utils\";\nimport { MapKernel } from \"@fluidframework/map\";\nimport * as MergeTree from \"@fluidframework/merge-tree\";\nimport { FileMode, MessageType, TreeEntry, } from \"@fluidframework/protocol-definitions\";\nimport { ObjectStoragePartition } from \"@fluidframework/runtime-utils\";\nimport { makeHandlesSerializable, parseHandles, SharedObject, } from \"@fluidframework/shared-object-base\";\nimport { debug } from \"./debug\";\nimport { SequenceIntervalCollectionValueType, } from \"./intervalCollection\";\nimport { SequenceDeltaEvent, SequenceMaintenanceEvent } from \"./sequenceDeltaEvent\";\nconst snapshotFileName = \"header\";\nconst contentPath = \"content\";\nexport class SharedSegmentSequence extends SharedObject {\n    constructor(dataStoreRuntime, id, attributes, segmentFromSpec) {\n        super(id, dataStoreRuntime, attributes);\n        this.dataStoreRuntime = dataStoreRuntime;\n        this.id = id;\n        this.segmentFromSpec = segmentFromSpec;\n        // Deferred that triggers once the object is loaded\n        this.loadedDeferred = new Deferred();\n        // cache out going ops created when parital loading\n        this.loadedDeferredOutgoingOps = [];\n        // cache incoming ops that arrive when partial loading\n        this.deferIncomingOps = true;\n        this.loadedDeferredIncomingOps = [];\n        this.messagesSinceMSNChange = [];\n        this.loadedDeferred.promise.catch((error) => {\n            this.logger.sendErrorEvent({ eventName: \"SequenceLoadFailed\" }, error);\n        });\n        this.client = new MergeTree.Client(segmentFromSpec, ChildLogger.create(this.logger, \"SharedSegmentSequence.MergeTreeClient\"), dataStoreRuntime.options);\n        super.on(\"newListener\", (event) => {\n            switch (event) {\n                case \"sequenceDelta\":\n                    if (!this.client.mergeTreeDeltaCallback) {\n                        this.client.mergeTreeDeltaCallback = (opArgs, deltaArgs) => {\n                            this.emit(\"sequenceDelta\", new SequenceDeltaEvent(opArgs, deltaArgs, this.client), this);\n                        };\n                    }\n                    break;\n                case \"maintenance\":\n                    if (!this.client.mergeTreeMaintenanceCallback) {\n                        this.client.mergeTreeMaintenanceCallback = (args, opArgs) => {\n                            this.emit(\"maintenance\", new SequenceMaintenanceEvent(opArgs, args, this.client), this);\n                        };\n                    }\n                    break;\n                default:\n            }\n        });\n        super.on(\"removeListener\", (event) => {\n            switch (event) {\n                case \"sequenceDelta\":\n                    if (super.listenerCount(event) === 0) {\n                        this.client.mergeTreeDeltaCallback = undefined;\n                    }\n                    break;\n                case \"maintenance\":\n                    if (super.listenerCount(event) === 0) {\n                        this.client.mergeTreeMaintenanceCallback = undefined;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        });\n        this.intervalMapKernel = new MapKernel(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), () => this.isAttached(), [new SequenceIntervalCollectionValueType()]);\n    }\n    get loaded() {\n        return this.loadedDeferred.promise;\n    }\n    static createOpsFromDelta(event) {\n        const ops = [];\n        for (const r of event.ranges) {\n            switch (event.deltaOperation) {\n                case 2 /* ANNOTATE */: {\n                    const lastAnnotate = ops[ops.length - 1];\n                    const props = {};\n                    for (const key of Object.keys(r.propertyDeltas)) {\n                        props[key] =\n                            // eslint-disable-next-line no-null/no-null\n                            r.segment.properties[key] === undefined ? null : r.segment.properties[key];\n                    }\n                    if (lastAnnotate && lastAnnotate.pos2 === r.position &&\n                        MergeTree.matchProperties(lastAnnotate.props, props)) {\n                        lastAnnotate.pos2 += r.segment.cachedLength;\n                    }\n                    else {\n                        ops.push(MergeTree.createAnnotateRangeOp(r.position, r.position + r.segment.cachedLength, props, undefined));\n                    }\n                    break;\n                }\n                case 0 /* INSERT */:\n                    ops.push(MergeTree.createInsertOp(r.position, r.segment.clone().toJSONObject()));\n                    break;\n                case 1 /* REMOVE */: {\n                    const lastRem = ops[ops.length - 1];\n                    if ((lastRem === null || lastRem === void 0 ? void 0 : lastRem.pos1) === r.position) {\n                        lastRem.pos2 += r.segment.cachedLength;\n                    }\n                    else {\n                        ops.push(MergeTree.createRemoveRangeOp(r.position, r.position + r.segment.cachedLength));\n                    }\n                    break;\n                }\n                default:\n            }\n        }\n        return ops;\n    }\n    /**\n     * @param start - The inclusive start of the range to remove\n     * @param end - The exclusive end of the range to remove\n     */\n    removeRange(start, end) {\n        const removeOp = this.client.removeRangeLocal(start, end);\n        if (removeOp) {\n            this.submitSequenceMessage(removeOp);\n        }\n        return removeOp;\n    }\n    /**\n     * Removes the range and puts the content of the removed range in a register\n     *\n     * @param start - The inclusive start of the range to remove\n     * @param end - The exclusive end of the range to remove\n     * @param register - The name of the register to store the removed range in\n     */\n    cut(start, end, register) {\n        const removeOp = this.client.removeRangeLocal(start, end, register);\n        if (removeOp) {\n            this.submitSequenceMessage(removeOp);\n        }\n    }\n    /**\n     * Inserts the content of the register.\n     *\n     * @param pos - The postition to insert the content at.\n     * @param register - The name of the register to get the content from\n     */\n    paste(pos, register) {\n        const insertOp = this.client.pasteLocal(pos, register);\n        if (insertOp) {\n            this.submitSequenceMessage(insertOp);\n        }\n        return pos;\n    }\n    /**\n     * Puts the content of the range in a register\n     *\n     * @param start - The inclusive start of the range\n     * @param end - The exclusive end of the range\n     * @param register - The name of the register to store the range in\n     */\n    copy(start, end, register) {\n        const insertOp = this.client.copyLocal(start, end, register);\n        if (insertOp) {\n            this.submitSequenceMessage(insertOp);\n        }\n    }\n    groupOperation(groupOp) {\n        this.client.localTransaction(groupOp);\n        this.submitSequenceMessage(groupOp);\n    }\n    getContainingSegment(pos) {\n        return this.client.getContainingSegment(pos);\n    }\n    /**\n     * Returns the length of the current sequence for the client\n     */\n    getLength() {\n        return this.client.getLength();\n    }\n    /**\n     * Returns the current position of a segment, and -1 if the segment\n     * does not exist in this sequence\n     * @param segment - The segment to get the position of\n     */\n    getPosition(segment) {\n        return this.client.getPosition(segment);\n    }\n    /**\n     * Annotates the range with the provided properties\n     *\n     * @param start - The inclusive start postition of the range to annotate\n     * @param end - The exclusive end position of the range to annotate\n     * @param props - The properties to annotate the range with\n     * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n     *\n     */\n    annotateRange(start, end, props, combiningOp) {\n        const annotateOp = this.client.annotateRangeLocal(start, end, props, combiningOp);\n        if (annotateOp) {\n            this.submitSequenceMessage(annotateOp);\n        }\n    }\n    getPropertiesAtPosition(pos) {\n        return this.client.getPropertiesAtPosition(pos);\n    }\n    getRangeExtentsOfPosition(pos) {\n        return this.client.getRangeExtentsOfPosition(pos);\n    }\n    createPositionReference(segment, offset, refType) {\n        const lref = new MergeTree.LocalReference(this.client, segment, offset, refType);\n        if (refType !== MergeTree.ReferenceType.Transient) {\n            this.addLocalReference(lref);\n        }\n        return lref;\n    }\n    localRefToPos(localRef) {\n        if (localRef.segment) {\n            return localRef.offset + this.getPosition(localRef.segment);\n        }\n        else {\n            return -1;\n        }\n    }\n    /**\n     * Resolves a remote client's position against the local sequence\n     * and returns the remote client's position relative to the local\n     * sequence\n     * @param remoteClientPosition - The remote client's position to resolve\n     * @param remoteClientRefSeq - The reference sequence number of the remote client\n     * @param remoteClientId - The client id of the remote client\n     */\n    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {\n        return this.client.resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId);\n    }\n    submitSequenceMessage(message) {\n        if (!this.isAttached()) {\n            return;\n        }\n        const translated = makeHandlesSerializable(message, this.serializer, this.handle);\n        const metadata = this.client.peekPendingSegmentGroups(message.type === 3 /* GROUP */ ? message.ops.length : 1);\n        // if loading isn't complete, we need to cache\n        // local ops until loading is complete, and then\n        // they will be resent\n        if (!this.loadedDeferred.isCompleted) {\n            this.loadedDeferredOutgoingOps.push([translated, metadata]);\n        }\n        else {\n            this.submitLocalMessage(translated, metadata);\n        }\n    }\n    addLocalReference(lref) {\n        return this.client.addLocalReference(lref);\n    }\n    removeLocalReference(lref) {\n        return this.client.removeLocalReference(lref);\n    }\n    /**\n     * Given a position specified relative to a marker id, lookup the marker\n     * and convert the position to a character position.\n     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.\n     */\n    posFromRelativePos(relativePos) {\n        return this.client.posFromRelativePos(relativePos);\n    }\n    /**\n     * Walk the underlying segments of the sequence.\n     * The walked segments may extend beyond the range\n     * if the segments cross the ranges start or end boundaries.\n     * Set split range to true to ensure only segments within the\n     * range are walked.\n     *\n     * @param handler - The function to handle each segment\n     * @param start - Optional. The start of range walk.\n     * @param end - Optional. The end of range walk\n     * @param accum - Optional. An object that will be passed to the handler for accumulation\n     * @param splitRange - Optional. Splits boundary segments on the range boundaries\n     */\n    walkSegments(handler, start, end, accum, splitRange = false) {\n        return this.client.walkSegments(handler, start, end, accum, splitRange);\n    }\n    getStackContext(startPos, rangeLabels) {\n        return this.client.getStackContext(startPos, rangeLabels);\n    }\n    getCurrentSeq() {\n        return this.client.getCurrentSeq();\n    }\n    insertAtReferencePosition(pos, segment) {\n        const insertOp = this.client.insertAtReferencePositionLocal(pos, segment);\n        if (insertOp) {\n            this.submitSequenceMessage(insertOp);\n        }\n    }\n    async waitIntervalCollection(label) {\n        return this.intervalMapKernel.wait(this.getIntervalCollectionPath(label));\n    }\n    // TODO: fix race condition on creation by putting type on every operation\n    getIntervalCollection(label) {\n        const labelPath = this.getIntervalCollectionPath(label);\n        if (!this.intervalMapKernel.has(labelPath)) {\n            this.intervalMapKernel.createValueType(labelPath, SequenceIntervalCollectionValueType.Name, undefined);\n        }\n        const sharedCollection = this.intervalMapKernel.get(labelPath);\n        return sharedCollection;\n    }\n    snapshotCore(serializer) {\n        const entries = [];\n        // conditionally write the interval collection blob\n        // only if it has entries\n        if (this.intervalMapKernel.size > 0) {\n            entries.push({\n                mode: FileMode.File,\n                path: snapshotFileName,\n                type: TreeEntry.Blob,\n                value: {\n                    contents: this.intervalMapKernel.serialize(serializer),\n                    encoding: \"utf-8\",\n                },\n            });\n        }\n        entries.push({\n            mode: FileMode.Directory,\n            path: contentPath,\n            type: TreeEntry.Tree,\n            value: this.snapshotMergeTree(serializer),\n        });\n        const tree = {\n            entries,\n        };\n        return tree;\n    }\n    /**\n     * Replace the range specified from start to end with the provided segment\n     * This is done by inserting the segment at the end of the range, followed\n     * by removing the contents of the range\n     * For a zero or reverse range (start \\>= end), insert at end do not remove anything\n     * @param start - The start of the range to replace\n     * @param end - The end of the range to replace\n     * @param segment - The segment that will replace the range\n     */\n    replaceRange(start, end, segment) {\n        // Insert at the max end of the range when start > end, but still remove the range later\n        const insertIndex = Math.max(start, end);\n        // Insert first, so local references can slide to the inserted seg if any\n        const insert = this.client.insertSegmentLocal(insertIndex, segment);\n        if (insert) {\n            if (start < end) {\n                const remove = this.client.removeRangeLocal(start, end);\n                this.submitSequenceMessage(MergeTree.createGroupOp(insert, remove));\n            }\n            else {\n                this.submitSequenceMessage(insert);\n            }\n        }\n    }\n    onConnect() {\n        // Update merge tree collaboration information with new client ID and then resend pending ops\n        this.client.startOrUpdateCollaboration(this.runtime.clientId);\n    }\n    onDisconnect() {\n        debug(`${this.id} is now disconnected`);\n    }\n    reSubmitCore(content, localOpMetadata) {\n        if (!this.intervalMapKernel.trySubmitMessage(content, localOpMetadata)) {\n            this.submitSequenceMessage(this.client.regeneratePendingOp(content, localOpMetadata));\n        }\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n     */\n    async loadCore(storage) {\n        var _a;\n        if (await storage.contains(snapshotFileName)) {\n            const blob = await storage.readBlob(snapshotFileName);\n            const header = bufferToString(blob, \"utf8\");\n            this.intervalMapKernel.populate(header);\n        }\n        try {\n            // this will load the header, and return a promise\n            // that will resolve when the body is loaded\n            // and the catchup ops are available.\n            const { catchupOpsP } = await this.client.load(this.runtime, new ObjectStoragePartition(storage, contentPath), this.serializer);\n            // setup a promise to process the\n            // catch up ops, and finishing the loading process\n            const loadCatchUpOps = catchupOpsP\n                .then((msgs) => {\n                msgs.forEach((m) => {\n                    const collabWindow = this.client.getCollabWindow();\n                    if (m.minimumSequenceNumber < collabWindow.minSeq\n                        || m.referenceSequenceNumber < collabWindow.minSeq\n                        || m.sequenceNumber <= collabWindow.minSeq\n                        || m.sequenceNumber <= collabWindow.currentSeq) {\n                        throw new Error(`Invalid catchup operations in snapshot: ${JSON.stringify({\n                            op: {\n                                seq: m.sequenceNumber,\n                                minSeq: m.minimumSequenceNumber,\n                                refSeq: m.referenceSequenceNumber,\n                            },\n                            collabWindow: {\n                                seq: collabWindow.currentSeq,\n                                minSeq: collabWindow.minSeq,\n                            },\n                        })}`);\n                    }\n                    this.processMergeTreeMsg(m);\n                });\n                this.loadFinished();\n            })\n                .catch((error) => {\n                this.loadFinished(error);\n            });\n            if (((_a = this.dataStoreRuntime.options) === null || _a === void 0 ? void 0 : _a.sequenceInitializeFromHeaderOnly) !== true) {\n                // if we not doing parital load, await the catch up ops,\n                // and the finalization of the load\n                await loadCatchUpOps;\n            }\n        }\n        catch (error) {\n            this.loadFinished(error);\n        }\n    }\n    processCore(message, local, localOpMetadata) {\n        // if loading isn't complete, we need to cache all\n        // incoming ops to be applied after loading is complete\n        if (this.deferIncomingOps) {\n            assert(!local, 0x072 /* \"Unexpected local op when loading not finished\" */);\n            this.loadedDeferredIncomingOps.push(message);\n        }\n        else {\n            assert(message.type === MessageType.Operation, 0x073 /* \"Sequence message not operation\" */);\n            const handled = this.intervalMapKernel.tryProcessMessage(message.contents, local, message, localOpMetadata);\n            if (!handled) {\n                this.processMergeTreeMsg(message);\n            }\n        }\n    }\n    registerCore() {\n        for (const value of this.intervalMapKernel.values()) {\n            if (SharedObject.is(value)) {\n                value.bindToContext();\n            }\n        }\n        this.client.startOrUpdateCollaboration(this.runtime.clientId);\n    }\n    didAttach() {\n        var _a;\n        // If we are not local, and we've attached we need to start generating and sending ops\n        // so start collaboration and provide a default client id incase we are not connected\n        if (this.isAttached()) {\n            this.client.startOrUpdateCollaboration((_a = this.runtime.clientId) !== null && _a !== void 0 ? _a : \"attached\");\n        }\n    }\n    initializeLocalCore() {\n        super.initializeLocalCore();\n        this.loadFinished();\n    }\n    snapshotMergeTree(serializer) {\n        // Are we fully loaded? If not, things will go south\n        assert(this.loadedDeferred.isCompleted, 0x074 /* \"Snapshot called when not fully loaded\" */);\n        const minSeq = this.runtime.deltaManager.minimumSequenceNumber;\n        this.processMinSequenceNumberChanged(minSeq);\n        this.messagesSinceMSNChange.forEach((m) => m.minimumSequenceNumber = minSeq);\n        return this.client.snapshot(this.runtime, this.handle, serializer, this.messagesSinceMSNChange);\n    }\n    processMergeTreeMsg(rawMessage) {\n        var _a, _b;\n        const message = parseHandles(rawMessage, this.serializer);\n        const ops = [];\n        function transfromOps(event) {\n            ops.push(...SharedSegmentSequence.createOpsFromDelta(event));\n        }\n        const needsTransformation = message.referenceSequenceNumber !== message.sequenceNumber - 1;\n        let stashMessage = message;\n        if (((_a = this.runtime.options) === null || _a === void 0 ? void 0 : _a.newMergeTreeSnapshotFormat) !== true) {\n            if (needsTransformation) {\n                this.on(\"sequenceDelta\", transfromOps);\n            }\n        }\n        this.client.applyMsg(message);\n        if (((_b = this.runtime.options) === null || _b === void 0 ? void 0 : _b.newMergeTreeSnapshotFormat) !== true) {\n            if (needsTransformation) {\n                this.removeListener(\"sequenceDelta\", transfromOps);\n                // shallow clone the message as we only overwrite top level properties,\n                // like referenceSequenceNumber and content only\n                stashMessage = Object.assign(Object.assign({}, message), { referenceSequenceNumber: stashMessage.sequenceNumber - 1, contents: ops.length !== 1 ? MergeTree.createGroupOp(...ops) : ops[0] });\n            }\n            this.messagesSinceMSNChange.push(stashMessage);\n            // Do GC every once in a while...\n            if (this.messagesSinceMSNChange.length > 20\n                && this.messagesSinceMSNChange[20].sequenceNumber < message.minimumSequenceNumber) {\n                this.processMinSequenceNumberChanged(message.minimumSequenceNumber);\n            }\n        }\n    }\n    getIntervalCollectionPath(label) {\n        return `intervalCollections/${label}`;\n    }\n    processMinSequenceNumberChanged(minSeq) {\n        let index = 0;\n        for (; index < this.messagesSinceMSNChange.length; index++) {\n            if (this.messagesSinceMSNChange[index].sequenceNumber > minSeq) {\n                break;\n            }\n        }\n        if (index !== 0) {\n            this.messagesSinceMSNChange = this.messagesSinceMSNChange.slice(index);\n        }\n    }\n    loadFinished(error) {\n        if (!this.loadedDeferred.isCompleted) {\n            // Initialize the interval collections\n            this.initializeIntervalCollections();\n            if (error) {\n                this.loadedDeferred.reject(error);\n                throw error;\n            }\n            else {\n                // it is important this series remains synchronous\n                // first we stop defering incoming ops, and apply then all\n                this.deferIncomingOps = false;\n                while (this.loadedDeferredIncomingOps.length > 0) {\n                    this.processCore(this.loadedDeferredIncomingOps.shift(), false, undefined);\n                }\n                // then resolve the loaded promise\n                // and resubmit all the outstanding ops, as the snapshot\n                // is fully loaded, and all outstanding ops are applied\n                this.loadedDeferred.resolve();\n                while (this.loadedDeferredOutgoingOps.length > 0) {\n                    const opData = this.loadedDeferredOutgoingOps.shift();\n                    this.reSubmitCore(opData[0], opData[1]);\n                }\n            }\n        }\n    }\n    initializeIntervalCollections() {\n        // Listen and initialize new SharedIntervalCollections\n        this.intervalMapKernel.eventEmitter.on(\"valueChanged\", (ev) => {\n            const intervalCollection = this.intervalMapKernel.get(ev.key);\n            if (!intervalCollection.attached) {\n                intervalCollection.attachGraph(this.client, ev.key);\n            }\n        });\n        // Initialize existing SharedIntervalCollections\n        for (const key of this.intervalMapKernel.keys()) {\n            const intervalCollection = this.intervalMapKernel.get(key);\n            intervalCollection.attachGraph(this.client, key);\n        }\n    }\n    applyStashedOp() {\n        throw new Error(\"not implemented\");\n    }\n}\n//# sourceMappingURL=sequence.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { SortedSegmentSet, } from \"@fluidframework/merge-tree\";\n/**\n * Base class for SequenceDeltaEvent and SequenceMaintenanceEvent.\n *\n * The properties of this object and its sub-objects represent a point in time state\n * at the time the operation was applied. They will not take into any future modifications\n * performed to the underlying sequence and merge tree.\n */\nexport class SequenceEvent {\n    constructor(deltaArgs, mergeTreeClient) {\n        this.deltaArgs = deltaArgs;\n        this.mergeTreeClient = mergeTreeClient;\n        this.isEmpty = deltaArgs.deltaSegments.length === 0;\n        this.deltaOperation = deltaArgs.operation;\n        this.sortedRanges = new Lazy(() => {\n            const set = new SortedSegmentSet();\n            this.deltaArgs.deltaSegments.forEach((delta) => {\n                const newRange = {\n                    operation: this.deltaArgs.operation,\n                    position: this.mergeTreeClient.getPosition(delta.segment),\n                    propertyDeltas: delta.propertyDeltas,\n                    segment: delta.segment,\n                };\n                set.addOrUpdate(newRange);\n            });\n            return set;\n        });\n        this.pFirst = new Lazy(() => {\n            if (this.isEmpty) {\n                return undefined;\n            }\n            return this.sortedRanges.value.items[0];\n        });\n        this.pLast = new Lazy(() => {\n            if (this.isEmpty) {\n                return undefined;\n            }\n            return this.sortedRanges.value.items[this.sortedRanges.value.size - 1];\n        });\n    }\n    /**\n     * The in-order ranges affected by this delta.\n     * These may not be continous.\n     */\n    get ranges() {\n        return this.sortedRanges.value.items;\n    }\n    /**\n     * The client id of the client that made the change which caused the delta event\n     */\n    get clientId() {\n        return this.mergeTreeClient.longClientId;\n    }\n    get first() {\n        return this.pFirst.value;\n    }\n    get last() {\n        return this.pLast.value;\n    }\n}\n/**\n * The event object returned on sequenceDelta events.\n *\n * The properties of this object and its sub-objects represent a point in time state\n * at the time the operation was applied. They will not take into any future modifications\n * performed to the underlying sequence and merge tree.\n *\n * For group ops, each op will get it's own event, and the group op property will be set on the op args.\n *\n * Ops may get multiple events. For instance, an insert-replace will get a remove then an insert event.\n */\nexport class SequenceDeltaEvent extends SequenceEvent {\n    constructor(opArgs, deltaArgs, mergeTreeClient) {\n        super(deltaArgs, mergeTreeClient);\n        this.opArgs = opArgs;\n        this.isLocal = opArgs.sequencedMessage === undefined;\n    }\n}\n/**\n * The event object returned on maintenance events.\n *\n * The properties of this object and its sub-objects represent a point in time state\n * at the time the operation was applied. They will not take into any future modifications\n * performed to the underlying sequence and merge tree.\n */\nexport class SequenceMaintenanceEvent extends SequenceEvent {\n    constructor(opArgs, deltaArgs, mergeTreeClient) {\n        super(deltaArgs, mergeTreeClient);\n        this.opArgs = opArgs;\n    }\n}\nclass Lazy {\n    constructor(valueGenerator) {\n        this.valueGenerator = valueGenerator;\n        this.pEvaluated = false;\n    }\n    get evaluated() {\n        return this.pEvaluated;\n    }\n    get value() {\n        if (!this.pEvaluated) {\n            this.pEvaluated = true;\n            this.pValue = this.valueGenerator();\n        }\n        return this.pValue;\n    }\n}\n//# sourceMappingURL=sequenceDeltaEvent.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as MergeTree from \"@fluidframework/merge-tree\";\nimport { pkgVersion } from \"./packageVersion\";\nimport { SharedNumberSequence } from \"./sharedNumberSequence\";\nimport { SharedObjectSequence } from \"./sharedObjectSequence\";\nimport { SubSequence } from \"./sharedSequence\";\nimport { SharedString } from \"./sharedString\";\nexport class SharedStringFactory {\n    static segmentFromSpec(spec) {\n        const maybeText = MergeTree.TextSegment.fromJSONObject(spec);\n        if (maybeText) {\n            return maybeText;\n        }\n        const maybeMarker = MergeTree.Marker.fromJSONObject(spec);\n        if (maybeMarker) {\n            return maybeMarker;\n        }\n    }\n    get type() {\n        return SharedStringFactory.Type;\n    }\n    get attributes() {\n        return SharedStringFactory.Attributes;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n     */\n    async load(runtime, id, services, attributes) {\n        const sharedString = new SharedString(runtime, id, attributes);\n        await sharedString.load(services);\n        return sharedString;\n    }\n    create(document, id) {\n        const sharedString = new SharedString(document, id, this.attributes);\n        sharedString.initializeLocal();\n        return sharedString;\n    }\n}\n// TODO rename back to https://graph.microsoft.com/types/mergeTree/string once paparazzi is able to dynamically\n// load code\nSharedStringFactory.Type = \"https://graph.microsoft.com/types/mergeTree\";\nSharedStringFactory.Attributes = {\n    type: SharedStringFactory.Type,\n    snapshotFormatVersion: \"0.1\",\n    packageVersion: pkgVersion,\n};\nexport class SharedObjectSequenceFactory {\n    static segmentFromSpec(segSpec) {\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        const runSegment = segSpec;\n        if (runSegment.items) {\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            const seg = new SubSequence(runSegment.items);\n            if (runSegment.props) {\n                seg.addProperties(runSegment.props);\n            }\n            return seg;\n        }\n    }\n    get type() {\n        return SharedObjectSequenceFactory.Type;\n    }\n    get attributes() {\n        return SharedObjectSequenceFactory.Attributes;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n     */\n    async load(runtime, id, services, attributes) {\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        const sharedSeq = new SharedObjectSequence(runtime, id, attributes);\n        await sharedSeq.load(services);\n        return sharedSeq;\n    }\n    create(document, id) {\n        const sharedString = new SharedObjectSequence(document, id, this.attributes);\n        sharedString.initializeLocal();\n        return sharedString;\n    }\n}\nSharedObjectSequenceFactory.Type = \"https://graph.microsoft.com/types/mergeTree/object-sequence\";\nSharedObjectSequenceFactory.Attributes = {\n    type: SharedObjectSequenceFactory.Type,\n    snapshotFormatVersion: \"0.1\",\n    packageVersion: pkgVersion,\n};\nexport class SharedNumberSequenceFactory {\n    static segmentFromSpec(segSpec) {\n        const runSegment = segSpec;\n        if (runSegment.items) {\n            const seg = new SubSequence(runSegment.items);\n            if (runSegment.props) {\n                seg.addProperties(runSegment.props);\n            }\n            return seg;\n        }\n    }\n    get type() {\n        return SharedNumberSequenceFactory.Type;\n    }\n    get attributes() {\n        return SharedNumberSequenceFactory.Attributes;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n     */\n    async load(runtime, id, services, attributes) {\n        const sharedSeq = new SharedNumberSequence(runtime, id, attributes);\n        await sharedSeq.load(services);\n        return sharedSeq;\n    }\n    create(document, id) {\n        const sharedString = new SharedNumberSequence(document, id, this.attributes);\n        sharedString.initializeLocal();\n        return sharedString;\n    }\n}\nSharedNumberSequenceFactory.Type = \"https://graph.microsoft.com/types/mergeTree/number-sequence\";\nSharedNumberSequenceFactory.Attributes = {\n    type: SharedNumberSequenceFactory.Type,\n    snapshotFormatVersion: \"0.1\",\n    packageVersion: pkgVersion,\n};\n//# sourceMappingURL=sequenceFactory.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { SharedNumberSequenceFactory } from \"./sequenceFactory\";\nimport { SharedSequence } from \"./sharedSequence\";\n/**\n * The SharedNumberSequence holds a sequence of numbers. Each number will be stored\n * at a position within the sequence. See the\n * {@link https://github.com/microsoft/FluidFramework/blob/main/packages/dds/sequence/README.md | sequence readme}\n * for details on working with sequences.\n */\nexport class SharedNumberSequence extends SharedSequence {\n    constructor(document, id, attributes) {\n        super(document, id, attributes, SharedNumberSequenceFactory.segmentFromSpec);\n        this.id = id;\n    }\n    /**\n     * Create a new shared number sequence\n     *\n     * @param runtime - data store runtime the new shared number sequence belongs to\n     * @param id - optional name of the shared number sequence\n     * @returns newly create shared number sequence (but not attached yet)\n     */\n    static create(runtime, id) {\n        return runtime.createChannel(id, SharedNumberSequenceFactory.Type);\n    }\n    /**\n     * Get a factory for SharedNumberSequence to register with the data store.\n     *\n     * @returns a factory that creates and load SharedNumberSequence\n     */\n    static getFactory() {\n        return new SharedNumberSequenceFactory();\n    }\n    getRange(start, end) {\n        return this.getItems(start, end);\n    }\n}\n//# sourceMappingURL=sharedNumberSequence.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { SharedObjectSequenceFactory } from \"./sequenceFactory\";\nimport { SharedSequence } from \"./sharedSequence\";\n/**\n * The SharedObjectSequence holds a sequence of serializable objects. Each object will be stored\n * at a position within the sequence. See the\n * {@link https://github.com/microsoft/FluidFramework/blob/main/packages/dds/sequence/README.md | sequence readme}\n * for details on working with sequences.\n */\nexport class SharedObjectSequence extends SharedSequence {\n    constructor(document, id, attributes) {\n        super(document, id, attributes, SharedObjectSequenceFactory.segmentFromSpec);\n        this.id = id;\n    }\n    /**\n     * Create a new shared object sequence\n     *\n     * @param runtime - data store runtime the new shared object sequence belongs to\n     * @param id - optional name of the shared object sequence\n     * @returns newly create shared object sequence (but not attached yet)\n     */\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    static create(runtime, id) {\n        return runtime.createChannel(id, SharedObjectSequenceFactory.Type);\n    }\n    /**\n     * Get a factory for SharedObjectSequence to register with the data store.\n     *\n     * @returns a factory that creates and load SharedObjectSequence\n     */\n    static getFactory() {\n        return new SharedObjectSequenceFactory();\n    }\n    getRange(start, end) {\n        return this.getItems(start, end);\n    }\n}\n//# sourceMappingURL=sharedObjectSequence.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { BaseSegment, LocalReferenceCollection, } from \"@fluidframework/merge-tree\";\nimport { SharedSegmentSequence } from \"./sequence\";\nconst MaxRun = 128;\nexport class SubSequence extends BaseSegment {\n    constructor(items) {\n        super();\n        this.items = items;\n        this.type = SubSequence.typeString;\n        this.cachedLength = items.length;\n    }\n    static is(segment) {\n        return segment.type === SubSequence.typeString;\n    }\n    static fromJSONObject(spec) {\n        if (spec && typeof spec === \"object\" && \"items\" in spec) {\n            const segment = new SubSequence(spec.items);\n            if (spec.props) {\n                segment.addProperties(spec.props);\n            }\n            return segment;\n        }\n        return undefined;\n    }\n    toJSONObject() {\n        const obj = { items: this.items };\n        super.addSerializedProps(obj);\n        return obj;\n    }\n    clone(start = 0, end) {\n        const clonedItems = this.items.slice(start, end);\n        const b = new SubSequence(clonedItems);\n        this.cloneInto(b);\n        return b;\n    }\n    canAppend(segment) {\n        return SubSequence.is(segment)\n            && (this.cachedLength <= MaxRun || segment.cachedLength <= MaxRun);\n    }\n    toString() {\n        return this.items.toString();\n    }\n    append(segment) {\n        if (!SubSequence.is(segment)) {\n            throw new Error(\"can only append another run segment\");\n        }\n        // Note: Must call 'appendLocalRefs' before modifying this segment's length as\n        //       'this.cachedLength' is used to adjust the offsets of the local refs.\n        LocalReferenceCollection.append(this, segment);\n        this.items = this.items.concat(segment.items);\n        this.cachedLength = this.items.length;\n    }\n    // TODO: retain removed items for undo\n    // returns true if entire run removed\n    removeRange(start, end) {\n        let remnantItems = [];\n        const len = this.items.length;\n        if (start > 0) {\n            remnantItems = remnantItems.concat(this.items.slice(0, start));\n        }\n        if (end < len) {\n            remnantItems = remnantItems.concat(this.items.slice(end));\n        }\n        this.items = remnantItems;\n        this.cachedLength = this.items.length;\n        return (this.items.length === 0);\n    }\n    createSplitSegmentAt(pos) {\n        if (pos > 0) {\n            const remainingItems = this.items.slice(pos);\n            this.items = this.items.slice(0, pos);\n            this.cachedLength = this.items.length;\n            const leafSegment = new SubSequence(remainingItems);\n            return leafSegment;\n        }\n    }\n}\nSubSequence.typeString = \"SubSequence\";\nexport class SharedSequence extends SharedSegmentSequence {\n    constructor(document, id, attributes, specToSegment) {\n        super(document, id, attributes, specToSegment);\n        this.id = id;\n    }\n    /**\n     * @param pos - The position to insert the items at.\n     * @param items - The items to insert.\n     * @param props - Optional. Properties to set on the inserted items.\n     */\n    insert(pos, items, props) {\n        const segment = new SubSequence(items);\n        if (props) {\n            segment.addProperties(props);\n        }\n        const insertOp = this.client.insertSegmentLocal(pos, segment);\n        if (insertOp) {\n            this.submitSequenceMessage(insertOp);\n        }\n    }\n    /**\n     * @param start - The inclusive start of the range to remove\n     * @param end - The exclusive end of the range to remove\n     */\n    remove(start, end) {\n        this.removeRange(start, end);\n    }\n    /**\n     * Returns the total count of items in the sequence\n     */\n    getItemCount() {\n        return this.getLength();\n    }\n    /**\n     * Gets the items in the specified range\n     *\n     * @param start - The inclusive start of the range\n     * @param end - The exclusive end of the range\n     */\n    getItems(start, end) {\n        const items = [];\n        let firstSegment;\n        // Return if the range is incorrect.\n        if (end !== undefined && end <= start) {\n            return items;\n        }\n        this.walkSegments((segment) => {\n            if (SubSequence.is(segment)) {\n                if (firstSegment === undefined) {\n                    firstSegment = segment;\n                }\n                items.push(...segment.items);\n            }\n            return true;\n        }, start, end);\n        // The above call to walkSegments adds all the items in the walked\n        // segments. However, we only want items beginning at |start| in\n        // the first segment. Similarly, if |end| is passed in, we only\n        // want items until |end| in the last segment. Remove the rest of\n        // the items.\n        if (firstSegment !== undefined) {\n            items.splice(0, start - this.getPosition(firstSegment));\n        }\n        if (end !== undefined) {\n            items.splice(end - start);\n        }\n        return items;\n    }\n}\n//# sourceMappingURL=sharedSequence.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as MergeTree from \"@fluidframework/merge-tree\";\nimport { SharedSegmentSequence } from \"./sequence\";\nimport { SharedStringFactory } from \"./sequenceFactory\";\n/**\n * The Shared String is a specialized data structure for handling collaborative\n *  text. It is based on a more general Sequence data structure but has\n * additional features that make working with text easier.\n *\n * In addition to text, a Shared String can also contain markers. Markers can be\n * used to store metadata at positions within the text, like the details of an\n * image or Fluid object that should be rendered with the text.\n *\n */\nexport class SharedString extends SharedSegmentSequence {\n    constructor(document, id, attributes) {\n        super(document, id, attributes, SharedStringFactory.segmentFromSpec);\n        this.id = id;\n        this.mergeTreeTextHelper = this.client.createTextHelper();\n    }\n    /**\n     * Create a new shared string\n     *\n     * @param runtime - data store runtime the new shared string belongs to\n     * @param id - optional name of the shared string\n     * @returns newly create shared string (but not attached yet)\n     */\n    static create(runtime, id) {\n        return runtime.createChannel(id, SharedStringFactory.Type);\n    }\n    /**\n     * Get a factory for SharedString to register with the data store.\n     *\n     * @returns a factory that creates and load SharedString\n     */\n    static getFactory() {\n        return new SharedStringFactory();\n    }\n    get ISharedString() {\n        return this;\n    }\n    /**\n     * Inserts a marker at a relative postition\n     *\n     * @param relativePos1 - The relative postition to insert the marker at\n     * @param refType - The reference type of the marker\n     * @param props - The properties of the marker\n     */\n    insertMarkerRelative(relativePos1, refType, props) {\n        const segment = new MergeTree.Marker(refType);\n        if (props) {\n            segment.addProperties(props);\n        }\n        const pos = this.posFromRelativePos(relativePos1);\n        const insertOp = this.client.insertSegmentLocal(pos, segment);\n        if (insertOp) {\n            this.submitSequenceMessage(insertOp);\n        }\n    }\n    /**\n     * Inserts a marker at the postition\n     *\n     * @param pos - The postition to insert the marker at\n     * @param refType - The reference type of the marker\n     * @param props - The properties of the marker\n     */\n    insertMarker(pos, refType, props) {\n        const segment = new MergeTree.Marker(refType);\n        if (props) {\n            segment.addProperties(props);\n        }\n        const insertOp = this.client.insertSegmentLocal(pos, segment);\n        if (insertOp) {\n            this.submitSequenceMessage(insertOp);\n        }\n        return insertOp;\n    }\n    /**\n     * Inserts the text at the postition\n     *\n     * @param relativePos1 - The relative postition to insert the text at\n     * @param text - The text to insert\n     * @param props - The properties of text\n     */\n    insertTextRelative(relativePos1, text, props) {\n        const segment = new MergeTree.TextSegment(text);\n        if (props) {\n            segment.addProperties(props);\n        }\n        const pos = this.posFromRelativePos(relativePos1);\n        const insertOp = this.client.insertSegmentLocal(pos, segment);\n        if (insertOp) {\n            this.submitSequenceMessage(insertOp);\n        }\n    }\n    /**\n     * Inserts the text at the postition\n     *\n     * @param pos - The  postition to insert the text at\n     * @param text - The text to insert\n     * @param props - The properties of text\n     */\n    insertText(pos, text, props) {\n        const segment = new MergeTree.TextSegment(text);\n        if (props) {\n            segment.addProperties(props);\n        }\n        const insertOp = this.client.insertSegmentLocal(pos, segment);\n        if (insertOp) {\n            this.submitSequenceMessage(insertOp);\n        }\n    }\n    /**\n     * Replaces a range with the provided text.\n     *\n     * @param start - The inclusive start of the range to replace\n     * @param end - The exclusive end of the range to replace\n     * @param text - The text to replace the range with\n     * @param props - Optional. The properties of the replacement text\n     */\n    replaceText(start, end, text, props) {\n        this.replaceRange(start, end, MergeTree.TextSegment.make(text, props));\n    }\n    removeText(start, end) {\n        return this.removeRange(start, end);\n    }\n    /**\n     * Annotates the marker with the provided properties\n     * and calls the callback on concensus.\n     *\n     * @param marker - The marker to annotate\n     * @param props - The properties to annotate the marker with\n     * @param consensusCallback - The callback called when consensus is reached\n     */\n    annotateMarkerNotifyConsensus(marker, props, callback) {\n        const annotateOp = this.client.annotateMarkerNotifyConsensus(marker, props, callback);\n        if (annotateOp) {\n            this.submitSequenceMessage(annotateOp);\n        }\n    }\n    /**\n     * Annotates the marker with the provided properties\n     *\n     * @param marker - The marker to annotate\n     * @param props - The properties to annotate the marker with\n     * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n     */\n    annotateMarker(marker, props, combiningOp) {\n        const annotateOp = this.client.annotateMarker(marker, props, combiningOp);\n        if (annotateOp) {\n            this.submitSequenceMessage(annotateOp);\n        }\n    }\n    findTile(startPos, tileLabel, preceding = true) {\n        return this.client.findTile(startPos, tileLabel, preceding);\n    }\n    getTextAndMarkers(label) {\n        const segmentWindow = this.client.getCollabWindow();\n        return this.mergeTreeTextHelper.getTextAndMarkers(segmentWindow.currentSeq, segmentWindow.clientId, label);\n    }\n    getText(start, end) {\n        const segmentWindow = this.client.getCollabWindow();\n        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, \"\", start, end);\n    }\n    /**\n     * Adds spaces for markers and handles, so that position calculations account for them\n     */\n    getTextWithPlaceholders() {\n        const segmentWindow = this.client.getCollabWindow();\n        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, \" \");\n    }\n    getTextRangeWithPlaceholders(start, end) {\n        const segmentWindow = this.client.getCollabWindow();\n        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, \" \", start, end);\n    }\n    getTextRangeWithMarkers(start, end) {\n        const segmentWindow = this.client.getCollabWindow();\n        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, \"*\", start, end);\n    }\n    getMarkerFromId(id) {\n        return this.client.getMarkerFromId(id);\n    }\n}\n//# sourceMappingURL=sharedString.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { FluidObjectHandle } from \"@fluidframework/datastore\";\nimport { create404Response } from \"@fluidframework/runtime-utils\";\n/**\n * Handle for shared object\n * This object is used for already loaded (in-memory) shared object\n * and is used only for serialization purposes.\n * De-serialization process goes through FluidObjectHandle and request flow:\n * FluidDataStoreRuntime.request() recognizes requests in the form of '/<shared object id>'\n * and loads shared object.\n */\nexport class SharedObjectHandle extends FluidObjectHandle {\n    /**\n     * Whether services have been attached for the associated shared object.\n     */\n    get isAttached() {\n        return this.value.isAttached();\n    }\n    /**\n     * Creates a new SharedObjectHandle.\n     * @param value - The shared object this handle is for.\n     * @param path - The id of the shared object. It is also the path to this object relative to the routeContext.\n     * @param routeContext - The parent IFluidHandleContext that has a route to this handle.\n     */\n    constructor(value, path, routeContext) {\n        super(value, path, routeContext);\n    }\n    /**\n     * Attaches all bound handles first (which may in turn attach further handles), then attaches this handle.\n     * When attaching the handle, it registers the associated shared object.\n     */\n    attachGraph() {\n        this.value.bindToContext();\n        super.attachGraph();\n    }\n    /**\n     * Returns 404.\n     * @param request - The request to make\n     * @returns A 404 error\n     */\n    async request(request) {\n        return create404Response(request);\n    }\n}\n//# sourceMappingURL=handle.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { v4 as uuid } from \"uuid\";\nimport { assert } from \"@fluidframework/common-utils\";\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { convertToSummaryTreeWithStats, FluidSerializer } from \"@fluidframework/runtime-utils\";\nimport { ChildLogger, EventEmitterWithErrorHandling } from \"@fluidframework/telemetry-utils\";\nimport { SharedObjectHandle } from \"./handle\";\nimport { SummarySerializer } from \"./summarySerializer\";\n/**\n *  Base class from which all shared objects derive\n */\nexport class SharedObject extends EventEmitterWithErrorHandling {\n    /**\n     * @param id - The id of the shared object\n     * @param runtime - The IFluidDataStoreRuntime which contains the shared object\n     * @param attributes - Attributes of the shared object\n     */\n    constructor(id, runtime, attributes) {\n        super();\n        this.id = id;\n        this.runtime = runtime;\n        this.attributes = attributes;\n        /**\n         * Connection state\n         */\n        this._connected = false;\n        /**\n         * True if the dds is bound to its parent.\n         */\n        this._isBoundToContext = false;\n        /**\n         * True while we are summarizing this object's data.\n         */\n        this._isSummarizing = false;\n        this.handle = new SharedObjectHandle(this, id, runtime.IFluidHandleContext);\n        // Runtime could be null since some package hasn't turn on strictNullChecks yet\n        // We should remove the null check once that is done\n        this.logger = ChildLogger.create(\n        // eslint-disable-next-line no-null/no-null\n        runtime !== null ? runtime.logger : undefined, undefined, { all: { sharedObjectId: uuid() } });\n        this._serializer = new FluidSerializer(this.runtime.channelsRoutingContext);\n        this.attachListeners();\n    }\n    /**\n     * @param obj - The thing to check if it is a SharedObject\n     * @returns Returns true if the thing is a SharedObject\n     */\n    static is(obj) {\n        return (obj === null || obj === void 0 ? void 0 : obj.ISharedObject) !== undefined;\n    }\n    get ISharedObject() { return this; }\n    get IChannel() { return this; }\n    get IFluidLoadable() { return this; }\n    /**\n     * Gets the connection state\n     * @returns The state of the connection\n     */\n    get connected() {\n        return this._connected;\n    }\n    get serializer() {\n        /**\n         * During summarize, the SummarySerializer keeps track of IFluidHandles that are serialized. These handles\n         * represent references to other Fluid objects and are used for garbage collection.\n         *\n         * This is fine for now. However, if we implement delay loading in DDss, they may load and de-serialize content\n         * in summarize. When that happens, they may incorrectly hit this assert and we will have to change this.\n         */\n        assert(!this._isSummarizing, 0x075 /* \"SummarySerializer should be used for serializing data during summary.\" */);\n        return this._serializer;\n    }\n    attachListeners() {\n        this.on(\"error\", (error) => {\n            this.runtime.raiseContainerWarning(error);\n        });\n        // Only listen to these events if not attached.\n        if (!this.isAttached()) {\n            this.runtime.once(\"attaching\", () => {\n                // Calling this will let the dds to do any custom processing based on attached\n                // like starting generating ops.\n                this.didAttach();\n            });\n        }\n    }\n    /**\n     * Not supported - use handles instead\n     */\n    toJSON() {\n        throw new Error(\"Only the handle can be converted to JSON\");\n    }\n    /**\n     * A shared object, after construction, can either be loaded in the case that it is already part of\n     * a shared document. Or later attached if it is being newly added.\n     * @param services - Services used by the shared object\n     */\n    async load(services) {\n        if (this.runtime.attachState !== AttachState.Detached) {\n            this.services = services;\n        }\n        await this.loadCore(services.objectStorage);\n        if (this.runtime.attachState !== AttachState.Detached) {\n            this.attachDeltaHandler();\n        }\n    }\n    /**\n     * Initializes the object as a local, non-shared object. This object can become shared after\n     * it is attached to the document.\n     */\n    initializeLocal() {\n        this.initializeLocalCore();\n    }\n    /**\n     * {@inheritDoc (ISharedObject:interface).bindToContext}\n     */\n    bindToContext() {\n        if (this._isBoundToContext) {\n            return;\n        }\n        this._isBoundToContext = true;\n        this.setOwner();\n        // Allow derived classes to perform custom processing prior to registering this object\n        this.registerCore();\n        this.runtime.bindChannel(this);\n    }\n    /**\n     * {@inheritDoc (ISharedObject:interface).connect}\n     */\n    connect(services) {\n        this.services = services;\n        this.attachDeltaHandler();\n    }\n    /**\n     * {@inheritDoc (ISharedObject:interface).isAttached}\n     */\n    isAttached() {\n        return this.services !== undefined && this.runtime.attachState !== AttachState.Detached;\n    }\n    /**\n     * {@inheritDoc (ISharedObject:interface).summarize}\n     */\n    summarize(fullTree = false, trackState = false) {\n        // Set _isSummarizing to true. This flag is used to ensure that we only use SummarySerializer (created below)\n        // to serialize handles in this object's data. The routes of these serialized handles are outbound routes\n        // to other Fluid objects.\n        assert(!this._isSummarizing, 0x076 /* \"Possible re-entrancy! Summary should not already be in progress.\" */);\n        this._isSummarizing = true;\n        let summaryTree;\n        let gcData;\n        try {\n            const serializer = new SummarySerializer(this.runtime.channelsRoutingContext);\n            const snapshot = this.snapshotCore(serializer);\n            summaryTree = convertToSummaryTreeWithStats(snapshot, fullTree);\n            // Add this channel's garbage collection data to the summarize result. The outbound routes of this channel\n            // are all the routes of all the handles that are tracked by the SummarySerializer above.\n            gcData = {\n                gcNodes: { \"/\": serializer.getSerializedRoutes() },\n            };\n            assert(this._isSummarizing, 0x077 /* \"Possible re-entrancy! Summary should have been in progress.\" */);\n        }\n        finally {\n            this._isSummarizing = false;\n        }\n        return Object.assign(Object.assign({}, summaryTree), { gcData });\n    }\n    /**\n     * {@inheritDoc (ISharedObject:interface).getGCData}\n     */\n    getGCData(fullGC = false) {\n        // We run the full summarize logic to get the list of outbound routes from this object. This is a little\n        // expensive but its okay for now. It will be updated to not use full summarize and make it more efficient.\n        // See: https://github.com/microsoft/FluidFramework/issues/4547\n        // Set _isSummarizing to true. This flag is used to ensure that we only use SummarySerializer (created below)\n        // to serialize handles in this object's data. The routes of these serialized handles are outbound routes\n        // to other Fluid objects.\n        assert(!this._isSummarizing, 0x078 /* \"Possible re-entrancy! Summary should not already be in progress.\" */);\n        this._isSummarizing = true;\n        let gcData;\n        try {\n            const serializer = new SummarySerializer(this.runtime.channelsRoutingContext);\n            this.snapshotCore(serializer);\n            // The GC data for this shared object contains a single GC node. The outbound routes of this node are the\n            // routes of handles serialized during snapshot.\n            gcData = {\n                gcNodes: { \"/\": serializer.getSerializedRoutes() },\n            };\n            assert(this._isSummarizing, 0x079 /* \"Possible re-entrancy! Summary should have been in progress.\" */);\n        }\n        finally {\n            this._isSummarizing = false;\n        }\n        return gcData;\n    }\n    /**\n     * Set the owner of the object if it is an OwnedSharedObject\n     * @returns The owner of the object if it is an OwnedSharedObject, otherwise undefined\n     */\n    setOwner() {\n        return;\n    }\n    /**\n     * Allows the distributed data type to perform custom local loading.\n     */\n    initializeLocalCore() {\n        return;\n    }\n    /**\n     * Allows the distributive data type the ability to perform custom processing once an attach has happened.\n     * Also called after non-local data type get loaded.\n     */\n    didAttach() {\n        return;\n    }\n    /**\n     * Submits a message by the local client to the runtime.\n     * @param content - Content of the message\n     * @param localOpMetadata - The local metadata associated with the message. This is kept locally by the runtime\n     * and not sent to the server. This will be sent back when this message is received back from the server. This is\n     * also sent if we are asked to resubmit the message.\n     */\n    submitLocalMessage(content, localOpMetadata = undefined) {\n        if (this.isAttached()) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.services.deltaConnection.submit(content, localOpMetadata);\n        }\n    }\n    /**\n     * Marks this object as dirty so that it is part of the next summary. It is called by a SharedSummaryBlock\n     * that want to be part of summary but does not generate ops.\n     */\n    dirty() {\n        if (!this.isAttached()) {\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.services.deltaConnection.dirty();\n    }\n    /**\n     * Called when the object has fully connected to the delta stream\n     * Default implementation for DDS, override if different behavior is required.\n     */\n    onConnect() { }\n    /**\n     * Called when a message has to be resubmitted. This typically happens after a reconnection for unacked messages.\n     * The default implementation here is to resubmit the same message. The client can override if different behavior\n     * is required. It can choose to resubmit the same message, submit different / multiple messages or not submit\n     * anything at all.\n     * @param content - The content of the original message.\n     * @param localOpMetadata - The local metadata associated with the original message.\n     */\n    reSubmitCore(content, localOpMetadata) {\n        this.submitLocalMessage(content, localOpMetadata);\n    }\n    /**\n     * Promises that are waiting for an ack from the server before resolving should use this instead of new Promise.\n     * It ensures that if something changes that will interrupt that ack (e.g. the FluidDataStoreRuntime disposes),\n     * the Promise will reject.\n     * If runtime is disposed when this call is made, executor is not run and promise is rejected right away.\n     */\n    async newAckBasedPromise(executor) {\n        let rejectBecauseDispose;\n        return new Promise((resolve, reject) => {\n            rejectBecauseDispose =\n                () => reject(new Error(\"FluidDataStoreRuntime disposed while this ack-based Promise was pending\"));\n            if (this.runtime.disposed) {\n                rejectBecauseDispose();\n                return;\n            }\n            this.runtime.on(\"dispose\", rejectBecauseDispose);\n            executor(resolve, reject);\n        }).finally(() => {\n            // Note: rejectBecauseDispose will never be undefined here\n            this.runtime.off(\"dispose\", rejectBecauseDispose);\n        });\n    }\n    /**\n     * Report ignorable errors in code logic or data integrity to the logger.\n     * Hosting app / container may want to optimize out these call sites and make them no-op.\n     * It may also show assert dialog in non-production builds of application.\n     * @param condition - If false, assert is logged\n     * @param message - Actual message to log; ideally should be unique message to identify call site\n     */\n    debugAssert(condition, event) {\n        this.logger.debugAssert(condition, event);\n    }\n    attachDeltaHandler() {\n        // Services should already be there in case we are attaching delta handler.\n        assert(this.services !== undefined, 0x07a /* \"Services should be there to attach delta handler\" */);\n        this._isBoundToContext = true;\n        // Allows objects to do any custom processing if it is attached.\n        this.didAttach();\n        // attachDeltaHandler is only called after services is assigned\n        this.services.deltaConnection.attach({\n            process: (message, local, localOpMetadata) => {\n                this.process(message, local, localOpMetadata);\n            },\n            setConnectionState: (connected) => {\n                this.setConnectionState(connected);\n            },\n            reSubmit: (content, localOpMetadata) => {\n                this.reSubmit(content, localOpMetadata);\n            },\n            applyStashedOp: (content) => {\n                return this.applyStashedOp(content);\n            },\n        });\n        // Trigger initial state\n        // attachDeltaHandler is only called after services is assigned\n        this.setConnectionState(this.services.deltaConnection.connected);\n    }\n    /**\n     * Set the state of connection to services.\n     * @param connected - true if connected, false otherwise.\n     */\n    setConnectionState(connected) {\n        if (this._connected === connected) {\n            // Not changing state, nothing the same.\n            return;\n        }\n        // Should I change the state at the end? So that we *can't* send new stuff before we send old?\n        this._connected = connected;\n        if (!connected) {\n            // Things that are true now...\n            // - if we had a connection we can no longer send messages over it\n            // - if we had outbound messages some may or may not be ACK'd. Won't know until next message\n            //\n            // - nack could get a new msn - but might as well do it in the join?\n            this.onDisconnect();\n        }\n        else {\n            // Call this for now so that DDSes like ConsensesOrderedCollection that maintain their own pending\n            // messages will work.\n            this.onConnect();\n        }\n    }\n    /**\n     * Handles a message being received from the remote delta server.\n     * @param message - The message to process\n     * @param local - Whether the message originated from the local client\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     */\n    process(message, local, localOpMetadata) {\n        this.emit(\"pre-op\", message, local, this);\n        this.processCore(message, local, localOpMetadata);\n        this.emit(\"op\", message, local, this);\n    }\n    /**\n     * Called when a message has to be resubmitted. This typically happens for unacked messages after a\n     * reconnection.\n     * @param content - The content of the original message.\n     * @param localOpMetadata - The local metadata associated with the original message.\n     */\n    reSubmit(content, localOpMetadata) {\n        this.reSubmitCore(content, localOpMetadata);\n    }\n}\n//# sourceMappingURL=sharedObject.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { FluidSerializer } from \"@fluidframework/runtime-utils\";\n/**\n * Serializer implementation for serializing handles during summary.\n */\nexport class SummarySerializer extends FluidSerializer {\n    constructor() {\n        super(...arguments);\n        this.serializedRoutes = new Set();\n    }\n    getSerializedRoutes() {\n        return Array.from(this.serializedRoutes);\n    }\n    serializeHandle(handle, bind) {\n        this.serializedRoutes.add(handle.absolutePath);\n        return super.serializeHandle(handle, bind);\n    }\n}\n//# sourceMappingURL=summarySerializer.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Given a mostly-plain object that may have handle objects embedded within, return a string representation of an object\n * where the handle objects have been replaced with a serializable form.\n * @param value - The mostly-plain object\n * @param serializer - The serializer that knows how to convert handles into serializable format\n * @param context - The handle context for the container\n * @param bind - Bind any other handles we find in the object against this given handle.\n * @returns Result of strigifying an object\n */\n// eslint-disable-next-line prefer-arrow/prefer-arrow-functions\nexport function serializeHandles(value, serializer, bind) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return value !== undefined\n        ? serializer.stringify(value, bind)\n        : value;\n}\n/**\n * Given a mostly-plain object that may have handle objects embedded within, will return a fully-plain object\n * where any embedded IFluidHandles have been replaced with a serializable form.\n *\n * The original `input` object is not mutated.  This method will shallowly clones all objects in the path from\n * the root to any replaced handles.  (If no handles are found, returns the original object.)\n *\n * @param input - The mostly-plain object\n * @param context - The handle context for the container\n * @param bind - Bind any other handles we find in the object against this given handle.\n * @returns The fully-plain object\n */\n// eslint-disable-next-line prefer-arrow/prefer-arrow-functions\nexport function makeHandlesSerializable(value, serializer, bind) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return serializer.replaceHandles(value, bind);\n}\n/**\n * Given a fully-plain object that may have serializable-form handles within, will return the mostly-plain object\n * with handle objects created instead.\n * @param value - The fully-plain object\n * @param serializer - The serializer that knows how to convert serializable-form handles into handle objects\n * @param context - The handle context for the container\n * @returns The mostly-plain object with handle objects within\n */\n// eslint-disable-next-line prefer-arrow/prefer-arrow-functions\nexport function parseHandles(value, serializer) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return value !== undefined ? serializer.parse(JSON.stringify(value)) : value;\n}\n//# sourceMappingURL=utils.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * enum representing the possible types of a shared object\n */\nexport var ValueType;\n(function (ValueType) {\n    /**\n     * The value is a shared object\n     * @deprecated Instead store the handle of the shared object, rather than the shared object itself.\n     */\n    ValueType[ValueType[\"Shared\"] = 0] = \"Shared\";\n    /**\n     * The value is a plain JavaScript object or handle.  If a plain object, it may contain handles deeper within.\n     */\n    ValueType[ValueType[\"Plain\"] = 1] = \"Plain\";\n})(ValueType || (ValueType = {}));\n//# sourceMappingURL=valueType.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * DependencyContainer is similar to a IoC Container. It takes providers and will\n * synthesize an object based on them when requested.\n */\nexport class DependencyContainer {\n    constructor(parent = undefined) {\n        this.parent = parent;\n        this.providers = new Map();\n    }\n    get IFluidDependencySynthesizer() { return this; }\n    /**\n     * {@inheritDoc (IFluidDependencySynthesizer:interface).registeredTypes}\n     */\n    get registeredTypes() {\n        return this.providers.keys();\n    }\n    /**\n     * {@inheritDoc (IFluidDependencySynthesizer:interface).register}\n     */\n    register(type, provider) {\n        if (this.has(type)) {\n            throw new Error(`Attempting to register a provider of type ${type} that already exists`);\n        }\n        this.providers.set(type, provider);\n    }\n    /**\n     * {@inheritDoc (IFluidDependencySynthesizer:interface).unregister}\n     */\n    unregister(type) {\n        if (this.providers.has(type)) {\n            this.providers.delete(type);\n        }\n    }\n    /**\n     * {@inheritDoc (IFluidDependencySynthesizer:interface).synthesize}\n     */\n    synthesize(optionalTypes, requiredTypes) {\n        const optionalValues = Object.values(optionalTypes);\n        const requiredValues = Object.values(requiredTypes);\n        // There was nothing passed in so we can return\n        if (optionalValues === [] && requiredValues === []) {\n            return {};\n        }\n        const required = this.generateRequired(requiredTypes);\n        const optional = this.generateOptional(optionalTypes);\n        return Object.assign(Object.assign({}, required), optional);\n    }\n    /**\n     * {@inheritDoc (IFluidDependencySynthesizer:interface).has}\n     */\n    has(...types) {\n        return types.every((type) => {\n            return this.providers.has(type);\n        });\n    }\n    /**\n     * {@inheritDoc (IFluidDependencySynthesizer:interface).getProvider}\n     */\n    getProvider(type) {\n        // If we have the provider return it\n        const provider = this.providers.get(type);\n        if (provider) {\n            return provider;\n        }\n        if (this.parent) {\n            return this.parent.getProvider(type);\n        }\n        return undefined;\n    }\n    generateRequired(types) {\n        const values = Object.values(types);\n        return Object.assign({}, ...Array.from(values, (t) => {\n            const provider = this.getProvider(t);\n            if (!provider) {\n                throw new Error(`Object attempted to be created without registered required provider ${t}`);\n            }\n            return this.resolveProvider(provider, t);\n        }));\n    }\n    generateOptional(types) {\n        const values = Object.values(types);\n        return Object.assign({}, ...Array.from(values, (t) => {\n            const provider = this.getProvider(t);\n            if (!provider) {\n                return { get [t]() { return Promise.resolve(undefined); } };\n            }\n            return this.resolveProvider(provider, t);\n        }));\n    }\n    resolveProvider(provider, t) {\n        // The double nested gets are required for lazy loading the provider resolution\n        if (typeof provider === \"function\") {\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const self = this;\n            return {\n                get [t]() {\n                    if (provider && typeof provider === \"function\") {\n                        return Promise.resolve(provider(self)).then((p) => {\n                            if (p) {\n                                return p[t];\n                            }\n                        });\n                    }\n                },\n            };\n        }\n        return {\n            get [t]() {\n                if (provider) {\n                    return Promise.resolve(provider).then((p) => {\n                        if (p) {\n                            return p[t];\n                        }\n                    });\n                }\n            },\n        };\n    }\n}\n//# sourceMappingURL=dependencyContainer.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { performance } from \"@fluidframework/common-utils\";\nimport { debug as registerDebug } from \"debug\";\nimport { TelemetryLogger, MultiSinkLogger, ChildLogger } from \"./logger\";\n/**\n * Implementation of debug logger\n */\nexport class DebugLogger extends TelemetryLogger {\n    constructor(debug, debugErr, properties) {\n        super(undefined, properties);\n        this.debug = debug;\n        this.debugErr = debugErr;\n    }\n    /**\n     * Create debug logger - all events are output to debug npm library\n     * @param namespace - Telemetry event name prefix to add to all events\n     * @param properties - Base properties to add to all events\n     * @param propertyGetters - Getters to add additional properties to all events\n     */\n    static create(namespace, properties) {\n        // Setup base logger upfront, such that host can disable it (if needed)\n        const debug = registerDebug(namespace);\n        const debugErr = registerDebug(namespace);\n        debugErr.log = console.error.bind(console);\n        debugErr.enabled = true;\n        return new DebugLogger(debug, debugErr, properties);\n    }\n    /**\n     * Mix in debug logger with another logger.\n     * Returned logger will output events to both newly created debug logger, as well as base logger\n     * @param namespace - Telemetry event name prefix to add to all events\n     * @param properties - Base properties to add to all events\n     * @param propertyGetters - Getters to add additional properties to all events\n     * @param baseLogger - Base logger to output events (in addition to debug logger being created). Can be undefined.\n     */\n    static mixinDebugLogger(namespace, baseLogger, properties) {\n        if (!baseLogger) {\n            return DebugLogger.create(namespace, properties);\n        }\n        const multiSinkLogger = new MultiSinkLogger(undefined, properties);\n        multiSinkLogger.addLogger(DebugLogger.create(namespace));\n        multiSinkLogger.addLogger(ChildLogger.create(baseLogger, namespace));\n        return multiSinkLogger;\n    }\n    /**\n     * Send an event to debug loggers\n     *\n     * @param event - the event to send\n     */\n    send(event) {\n        const newEvent = this.prepareEvent(event);\n        const isError = newEvent.category === \"error\";\n        let logger = isError ? this.debugErr : this.debug;\n        // Use debug's coloring schema for base of the event\n        const index = event.eventName.lastIndexOf(TelemetryLogger.eventNamespaceSeparator);\n        const name = event.eventName.substring(index + 1);\n        if (index > 0) {\n            logger = logger.extend(event.eventName.substring(0, index));\n        }\n        newEvent.eventName = undefined;\n        let tick = \"\";\n        tick = `tick=${TelemetryLogger.formatTick(performance.now())}`;\n        // Extract stack to put it last, but also to avoid escaping '\\n' in it by JSON.stringify below\n        const stack = newEvent.stack ? newEvent.stack : \"\";\n        newEvent.stack = undefined;\n        // Watch out for circular references - they can come from two sources\n        // 1) error object - we do not control it and should remove it and retry\n        // 2) properties supplied by telemetry caller - that's a bug that should be addressed!\n        let payload;\n        try {\n            payload = JSON.stringify(newEvent);\n        }\n        catch (error) {\n            newEvent.error = undefined;\n            payload = JSON.stringify(newEvent);\n        }\n        if (payload === \"{}\") {\n            payload = \"\";\n        }\n        // Force errors out, to help with diagnostics\n        if (isError) {\n            logger.enabled = true;\n        }\n        // Print multi-line.\n        logger(`${name} ${payload} ${tick} ${stack}`);\n    }\n}\n//# sourceMappingURL=debugLogger.js.map","import { TypedEventEmitter } from \"@fluidframework/common-utils\";\n/**\n * Event Emitter helper class\n * Any exceptions thrown by listeners will be caught and raised through \"error\" event.\n * Any exception thrown by \"error\" listeners will propagate to the caller.\n */\nexport class EventEmitterWithErrorHandling extends TypedEventEmitter {\n    emit(event, ...args) {\n        try {\n            return super.emit(event, ...args);\n        }\n        catch (error) {\n            // Some listener threw an error, we'll try emitting that error via the error event\n            // But not if we're already dealing with the error event, in that case just let the error be thrown\n            if (event === \"error\") {\n                throw error;\n            }\n            // Note: This will throw if no listeners are registered for the error event\n            return super.emit(\"error\", error);\n        }\n    }\n}\n//# sourceMappingURL=eventEmitterWithErrorHandling.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nexport const connectedEventName = \"connected\";\nexport const disconnectedEventName = \"disconnected\";\nexport function safeRaiseEvent(emitter, logger, event, ...args) {\n    try {\n        emitter.emit(event, ...args);\n    }\n    catch (error) {\n        logger.sendErrorEvent({ eventName: \"RaiseEventError\", event }, error);\n    }\n}\nexport function raiseConnectedEvent(logger, emitter, connected, clientId) {\n    try {\n        if (connected) {\n            emitter.emit(connectedEventName, clientId);\n        }\n        else {\n            emitter.emit(disconnectedEventName);\n        }\n    }\n    catch (error) {\n        logger.sendErrorEvent({ eventName: \"RaiseConnectedEventError\" }, error);\n    }\n}\n//# sourceMappingURL=events.js.map","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { BaseTelemetryNullLogger, performance } from \"@fluidframework/common-utils\";\n/**\n * TelemetryLogger class contains various helper telemetry methods,\n * encoding in one place schemas for various types of Fluid telemetry events.\n * Creates sub-logger that appends properties to all events\n */\nexport class TelemetryLogger {\n    constructor(namespace, properties) {\n        this.namespace = namespace;\n        this.properties = properties;\n    }\n    static formatTick(tick) {\n        return Math.floor(tick);\n    }\n    /**\n     * Attempts to parse number from string.\n     * If fails,returns original string.\n     * Used to make telemetry data typed (and support math operations, like comparison),\n     * in places where we do expect numbers (like contentsize/duration property in http header)\n     */\n    static numberFromString(str) {\n        if (str === undefined || str === null) {\n            return undefined;\n        }\n        const num = Number(str);\n        return Number.isNaN(num) ? str : num;\n    }\n    static sanitizePkgName(name) {\n        return name.replace(\"@\", \"\").replace(\"/\", \"-\");\n    }\n    /**\n     * Take an unknown error object and add the appropriate info from it to the event\n     * NOTE - message and stack will be copied over from the error object,\n     * along with other telemetry properties if it's an ILoggingError\n     * @param event - Event being logged\n     * @param error - Error to extract info from\n     * @param fetchStack - Whether to fetch the current callstack if error.stack is undefined\n     */\n    static prepareErrorObject(event, error, fetchStack) {\n        if (isILoggingError(error)) {\n            // First, copy over stack and error message directly\n            // Warning: if these were overwritten with PII-tagged props, they will be logged as-is\n            const errorAsObject = error;\n            event.stack = errorAsObject.stack;\n            event.error = errorAsObject.message;\n            // Then add any other telemetry properties from the LoggingError\n            const taggableProps = error.getTelemetryProperties();\n            for (const key of Object.keys(taggableProps)) {\n                if (event[key] !== undefined) {\n                    // Don't overwrite existing properties on the event\n                    continue;\n                }\n                const taggableProp = taggableProps[key];\n                const { value, tag } = (typeof taggableProp === \"object\")\n                    ? taggableProp\n                    : { value: taggableProp, tag: undefined };\n                switch (tag) {\n                    case undefined:\n                        // No tag means we can log plainly\n                        event[key] = value;\n                        break;\n                    case TelemetryDataTag.PackageData:\n                        // For Microsoft applications, PackageData is safe for now\n                        // (we don't load 3P code in 1P apps)\n                        // But this determination really belongs in the host layer\n                        event[key] = value;\n                        break;\n                    case TelemetryDataTag.UserData:\n                        // Strip out anything tagged explicitly as PII.\n                        // Alternate strategy would be to hash these props\n                        event[key] = \"REDACTED (UserData)\";\n                        break;\n                    default:\n                        // This will help us keep this switch statement up to date\n                        (function (_) { })(tag);\n                        // If we encounter a tag we don't recognize\n                        // (e.g. due to interaction between different versions)\n                        // then we must assume we should scrub.\n                        event[key] = \"REDACTED (unknown tag)\";\n                        break;\n                }\n            }\n        }\n        else if (typeof error === \"object\" && error !== null) {\n            // Try to pull the stack and message off even if it's not an ILoggingError\n            const errorAsObject = error;\n            event.stack = errorAsObject.stack;\n            event.error = errorAsObject.message;\n        }\n        else {\n            event.error = error;\n        }\n        // Collect stack if we were not able to extract it from error\n        if (event.stack === undefined && fetchStack) {\n            event.stack = TelemetryLogger.getStack();\n        }\n    }\n    static getStack() {\n        // Some browsers will populate stack right away, others require throwing Error\n        let stack = new Error().stack;\n        if (!stack) {\n            try {\n                throw new Error();\n            }\n            catch (e) {\n                stack = e.stack;\n            }\n        }\n        return stack;\n    }\n    /**\n     * Send a telemetry event with the logger\n     *\n     * @param event - the event to send\n     * @param error - optional error object to log\n     */\n    sendTelemetryEvent(event, error) {\n        var _a;\n        const newEvent = Object.assign(Object.assign({}, event), { category: (_a = event.category) !== null && _a !== void 0 ? _a : (error === undefined ? \"generic\" : \"error\") });\n        if (error !== undefined) {\n            TelemetryLogger.prepareErrorObject(newEvent, error, false);\n        }\n        this.send(newEvent);\n    }\n    /**\n     * Send an error telemetry event with the logger\n     *\n     * @param event - the event to send\n     * @param error - optional error object to log\n     */\n    sendErrorEvent(event, error) {\n        this.sendTelemetryEvent(Object.assign(Object.assign({}, event), { category: \"error\" }), error);\n    }\n    /**\n     * Send a performance telemetry event with the logger\n     *\n     * @param event - Event to send\n     * @param error - optional error object to log\n     */\n    sendPerformanceEvent(event, error) {\n        const perfEvent = Object.assign(Object.assign({}, event), { category: event.category ? event.category : \"performance\" });\n        if (error !== undefined) {\n            TelemetryLogger.prepareErrorObject(perfEvent, error, false);\n        }\n        if (event.duration) {\n            perfEvent.duration = TelemetryLogger.formatTick(event.duration);\n        }\n        this.send(perfEvent);\n    }\n    /**\n     * @deprecated - use sendErrorEvent\n     * Log generic error with the logger\n     *\n     * @param eventName - the name of the event\n     * @param error - the error object to include in the event, require to be JSON-able\n     */\n    logGenericError(eventName, error) {\n        this.sendErrorEvent({ eventName }, error);\n    }\n    /**\n     * @deprecated - use sendErrorEvent\n     * Helper method to log exceptions\n     * @param event - the event to send\n     * @param exception - Exception object to add to an event\n     */\n    logException(event, exception) {\n        this.sendErrorEvent(Object.assign(Object.assign({}, event), { isException: true }), exception);\n    }\n    /**\n     * @deprecated - use sendErrorEvent\n\n     * Log an debug assert with the logger\n     *\n     * @param condition - the condition to assert on\n     * @param event - the event to log if the condition fails\n     */\n    debugAssert(condition, event) {\n        this.shipAssert(condition, event);\n    }\n    /**\n     * @deprecated - use sendErrorEvent\n     * Log an ship assert with the logger\n     *\n     * @param condition - the condition to assert on\n     * @param event - the event to log if the condition fails\n     */\n    shipAssert(condition, event) {\n        if (!condition) {\n            const realEvent = event === undefined ? { eventName: \"Assert\" } : event;\n            realEvent.isAssert = true;\n            realEvent.stack = TelemetryLogger.getStack();\n            this.sendErrorEvent(realEvent);\n        }\n    }\n    prepareEvent(event) {\n        const includeErrorProps = event.category === \"error\" || event.error !== undefined;\n        const newEvent = Object.assign({}, event);\n        if (this.namespace !== undefined) {\n            newEvent.eventName = `${this.namespace}${TelemetryLogger.eventNamespaceSeparator}${newEvent.eventName}`;\n        }\n        if (this.properties) {\n            const properties = [];\n            properties.push(this.properties.all);\n            if (includeErrorProps) {\n                properties.push(this.properties.error);\n            }\n            for (const props of properties) {\n                if (props !== undefined) {\n                    for (const key of Object.keys(props)) {\n                        if (event[key] !== undefined) {\n                            continue;\n                        }\n                        const getterOrValue = props[key];\n                        // If this throws, hopefully it is handled elsewhere\n                        const value = typeof getterOrValue === \"function\" ? getterOrValue() : getterOrValue;\n                        if (value !== undefined) {\n                            newEvent[key] = value;\n                        }\n                    }\n                }\n            }\n        }\n        return newEvent;\n    }\n}\nTelemetryLogger.eventNamespaceSeparator = \":\";\n/**\n * ChildLogger class contains various helper telemetry methods,\n * encoding in one place schemas for various types of Fluid telemetry events.\n * Creates sub-logger that appends properties to all events\n */\nexport class ChildLogger extends TelemetryLogger {\n    constructor(baseLogger, namespace, properties) {\n        super(namespace, properties);\n        this.baseLogger = baseLogger;\n    }\n    /**\n     * Create child logger\n     * @param baseLogger - Base logger to use to output events. If undefined, proper child logger\n     * is created, but it does not sends telemetry events anywhere.\n     * @param namespace - Telemetry event name prefix to add to all events\n     * @param properties - Base properties to add to all events\n     * @param propertyGetters - Getters to add additional properties to all events\n     */\n    static create(baseLogger, namespace, properties) {\n        // if we are creating a child of a child, rather than nest, which will increase\n        // the callstack overhead, just generate a new logger that includes everything from the previous\n        if (baseLogger instanceof ChildLogger) {\n            const combinedProperties = {};\n            for (const extendedProps of [baseLogger.properties, properties]) {\n                if (extendedProps !== undefined) {\n                    if (extendedProps.all !== undefined) {\n                        combinedProperties.all = Object.assign(Object.assign({}, combinedProperties.all), extendedProps.all);\n                    }\n                    if (extendedProps.error !== undefined) {\n                        combinedProperties.error = Object.assign(Object.assign({}, combinedProperties.error), extendedProps.error);\n                    }\n                }\n            }\n            const combinedNamespace = baseLogger.namespace === undefined\n                ? namespace\n                : namespace === undefined\n                    ? baseLogger.namespace\n                    : `${baseLogger.namespace}${TelemetryLogger.eventNamespaceSeparator}${namespace}`;\n            return new ChildLogger(baseLogger.baseLogger, combinedNamespace, combinedProperties);\n        }\n        return new ChildLogger(baseLogger ? baseLogger : new BaseTelemetryNullLogger(), namespace, properties);\n    }\n    /**\n     * Send an event with the logger\n     *\n     * @param event - the event to send\n     */\n    send(event) {\n        this.baseLogger.send(this.prepareEvent(event));\n    }\n}\n/**\n * Multi-sink logger\n * Takes multiple ITelemetryBaseLogger objects (sinks) and logs all events into each sink\n * Implements ITelemetryBaseLogger (through static create() method)\n */\nexport class MultiSinkLogger extends TelemetryLogger {\n    /**\n     * Create multiple sink logger (i.e. logger that sends events to multiple sinks)\n     * @param namespace - Telemetry event name prefix to add to all events\n     * @param properties - Base properties to add to all events\n     * @param propertyGetters - Getters to add additional properties to all events\n     */\n    constructor(namespace, properties) {\n        super(namespace, properties);\n        this.loggers = [];\n    }\n    /**\n     * Add logger to send all events to\n     * @param logger - Logger to add\n     */\n    addLogger(logger) {\n        if (logger !== undefined && logger !== null) {\n            this.loggers.push(logger);\n        }\n    }\n    /**\n     * Send an event to the loggers\n     *\n     * @param event - the event to send to all the registered logger\n     */\n    send(event) {\n        const newEvent = this.prepareEvent(event);\n        this.loggers.forEach((logger) => {\n            logger.send(newEvent);\n        });\n    }\n}\n/**\n * Helper class to log performance events\n */\nexport class PerformanceEvent {\n    constructor(logger, event, markers = { start: true, end: true, cancel: \"generic\" }) {\n        this.logger = logger;\n        this.markers = markers;\n        this.startTime = performance.now();\n        this.event = Object.assign({}, event);\n        if (this.markers.start) {\n            this.reportEvent(\"start\");\n        }\n        if (typeof window === \"object\" && window != null && window.performance) {\n            this.startMark = `${event.eventName}-start`;\n            window.performance.mark(this.startMark);\n        }\n    }\n    static start(logger, event, markers) {\n        return new PerformanceEvent(logger, event, markers);\n    }\n    static timedExec(logger, event, callback, markers) {\n        const perfEvent = PerformanceEvent.start(logger, event, markers);\n        try {\n            const ret = callback(perfEvent);\n            // Event might have been cancelled or ended in the callback\n            if (perfEvent.event) {\n                perfEvent.end();\n            }\n            return ret;\n        }\n        catch (error) {\n            perfEvent.cancel(undefined, error);\n            throw error;\n        }\n    }\n    static async timedExecAsync(logger, event, callback, markers) {\n        const perfEvent = PerformanceEvent.start(logger, event, markers);\n        try {\n            const ret = await callback(perfEvent);\n            // Event might have been cancelled or ended in the callback\n            if (perfEvent.event) {\n                perfEvent.end();\n            }\n            return ret;\n        }\n        catch (error) {\n            perfEvent.cancel(undefined, error);\n            throw error;\n        }\n    }\n    reportProgress(props, eventNameSuffix = \"update\") {\n        this.reportEvent(eventNameSuffix, props);\n    }\n    end(props, eventNameSuffix = \"end\") {\n        if (this.markers.end) {\n            this.reportEvent(eventNameSuffix, props);\n        }\n        if (this.startMark && this.event) {\n            const endMark = `${this.event.eventName}-${eventNameSuffix}`;\n            window.performance.mark(endMark);\n            window.performance.measure(`${this.event.eventName}`, this.startMark, endMark);\n            this.startMark = undefined;\n        }\n        this.event = undefined;\n    }\n    cancel(props, error) {\n        if (this.markers.cancel !== undefined) {\n            this.reportEvent(\"cancel\", Object.assign({ category: this.markers.cancel }, props), error);\n        }\n        this.event = undefined;\n    }\n    /**\n     * Report the event, if it hasn't already been reported.\n     */\n    reportEvent(eventNameSuffix, props, error) {\n        // There are strange sequences involving multiple Promise chains\n        // where the event can be cancelled and then later a callback is invoked\n        // and the caller attempts to end directly, e.g. issue #3936. Just return.\n        if (!this.event) {\n            return;\n        }\n        const event = Object.assign(Object.assign({}, this.event), props);\n        event.eventName = `${event.eventName}_${eventNameSuffix}`;\n        if (eventNameSuffix !== \"start\") {\n            event.duration = performance.now() - this.startTime;\n        }\n        this.logger.sendPerformanceEvent(event, error);\n    }\n}\n// Note - these Telemetry types should move to common-definitions package\n/**\n * Broad classifications to be applied to individual properties as they're prepared to be logged to telemetry.\n * Please do not modify existing entries for backwards compatibility.\n */\nexport var TelemetryDataTag;\n(function (TelemetryDataTag) {\n    /** Data containing terms from code packages that may have been dynamically loaded */\n    TelemetryDataTag[\"PackageData\"] = \"PackageData\";\n    /** Personal data of a variety of classifications that pertains to the user */\n    TelemetryDataTag[\"UserData\"] = \"UserData\";\n})(TelemetryDataTag || (TelemetryDataTag = {}));\n/**\n * Type guard to identify if a particular value (loosely) appears to be a tagged telemetry property\n */\nexport function isTaggedTelemetryPropertyValue(x) {\n    return (typeof (x === null || x === void 0 ? void 0 : x.value) !== \"object\" && typeof (x === null || x === void 0 ? void 0 : x.tag) === \"string\");\n}\nexport const isILoggingError = (x) => typeof (x === null || x === void 0 ? void 0 : x.getTelemetryProperties) === \"function\";\n/**\n * Walk an object's enumerable properties to find those fit for telemetry.\n */\nfunction getValidTelemetryProps(obj) {\n    const props = {};\n    for (const key of Object.keys(obj)) {\n        const val = obj[key];\n        switch (typeof val) {\n            case \"string\":\n            case \"number\":\n            case \"boolean\":\n            case \"undefined\":\n                props[key] = val;\n                break;\n            default: {\n                if (isTaggedTelemetryPropertyValue(val)) {\n                    props[key] = val;\n                }\n                else {\n                    // We don't support logging arbitrary objects\n                    props[key] = \"REDACTED (arbitrary object)\";\n                }\n                break;\n            }\n        }\n    }\n    return props;\n}\n/**\n * Helper class for error tracking that can be used to log an error in telemetry.\n * The props passed in (and any set directly on the object after the fact) will be\n * logged in accordance with the given TelemetryDataTag, if present.\n *\n * PLEASE take care to properly tag properties set on this object\n */\nexport class LoggingError extends Error {\n    constructor(message, props) {\n        super(message);\n        if (props) {\n            this.addTelemetryProperties(props);\n        }\n    }\n    /**\n     * Add additional properties to be logged\n     */\n    addTelemetryProperties(props) {\n        Object.assign(this, props);\n    }\n    /**\n     * Get all properties fit to be logged to telemetry for this error\n     */\n    getTelemetryProperties() {\n        const taggableProps = getValidTelemetryProps(this);\n        // Include non-enumerable props inherited from Error that would not be returned by getValidTelemetryProps\n        // But if any were overwritten (e.g. with a tagged property), then use the result from getValidTelemetryProps.\n        // Not including the 'name' property because it's likely always \"Error\"\n        return Object.assign({ stack: this.stack, message: this.message }, taggableProps);\n    }\n}\n/**\n * Logger that is useful for UT\n * It can be used in places where logger instance is required, but events should be not send over.\n */\nexport class TelemetryUTLogger {\n    send(event) {\n    }\n    sendTelemetryEvent(event, error) {\n    }\n    sendErrorEvent(event, error) {\n        this.reportError(\"errorEvent in UT logger!\", event, error);\n    }\n    sendPerformanceEvent(event, error) {\n    }\n    logGenericError(eventName, error) {\n        this.reportError(`genericError in UT logger!`, { eventName }, error);\n    }\n    logException(event, exception) {\n        this.reportError(\"exception in UT logger!\", event, exception);\n    }\n    debugAssert(condition, event) {\n        this.reportError(\"debugAssert in UT logger!\");\n    }\n    shipAssert(condition, event) {\n        this.reportError(\"shipAssert in UT logger!\");\n    }\n    reportError(message, event, err) {\n        const error = new Error(message);\n        error.error = error;\n        error.event = event;\n        // report to console as exception can be eaten\n        console.error(message);\n        console.error(error);\n        throw error;\n    }\n}\n//# sourceMappingURL=logger.js.map","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Copyright (c) 2013 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\"use strict\";\nfunction Deque(capacity) {\n    this._capacity = getCapacity(capacity);\n    this._length = 0;\n    this._front = 0;\n    if (isArray(capacity)) {\n        var len = capacity.length;\n        for (var i = 0; i < len; ++i) {\n            this[i] = capacity[i];\n        }\n        this._length = len;\n    }\n}\n\nDeque.prototype.toArray = function Deque$toArray() {\n    var len = this._length;\n    var ret = new Array(len);\n    var front = this._front;\n    var capacity = this._capacity;\n    for (var j = 0; j < len; ++j) {\n        ret[j] = this[(front + j) & (capacity - 1)];\n    }\n    return ret;\n};\n\nDeque.prototype.push = function Deque$push(item) {\n    var argsLength = arguments.length;\n    var length = this._length;\n    if (argsLength > 1) {\n        var capacity = this._capacity;\n        if (length + argsLength > capacity) {\n            for (var i = 0; i < argsLength; ++i) {\n                this._checkCapacity(length + 1);\n                var j = (this._front + length) & (this._capacity - 1);\n                this[j] = arguments[i];\n                length++;\n                this._length = length;\n            }\n            return length;\n        }\n        else {\n            var j = this._front;\n            for (var i = 0; i < argsLength; ++i) {\n                this[(j + length) & (capacity - 1)] = arguments[i];\n                j++;\n            }\n            this._length = length + argsLength;\n            return length + argsLength;\n        }\n\n    }\n\n    if (argsLength === 0) return length;\n\n    this._checkCapacity(length + 1);\n    var i = (this._front + length) & (this._capacity - 1);\n    this[i] = item;\n    this._length = length + 1;\n    return length + 1;\n};\n\nDeque.prototype.pop = function Deque$pop() {\n    var length = this._length;\n    if (length === 0) {\n        return void 0;\n    }\n    var i = (this._front + length - 1) & (this._capacity - 1);\n    var ret = this[i];\n    this[i] = void 0;\n    this._length = length - 1;\n    return ret;\n};\n\nDeque.prototype.shift = function Deque$shift() {\n    var length = this._length;\n    if (length === 0) {\n        return void 0;\n    }\n    var front = this._front;\n    var ret = this[front];\n    this[front] = void 0;\n    this._front = (front + 1) & (this._capacity - 1);\n    this._length = length - 1;\n    return ret;\n};\n\nDeque.prototype.unshift = function Deque$unshift(item) {\n    var length = this._length;\n    var argsLength = arguments.length;\n\n\n    if (argsLength > 1) {\n        var capacity = this._capacity;\n        if (length + argsLength > capacity) {\n            for (var i = argsLength - 1; i >= 0; i--) {\n                this._checkCapacity(length + 1);\n                var capacity = this._capacity;\n                var j = (((( this._front - 1 ) &\n                    ( capacity - 1) ) ^ capacity ) - capacity );\n                this[j] = arguments[i];\n                length++;\n                this._length = length;\n                this._front = j;\n            }\n            return length;\n        }\n        else {\n            var front = this._front;\n            for (var i = argsLength - 1; i >= 0; i--) {\n                var j = (((( front - 1 ) &\n                    ( capacity - 1) ) ^ capacity ) - capacity );\n                this[j] = arguments[i];\n                front = j;\n            }\n            this._front = front;\n            this._length = length + argsLength;\n            return length + argsLength;\n        }\n    }\n\n    if (argsLength === 0) return length;\n\n    this._checkCapacity(length + 1);\n    var capacity = this._capacity;\n    var i = (((( this._front - 1 ) &\n        ( capacity - 1) ) ^ capacity ) - capacity );\n    this[i] = item;\n    this._length = length + 1;\n    this._front = i;\n    return length + 1;\n};\n\nDeque.prototype.peekBack = function Deque$peekBack() {\n    var length = this._length;\n    if (length === 0) {\n        return void 0;\n    }\n    var index = (this._front + length - 1) & (this._capacity - 1);\n    return this[index];\n};\n\nDeque.prototype.peekFront = function Deque$peekFront() {\n    if (this._length === 0) {\n        return void 0;\n    }\n    return this[this._front];\n};\n\nDeque.prototype.get = function Deque$get(index) {\n    var i = index;\n    if ((i !== (i | 0))) {\n        return void 0;\n    }\n    var len = this._length;\n    if (i < 0) {\n        i = i + len;\n    }\n    if (i < 0 || i >= len) {\n        return void 0;\n    }\n    return this[(this._front + i) & (this._capacity - 1)];\n};\n\nDeque.prototype.isEmpty = function Deque$isEmpty() {\n    return this._length === 0;\n};\n\nDeque.prototype.clear = function Deque$clear() {\n    var len = this._length;\n    var front = this._front;\n    var capacity = this._capacity;\n    for (var j = 0; j < len; ++j) {\n        this[(front + j) & (capacity - 1)] = void 0;\n    }\n    this._length = 0;\n    this._front = 0;\n};\n\nDeque.prototype.toString = function Deque$toString() {\n    return this.toArray().toString();\n};\n\nDeque.prototype.valueOf = Deque.prototype.toString;\nDeque.prototype.removeFront = Deque.prototype.shift;\nDeque.prototype.removeBack = Deque.prototype.pop;\nDeque.prototype.insertFront = Deque.prototype.unshift;\nDeque.prototype.insertBack = Deque.prototype.push;\nDeque.prototype.enqueue = Deque.prototype.push;\nDeque.prototype.dequeue = Deque.prototype.shift;\nDeque.prototype.toJSON = Deque.prototype.toArray;\n\nObject.defineProperty(Deque.prototype, \"length\", {\n    get: function() {\n        return this._length;\n    },\n    set: function() {\n        throw new RangeError(\"\");\n    }\n});\n\nDeque.prototype._checkCapacity = function Deque$_checkCapacity(size) {\n    if (this._capacity < size) {\n        this._resizeTo(getCapacity(this._capacity * 1.5 + 16));\n    }\n};\n\nDeque.prototype._resizeTo = function Deque$_resizeTo(capacity) {\n    var oldCapacity = this._capacity;\n    this._capacity = capacity;\n    var front = this._front;\n    var length = this._length;\n    if (front + length > oldCapacity) {\n        var moveItemsCount = (front + length) & (oldCapacity - 1);\n        arrayMove(this, 0, this, oldCapacity, moveItemsCount);\n    }\n};\n\n\nvar isArray = Array.isArray;\n\nfunction arrayMove(src, srcIndex, dst, dstIndex, len) {\n    for (var j = 0; j < len; ++j) {\n        dst[j + dstIndex] = src[j + srcIndex];\n        src[j + srcIndex] = void 0;\n    }\n}\n\nfunction pow2AtLeast(n) {\n    n = n >>> 0;\n    n = n - 1;\n    n = n | (n >> 1);\n    n = n | (n >> 2);\n    n = n | (n >> 4);\n    n = n | (n >> 8);\n    n = n | (n >> 16);\n    return n + 1;\n}\n\nfunction getCapacity(capacity) {\n    if (typeof capacity !== \"number\") {\n        if (isArray(capacity)) {\n            capacity = capacity.length;\n        }\n        else {\n            return 16;\n        }\n    }\n    return pow2AtLeast(\n        Math.min(\n            Math.max(16, capacity), 1073741824)\n    );\n}\n\nmodule.exports = Deque;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignMergeValue;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var copyObject = require('./_copyObject'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n","var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n","var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n","var Stack = require('./_Stack'),\n    arrayEach = require('./_arrayEach'),\n    assignValue = require('./_assignValue'),\n    baseAssign = require('./_baseAssign'),\n    baseAssignIn = require('./_baseAssignIn'),\n    cloneBuffer = require('./_cloneBuffer'),\n    copyArray = require('./_copyArray'),\n    copySymbols = require('./_copySymbols'),\n    copySymbolsIn = require('./_copySymbolsIn'),\n    getAllKeys = require('./_getAllKeys'),\n    getAllKeysIn = require('./_getAllKeysIn'),\n    getTag = require('./_getTag'),\n    initCloneArray = require('./_initCloneArray'),\n    initCloneByTag = require('./_initCloneByTag'),\n    initCloneObject = require('./_initCloneObject'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isMap = require('./isMap'),\n    isObject = require('./isObject'),\n    isSet = require('./isSet'),\n    keys = require('./keys'),\n    keysIn = require('./keysIn');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n","var isObject = require('./isObject');\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","var isObject = require('./isObject'),\n    isPrototype = require('./_isPrototype'),\n    nativeKeysIn = require('./_nativeKeysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n","var Stack = require('./_Stack'),\n    assignMergeValue = require('./_assignMergeValue'),\n    baseFor = require('./_baseFor'),\n    baseMergeDeep = require('./_baseMergeDeep'),\n    isObject = require('./isObject'),\n    keysIn = require('./keysIn'),\n    safeGet = require('./_safeGet');\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\nmodule.exports = baseMerge;\n","var assignMergeValue = require('./_assignMergeValue'),\n    cloneBuffer = require('./_cloneBuffer'),\n    cloneTypedArray = require('./_cloneTypedArray'),\n    copyArray = require('./_copyArray'),\n    initCloneObject = require('./_initCloneObject'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isArrayLikeObject = require('./isArrayLikeObject'),\n    isBuffer = require('./isBuffer'),\n    isFunction = require('./isFunction'),\n    isObject = require('./isObject'),\n    isPlainObject = require('./isPlainObject'),\n    isTypedArray = require('./isTypedArray'),\n    safeGet = require('./_safeGet'),\n    toPlainObject = require('./toPlainObject');\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\nmodule.exports = baseMergeDeep;\n","var identity = require('./identity'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n","var constant = require('./constant'),\n    defineProperty = require('./_defineProperty'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","var Uint8Array = require('./_Uint8Array');\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n","var root = require('./_root');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n","/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n","var Symbol = require('./_Symbol');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n","var assignValue = require('./_assignValue'),\n    baseAssignValue = require('./_baseAssignValue');\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n","var copyObject = require('./_copyObject'),\n    getSymbols = require('./_getSymbols');\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n","var copyObject = require('./_copyObject'),\n    getSymbolsIn = require('./_getSymbolsIn');\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","var baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbolsIn = require('./_getSymbolsIn'),\n    keysIn = require('./keysIn');\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n","var arrayPush = require('./_arrayPush'),\n    getPrototype = require('./_getPrototype'),\n    getSymbols = require('./_getSymbols'),\n    stubArray = require('./stubArray');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer'),\n    cloneDataView = require('./_cloneDataView'),\n    cloneRegExp = require('./_cloneRegExp'),\n    cloneSymbol = require('./_cloneSymbol'),\n    cloneTypedArray = require('./_cloneTypedArray');\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n","var baseCreate = require('./_baseCreate'),\n    getPrototype = require('./_getPrototype'),\n    isPrototype = require('./_isPrototype');\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var apply = require('./_apply');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\nmodule.exports = safeGet;\n","var baseSetToString = require('./_baseSetToString'),\n    shortOut = require('./_shortOut');\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n","/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","var baseClone = require('./_baseClone');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = cloneDeep;\n","/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var isArrayLike = require('./isArrayLike'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\nmodule.exports = isArrayLikeObject;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","var baseIsMap = require('./_baseIsMap'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    getPrototype = require('./_getPrototype'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n","var baseIsSet = require('./_baseIsSet'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeysIn = require('./_baseKeysIn'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n","var baseMerge = require('./_baseMerge'),\n    createAssigner = require('./_createAssigner');\n\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */\nvar merge = createAssigner(function(object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\n\nmodule.exports = merge;\n","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\nmodule.exports = toPlainObject;\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return Object.keys(obj).map(function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n */\r\nimport { DataObject, DataObjectFactory } from \"@fluidframework/aqueduct\";\r\nimport { SharedMap } from \"@fluidframework/map\";\r\nimport { SharedString } from \"@fluidframework/sequence\";\r\n\r\nimport { DocumentModel } from \"./documentModel\";\r\n\r\nexport class DocumentComponent extends DataObject {\r\n    public static readonly objectType = \"DocumentComponent\";\r\n\r\n    /**\r\n     * Factory for creating a DocumentComponent\r\n     */\r\n    public static readonly factory = new DataObjectFactory(\r\n        DocumentComponent.objectType,\r\n        DocumentComponent,\r\n        [SharedMap.getFactory(), SharedString.getFactory()],\r\n        {},\r\n    );\r\n\r\n    private _documentModel?: DocumentModel;\r\n\r\n    public get documentModel(): DocumentModel {\r\n        if (!this._documentModel) {\r\n            throw new Error(\"documentModel has not been initialized yet\");\r\n        }\r\n        return this._documentModel;\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     *\r\n     * Called the first time, and *only* the first time, that the DataObject\r\n     * is opened on a client. It is _not_ called on any subsequent clients that\r\n     * open it.\r\n     */\r\n    protected initializingFirstTime(): Promise<void> {\r\n        DocumentModel.createForNewDocument(this.runtime, this.root);\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Called every time the DataObject is initialized _from an existing\r\n     * instance_. * Not called the first time the DataObject is initialized.\r\n     */\r\n    // Not implementing this yet for our component as it is not needed.\r\n    // The data stored in DDSs are already loaded even without this.\r\n    // This can be used to provide backwards compatibility when a\r\n    // new instance can consume and upgrade a model from an older client\r\n    // protected async initializingFromExisting(): Promise<void> { }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    protected async hasInitialized(): Promise<void> {\r\n        // Store references to the Distributed Data Structures in DocumentModel\r\n        this._documentModel = await DocumentModel.fromExistingDocument(this.root);\r\n    }\r\n}\r\n","/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n */\r\nimport { IFluidHandle } from \"@fluidframework/core-interfaces\";\r\nimport { IFluidDataStoreRuntime } from \"@fluidframework/datastore-definitions\";\r\nimport { ISharedDirectory, SharedDirectory, SharedMap } from \"@fluidframework/map\";\r\nimport { SharedString } from \"@fluidframework/sequence\";\r\n\r\n/**\r\n * The keys of this type define the keys used by {@link DocumentModel} to store DDSes in an {@link ISharedDirectory},\r\n * and the value associated with each key defines the type of DDS that MUST be used with that key.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention -- the TypeScript language demands this be an interface, but it doesn't define a contract, so not adding an 'I' prefix\r\ninterface DocumentModelKeyToDdsType {\r\n    listDefinitionsMap: SharedMap;\r\n    listOverridesMap: SharedMap;\r\n    oartDirectory: SharedDirectory;\r\n    presenceMap: SharedMap;\r\n    snapshotsMap: SharedMap;\r\n    textString: SharedString;\r\n}\r\n\r\nfunction setDds<K extends keyof DocumentModelKeyToDdsType>(\r\n    rootDirectory: ISharedDirectory,\r\n    key: K,\r\n    dds: DocumentModelKeyToDdsType[K],\r\n): void {\r\n    rootDirectory.set(key, dds.handle);\r\n}\r\n\r\nasync function getDds<K extends keyof DocumentModelKeyToDdsType>(\r\n    rootDirectory: ISharedDirectory,\r\n    key: K,\r\n): Promise<DocumentModelKeyToDdsType[K]> {\r\n    const ddsHandle = rootDirectory.get<IFluidHandle<DocumentModelKeyToDdsType[K]>>(key);\r\n    if (!ddsHandle) {\r\n        throw new Error(`Could not get handle to DDS for ${key}`);\r\n    }\r\n    return await ddsHandle.get();\r\n}\r\n\r\nexport class DocumentModel {\r\n    /**\r\n     * Populate the given rootDirectory given be a new document\r\n     */\r\n    public static createForNewDocument(\r\n        runtime: IFluidDataStoreRuntime,\r\n        rootDirectory: ISharedDirectory,\r\n    ): DocumentModel {\r\n        const textString = SharedString.create(runtime);\r\n\r\n        textString.insertMarker(0, 1, {\r\n            markerId: \"{61E35DF2-8462-4CE1-8EEB-1D00F4AC6457}\",\r\n            referenceTileLabels: [\"Eop\"],\r\n        });\r\n        textString.insertMarker(0, 1, {\r\n            markerId: \"{07480EF9-939A-4922-8822-2C0E16253659}\",\r\n            referenceTileLabels: [\"Eop\"],\r\n        });\r\n        textString.insertMarker(0, 1, {\r\n            markerId: \"{DC6D36DF-DABF-4BA0-BFCA-0133AF997332}\",\r\n            referenceTileLabels: [\"Eop\"],\r\n        });\r\n\r\n        setDds(rootDirectory, \"textString\", textString);\r\n        const presenceMap = SharedMap.create(runtime);\r\n        setDds(rootDirectory, \"presenceMap\", presenceMap);\r\n\r\n        const snapshotsMap = SharedMap.create(runtime);\r\n        setDds(rootDirectory, \"snapshotsMap\", snapshotsMap);\r\n\r\n        const listDefinitionsMap = SharedMap.create(runtime);\r\n        setDds(rootDirectory, \"listDefinitionsMap\", listDefinitionsMap);\r\n\r\n        const listOverridesMap = SharedMap.create(runtime);\r\n        setDds(rootDirectory, \"listOverridesMap\", listOverridesMap);\r\n\r\n        const oartDirectory = SharedDirectory.create(runtime);\r\n        setDds(rootDirectory, \"oartDirectory\", oartDirectory);\r\n\r\n        return new DocumentModel(\r\n            textString,\r\n            presenceMap,\r\n            snapshotsMap,\r\n            listDefinitionsMap,\r\n            listOverridesMap,\r\n            oartDirectory,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * When component has finished initializing via hasInitialized(),\r\n     * store references to the ready Distributed Data Structures\r\n     * in the component's root\r\n     */\r\n    public static async fromExistingDocument(rootDirectory: ISharedDirectory): Promise<DocumentModel> {\r\n        const [textString, presenceMap, snapshotsMap, listDefinitionsMap, listOverridesMap, oartDirectory] =\r\n            await Promise.all([\r\n                getDds(rootDirectory, \"textString\"),\r\n                getDds(rootDirectory, \"presenceMap\"),\r\n                getDds(rootDirectory, \"snapshotsMap\"),\r\n                getDds(rootDirectory, \"listDefinitionsMap\"),\r\n                getDds(rootDirectory, \"listOverridesMap\"),\r\n                getDds(rootDirectory, \"oartDirectory\"),\r\n            ]);\r\n\r\n        return new DocumentModel(\r\n            textString,\r\n            presenceMap,\r\n            snapshotsMap,\r\n            listDefinitionsMap,\r\n            listOverridesMap,\r\n            oartDirectory,\r\n        );\r\n    }\r\n\r\n    private constructor(\r\n        public readonly textString: SharedString,\r\n        public readonly presenceMap: SharedMap,\r\n        public readonly snapshotsMap: SharedMap,\r\n        public readonly listDefinitionsMap: SharedMap,\r\n        public readonly listOverridesMap: SharedMap,\r\n        public readonly oartDirectory: SharedDirectory,\r\n    ) {}\r\n}\r\n","/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n */\r\nimport { ContainerRuntimeFactoryWithDefaultDataStore } from \"@fluidframework/aqueduct\";\r\nimport { ICodeLoader, IFluidModule, IRuntimeFactory } from \"@fluidframework/container-definitions\";\r\nimport { Loader } from \"@fluidframework/container-loader\";\r\nimport { IContainerRuntimeOptions } from \"@fluidframework/container-runtime\";\r\nimport { IFluidCodeDetails } from \"@fluidframework/core-interfaces\";\r\nimport { IDocumentServiceFactory, IUrlResolver } from \"@fluidframework/driver-definitions\";\r\nimport { IClient } from \"@fluidframework/protocol-definitions\";\r\nimport { DebugLogger } from \"@fluidframework/telemetry-utils\";\r\n\r\nimport { DocumentComponent } from \"./documentComponent\";\r\n\r\nexport class WordCodeLoader implements ICodeLoader {\r\n    private readonly runtimeFactory: IRuntimeFactory;\r\n\r\n    constructor(enableSummaries: boolean) {\r\n        const runtimeOptions: IContainerRuntimeOptions = {};\r\n\r\n        if (!enableSummaries) {\r\n            runtimeOptions.disableGC = true;\r\n            runtimeOptions.generateSummaries = false;\r\n        }\r\n\r\n        this.runtimeFactory = new ContainerRuntimeFactoryWithDefaultDataStore(\r\n            DocumentComponent.factory,\r\n            new Map([[DocumentComponent.objectType, Promise.resolve(DocumentComponent.factory)]]),\r\n            [],\r\n            [],\r\n            runtimeOptions,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public load(pkg: IFluidCodeDetails): Promise<IFluidModule> {\r\n        let source: string;\r\n\r\n        if (typeof pkg.package === \"string\") {\r\n            source = pkg.package;\r\n        } else {\r\n            throw new Error(`Unexpected package type: '${typeof pkg.package}'`);\r\n        }\r\n\r\n        if (source !== DocumentComponent.objectType) {\r\n            throw new Error(`No factory for '${source}'`);\r\n        }\r\n\r\n        return Promise.resolve({ fluidExport: this.runtimeFactory });\r\n    }\r\n\r\n    /**\r\n     * Returns the correct container loader\r\n     */\r\n    public getLoader(\r\n        urlResolver: IUrlResolver,\r\n        documentServiceFactory: IDocumentServiceFactory,\r\n        client?: IClient,\r\n    ): Loader {\r\n        const module = { fluidExport: this.runtimeFactory };\r\n        const codeLoader = { load: () => Promise.resolve(module) };\r\n        const loaderProps = {\r\n            codeLoader,\r\n            documentServiceFactory,\r\n            logger: DebugLogger.create(\"Word\"),\r\n            options: {\r\n                client,\r\n            },\r\n            urlResolver,\r\n        };\r\n\r\n        return new Loader(loaderProps);\r\n    }\r\n}\r\n","/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n */\r\nimport {\r\n    IClient,\r\n    IClientJoin,\r\n    IDocumentMessage,\r\n    IDocumentSystemMessage,\r\n    ISequencedDocumentMessage,\r\n    ISequencedDocumentSystemMessage,\r\n    MessageType,\r\n    ScopeType,\r\n} from \"@fluidframework/protocol-definitions\";\r\n\r\nimport {\r\n    WpmOverOcsSequencedDocumentMessages,\r\n    WpmOverOcsSequencedMessagesEncoded,\r\n    WpmOverOcsSequencedSystemMessage,\r\n} from \"./wpmTypes\";\r\n\r\ntype DecodedWpmDocumentMessages = Readonly<{\r\n    type: \"document\";\r\n    decoded: WpmOverOcsSequencedDocumentMessages[];\r\n}>;\r\n\r\ntype DecodedWpmSystemMessage = Readonly<{\r\n    type: \"system\";\r\n    decoded: WpmOverOcsSequencedSystemMessage;\r\n}>;\r\n\r\ntype DecodedWpmDeltaMessages = DecodedWpmDocumentMessages | DecodedWpmSystemMessage;\r\n\r\nconst SUPPORTED_DOCUMENT_MESSAGE_TYPES = new Set<string>([\r\n    // Note: join/leave are not in this list because they are system messages\r\n    MessageType.NoOp,\r\n    MessageType.Operation,\r\n    MessageType.Propose,\r\n    MessageType.Reject,\r\n]);\r\n\r\n/**\r\n * Decodes the JSON stored in a {@link WpmOverOcsSequencedMessagesEncoded} performing validation on the\r\n * Word-owned envelope. Fluid is responsible for validating the contained messages.\r\n */\r\nfunction decodeWpmDeltaMessagesFromJson(json: string): DecodedWpmDeltaMessages {\r\n    /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access -- We're going to parse JSON and validate it */\r\n    const raw = JSON.parse(json);\r\n\r\n    if (Array.isArray(raw)) {\r\n        for (let i = 0; i < raw.length; i += 1) {\r\n            const group = raw[i];\r\n\r\n            if (\r\n                typeof group.sender !== \"string\" ||\r\n                group.sender.length === 0 ||\r\n                !Array.isArray(group.messages) ||\r\n                group.messages.length === 0\r\n            ) {\r\n                throw new Error(\"Malformed delta messages\");\r\n            }\r\n\r\n            for (let j = 0; j < group.messages.length; j += 1) {\r\n                const msg = group.messages[j];\r\n\r\n                // Fluid is responsible for validating the IDocumentMessage format, we're just doing a\r\n                // sanity-check here\r\n                if (\r\n                    typeof msg !== \"object\" ||\r\n                    // eslint-disable-next-line no-null/no-null -- required to validate the object is safe\r\n                    msg === null ||\r\n                    // minimumSequenceNumber will be set if immediate-ACK was in use\r\n                    (typeof msg.minimimSequenceNumber !== \"undefined\" && typeof msg.minimimSequenceNumber !== \"number\")\r\n                ) {\r\n                    throw new Error(\"Malformed delta messages\");\r\n                }\r\n            }\r\n\r\n            return { decoded: raw as WpmOverOcsSequencedDocumentMessages[], type: \"document\" };\r\n        }\r\n    }\r\n\r\n    if (\r\n        (raw.type !== \"ClientJoin\" && raw.type !== \"ClientLeave\") ||\r\n        typeof raw.clientId !== \"string\" ||\r\n        typeof raw.userId !== \"string\"\r\n    ) {\r\n        throw new Error(\"Malformed delta messages\");\r\n    }\r\n\r\n    return { decoded: raw as WpmOverOcsSequencedSystemMessage, type: \"system\" };\r\n    /* eslint-enable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access */\r\n}\r\n\r\n/**\r\n * Helper to create either a ClientJoin or ClientLeave Fluid message.\r\n */\r\nfunction createFluidSystemMessage<T>(type: MessageType, data: T): IDocumentSystemMessage {\r\n    if (type !== MessageType.ClientJoin && type !== MessageType.ClientLeave) {\r\n        throw new Error(\"Invalid type\");\r\n    }\r\n\r\n    return {\r\n        clientSequenceNumber: -1,\r\n\r\n        // eslint-disable-next-line no-null/no-null -- null is expected by Fluid\r\n        contents: null,\r\n\r\n        data: JSON.stringify(data),\r\n        referenceSequenceNumber: -1,\r\n        type,\r\n    };\r\n}\r\n\r\n/**\r\n * Provides type safety for {@link createSequencedFluidMessage}.\r\n */\r\ninterface ISequencedMessageConversionType {\r\n    document: ISequencedDocumentMessage;\r\n    system: ISequencedDocumentSystemMessage;\r\n}\r\n\r\n/**\r\n * Applies a stamped sequence number (and associated metadata) to a Fluid message.\r\n */\r\nfunction createSequencedFluidMessage<K extends keyof ISequencedMessageConversionType>(\r\n    _type: K, // Only used for inferring the return type\r\n    clientId: string | null,\r\n    message: IDocumentMessage | IDocumentSystemMessage,\r\n    minimumSequenceNumber: number,\r\n    sequenceNumber: number,\r\n): ISequencedMessageConversionType[K] {\r\n    return {\r\n        ...message,\r\n\r\n        clientId,\r\n        minimumSequenceNumber,\r\n        sequenceNumber,\r\n\r\n        // Fluid doesn't seem to care too much about these for our purposes\r\n        term: 1,\r\n\r\n        // This must be zero! That way Fluid is okay with receiving a duplicate ClientJoin message for itself when it\r\n        // fetches via Delta Storage (which we synthesized to unblock booting) and then when it receives the stamped\r\n        // message later.\r\n        //\r\n        // This means we don't store timestamps in the delta stream!\r\n        timestamp: 0,\r\n    } as ISequencedMessageConversionType[K];\r\n}\r\n\r\n/**\r\n * Applies a consistent envelope used by WPM Over OCS for stamping/sequencing to a message.\r\n *\r\n * @param clientId - the ID of the client sending the message.\r\n * @param minimumSequenceNumber - the minimum sequence number of the session.\r\n * @param sequenceNumber - the sequence number to assign to the message.\r\n * @param message - the message to sequence/stamp.\r\n * @returns the sequenced copy of the message.\r\n */\r\nexport function applySequenceNumberToFluidMessage(\r\n    clientId: string,\r\n    minimumSequenceNumber: number,\r\n    sequenceNumber: number,\r\n    message: IDocumentMessage,\r\n): ISequencedDocumentMessage {\r\n    return createSequencedFluidMessage(\"document\", clientId, message, minimumSequenceNumber, sequenceNumber);\r\n}\r\n\r\n/**\r\n * Converts a {@link WpmOverOcsSequencedDocumentMessages} to an array of Fluid's {@link ISequencedDocumentMessage}.\r\n */\r\nfunction convertWpmToFluidSequencedDocumentMessages(\r\n    startingMinimumSequenceNumber: number,\r\n    startingSequenceNumber: number,\r\n    decoded: WpmOverOcsSequencedDocumentMessages[],\r\n): ISequencedDocumentMessage[] {\r\n    const messages: ISequencedDocumentMessage[] = [];\r\n    let sequenceNumberTracker = startingSequenceNumber;\r\n    let lastMinimumSequenceNumber = startingMinimumSequenceNumber;\r\n\r\n    for (let groupIndex = 0; groupIndex < decoded.length; groupIndex += 1) {\r\n        const group = decoded[groupIndex];\r\n\r\n        for (let messageIndex = 0; messageIndex < group.messages.length; messageIndex += 1) {\r\n            const messageSequenceNumber = sequenceNumberTracker;\r\n            sequenceNumberTracker += 1;\r\n\r\n            // Fluid is responsible for validating this object matches the expected schema\r\n            const message = group.messages[messageIndex];\r\n\r\n            if (!SUPPORTED_DOCUMENT_MESSAGE_TYPES.has(message.type)) {\r\n                throw new Error(\"Unsupported document message type\");\r\n            }\r\n\r\n            // minimumSequenceNumber will be set on the message if immediate-ACK was in use\r\n            const messageMinimumSequenceNumber = message.minimumSequenceNumber ?? lastMinimumSequenceNumber;\r\n\r\n            if (messageMinimumSequenceNumber < lastMinimumSequenceNumber) {\r\n                throw new Error(\"Malformed delta message\");\r\n            }\r\n\r\n            lastMinimumSequenceNumber = messageMinimumSequenceNumber;\r\n\r\n            const sequencedMessage = createSequencedFluidMessage(\r\n                \"document\",\r\n                group.sender,\r\n                message,\r\n                messageMinimumSequenceNumber,\r\n                messageSequenceNumber,\r\n            );\r\n\r\n            messages.push(sequencedMessage);\r\n        }\r\n    }\r\n\r\n    if (messages.length === 0) {\r\n        throw new Error(\"Malformed encoded messages\");\r\n    }\r\n\r\n    return messages;\r\n}\r\n\r\n/**\r\n * Converts a {@link WpmOverOcsSequencedSystemMessage} to a Fluid {@link ISequencedDocumentSystemMessage}.\r\n */\r\nfunction convertWpmToFluidSequencedSystemMessage(\r\n    startingMinimumSequenceNumber: number,\r\n    startingSequenceNumber: number,\r\n    decoded: WpmOverOcsSequencedSystemMessage,\r\n): ISequencedDocumentSystemMessage {\r\n    let systemMessage: IDocumentSystemMessage;\r\n\r\n    if (decoded.type === \"ClientJoin\") {\r\n        systemMessage = createFluidSystemMessage<IClientJoin>(MessageType.ClientJoin, {\r\n            clientId: decoded.clientId,\r\n            detail: createFluidClient(decoded.userId),\r\n        });\r\n    } else {\r\n        systemMessage = createFluidSystemMessage<string>(MessageType.ClientLeave, decoded.clientId);\r\n    }\r\n\r\n    const sequencedMessage = createSequencedFluidMessage(\r\n        \"system\",\r\n        // eslint-disable-next-line no-null/no-null -- Fluid expects null\r\n        null, // clientId\r\n        systemMessage,\r\n        startingMinimumSequenceNumber,\r\n        startingSequenceNumber,\r\n    );\r\n\r\n    return sequencedMessage;\r\n}\r\n\r\n/**\r\n * Convert messages stored in an OCS dictionary format into the format Fluid expects.\r\n */\r\nexport function convertWpmToFluidSequencedMessages(\r\n    encoded: WpmOverOcsSequencedMessagesEncoded,\r\n): (ISequencedDocumentMessage | ISequencedDocumentSystemMessage)[] {\r\n    const deltaMessages = decodeWpmDeltaMessagesFromJson(encoded.json);\r\n\r\n    if (deltaMessages.type === \"document\") {\r\n        return convertWpmToFluidSequencedDocumentMessages(\r\n            encoded.minimumSequenceNumber,\r\n            encoded.startingSequenceNumber,\r\n            deltaMessages.decoded,\r\n        );\r\n    }\r\n\r\n    return [\r\n        convertWpmToFluidSequencedSystemMessage(\r\n            encoded.minimumSequenceNumber,\r\n            encoded.startingSequenceNumber,\r\n            deltaMessages.decoded,\r\n        ),\r\n    ];\r\n}\r\n\r\n/**\r\n * Creates a Fluid {@link IClient} with a consistent set of properties for use with WPM Over OCS.\r\n */\r\nexport function createFluidClient(userId: string): IClient {\r\n    return {\r\n        details: {\r\n            capabilities: {\r\n                // Not true for Sword but we don't really care\r\n                interactive: true,\r\n            },\r\n        },\r\n\r\n        // We don't support read-only Fluid for WPM Over OCS\r\n        mode: \"write\",\r\n\r\n        permission: [],\r\n\r\n        // Notice that there is no SummaryWrite here\r\n        scopes: [ScopeType.DocRead, ScopeType.DocWrite],\r\n\r\n        user: {\r\n            id: userId,\r\n        },\r\n    };\r\n}\r\n","/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n */\r\nimport { EventEmitter } from \"events\";\r\n\r\nimport { IDocumentDeltaConnection } from \"@fluidframework/driver-definitions\";\r\nimport {\r\n    IClientConfiguration,\r\n    IDocumentMessage,\r\n    ISequencedDocumentMessage,\r\n    ISequencedDocumentSystemMessage,\r\n    ISignalClient,\r\n    ISignalMessage,\r\n    ITokenClaims,\r\n    IUser,\r\n    ScopeType,\r\n} from \"@fluidframework/protocol-definitions\";\r\n\r\nimport { WPM_OVER_OCS_DOCUMENT_ID, WPM_OVER_OCS_TENANT_ID } from \"./urlResolver\";\r\nimport {\r\n    IWpmOverOcsCallsFromNative,\r\n    IWpmOverOcsCallsIntoNative,\r\n    WpmOverOcsOutgoingBufferedMessages,\r\n    WpmOverOcsSequencedDocumentMessages,\r\n    WpmOverOcsSequencedMessagesEncoded,\r\n} from \"./wpmTypes.js\";\r\n\r\n/**\r\n * Implementation of {@link IDocumentDeltaConnection} as part of the WPM Over OCS driver.\r\n */\r\nexport class WpmOverOcsDocumentDeltaConnection\r\n    extends EventEmitter\r\n    implements IDocumentDeltaConnection, IWpmOverOcsCallsFromNative\r\n{\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public readonly initialClients: ISignalClient[] = []; // Fluid will figure it out as it goes through the op stream\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public readonly mode = \"write\"; // We don't support read-only Fluid\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public readonly maxMessageSize = Number.MAX_SAFE_INTEGER; // Technically there is a limit for what we put in the dictionary; just let that fail in native\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public readonly version = \"WPMv1\"; // Does not have to match ocsfmt\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public readonly initialMessages: ISequencedDocumentMessage[] = []; // Fluid will figure this out from the delta stream\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public readonly initialSignals: ISignalMessage[] = []; // Fluid will figure this out from the delta stream\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public readonly serviceConfiguration: IClientConfiguration = {\r\n        // See comment above for maxMessageSize\r\n        blockSize: Number.MAX_SAFE_INTEGER,\r\n        maxMessageSize: Number.MAX_SAFE_INTEGER,\r\n\r\n        // We disable summaries when loading the container\r\n        summary: {\r\n            idleTime: Number.MAX_SAFE_INTEGER,\r\n            maxAckWaitTime: Number.MAX_SAFE_INTEGER,\r\n            maxOps: Number.MAX_SAFE_INTEGER,\r\n            maxTime: Number.MAX_SAFE_INTEGER,\r\n        },\r\n    };\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public readonly checkpointSequenceNumber?: number; // Fluid will figure this out on its own\r\n\r\n    private readonly _bufferedOutgoingMessages: (IDocumentMessage & { minimumSequenceNumber?: number })[] = [];\r\n    private _closed = false;\r\n\r\n    private _immediateAck = true;\r\n    private _immediateAckNextSeqNumber = 2; // 1 is the ClientJoin generated by native\r\n\r\n    /**\r\n     * @param _native - interface back into Word native code.\r\n     * @param clientId - the Fluid ID of the connecting client.\r\n     * @param _user - the Fluid identity of the connecting user.\r\n     * @param existing - whether this is for an existing Fluid container (one with a code proposal & populated delta stream).\r\n     * @param _decodeHelper - helper to convert messages stored in a WPM Over OCS dictionary to what Fluid expects.\r\n     * @param _stampingHelper - helper to attach a sequencing metadata to a message.\r\n     */\r\n    constructor(\r\n        private readonly _native: IWpmOverOcsCallsIntoNative,\r\n        public readonly clientId: string,\r\n        private readonly _user: IUser,\r\n        public readonly existing: boolean,\r\n        private readonly _decodeHelper: (\r\n            encoded: WpmOverOcsSequencedMessagesEncoded,\r\n        ) => (ISequencedDocumentMessage | ISequencedDocumentSystemMessage)[],\r\n        private readonly _stampingHelper: (\r\n            clientId: string,\r\n            minimumSequenceNumber: number,\r\n            desiredSequenceNumber: number,\r\n            message: IDocumentMessage,\r\n        ) => ISequencedDocumentMessage,\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public stopImmediateAck(): void {\r\n        this._immediateAck = false;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public retrieveAndClearBufferedMessages(): WpmOverOcsOutgoingBufferedMessages {\r\n        if (this._bufferedOutgoingMessages.length === 0) {\r\n            throw new Error(\"No buffered messages available\");\r\n        }\r\n\r\n        const result: WpmOverOcsOutgoingBufferedMessages = {\r\n            count: this._bufferedOutgoingMessages.length,\r\n            json: JSON.stringify([\r\n                {\r\n                    messages: this._bufferedOutgoingMessages,\r\n                    sender: this.clientId,\r\n                },\r\n            ] as WpmOverOcsSequencedDocumentMessages[]),\r\n            refSeqLast:\r\n                this._bufferedOutgoingMessages[this._bufferedOutgoingMessages.length - 1].referenceSequenceNumber,\r\n        };\r\n\r\n        // Clear the buffer\r\n        this._bufferedOutgoingMessages.splice(0, this._bufferedOutgoingMessages.length);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public submitSequencedMessages(sequencedMessages: WpmOverOcsSequencedMessagesEncoded): void {\r\n        const decoded = this._decodeHelper(sequencedMessages);\r\n        this.emit(\"op\", WPM_OVER_OCS_DOCUMENT_ID, decoded);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public get claims(): ITokenClaims {\r\n        return {\r\n            documentId: WPM_OVER_OCS_DOCUMENT_ID,\r\n            exp: Number.MAX_SAFE_INTEGER,\r\n            iat: Number.MAX_SAFE_INTEGER,\r\n            scopes: [ScopeType.DocRead, ScopeType.DocWrite],\r\n            tenantId: WPM_OVER_OCS_TENANT_ID,\r\n            user: this._user,\r\n            ver: this.version,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public submit(messages: IDocumentMessage[]): void {\r\n        if (this._closed) {\r\n            throw new Error(\"Delta connection is closed\");\r\n        }\r\n\r\n        // Don't try to notify Fluid of messages in the same turn of the event loop. It doesn't like that.\r\n        queueMicrotask(() => {\r\n            if (this._closed) {\r\n                return;\r\n            }\r\n\r\n            for (const message of messages) {\r\n                if (this._immediateAck) {\r\n                    // If we're in immediate-ACK mode, then this is the only client, and it controls the collab\r\n                    // window. To make forward progress, we need to keep moving the collab window forward as the\r\n                    // client buffers messages.\r\n                    this._bufferedOutgoingMessages.push({\r\n                        ...message,\r\n                        minimumSequenceNumber: message.referenceSequenceNumber,\r\n                    });\r\n                } else {\r\n                    this._bufferedOutgoingMessages.push(message);\r\n                }\r\n            }\r\n\r\n            if (this._immediateAck) {\r\n                // Immediate-ACK mode means we need to immediately stamp the message and tell Fluid about it\r\n                const sequenced: ISequencedDocumentMessage[] = [];\r\n\r\n                for (const message of messages) {\r\n                    const sequencedMessage = this._stampingHelper(\r\n                        this.clientId,\r\n                        message.referenceSequenceNumber,\r\n                        this._immediateAckNextSeqNumber,\r\n                        message,\r\n                    );\r\n\r\n                    this._immediateAckNextSeqNumber += 1;\r\n\r\n                    sequenced.push(sequencedMessage);\r\n                }\r\n\r\n                this.emit(\"op\", WPM_OVER_OCS_DOCUMENT_ID, sequenced);\r\n            }\r\n\r\n            // Ring the dinner bell; let native know there's messages it needs to fetch\r\n            this._native.onConnectionMessagesBuffered();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types -- this API signature comes from Fluid\r\n    public submitSignal(_message: any): void {\r\n        throw new Error(\"We do not expect signals to be used in WPM Over OCS\");\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public close(): void {\r\n        if (this._closed) {\r\n            throw new Error(\"Delta connection is already closed\");\r\n        }\r\n\r\n        this._closed = true;\r\n        this._native.onConnectionClosed();\r\n    }\r\n}\r\n","/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n */\r\nimport { IDeltasFetchResult, IDocumentDeltaStorageService } from \"@fluidframework/driver-definitions\";\r\nimport { ISequencedDocumentMessage, ISequencedDocumentSystemMessage } from \"@fluidframework/protocol-definitions\";\r\n\r\nimport { IWpmOverOcsCallsIntoNative, WpmOverOcsSequencedMessagesEncoded } from \"./wpmTypes\";\r\n\r\n/**\r\n * Implementation of {@link IDocumentDeltaStorageService} as part of the WPM Over OCS driver.\r\n */\r\nexport class WpmOverOcsDocumentDeltaStorageService implements IDocumentDeltaStorageService {\r\n    private _native: IWpmOverOcsCallsIntoNative | undefined;\r\n\r\n    /**\r\n     * @param native - interface back into native Word code.\r\n     * @param _conversionHelper - helper to convert messages stored in a WPM Over OCS dictionary to what Fluid expects.\r\n     */\r\n    constructor(\r\n        native: IWpmOverOcsCallsIntoNative,\r\n        private readonly _conversionHelper: (\r\n            encoded: WpmOverOcsSequencedMessagesEncoded,\r\n        ) => (ISequencedDocumentMessage | ISequencedDocumentSystemMessage)[],\r\n    ) {\r\n        this._native = native;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public get(from: number, to: number): Promise<IDeltasFetchResult> {\r\n        if (!this._native) {\r\n            throw new Error(\"We only expect Fluid to fetch one time to simplify the native implementation\");\r\n        }\r\n\r\n        if (from !== 0) {\r\n            throw new Error(\r\n                \"We only expect Fluid to fetch from the very first message to simplify the native implementation\",\r\n            );\r\n        }\r\n\r\n        const fetched = this._native.retrieveSequencedMessages(from, to);\r\n        const messages: (ISequencedDocumentMessage | ISequencedDocumentSystemMessage)[] = [];\r\n\r\n        for (let i = 0; i < fetched.length; i += 1) {\r\n            const encoded = fetched[i];\r\n            const decoded = this._conversionHelper(encoded);\r\n\r\n            // Native can't break apart chunks of messages so we need to filter here\r\n            const messagesToAppend = decoded.filter((m) => m.sequenceNumber < to);\r\n\r\n            messages.push(...messagesToAppend);\r\n\r\n            // If we filtered anything, then anything remaining must be beyond what we're looking for\r\n            if (messagesToAppend.length !== decoded.length) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        this._native = undefined;\r\n\r\n        return Promise.resolve({\r\n            messages,\r\n            partialResult: false,\r\n        });\r\n    }\r\n}\r\n","/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n */\r\nimport { ITelemetryBaseLogger } from \"@fluidframework/common-definitions\";\r\nimport {\r\n    IDocumentDeltaConnection,\r\n    IDocumentDeltaStorageService,\r\n    IDocumentService,\r\n    IDocumentServiceFactory,\r\n    IDocumentStorageService,\r\n    IResolvedUrl,\r\n} from \"@fluidframework/driver-definitions\";\r\nimport { IClient, IErrorTrackingService, ISummaryTree, IUser, ScopeType } from \"@fluidframework/protocol-definitions\";\r\n\r\nimport { applySequenceNumberToFluidMessage, convertWpmToFluidSequencedMessages } from \"./conversionHelpers\";\r\nimport { WpmOverOcsDocumentDeltaConnection } from \"./deltaConnection\";\r\nimport { WpmOverOcsDocumentDeltaStorageService } from \"./deltaStorage\";\r\nimport { WpmOverOcsDocumentStorageService } from \"./documentStorage\";\r\nimport { isWpmOverOcsResolvedUrl, WPM_OVER_OCS_FLUID_URL_PROTOCOL } from \"./urlResolver\";\r\nimport {\r\n    IWpmOverOcsCallsFromNative,\r\n    IWpmOverOcsCallsIntoNative,\r\n    WpmOverOcsOutgoingBufferedMessages,\r\n    WpmOverOcsSequencedMessagesEncoded,\r\n} from \"./wpmTypes.js\";\r\n\r\n/**\r\n * Implementation of {@link IDocumentService} as part of the WPM Over OCS driver.\r\n *\r\n * @see WpmOverOcsDocumentDeltaConnection\r\n * @see WpmOverOcsDocumentDeltaStorageService\r\n * @see WpmOverOcsDocumentStorageService\r\n * @see WpmOverOcsDocumentServiceFactory\r\n */\r\nexport class WpmOverOcsDocumentService implements IDocumentService, IWpmOverOcsCallsFromNative {\r\n    private readonly _storage: WpmOverOcsDocumentStorageService;\r\n    private readonly _deltaStorage: WpmOverOcsDocumentDeltaStorageService;\r\n    private readonly _deltaConnection: WpmOverOcsDocumentDeltaConnection;\r\n\r\n    // We don't allow Fluid to make arbitrary/multiple \"connections\" to OCS. This flag is to enforce that\r\n    // Fluid only connects once.\r\n    private _connected = false;\r\n\r\n    constructor(\r\n        native: IWpmOverOcsCallsIntoNative,\r\n        public readonly resolvedUrl: IResolvedUrl,\r\n        clientId: string,\r\n        private readonly _user: IUser,\r\n        existing: boolean,\r\n    ) {\r\n        this._storage = new WpmOverOcsDocumentStorageService();\r\n        this._deltaStorage = new WpmOverOcsDocumentDeltaStorageService(native, convertWpmToFluidSequencedMessages);\r\n        this._deltaConnection = new WpmOverOcsDocumentDeltaConnection(\r\n            native,\r\n            clientId,\r\n            _user,\r\n            existing,\r\n            convertWpmToFluidSequencedMessages,\r\n            applySequenceNumberToFluidMessage,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public readonly policies = undefined;\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public connectToStorage(): Promise<IDocumentStorageService> {\r\n        return Promise.resolve(this._storage);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public connectToDeltaStorage(): Promise<IDocumentDeltaStorageService> {\r\n        return Promise.resolve(this._deltaStorage);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public connectToDeltaStream(client: IClient): Promise<IDocumentDeltaConnection> {\r\n        if (this._connected) {\r\n            throw new Error(\"Multiple/arbitrary connections to OCS are not supported\");\r\n        }\r\n\r\n        if (\r\n            client.user.id !== this._user.id ||\r\n            client.mode !== \"write\" ||\r\n            client.scopes.indexOf(ScopeType.DocRead) === -1 ||\r\n            client.scopes.indexOf(ScopeType.DocWrite) === -1 ||\r\n            client.scopes.indexOf(ScopeType.SummaryWrite) !== -1\r\n        ) {\r\n            throw new Error(\"Invalid client\");\r\n        }\r\n\r\n        this._connected = true;\r\n        return Promise.resolve(this._deltaConnection);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public getErrorTrackingService(): IErrorTrackingService | null {\r\n        // eslint-disable-next-line no-null/no-null -- this signature is from Fluid\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public stopImmediateAck(): void {\r\n        this._deltaConnection.stopImmediateAck();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public retrieveAndClearBufferedMessages(): WpmOverOcsOutgoingBufferedMessages {\r\n        return this._deltaConnection.retrieveAndClearBufferedMessages();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public submitSequencedMessages(sequencedMessages: WpmOverOcsSequencedMessagesEncoded): void {\r\n        this._deltaConnection.submitSequencedMessages(sequencedMessages);\r\n    }\r\n}\r\n\r\n/**\r\n * Implementation of {@link IDocumentServiceFactory} as part of the WPM Over OCS driver.\r\n *\r\n * @see WpmOverOcsDocumentService\r\n */\r\nexport class WpmOverOcsDocumentServiceFactory implements IDocumentServiceFactory {\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public readonly protocolName = WPM_OVER_OCS_FLUID_URL_PROTOCOL;\r\n\r\n    // We don't allow Fluid to make arbitrary/multiple \"connections\" to OCS. This implementation of the\r\n    // factory accepts a preconfigured document service object and returns it (once, and only once) when\r\n    // Fluid asks for it.\r\n    private _documentService?: WpmOverOcsDocumentService;\r\n\r\n    constructor(documentService: WpmOverOcsDocumentService) {\r\n        this._documentService = documentService;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public createDocumentService(resolvedUrl: IResolvedUrl, _logger?: ITelemetryBaseLogger): Promise<IDocumentService> {\r\n        if (!isWpmOverOcsResolvedUrl(resolvedUrl)) {\r\n            throw new Error(\"URL is not supported by WPM Over OCS driver\");\r\n        }\r\n\r\n        if (this._documentService === undefined) {\r\n            throw new Error(\"Multiple/arbitrary connections to OCS are not supported\");\r\n        }\r\n\r\n        const documentService = this._documentService;\r\n        this._documentService = undefined;\r\n\r\n        return Promise.resolve(documentService);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public createContainer(\r\n        _createNewSummary: ISummaryTree,\r\n        _createNewResolvedUrl: IResolvedUrl,\r\n        _logger?: ITelemetryBaseLogger,\r\n    ): Promise<IDocumentService> {\r\n        throw new Error(\"Not supported in WPM Over OCS\");\r\n    }\r\n}\r\n","/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n */\r\nimport { IDocumentStorageService, ISummaryContext } from \"@fluidframework/driver-definitions\";\r\nimport {\r\n    ICreateBlobResponse,\r\n    ISnapshotTree,\r\n    ISummaryHandle,\r\n    ISummaryTree,\r\n    ITree,\r\n    IVersion,\r\n} from \"@fluidframework/protocol-definitions\";\r\n\r\n/**\r\n * Implementation of {@link IDocumentStorageService} as part of the WPM Over OCS driver.\r\n */\r\nexport class WpmOverOcsDocumentStorageService implements IDocumentStorageService {\r\n    private notReached<T>(): T {\r\n        throw new Error(\"Not expected to be used in WPM Over OCS\");\r\n    }\r\n\r\n    /**\r\n     * {@inheritdoc}\r\n     */\r\n    public get repositoryUrl(): string {\r\n        return this.notReached();\r\n    }\r\n\r\n    /**\r\n     * {@inheritdoc}\r\n     */\r\n    public readonly policies = undefined; // Fluid requires we return something, we can't notReached() in a getter\r\n\r\n    /**\r\n     * {@inheritdoc}\r\n     */\r\n    public getSnapshotTree(_version?: IVersion): Promise<ISnapshotTree | null> {\r\n        // eslint-disable-next-line no-null/no-null -- this signature is from Fluid\r\n        return Promise.resolve(null);\r\n    }\r\n\r\n    /**\r\n     * {@inheritdoc}\r\n     */\r\n    public getVersions(_versionId: string | null, _count: number): Promise<IVersion[]> {\r\n        // Fluid requires we return something here, we can't notReached()\r\n        return Promise.resolve([]);\r\n    }\r\n\r\n    /**\r\n     * {@inheritdoc}\r\n     */\r\n    public write(_root: ITree, _parents: string[], _message: string, _ref: string): Promise<IVersion> {\r\n        return this.notReached();\r\n    }\r\n\r\n    /**\r\n     * {@inheritdoc}\r\n     */\r\n    public createBlob(_file: ArrayBufferLike): Promise<ICreateBlobResponse> {\r\n        return this.notReached();\r\n    }\r\n\r\n    /**\r\n     * {@inheritdoc}\r\n     */\r\n    public readBlob(_id: string): Promise<ArrayBufferLike> {\r\n        return this.notReached();\r\n    }\r\n\r\n    /**\r\n     * {@inheritdoc}\r\n     */\r\n    public uploadSummaryWithContext(_summary: ISummaryTree, _context: ISummaryContext): Promise<string> {\r\n        return this.notReached();\r\n    }\r\n\r\n    /**\r\n     * {@inheritdoc}\r\n     */\r\n    public downloadSummary(_handle: ISummaryHandle): Promise<ISummaryTree> {\r\n        return this.notReached();\r\n    }\r\n}\r\n","/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n */\r\nimport { IFluidCodeDetails } from \"@fluidframework/core-interfaces\";\r\nimport { Loader } from \"@fluidframework/container-loader\";\r\n\r\nimport { DocumentComponent } from \"../documentComponent\";\r\nimport { WordCodeLoader } from \"../loader\";\r\nimport { WordDocument } from \"../wordDocument\";\r\n\r\nimport { createFluidClient } from \"./conversionHelpers\";\r\nimport { WpmOverOcsDocumentService, WpmOverOcsDocumentServiceFactory } from \"./documentService\";\r\nimport { WpmOverOcsUrlResolver } from \"./urlResolver\";\r\nimport { IWpmOverOcsCallsFromNative, IWpmOverOcsCallsIntoNative } from \"./wpmTypes\";\r\n\r\nconst CODE_PROPOSAL: IFluidCodeDetails = {\r\n    config: {},\r\n    package: DocumentComponent.objectType,\r\n};\r\n\r\nexport interface IOcsRouteOptions {\r\n    /**\r\n     * The Fluid ID that represents the local joining client.\r\n     */\r\n    clientId: string;\r\n\r\n    /**\r\n     * The Fluid ID that represents the local joining user.\r\n     */\r\n    userId: string;\r\n\r\n    /**\r\n     * Handlers for routing calls into native code.\r\n     */\r\n    native: IWpmOverOcsCallsIntoNative;\r\n}\r\n\r\n/**\r\n * Creates a new, or loads an existing, WPM document (aka container) for use on WPM Over OCS.\r\n *\r\n * @param routeOptions - options for booting Fluid.\r\n * @param existing - whether to create or load.\r\n * @returns the {@link WordDocument} in the WPM container, and the object for the host-side\r\n *          contract of the WPM Over OCS driver.\r\n */\r\nasync function loadContainer(\r\n    routeOptions: IOcsRouteOptions,\r\n    existing: boolean,\r\n): Promise<[WordDocument, IWpmOverOcsCallsFromNative]> {\r\n    const client = createFluidClient(routeOptions.userId);\r\n    const user = {\r\n        id: routeOptions.userId,\r\n    };\r\n\r\n    const urlResolver = new WpmOverOcsUrlResolver();\r\n    const documentUrl = \"wpm://ocs/document.wpm\";\r\n    const resolvedUrlExpected = await urlResolver.resolve({ url: documentUrl });\r\n\r\n    const documentService = new WpmOverOcsDocumentService(\r\n        routeOptions.native,\r\n        resolvedUrlExpected,\r\n        routeOptions.clientId,\r\n        user,\r\n        existing,\r\n    );\r\n    const documentServiceFactory = new WpmOverOcsDocumentServiceFactory(documentService);\r\n\r\n    if (existing) {\r\n        // We're not bootstrapping so don't try to immediately stamp messages in the driver\r\n        documentService.stopImmediateAck();\r\n    }\r\n\r\n    const codeLoader = new WordCodeLoader(false /*enable summaries*/);\r\n    const loader = codeLoader.getLoader(urlResolver, documentServiceFactory, client);\r\n\r\n    // WPM Over OCS doesn't currently support summaries, so it seems we can't use createDetachedContainer().\r\n    // We get to do all the loading & setup.\r\n    const container = await loader.resolve({ url: documentUrl });\r\n\r\n    let acceptDocumentComponentLambda!: (value: DocumentComponent) => void;\r\n    let rejectDocumentComponentLambda!: (reason: unknown) => void;\r\n\r\n    const documentComponentPromise = new Promise<DocumentComponent>((accept, reject) => {\r\n        acceptDocumentComponentLambda = accept;\r\n        rejectDocumentComponentLambda = reject;\r\n    });\r\n\r\n    const attach = async (loader: Loader, url: string): Promise<void> => {\r\n        const response = await loader.request({ url });\r\n\r\n        if (response.status !== 200) {\r\n            // We queue up two attach() calls below - one better succeed since we're trying to connect to FluidTestHostComponent\r\n            return;\r\n        }\r\n\r\n        if (response.mimeType !== \"fluid/object\") {\r\n            throw new Error(\"Invalid response when retrieving DocumentComponent\");\r\n        }\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- we go on to validate the type right below here\r\n        const documentComponent = response.value;\r\n        if (!documentComponent || !(documentComponent instanceof DocumentComponent)) {\r\n            throw new Error(\"Invalid DocumentComponent\");\r\n        }\r\n\r\n        acceptDocumentComponentLambda(documentComponent);\r\n    };\r\n\r\n    container.on(\"contextChanged\", () => {\r\n        attach(loader, documentUrl).catch((e) => rejectDocumentComponentLambda(e));\r\n    });\r\n    await attach(loader, documentUrl);\r\n\r\n    if (!container.connected) {\r\n        await new Promise<void>((resolve) =>\r\n            container.on(\"connected\", () => {\r\n                resolve();\r\n            }),\r\n        );\r\n    }\r\n\r\n    const quorum = container.getQuorum();\r\n    if (!quorum.has(\"code\")) {\r\n        await quorum.propose(\"code\", CODE_PROPOSAL);\r\n    }\r\n\r\n    const documentComponent = await documentComponentPromise;\r\n    const wordDocument = new WordDocument(documentComponent, () => container.close());\r\n\r\n    return [wordDocument, documentService];\r\n}\r\n\r\n/**\r\n * Creates a new WPM document for use on WPM Over OCS.\r\n *\r\n * @param routeOptions - options for booting Fluid.\r\n * @returns the {@link WordDocument} in the WPM container, and the object for the host-side\r\n *          contract of the WPM Over OCS driver.\r\n */\r\nexport async function createWpmOverOcsDocument(\r\n    routeOptions: IOcsRouteOptions,\r\n): Promise<[WordDocument, IWpmOverOcsCallsFromNative]> {\r\n    return await loadContainer(routeOptions, false /*existing*/);\r\n}\r\n\r\n/**\r\n * Opens an existing WPM document on WPM Over OCS.\r\n *\r\n * @param routeOptions - options for booting Fluid.\r\n * @returns the {@link WordDocument} in the WPM container, and the object for the host-side\r\n *          contract of the WPM Over OCS driver.\r\n */\r\nexport async function openWpmOverOcsDocument(\r\n    routeOptions: IOcsRouteOptions,\r\n): Promise<[WordDocument, IWpmOverOcsCallsFromNative]> {\r\n    return await loadContainer(routeOptions, true /*existing*/);\r\n}\r\n","/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n */\r\nimport { IRequest } from \"@fluidframework/core-interfaces\";\r\nimport { IFluidResolvedUrl, IResolvedUrl, IUrlResolver } from \"@fluidframework/driver-definitions\";\r\n\r\n/*\r\n * Fluid expects some sort of document ID to be used, even if we don't really need one for WPM Over OCS.\r\n */\r\nexport const WPM_OVER_OCS_DOCUMENT_ID = \"document.wpm\";\r\n\r\n/*\r\n * Fluid expects some sort of tenant ID to be used, even if we don't really need one for WPM Over OCS.\r\n */\r\nexport const WPM_OVER_OCS_TENANT_ID = \"00000000-0000-0000-0000-000000000000\";\r\n\r\n/**\r\n * Protocol that when used in Fluid indicates that WPM Over OCS is in use.\r\n */\r\nexport const WPM_OVER_OCS_FLUID_URL_PROTOCOL = \"fluid-wpm://\";\r\n\r\n/**\r\n * Checks if a given URL is for use with WPM Over OCS.\r\n *\r\n * @param resolvedUrl - the URL to check.\r\n * @returns whether the provided URL was resolved by {@link WpmOverOcsUrlResolver}.\r\n */\r\nexport function isWpmOverOcsResolvedUrl(resolvedUrl: IResolvedUrl): boolean {\r\n    if (resolvedUrl.type !== \"fluid\") {\r\n        return false;\r\n    }\r\n\r\n    return (\r\n        resolvedUrl.endpoints[\"wpm-over-ocs\"] === \"yes\" &&\r\n        resolvedUrl.url === `fluid-wpm://ocs/${WPM_OVER_OCS_TENANT_ID}/${WPM_OVER_OCS_DOCUMENT_ID}`\r\n    );\r\n}\r\n\r\n/**\r\n * Implementation of {@link IUrlResolver} for WPM Over OCS.\r\n */\r\nexport class WpmOverOcsUrlResolver implements IUrlResolver {\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public resolve(request: IRequest): Promise<IResolvedUrl> {\r\n        if (request.url !== `wpm://ocs/${WPM_OVER_OCS_DOCUMENT_ID}`) {\r\n            throw new Error(\"Unsupported URL\");\r\n        }\r\n\r\n        const resolved: IFluidResolvedUrl = {\r\n            endpoints: {\r\n                \"wpm-over-ocs\": \"yes\",\r\n            },\r\n\r\n            // Fluid demands we provide some sort of token, even if we don't actually use it\r\n            tokens: { jwt: \"\" },\r\n            type: \"fluid\",\r\n\r\n            // Fluid itself expects a tenant ID in the URL (it doesn't care about the format), so just use a null GUID.\r\n            // Tenant-related stuff is handled in higher layers by the rest of the Office coauth/FIO stack.\r\n            url: `${WPM_OVER_OCS_FLUID_URL_PROTOCOL}ocs/${WPM_OVER_OCS_TENANT_ID}/${WPM_OVER_OCS_DOCUMENT_ID}`,\r\n        };\r\n\r\n        return Promise.resolve(resolved);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public getAbsoluteUrl(_resolvedUrl: IResolvedUrl, _relativeUrl: string): Promise<string> {\r\n        throw new Error(\"Not expected to be used in WPM Over OCS\");\r\n    }\r\n}\r\n","/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n */\r\nimport { SharedDirectory, SharedMap } from \"@fluidframework/map\";\r\nimport { SharedString } from \"@fluidframework/sequence\";\r\n\r\nimport { DocumentComponent } from \"./documentComponent\";\r\nimport { DocumentModel } from \"./documentModel\";\r\n\r\n/**\r\n * Wrapper over Prague collab document for Word\r\n */\r\nexport class WordDocument {\r\n    constructor(public readonly component: DocumentComponent, public readonly close: () => void) {}\r\n\r\n    public get model(): DocumentModel {\r\n        return this.component.documentModel;\r\n    }\r\n\r\n    /**\r\n     * Returns text of collab document\r\n     */\r\n    public getText(): SharedString {\r\n        return this.model.textString;\r\n    }\r\n\r\n    /**\r\n     * Returns presence of collab document\r\n     */\r\n    public getPresence(): SharedMap {\r\n        return this.model.presenceMap;\r\n    }\r\n\r\n    /**\r\n     * Returns snapshots of collab document\r\n     */\r\n    public getSnapshots(): SharedMap {\r\n        return this.model.snapshotsMap;\r\n    }\r\n\r\n    /**\r\n     * Returns listDefinitions of collab document\r\n     */\r\n    public getListDefinitions(): SharedMap {\r\n        return this.model.listDefinitionsMap;\r\n    }\r\n\r\n    /**\r\n     * Returns listOverrides of collab document\r\n     */\r\n    public getListOverrides(): SharedMap {\r\n        return this.model.listOverridesMap;\r\n    }\r\n\r\n    /**\r\n     * Returns oartData of collab document\r\n     */\r\n    public getOArt(): SharedDirectory {\r\n        return this.model.oartDirectory;\r\n    }\r\n}\r\n","/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n */\r\nimport { WordDocument } from \"./wordDocument\";\r\nimport { createWpmOverOcsDocument, IOcsRouteOptions, openWpmOverOcsDocument } from \"./ocs/ocsDocumentFactory\";\r\nimport {\r\n    createRouterliciousDocument,\r\n    openRouterliciousDocument,\r\n    IRouterliciousRouteOptions,\r\n} from \"./routerliciousDocumentFactory\";\r\nimport { IWpmOverOcsCallsFromNative } from \"./ocs/wpmTypes\";\r\n\r\nexport type { IOcsRouteOptions, IRouterliciousRouteOptions };\r\n/**\r\n * IwordApi\r\n *\r\n * The main API interface made available to Word from the JS code\r\n */\r\nexport interface IWordApi {\r\n    createDocumentOnRouterlicious: (\r\n        documentId: string,\r\n        routeOptions: IRouterliciousRouteOptions,\r\n    ) => Promise<WordDocument>;\r\n\r\n    openDocumentOnRouterlicious: (\r\n        documentId: string,\r\n        routeOptions: IRouterliciousRouteOptions,\r\n    ) => Promise<WordDocument>;\r\n\r\n    createDocumentOnOcs: (routeOptions: IOcsRouteOptions) => Promise<[WordDocument, IWpmOverOcsCallsFromNative]>;\r\n\r\n    openDocumentOnOcs: (routeOptions: IOcsRouteOptions) => Promise<[WordDocument, IWpmOverOcsCallsFromNative]>;\r\n}\r\n\r\nclass WordApi implements IWordApi {\r\n    public createDocumentOnRouterlicious(\r\n        documentId: string,\r\n        options: IRouterliciousRouteOptions,\r\n    ): Promise<WordDocument> {\r\n        if (process.env.ENABLE_ROUTERLICIOUS_SUPPORT) {\r\n            return createRouterliciousDocument(documentId, options);\r\n        }\r\n        throw new Error(\"Routerlicious is not supported\");\r\n    }\r\n\r\n    public openDocumentOnRouterlicious(documentId: string, options: IRouterliciousRouteOptions): Promise<WordDocument> {\r\n        if (process.env.ENABLE_ROUTERLICIOUS_SUPPORT) {\r\n            return openRouterliciousDocument(documentId, options);\r\n        }\r\n        throw new Error(\"Routerlicious is not supported\");\r\n    }\r\n\r\n    public createDocumentOnOcs(routeOptions: IOcsRouteOptions): Promise<[WordDocument, IWpmOverOcsCallsFromNative]> {\r\n        if (process.env.ENABLE_WPM_OVER_OCS_SUPPORT) {\r\n            return createWpmOverOcsDocument(routeOptions);\r\n        }\r\n        throw new Error(\"WPM Over OCS is not supported\");\r\n    }\r\n\r\n    public openDocumentOnOcs(routeOptions: IOcsRouteOptions): Promise<[WordDocument, IWpmOverOcsCallsFromNative]> {\r\n        if (process.env.ENABLE_WPM_OVER_OCS_SUPPORT) {\r\n            return openWpmOverOcsDocument(routeOptions);\r\n        }\r\n        throw new Error(\"WPM Over OCS is not supported\");\r\n    }\r\n}\r\n\r\n/**\r\n * makeWordApi\r\n *\r\n * @returns a new instance of the word api\r\n */\r\nexport function makeWordApi(): IWordApi {\r\n    return new WordApi();\r\n}\r\n","/*! https://mths.be/punycode v1.3.2 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","\"use strict\";\r\n\r\nexport class TextEncoder {\r\n    constructor() {}\r\n\r\n    encode(str) {\r\n        let length = str.length;\r\n        var retArr = new Uint8Array(length);\r\n        for (var ich = 0; ich < length; ich++) {\r\n            var ch = str.charCodeAt(ich);\r\n            if (ch < 0x7f) {\r\n                retArr[ich] = ch;\r\n            } else {\r\n                throw new Error(\"TextEncoder does not support characters > 0x7f\");\r\n            }\r\n        }\r\n        return retArr;\r\n    };\r\n}\r\n\r\nexport class TextDecoder {\r\n    constructor() {}\r\n\r\n    decode(input){\r\n        var str = \"\";\r\n        var len = input.length;\r\n\r\n        for (var i = 0; i < len; i++) {\r\n            if (input[i] <= 0x7f) {\r\n                str += String.fromCharCode(input[i]);\r\n            } else {\r\n                throw new Error(\"TextEncoder does not support characters > 0x7f\");\r\n            }\r\n        }\r\n\r\n        return str;\r\n    }\r\n}","\"use strict\";\r\n\r\nvar rnds8 = new Uint8Array(16);\r\nexport default function rng() {\r\n    rnds8[0] = Math.random() * 256;\r\n    rnds8[1] = Math.random() * 256;\r\n    rnds8[2] = Math.random() * 256;\r\n    rnds8[3] = Math.random() * 256;\r\n    rnds8[4] = Math.random() * 256;\r\n    rnds8[5] = Math.random() * 256;\r\n    rnds8[6] = Math.random() * 256;\r\n    rnds8[7] = Math.random() * 256;\r\n    rnds8[8] = Math.random() * 256;\r\n    rnds8[9] = Math.random() * 256;\r\n    rnds8[10] = Math.random() * 256;\r\n    rnds8[11] = Math.random() * 256;\r\n    rnds8[12] = Math.random() * 256;\r\n    rnds8[13] = Math.random() * 256;\r\n    rnds8[14] = Math.random() * 256;\r\n    rnds8[15] = Math.random() * 256;\r\n\r\n    return rnds8;\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n */\r\nimport { makeWordApi } from \"./wordapi\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- queueMicrotask isn't defined in V8 in native\r\nif (process.env.ENABLE_QUEUE_MICROTASK_POLYFILL && !globalThis.queueMicrotask) {\r\n    const fulfilledPromise = Promise.resolve();\r\n\r\n    // eslint-disable-next-line no-inner-declarations -- polyfill\r\n    function wdQueueMicrotaskPolyfill(fn: () => void): void {\r\n        // Promise completion callback will be queued to the microtask queue\r\n        fulfilledPromise.finally(fn);\r\n    }\r\n\r\n    globalThis.queueMicrotask = wdQueueMicrotaskPolyfill;\r\n}\r\n\r\n/**\r\n * init\r\n *\r\n * The entry point into this file\r\n */\r\nfunction init(): void {\r\n    onWordApiAvailable(makeWordApi());\r\n}\r\n\r\ninit();\r\n"],"sourceRoot":""}