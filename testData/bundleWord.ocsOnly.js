/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/@fluidframework/agent-scheduler/lib/scheduler.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@fluidframework/agent-scheduler/lib/scheduler.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AgentSchedulerFactory": () => (/* binding */ AgentSchedulerFactory)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @fluidframework/datastore */ "../../node_modules/@fluidframework/datastore/lib/dataStoreRuntime.js");
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @fluidframework/container-definitions */ "../../node_modules/@fluidframework/container-definitions/lib/runtime.js");
/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/map */ "../../node_modules/@fluidframework/map/lib/map.js");
/* harmony import */ var _fluidframework_register_collection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/register-collection */ "../../node_modules/@fluidframework/register-collection/lib/consensusRegisterCollection.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "../../node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-browser/v4.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */








// Note: making sure this ID is unique and does not collide with storage provided clientID
const UnattachedClientId = `${(0,uuid__WEBPACK_IMPORTED_MODULE_2__.default)()}_unattached`;
class AgentScheduler extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor(runtime, context, consensusRegisterCollection) {
        super();
        this.runtime = runtime;
        this.context = context;
        this.consensusRegisterCollection = consensusRegisterCollection;
        // Set of tasks registered by this client.
        // Has no relationship with lists below.
        // The only requirement here - a task can be registered by a client only once.
        // Other clients can pick these tasks.
        this.registeredTasks = new Set();
        // List of all tasks client is capable of running (essentially expressed desire to run)
        // Client will proactively attempt to pick them up these tasks if they are not assigned to other clients.
        // This is a strict superset of tasks running in the client.
        this.locallyRunnableTasks = new Map();
        // Set of registered tasks client is currently running.
        // It's subset of this.locallyRunnableTasks
        this.runningTasks = new Set();
    }
    static async load(runtime, context) {
        let root;
        let consensusRegisterCollection;
        if (!runtime.existing) {
            root = _fluidframework_map__WEBPACK_IMPORTED_MODULE_3__.SharedMap.create(runtime, "root");
            root.bindToContext();
            consensusRegisterCollection = _fluidframework_register_collection__WEBPACK_IMPORTED_MODULE_4__.ConsensusRegisterCollection.create(runtime);
            consensusRegisterCollection.bindToContext();
            root.set("scheduler", consensusRegisterCollection.handle);
        }
        else {
            root = await runtime.getChannel("root");
            const handle = await root.wait("scheduler");
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(handle !== undefined, 0x116 /* "Missing handle on scheduler load" */);
            consensusRegisterCollection = await handle.get();
        }
        const agentScheduler = new AgentScheduler(runtime, context, consensusRegisterCollection);
        agentScheduler.initialize();
        return agentScheduler;
    }
    get IAgentScheduler() { return this; }
    get clientId() {
        if (this.runtime.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_6__.AttachState.Detached) {
            return UnattachedClientId;
        }
        const clientId = this.runtime.clientId;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!!clientId, 0x117 /* "Trying to get missing clientId!" */);
        return clientId;
    }
    async register(...taskUrls) {
        for (const taskUrl of taskUrls) {
            if (this.registeredTasks.has(taskUrl)) {
                throw new Error(`${taskUrl} is already registered`);
            }
        }
        const unregisteredTasks = [];
        for (const taskUrl of taskUrls) {
            this.registeredTasks.add(taskUrl);
            // Only register for a new task.
            const currentClient = this.getTaskClientId(taskUrl);
            if (currentClient === undefined) {
                unregisteredTasks.push(taskUrl);
            }
        }
        return this.registerCore(unregisteredTasks);
    }
    async pick(taskId, worker) {
        if (this.locallyRunnableTasks.has(taskId)) {
            throw new Error(`${taskId} is already attempted`);
        }
        this.locallyRunnableTasks.set(taskId, worker);
        // Note: we are not checking for this.context.deltaManager.clientDetails.capabilities.interactive
        // in isActive(). This check is done by users of this class - containerRuntime.ts (for "leader") and
        // TaskManager. In the future, as new usage shows up, we may need to reconsider that.
        // I'm adding assert here to catch that case and make decision on which way we go - push requirements
        // to consumers to make a choice, or centrally make this call here.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(this.context.deltaManager.clientDetails.capabilities.interactive, 0x118 /* "Bad client interactive check" */);
        // Check the current status and express interest if it's a new one (undefined) or currently unpicked (null).
        if (this.isActive()) {
            const currentClient = this.getTaskClientId(taskId);
            if (currentClient === undefined || currentClient === null) {
                debug__WEBPACK_IMPORTED_MODULE_1___default()(`Requesting ${taskId}`);
                await this.writeCore(taskId, this.clientId);
            }
        }
    }
    async release(...taskUrls) {
        const active = this.isActive();
        for (const taskUrl of taskUrls) {
            if (!this.locallyRunnableTasks.has(taskUrl)) {
                throw new Error(`${taskUrl} was never registered`);
            }
            // Note - the assumption is - we are connected.
            // If not - all tasks should have been dropped already on disconnect / attachment
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(active, 0x119 /* "This agent became inactive while releasing" */);
            if (this.getTaskClientId(taskUrl) !== this.clientId) {
                throw new Error(`${taskUrl} was never picked`);
            }
        }
        return this.releaseCore([...taskUrls]);
    }
    pickedTasks() {
        return Array.from(this.runningTasks.values());
    }
    async registerCore(taskUrls) {
        if (taskUrls.length > 0) {
            const registersP = [];
            for (const taskUrl of taskUrls) {
                debug__WEBPACK_IMPORTED_MODULE_1___default()(`Registering ${taskUrl}`);
                registersP.push(this.writeCore(taskUrl, null));
            }
            await Promise.all(registersP);
            // The registers should have up to date results now. Check the status.
            for (const taskUrl of taskUrls) {
                const taskStatus = this.getTaskClientId(taskUrl);
                // Task should be either registered (null) or picked up.
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(taskStatus !== undefined, 0x11a /* `Unsuccessful registration` */);
                if (taskStatus === null) {
                    debug__WEBPACK_IMPORTED_MODULE_1___default()(`Registered ${taskUrl}`);
                }
                else {
                    debug__WEBPACK_IMPORTED_MODULE_1___default()(`${taskStatus} is running ${taskUrl}`);
                }
            }
        }
    }
    async releaseCore(taskUrls) {
        if (taskUrls.length > 0) {
            const releasesP = [];
            for (const taskUrl of taskUrls) {
                debug__WEBPACK_IMPORTED_MODULE_1___default()(`Releasing ${taskUrl}`);
                // Remove from local map so that it can be picked later.
                this.locallyRunnableTasks.delete(taskUrl);
                releasesP.push(this.writeCore(taskUrl, null));
            }
            await Promise.all(releasesP);
        }
    }
    async clearTasks(taskUrls) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(this.isActive(), 0x11b /* "Trying to clear tasks on inactive agent" */);
        const clearP = [];
        for (const taskUrl of taskUrls) {
            debug__WEBPACK_IMPORTED_MODULE_1___default()(`Clearing ${taskUrl}`);
            clearP.push(this.writeCore(taskUrl, null));
        }
        await Promise.all(clearP);
    }
    getTaskClientId(url) {
        return this.consensusRegisterCollection.read(url);
    }
    async writeCore(key, clientId) {
        await this.consensusRegisterCollection.write(key, clientId);
    }
    initialize() {
        const quorum = this.runtime.getQuorum();
        // A client left the quorum. Iterate and clear tasks held by that client.
        // Ideally a leader should do this cleanup. But it's complicated when a leader itself leaves.
        // Probably okay for now to have every client try to do this.
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        quorum.on("removeMember", async (clientId) => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(this.runtime.objectsRoutingContext.isAttached, 0x11c /* "Detached object routing context" */);
            // Cleanup only if connected. If not, cleanup will happen in initializeCore() that runs on connection.
            if (this.isActive()) {
                const leftTasks = [];
                for (const taskUrl of this.consensusRegisterCollection.keys()) {
                    if (this.getTaskClientId(taskUrl) === clientId) {
                        leftTasks.push(taskUrl);
                    }
                }
                await this.clearTasks(leftTasks);
            }
        });
        // Listeners for new/released tasks. All clients will try to grab at the same time.
        // May be we want a randomized timer (Something like raft) to reduce chattiness?
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        this.consensusRegisterCollection.on("atomicChanged", async (key, currentClient) => {
            // Check if this client was chosen.
            if (this.isActive() && currentClient === this.clientId) {
                this.onNewTaskAssigned(key);
            }
            else {
                await this.onTaskReassigned(key, currentClient);
            }
        });
        if (this.isActive()) {
            this.initializeCore();
        }
        this.runtime.on("connected", () => {
            if (this.isActive()) {
                this.initializeCore();
            }
        });
        if (this.runtime.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_6__.AttachState.Detached) {
            this.runtime.waitAttached().then(() => {
                this.clearRunningTasks();
            }).catch((error) => {
                this.sendErrorEvent("AgentScheduler_clearRunningTasks", error);
            });
        }
        this.runtime.on("disconnected", () => {
            if (this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_6__.AttachState.Detached) {
                this.clearRunningTasks();
            }
        });
    }
    onNewTaskAssigned(key) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!this.runningTasks.has(key), 0x11d /* "task is already running" */);
        this.runningTasks.add(key);
        const worker = this.locallyRunnableTasks.get(key);
        if (worker === undefined) {
            this.sendErrorEvent("AgentScheduler_UnwantedChange", undefined, key);
        }
        else {
            this.emit("picked", key);
            worker().catch((error) => {
                this.sendErrorEvent("AgentScheduler_FailedWork", error, key);
            });
        }
    }
    async onTaskReassigned(key, currentClient) {
        if (this.runningTasks.has(key)) {
            this.runningTasks.delete(key);
            this.emit("released", key);
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(currentClient !== undefined, 0x11e /* "client is undefined" */);
        if (this.isActive()) {
            // attempt to pick up task if we are connected.
            // If not, initializeCore() will do it when connected
            if (currentClient === null) {
                if (this.locallyRunnableTasks.has(key)) {
                    debug__WEBPACK_IMPORTED_MODULE_1___default()(`Requesting ${key}`);
                    await this.writeCore(key, this.clientId);
                }
            }
            // Check if the op came from dropped client
            // This could happen when "old" ops are submitted on reconnection.
            // They carry "old" ref seq number, but if write is not contested, it will get accepted
            else if (this.runtime.getQuorum().getMember(currentClient) === undefined) {
                await this.writeCore(key, null);
            }
        }
    }
    isActive() {
        // Scheduler should be active in detached container.
        if (this.runtime.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_6__.AttachState.Detached) {
            return true;
        }
        if (!this.runtime.connected) {
            return false;
        }
        // Note: we are not checking for this.context.deltaManager.clientDetails.capabilities.interactive
        // here. This is done by users of this class - containerRuntime.ts (for "leader") and TaskManager.
        // In the future, as new usage shows up, we may need to reconsider that.
        // I'm adding assert in pick() to catch that case and make decision on which way we go - push requirements
        // to consumers to make a choice, or centrally make this call here.
        return this.context.deltaManager.active;
    }
    initializeCore() {
        // Nobody released the tasks held by last client in previous session.
        // Check to see if this client needs to do this.
        const clearCandidates = [];
        const tasks = [];
        for (const [taskUrl] of this.locallyRunnableTasks) {
            if (!this.getTaskClientId(taskUrl)) {
                debug__WEBPACK_IMPORTED_MODULE_1___default()(`Requesting ${taskUrl}`);
                tasks.push(this.writeCore(taskUrl, this.clientId));
            }
        }
        for (const taskUrl of this.consensusRegisterCollection.keys()) {
            const currentClient = this.getTaskClientId(taskUrl);
            if (currentClient && this.runtime.getQuorum().getMember(currentClient) === undefined) {
                clearCandidates.push(taskUrl);
            }
        }
        tasks.push(this.clearTasks(clearCandidates));
        Promise.all(tasks).catch((error) => {
            this.sendErrorEvent("AgentScheduler_InitError", error);
        });
    }
    clearRunningTasks() {
        const tasks = this.runningTasks;
        this.runningTasks = new Set();
        if (this.isActive()) {
            // Clear all tasks with UnattachedClientId (if was unattached) and reapply for tasks with new clientId
            // If we are simply disconnected, then proper cleanup will be done on connection.
            this.initializeCore();
        }
        for (const task of tasks) {
            this.emit("lost", task);
        }
    }
    sendErrorEvent(eventName, error, key) {
        this.runtime.logger.sendErrorEvent({ eventName, key }, error);
    }
}
class AgentSchedulerRuntime extends _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_7__.FluidDataStoreRuntime {
    constructor(dataStoreContext, sharedObjectRegistry) {
        super(dataStoreContext, sharedObjectRegistry);
        this.agentSchedulerP = AgentScheduler.load(this, dataStoreContext);
    }
    async request(request) {
        const response = await super.request(request);
        if (response.status === 404) {
            if (request.url === "" || request.url === "/") {
                const agentScheduler = await this.agentSchedulerP;
                return { status: 200, mimeType: "fluid/object", value: agentScheduler };
            }
        }
        return response;
    }
}
class AgentSchedulerFactory {
    constructor() {
        this.type = AgentSchedulerFactory.type;
    }
    get IFluidDataStoreFactory() { return this; }
    static get registryEntry() {
        return [this.type, Promise.resolve(new AgentSchedulerFactory())];
    }
    async instantiateDataStore(context) {
        const mapFactory = _fluidframework_map__WEBPACK_IMPORTED_MODULE_3__.SharedMap.getFactory();
        const consensusRegisterCollectionFactory = _fluidframework_register_collection__WEBPACK_IMPORTED_MODULE_4__.ConsensusRegisterCollection.getFactory();
        const dataTypes = new Map();
        dataTypes.set(mapFactory.type, mapFactory);
        dataTypes.set(consensusRegisterCollectionFactory.type, consensusRegisterCollectionFactory);
        return new AgentSchedulerRuntime(context, dataTypes);
    }
}
AgentSchedulerFactory.type = "_scheduler";
//# sourceMappingURL=scheduler.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/aqueduct/lib/container-runtime-factories/baseContainerRuntimeFactory.js":
/*!******************************************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/aqueduct/lib/container-runtime-factories/baseContainerRuntimeFactory.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseContainerRuntimeFactory": () => (/* binding */ BaseContainerRuntimeFactory)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/container-runtime */ "../../node_modules/@fluidframework/container-runtime/lib/dataStoreRegistry.js");
/* harmony import */ var _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/container-runtime */ "../../node_modules/@fluidframework/container-runtime/lib/containerRuntime.js");
/* harmony import */ var _fluidframework_container_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/container-runtime-definitions */ "../../node_modules/@fluidframework/container-runtime-definitions/dist/index.js");
/* harmony import */ var _fluidframework_container_runtime_definitions__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_container_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/request-handler */ "../../node_modules/@fluidframework/request-handler/lib/runtimeRequestHandlerBuilder.js");
/* harmony import */ var _fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/request-handler */ "../../node_modules/@fluidframework/request-handler/lib/requestHandlers.js");
/* harmony import */ var _fluidframework_synthesize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/synthesize */ "../../node_modules/@fluidframework/synthesize/lib/dependencyContainer.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */




/**
 * BaseContainerRuntimeFactory produces container runtimes with a given data store and service registry, as well as
 * given request handlers.  It can be subclassed to implement a first-time initialization procedure for the containers
 * it creates.
 */
class BaseContainerRuntimeFactory {
    /**
     * @param registryEntries - The data store registry for containers produced
     * @param serviceRegistry - The service registry for containers produced
     * @param requestHandlers - Request handlers for containers produced
     * @param runtimeOptions - The runtime options passed to the ContainerRuntime when instantiating it
     */
    constructor(registryEntries, providerEntries = [], requestHandlers = [], runtimeOptions) {
        this.registryEntries = registryEntries;
        this.providerEntries = providerEntries;
        this.requestHandlers = requestHandlers;
        this.runtimeOptions = runtimeOptions;
        this.registry = new _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_0__.FluidDataStoreRegistry(registryEntries);
    }
    get IFluidDataStoreRegistry() { return this.registry; }
    get IRuntimeFactory() { return this; }
    /**
     * {@inheritDoc @fluidframework/container-definitions#IRuntimeFactory.instantiateRuntime}
     */
    async instantiateRuntime(context) {
        const parentDependencyContainer = context.scope.IFluidDependencySynthesizer;
        const dc = new _fluidframework_synthesize__WEBPACK_IMPORTED_MODULE_1__.DependencyContainer(parentDependencyContainer);
        for (const entry of Array.from(this.providerEntries)) {
            dc.register(entry.type, entry.provider);
        }
        // Create a scope object that passes through everything except for IFluidDependencySynthesizer
        // which we will replace with the new one we just created.
        const scope = context.scope;
        scope.IFluidDependencySynthesizer = dc;
        const runtime = await _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_2__.ContainerRuntime.load(context, this.registryEntries, (0,_fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_3__.buildRuntimeRequestHandler)(...this.requestHandlers, _fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_4__.innerRequestHandler), this.runtimeOptions, scope);
        // we register the runtime so developers of providers can use it in the factory pattern.
        dc.register(_fluidframework_container_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__.IContainerRuntime, runtime);
        if (!runtime.existing) {
            // If it's the first time through.
            await this.containerInitializingFirstTime(runtime);
        }
        // This always gets called at the end of initialize on first time or from existing.
        await this.containerHasInitialized(runtime);
        return runtime;
    }
    /**
     * Subclasses may override containerInitializingFirstTime to perform any setup steps at the time the container
     * is created. This likely includes creating any initial data stores that are expected to be there at the outset.
     * @param runtime - The container runtime for the container being initialized
     */
    async containerInitializingFirstTime(runtime) { }
    /**
     * Subclasses may override containerHasInitialized to perform any steps after the container has initialized.
     * This likely includes loading any data stores that are expected to be there at the outset.
     * @param runtime - The container runtime for the container being initialized
     */
    async containerHasInitialized(runtime) { }
}
//# sourceMappingURL=baseContainerRuntimeFactory.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/aqueduct/lib/container-runtime-factories/containerRuntimeFactoryWithDefaultDataStore.js":
/*!**********************************************************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/aqueduct/lib/container-runtime-factories/containerRuntimeFactoryWithDefaultDataStore.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContainerRuntimeFactoryWithDefaultDataStore": () => (/* binding */ ContainerRuntimeFactoryWithDefaultDataStore)
/* harmony export */ });
/* harmony import */ var _fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/request-handler */ "../../node_modules/@fluidframework/request-handler/lib/requestHandlers.js");
/* harmony import */ var _request_handlers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../request-handlers */ "../../node_modules/@fluidframework/aqueduct/lib/request-handlers/requestHandlers.js");
/* harmony import */ var _baseContainerRuntimeFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./baseContainerRuntimeFactory */ "../../node_modules/@fluidframework/aqueduct/lib/container-runtime-factories/baseContainerRuntimeFactory.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */



const defaultDataStoreId = "default";
/**
 * A ContainerRuntimeFactory that initializes Containers with a single default data store, which can be requested from
 * the container with an empty URL.
 *
 * This factory should be exposed as fluidExport off the entry point to your module.
 */
class ContainerRuntimeFactoryWithDefaultDataStore extends _baseContainerRuntimeFactory__WEBPACK_IMPORTED_MODULE_0__.BaseContainerRuntimeFactory {
    constructor(defaultFactory, registryEntries, providerEntries = [], requestHandlers = [], runtimeOptions) {
        super(registryEntries, providerEntries, [
            ...requestHandlers,
            (0,_request_handlers__WEBPACK_IMPORTED_MODULE_1__.defaultRouteRequestHandler)(defaultDataStoreId),
            _fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_2__.innerRequestHandler,
        ], runtimeOptions);
        this.defaultFactory = defaultFactory;
    }
    /**
     * {@inheritDoc BaseContainerRuntimeFactory.containerInitializingFirstTime}
     */
    async containerInitializingFirstTime(runtime) {
        await runtime.createRootDataStore(this.defaultFactory.type, defaultDataStoreId);
    }
}
ContainerRuntimeFactoryWithDefaultDataStore.defaultDataStoreId = defaultDataStoreId;
//# sourceMappingURL=containerRuntimeFactoryWithDefaultDataStore.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/aqueduct/lib/container-services/containerServices.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/aqueduct/lib/container-services/containerServices.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "serviceRoutePathRoot": () => (/* binding */ serviceRoutePathRoot)
/* harmony export */ });
/* unused harmony exports BaseContainerService, generateContainerServicesRequestHandler */
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHelpers.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

// TODO: should this just be "s"?
const serviceRoutePathRoot = "_services";
/**
 * This class is a simple starter class for building a Container Service. It simply provides routing
 */
class BaseContainerService {
    constructor(runtime) {
        this.runtime = runtime;
    }
    get IFluidRouter() { return this; }
    async request(request) {
        return {
            status: 200,
            mimeType: "fluid/object",
            value: this,
        };
    }
}
/**
 * ContainerService Factory that will only create one instance of the service for the Container.
 */
class SingletonContainerServiceFactory {
    constructor(serviceFn) {
        this.serviceFn = serviceFn;
    }
    async getService(runtime) {
        if (!this.service) {
            this.service = this.serviceFn(runtime);
        }
        return this.service;
    }
}
/**
 * Given a collection of IContainerServices will produce a RequestHandler for them all
 * @param serviceRegistry - Collection of Container Services
 */
const generateContainerServicesRequestHandler = (serviceRegistry) => {
    const factories = new Map();
    new Map(serviceRegistry).forEach((fn, id) => {
        factories.set(id, new SingletonContainerServiceFactory(fn));
    });
    return async (request, runtime) => {
        if (request.pathParts[0] !== serviceRoutePathRoot) {
            // If the request is not for a service we return undefined so the next handler can use it
            return undefined;
        }
        if (request.pathParts.length < 2) {
            // If there is not service to route to then return a failure
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.createResponseError)(400, "request did not specify a service to route to", request);
        }
        const factory = factories.get(request.pathParts[1]);
        if (!factory) {
            // If we can't find a registry entry then return
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.create404Response)(request);
        }
        const service = await factory.getService(runtime);
        const router = service.IFluidRouter;
        const subRequest = request.createSubRequest(2);
        if (router) {
            return router.request(subRequest);
        }
        if (!request.isLeaf(2)) {
            // If there is not terminating route but a sub-route was requested then we will fail.
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.createResponseError)(400, "request sub-url for service that doesn't support routing", request);
        }
        // Otherwise we will just return the service
        return {
            status: 200,
            mimeType: "fluid/object",
            value: service,
        };
    };
};
//# sourceMappingURL=containerServices.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/aqueduct/lib/data-object-factories/dataObjectFactory.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/aqueduct/lib/data-object-factories/dataObjectFactory.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataObjectFactory": () => (/* binding */ DataObjectFactory)
/* harmony export */ });
/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/map */ "../../node_modules/@fluidframework/map/lib/directory.js");
/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/map */ "../../node_modules/@fluidframework/map/lib/map.js");
/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/datastore */ "../../node_modules/@fluidframework/datastore/lib/dataStoreRuntime.js");
/* harmony import */ var _pureDataObjectFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pureDataObjectFactory */ "../../node_modules/@fluidframework/aqueduct/lib/data-object-factories/pureDataObjectFactory.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * DataObjectFactory is the IFluidDataStoreFactory for use with DataObjects.
 * It facilitates DataObject's features (such as its shared directory) by
 * ensuring relevant shared objects etc are available to the factory.
 *
 * Generics:
 * O - represents a type that will define optional providers that will be injected
 * S - the initial state type that the produced data object may take during creation
 */
class DataObjectFactory extends _pureDataObjectFactory__WEBPACK_IMPORTED_MODULE_0__.PureDataObjectFactory {
    constructor(type, ctor, sharedObjects = [], optionalProviders, registryEntries, runtimeFactory = _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_1__.FluidDataStoreRuntime) {
        const mergedObjects = [...sharedObjects];
        if (!sharedObjects.find((factory) => factory.type === _fluidframework_map__WEBPACK_IMPORTED_MODULE_2__.DirectoryFactory.Type)) {
            // User did not register for directory
            mergedObjects.push(_fluidframework_map__WEBPACK_IMPORTED_MODULE_2__.SharedDirectory.getFactory());
        }
        // TODO: Remove SharedMap factory when compatibility with SharedMap DataObject is no longer needed in 0.10
        if (!sharedObjects.find((factory) => factory.type === _fluidframework_map__WEBPACK_IMPORTED_MODULE_3__.MapFactory.Type)) {
            // User did not register for map
            mergedObjects.push(_fluidframework_map__WEBPACK_IMPORTED_MODULE_3__.SharedMap.getFactory());
        }
        super(type, ctor, mergedObjects, optionalProviders, registryEntries, runtimeFactory);
    }
}
//# sourceMappingURL=dataObjectFactory.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/aqueduct/lib/data-object-factories/pureDataObjectFactory.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/aqueduct/lib/data-object-factories/pureDataObjectFactory.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PureDataObjectFactory": () => (/* binding */ PureDataObjectFactory)
/* harmony export */ });
/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/datastore */ "../../node_modules/@fluidframework/datastore/lib/dataStoreRuntime.js");
/* harmony import */ var _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/container-runtime */ "../../node_modules/@fluidframework/container-runtime/lib/dataStoreRegistry.js");
/* harmony import */ var _fluidframework_synthesize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/synthesize */ "../../node_modules/@fluidframework/synthesize/lib/dependencyContainer.js");
/* harmony import */ var _data_objects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data-objects */ "../../node_modules/@fluidframework/aqueduct/lib/data-objects/pureDataObject.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */




/**
 * Proxy over PureDataObject
 * Does delayed creation & initialization of PureDataObject
*/
async function createDataObject(ctor, context, sharedObjectRegistry, optionalProviders, runtimeClassArg, initProps) {
    // base
    let runtimeClass = runtimeClassArg;
    // request mixin in
    runtimeClass = (0,_fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__.mixinRequestHandler)(async (request, runtimeArg) => (await _data_objects__WEBPACK_IMPORTED_MODULE_1__.PureDataObject.getDataObject(runtimeArg)).request(request), runtimeClass);
    // Create a new runtime for our data store
    // The runtime is what Fluid uses to create DDS' and route to your data store
    const runtime = new runtimeClass(context, sharedObjectRegistry);
    // Create object right away.
    // This allows object to register various callbacks with runtime before runtime
    // becomes globally available. But it's not full initialization - constructor can't
    // access DDSs or other services of runtime as objects are not fully initialized.
    // In order to use object, we need to go through full initialization by calling finishInitialization().
    const dependencyContainer = new _fluidframework_synthesize__WEBPACK_IMPORTED_MODULE_2__.DependencyContainer(context.scope.IFluidDependencySynthesizer);
    const providers = dependencyContainer.synthesize(optionalProviders, {});
    const instance = new ctor({ runtime, context, providers, initProps });
    // if it's a newly created object, we need to wait for it to finish initialization
    // as that results in creation of DDSs, before it gets attached, providing atomic
    // guarantee of creation.
    // WARNING: we can't do the same (yet) for already existing PureDataObject!
    // This will result in deadlock, as it tries to resolve internal handles, but any
    // handle resolution goes through root (container runtime), which can't route it back
    // to this data store, as it's still not initialized and not known to container runtime yet.
    // In the future, we should address it by using relative paths for handles and be able to resolve
    // local DDSs while data store is not fully initialized.
    if (!runtime.existing) {
        await instance.finishInitialization();
    }
    return { instance, runtime };
}
/**
 * PureDataObjectFactory is a barebones IFluidDataStoreFactory for use with PureDataObject.
 * Consumers should typically use DataObjectFactory instead unless creating
 * another base data store factory.
 *
 * Generics:
 * TObj - DataObject (concrete type)
 * O - represents a type that will define optional providers that will be injected
 * S - the initial state type that the produced data store may take during creation
 * E - represents events that will be available in the EventForwarder
 */
class PureDataObjectFactory {
    constructor(type, ctor, sharedObjects, optionalProviders, registryEntries, runtimeClass = _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__.FluidDataStoreRuntime) {
        this.type = type;
        this.ctor = ctor;
        this.optionalProviders = optionalProviders;
        this.runtimeClass = runtimeClass;
        if (this.type === "") {
            throw new Error("undefined type member");
        }
        if (registryEntries !== undefined) {
            this.registry = new _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_3__.FluidDataStoreRegistry(registryEntries);
        }
        this.sharedObjectRegistry = new Map(sharedObjects.map((ext) => [ext.type, ext]));
    }
    get IFluidDataStoreFactory() { return this; }
    get IFluidDataStoreRegistry() {
        return this.registry;
    }
    /**
     * Convenience helper to get the data store's/factory's data store registry entry.
     * The return type hides the factory's generics, easing grouping of registry
     * entries that differ only in this way into the same array.
     * @returns The NamedFluidDataStoreRegistryEntry
     */
    get registryEntry() {
        return [this.type, Promise.resolve(this)];
    }
    /**
     * This is where we do data store setup.
     *
     * @param context - data store context used to load a data store runtime
     */
    async instantiateDataStore(context) {
        const { runtime } = await createDataObject(this.ctor, context, this.sharedObjectRegistry, this.optionalProviders, this.runtimeClass);
        return runtime;
    }
    /**
     * Creates a new instance of the object. Uses parent context's registry to build package path to this factory.
     * In other words, registry of context passed in has to contain this factory, with the name that matches
     * this factory's type.
     * It is intended to be used by data store objects that create sub-objects.
     * @param context - The context being used to create the runtime
     * (the created object will have its own new context created as well)
     * @param initialState - The initial state to provide to the created data store.
     * @returns an object created by this factory. Data store and objects created are not attached to container.
     * They get attached only when a handle to one of them is attached to already attached objects.
     */
    async createChildInstance(parentContext, initialState) {
        return this.createNonRootInstanceCore(parentContext.containerRuntime, [...parentContext.packagePath, this.type], initialState);
    }
    /**
     * Creates a new instance of the object. Uses peer context's registry and its package path to identify this factory.
     * In other words, registry of context passed in has to have this factory.
     * Intended to be used by data store objects that need to create peers (similar) instances of existing objects.
     * @param context - The component context being used to create the object
     * (the created object will have its own new context created as well)
     * @param initialState - The initial state to provide to the created component.
     * @returns an object created by this factory. Data store and objects created are not attached to container.
     * They get attached only when a handle to one of them is attached to already attached objects.
     */
    async createPeerInstance(peerContext, initialState) {
        return this.createNonRootInstanceCore(peerContext.containerRuntime, peerContext.packagePath, initialState);
    }
    /**
     * Creates a new instance of the object. Uses container's registry to find this factory.
     * It's expected that only container owners would use this functionality, as only such developers
     * have knowledge of entries in container registry.
     * The name in this registry for such record should match type of this factory.
     * @param runtime - container runtime. It's registry is used to create an object.
     * @param initialState - The initial state to provide to the created component.
     * @returns an object created by this factory. Data store and objects created are not attached to container.
     * They get attached only when a handle to one of them is attached to already attached objects.
     */
    async createInstance(runtime, initialState) {
        return this.createNonRootInstanceCore(runtime, [this.type], initialState);
    }
    /**
     * Creates a new root instance of the object. Uses container's registry to find this factory.
     * It's expected that only container owners would use this functionality, as only such developers
     * have knowledge of entries in container registry.
     * The name in this registry for such record should match type of this factory.
     * @param runtime - container runtime. It's registry is used to create an object.
     * @param initialState - The initial state to provide to the created component.
     * @returns an object created by this factory. Data store and objects created are not attached to container.
     * They get attached only when a handle to one of them is attached to already attached objects.
     */
    async createRootInstance(rootDataStoreId, runtime, initialState) {
        const context = runtime.createDetachedRootDataStore([this.type], rootDataStoreId);
        return this.createInstanceCore(context, initialState);
    }
    async createNonRootInstanceCore(containerRuntime, packagePath, initialState) {
        const context = containerRuntime.createDetachedDataStore(packagePath);
        return this.createInstanceCore(context, initialState);
    }
    async createInstanceCore(context, initialState) {
        const { instance, runtime } = await createDataObject(this.ctor, context, this.sharedObjectRegistry, this.optionalProviders, this.runtimeClass, initialState);
        await context.attachRuntime(this, runtime);
        return instance;
    }
}
//# sourceMappingURL=pureDataObjectFactory.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/aqueduct/lib/data-objects/dataObject.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/aqueduct/lib/data-objects/dataObject.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataObject": () => (/* binding */ DataObject)
/* harmony export */ });
/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/map */ "../../node_modules/@fluidframework/map/lib/directory.js");
/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/map */ "../../node_modules/@fluidframework/map/lib/map.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/requestParser.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHelpers.js");
/* harmony import */ var _pureDataObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pureDataObject */ "../../node_modules/@fluidframework/aqueduct/lib/data-objects/pureDataObject.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * DataObject is a base data store that is primed with a root directory. It
 * ensures that it is created and ready before you can access it.
 *
 * Having a single root directory allows for easier development. Instead of creating
 * and registering channels with the runtime any new DDS that is set on the root
 * will automatically be registered.
 *
 * Generics:
 * O - represents a type that will define optional providers that will be injected
 * S - the initial state type that the produced data store may take during creation
 * E - represents events that will be available in the EventForwarder
 */
// eslint-disable-next-line @typescript-eslint/ban-types
class DataObject extends _pureDataObject__WEBPACK_IMPORTED_MODULE_0__.PureDataObject {
    constructor() {
        super(...arguments);
        this.rootDirectoryId = "root";
    }
    async request(request) {
        const requestParser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__.RequestParser.create(request);
        const itemId = requestParser.pathParts[0];
        if (itemId === "bigBlobs") {
            const value = this.root.get(requestParser.pathParts.join("/"));
            if (value === undefined) {
                return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.create404Response)(requestParser);
            }
            return { mimeType: "fluid/object", status: 200, value };
        }
        else {
            return super.request(requestParser);
        }
    }
    /**
     * The root directory will either be ready or will return an error. If an error is thrown
     * the root has not been correctly created/set.
     */
    get root() {
        if (!this.internalRoot) {
            throw new Error(this.getUninitializedErrorString(`root`));
        }
        return this.internalRoot;
    }
    /**
     * Initializes internal objects and calls initialization overrides.
     * Caller is responsible for ensuring this is only invoked once.
     */
    async initializeInternal() {
        if (!this.runtime.existing) {
            // Create a root directory and register it before calling initializingFirstTime
            this.internalRoot = _fluidframework_map__WEBPACK_IMPORTED_MODULE_3__.SharedDirectory.create(this.runtime, this.rootDirectoryId);
            this.internalRoot.bindToContext();
        }
        else {
            // data store has a root directory so we just need to set it before calling initializingFromExisting
            this.internalRoot = await this.runtime.getChannel(this.rootDirectoryId);
            // This will actually be an ISharedMap if the channel was previously created by the older version of
            // DataObject which used a SharedMap.  Since SharedMap and SharedDirectory are compatible unless
            // SharedDirectory-only commands are used on SharedMap, this will mostly just work for compatibility.
            if (this.internalRoot.attributes.type === _fluidframework_map__WEBPACK_IMPORTED_MODULE_4__.MapFactory.Type) {
                this.runtime.logger.send({
                    category: "generic",
                    eventName: "MapDataObject",
                    message: "Legacy document, SharedMap is masquerading as SharedDirectory in DataObject",
                });
            }
        }
        await super.initializeInternal();
    }
    getUninitializedErrorString(item) {
        return `${item} must be initialized before being accessed.`;
    }
}
//# sourceMappingURL=dataObject.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/aqueduct/lib/data-objects/pureDataObject.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/aqueduct/lib/data-objects/pureDataObject.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PureDataObject": () => (/* binding */ PureDataObject)
/* harmony export */ });
/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/datastore */ "../../node_modules/@fluidframework/datastore/lib/fluidHandle.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/eventForwarder.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/request-handler */ "../../node_modules/@fluidframework/request-handler/lib/requestHandlers.js");
/* harmony import */ var _container_services__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../container-services */ "../../node_modules/@fluidframework/aqueduct/lib/container-services/containerServices.js");
/* harmony import */ var _request_handlers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../request-handlers */ "../../node_modules/@fluidframework/aqueduct/lib/request-handlers/requestHandlers.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */





/**
 * This is a bare-bones base class that does basic setup and enables for factory on an initialize call.
 * You probably don't want to inherit from this data store directly unless
 * you are creating another base data store class
 *
 * Generics:
 * O - represents a type that will define optional providers that will be injected
 * S - the initial state type that the produced data store may take during creation
 * E - represents events that will be available in the EventForwarder
 */
// eslint-disable-next-line @typescript-eslint/ban-types
class PureDataObject extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.EventForwarder {
    constructor(props) {
        super();
        this._disposed = false;
        this.runtime = props.runtime;
        this.context = props.context;
        this.providers = props.providers;
        this.initProps = props.initProps;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.runtime._dataObject === undefined, 0x0bd /* "Object runtime already has DataObject!" */);
        this.runtime._dataObject = this;
        // Create a FluidObjectHandle with empty string as `path`. This is because reaching this PureDataObject is the
        // same as reaching its routeContext (FluidDataStoreRuntime) so there is so the relative path to it from the
        // routeContext is empty.
        this.innerHandle = new _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_2__.FluidObjectHandle(this, "", this.runtime.objectsRoutingContext);
        // Container event handlers
        this.runtime.once("dispose", () => {
            this._disposed = true;
            this.dispose();
        });
    }
    get disposed() { return this._disposed; }
    get id() { return this.runtime.id; }
    get IFluidRouter() { return this; }
    get IFluidLoadable() { return this; }
    get IFluidHandle() { return this.innerHandle; }
    /**
     * Handle to a data store
     */
    get handle() { return this.innerHandle; }
    static async getDataObject(runtime) {
        const obj = runtime._dataObject;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(obj !== undefined, 0x0bc /* "Runtime has no DataObject!" */);
        await obj.finishInitialization();
        return obj;
    }
    // #region IFluidRouter
    /**
     * Return this object if someone requests it directly
     * We will return this object in two scenarios:
     *  1. the request url is a "/"
     *  2. the request url is empty
     */
    async request(req) {
        return (0,_request_handlers__WEBPACK_IMPORTED_MODULE_3__.defaultFluidObjectRequestHandler)(this, req);
    }
    // #endregion IFluidRouter
    // #region IFluidLoadable
    // #endregion IFluidLoadable
    /**
     * Call this API to ensure PureDataObject is fully initialized
     * initialization happens on demand, only on as-needed bases.
     * In most cases you should allow factory/object to decide when to finish initialization.
     * But if you are supplying your own implementation of DataStoreRuntime factory and overriding some methods
     * and need fully initialized object, then you can call this API to ensure object is fully initialized.
     */
    async finishInitialization() {
        if (this.initializeP !== undefined) {
            return this.initializeP;
        }
        this.initializeP = this.initializeInternal();
        return this.initializeP;
    }
    /**
     * Internal initialize implementation. Overwriting this will change the flow of the PureDataObject and should
     * generally not be done.
     *
     * Calls initializingFirstTime, initializingFromExisting, and hasInitialized. Caller is
     * responsible for ensuring this is only invoked once.
     */
    async initializeInternal() {
        var _a;
        await this.preInitialize();
        if (this.runtime.existing) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.initProps === undefined, 0x0be /* "Trying to initialize from existing while initProps is set!" */);
            await this.initializingFromExisting();
        }
        else {
            await this.initializingFirstTime((_a = this.context.createProps) !== null && _a !== void 0 ? _a : this.initProps);
        }
        await this.hasInitialized();
    }
    /**
     * Retreive Fluid object using the handle get or the older requestFluidObject_UNSAFE call to fetch by ID
     *
     * @param key - key that object (handle/id) is stored with in the directory
     * @param directory - directory containing the object
     * @param getObjectFromDirectory - optional callback for fetching object from the directory, allows users to
     * define custom types/getters for object retrieval
     */
    async getFluidObjectFromDirectory(key, directory, getObjectFromDirectory) {
        const handleOrId = getObjectFromDirectory ? getObjectFromDirectory(key, directory) : directory.get(key);
        if (typeof handleOrId === "string") {
            // For backwards compatibility with older stored IDs
            // We update the storage with the handle so that this code path is less and less trafficked
            const fluidObject = await this.requestFluidObject_UNSAFE(handleOrId);
            if (fluidObject.IFluidLoadable && fluidObject.handle) {
                directory.set(key, fluidObject.handle);
            }
            return fluidObject;
        }
        else {
            const handle = handleOrId === null || handleOrId === void 0 ? void 0 : handleOrId.IFluidHandle;
            return await (handle ? handle.get() : this.requestFluidObject_UNSAFE(key));
        }
    }
    /**
     * @deprecated
     * Gets the data store of a given id. Will follow the pattern of the container for waiting.
     * @param id - data store id
     */
    async requestFluidObject_UNSAFE(id) {
        return (0,_fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_4__.handleFromLegacyUri)(`/${id}`, this.context.containerRuntime).get();
    }
    /**
     * Gets the service at a given id.
     * @param id - service id
     */
    async getService(id) {
        return (0,_fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_4__.handleFromLegacyUri)(`/${_container_services__WEBPACK_IMPORTED_MODULE_5__.serviceRoutePathRoot}/${id}`, this.context.containerRuntime).get();
    }
    /**
     * Called every time the data store is initialized, before initializingFirstTime or
     * initializingFromExisting is called.
     */
    async preInitialize() { }
    /**
     * Called the first time the data store is initialized (new creations with a new
     * data store runtime)
     *
     * @param props - Optional props to be passed in on create
     */
    async initializingFirstTime(props) { }
    /**
     * Called every time but the first time the data store is initialized (creations
     * with an existing data store runtime)
     */
    async initializingFromExisting() { }
    /**
     * Called every time the data store is initialized after create or existing.
     */
    async hasInitialized() { }
    /**
     * Called when the host container closes and disposes itself
     */
    dispose() {
        super.dispose();
    }
}
//# sourceMappingURL=pureDataObject.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/aqueduct/lib/request-handlers/requestHandlers.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/aqueduct/lib/request-handlers/requestHandlers.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultRouteRequestHandler": () => (/* binding */ defaultRouteRequestHandler),
/* harmony export */   "defaultFluidObjectRequestHandler": () => (/* binding */ defaultFluidObjectRequestHandler)
/* harmony export */ });
/* unused harmony export mountableViewRequestHandler */
/* harmony import */ var _fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/request-handler */ "../../node_modules/@fluidframework/request-handler/lib/runtimeRequestHandlerBuilder.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/requestParser.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHelpers.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * A mountable view is only required if the view needs to be mounted across a bundle boundary.  Mounting across
 * bundle boundaries breaks some frameworks, so the mountable view is used to ensure the mounting is done within
 * the same bundle as the view.  For example, React hooks don't work if mounted across bundles since there will
 * be two React instances, breaking the Rules of Hooks.  When cross-bundle mounting isn't required, the mountable
 * view isn't necessary.
 *
 * When a request is received with a mountableView: true header, this request handler will reissue the request
 * without the header, and respond with a mountable view of the given class using the response.
 * @param MountableViewClass - The type of mountable view to use when responding
 */
const mountableViewRequestHandler = (MountableViewClass, handlers) => {
    const nestedHandler = (0,_fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_0__.buildRuntimeRequestHandler)(...handlers);
    return async (request, runtime) => {
        var _a;
        const mountableView = ((_a = request.headers) === null || _a === void 0 ? void 0 : _a.mountableView) === true;
        let newRequest = request;
        if (mountableView) {
            // Reissue the request without the mountableView header.
            // We'll repack whatever the response is if we can.
            const headers = Object.assign({}, request.headers);
            delete headers.mountableView;
            newRequest = {
                url: request.url,
                headers,
            };
        }
        const response = await nestedHandler(newRequest, runtime);
        if (mountableView && response.status === 200 && MountableViewClass.canMount(response.value)) {
            return {
                status: 200,
                mimeType: "fluid/object",
                value: new MountableViewClass(response.value),
            };
        }
        return response;
    };
};
/**
 * Pipe through container request into internal request.
 * If request is empty and default url is provided, redirect request to such default url.
 * @param defaultRootId - optional default root data store ID to pass request in case request is empty.
 */
const defaultRouteRequestHandler = (defaultRootId) => {
    return async (request, runtime) => {
        const parser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__.RequestParser.create(request);
        if (parser.pathParts.length === 0) {
            return runtime.IFluidHandleContext.resolveHandle({
                url: `/${defaultRootId}${parser.query}`,
                headers: request.headers
            });
        }
        return undefined; // continue search
    };
};
/**
 * Default request handler for a Fluid object that returns the object itself if:
 *  1. the request url is a "/"
 *  2. the request url is empty
 * Returns a 404 error for any other url.
 */
function defaultFluidObjectRequestHandler(fluidObject, request) {
    if (request.url === "/" || request.url === "") {
        return { mimeType: "fluid/object", status: 200, value: fluidObject };
    }
    else {
        return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.create404Response)(request);
    }
}
//# sourceMappingURL=requestHandlers.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/common-utils/lib/assert.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@fluidframework/common-utils/lib/assert.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/common-utils/lib/base64Encoding.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@fluidframework/common-utils/lib/base64Encoding.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fromBase64ToUtf8": () => (/* binding */ fromBase64ToUtf8),
/* harmony export */   "fromUtf8ToBase64": () => (/* binding */ fromUtf8ToBase64)
/* harmony export */ });
/* unused harmony export toUtf8 */
/* harmony import */ var _indexNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./indexNode */ "../../node_modules/@fluidframework/common-utils/lib/bufferBrowser.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

const fromBase64ToUtf8 = (input) => _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, "base64").toString("utf-8");
const fromUtf8ToBase64 = (input) => _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, "utf8").toString("base64");
/**
 * Convenience function to convert unknown encoding to utf8 that avoids
 * buffer copies/encode ops when no conversion is needed
 * @param input - The source string to convert
 * @param encoding - The source string's encoding
 */
const toUtf8 = (input, encoding) => {
    switch (encoding) {
        case "utf8":
        case "utf-8":
            return input;
        default:
            return _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, encoding).toString();
    }
};
//# sourceMappingURL=base64Encoding.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/common-utils/lib/bufferBrowser.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@fluidframework/common-utils/lib/bufferBrowser.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Uint8ArrayToString": () => (/* binding */ Uint8ArrayToString),
/* harmony export */   "stringToBuffer": () => (/* binding */ stringToBuffer),
/* harmony export */   "bufferToString": () => (/* binding */ bufferToString),
/* harmony export */   "IsoBuffer": () => (/* binding */ IsoBuffer)
/* harmony export */ });
/* unused harmony export isArrayBuffer */
/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base64-js */ "../../node_modules/base64-js/index.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assert */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* provided dependency */ var TextDecoder = __webpack_require__(/*! ./custom_modules/TextEncoder.js */ "./custom_modules/TextEncoder.js")["TextDecoder"];
/* provided dependency */ var TextEncoder = __webpack_require__(/*! ./custom_modules/TextEncoder.js */ "./custom_modules/TextEncoder.js")["TextEncoder"];
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Converts a Uint8Array to a string of the provided encoding
 * Useful when the array might be an IsoBuffer
 * @param arr - The array to convert
 * @param encoding - Optional target encoding; only "utf8" and "base64" are
 * supported, with "utf8" being default
 * @returns The converted string
 */
function Uint8ArrayToString(arr, encoding) {
    switch (encoding) {
        case "base64": {
            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(arr);
        }
        case "utf8":
        case "utf-8":
        case undefined: {
            return new TextDecoder().decode(arr);
        }
        default: {
            throw new Error("invalid/unsupported encoding");
        }
    }
}
/**
 * Convert base64 or utf8 string to array buffer
 * @param encoding - input string's encoding
 */
const stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;
/**
 * Convert binary blob to string format
 *
 * @param blob - the binary blob
 * @param encoding - output string's encoding
 * @returns the blob in string format
 */
const bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);
/**
 * Determines if an object is an array buffer
 * Will detect and reject TypedArrays, like Uint8Array.
 * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with
 * math properly (i.e. take into account byteOffset at minimum).
 * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or
 * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and
 * ignoring byteOffice, length)
 * @param obj - The object to determine if it is an ArrayBuffer
 */
function isArrayBuffer(obj) {
    const maybe = obj;
    return obj instanceof ArrayBuffer
        || (typeof maybe === "object"
            && maybe !== null
            && typeof maybe.byteLength === "number"
            && typeof maybe.slice === "function"
            && maybe.byteOffset === undefined
            && maybe.buffer === undefined);
}
/**
 * Minimal implementation of Buffer for our usages in the browser environment.
 */
class IsoBuffer extends Uint8Array {
    /**
     * Convert the buffer to a string.
     * Only supports encoding the whole string (unlike the Node Buffer equivalent)
     * and only utf8 and base64 encodings
     * @param encoding
     */
    toString(encoding) {
        return Uint8ArrayToString(this, encoding);
    }
    /**
     * @param value - string | ArrayBuffer
     * @param encodingOrOffset - string | number
     * @param length - number
     */
    static from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
            return IsoBuffer.fromString(value, encodingOrOffset);
            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)
        }
        else if (value !== null && typeof value === "object" && isArrayBuffer(value.buffer)) {
            // Support currently for full array, no view ports! (though it can be added in future)
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteOffset === 0, 0x000 /* "nonzero isobuffer byte offset" */);
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteLength === value.buffer.byteLength, 0x001 /* "unexpected isobuffer byte length" */);
            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);
        }
        else if (isArrayBuffer(value)) {
            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);
        }
        else {
            throw new TypeError();
        }
    }
    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {
        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;
        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;
        if (offset < 0 ||
            offset > arrayBuffer.byteLength ||
            validLength < 0 ||
            validLength + offset > arrayBuffer.byteLength) {
            throw new RangeError();
        }
        return new IsoBuffer(arrayBuffer, offset, validLength);
    }
    static fromString(str, encoding) {
        switch (encoding) {
            case "base64": {
                const sanitizedString = this.sanitizeBase64(str);
                const encoded = base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(sanitizedString);
                return new IsoBuffer(encoded.buffer);
            }
            case "utf8":
            case "utf-8":
            case undefined: {
                const encoded = new TextEncoder().encode(str);
                return new IsoBuffer(encoded.buffer);
            }
            default: {
                throw new Error("invalid/unsupported encoding");
            }
        }
    }
    static isBuffer(obj) {
        throw new Error("unimplemented");
    }
    /**
     * Sanitize a base64 string to provide to base64-js library.  base64-js
     * is not as tolerant of the same malformed base64 as Node's Buffer is.
     * @param str
     */
    static sanitizeBase64(str) {
        let sanitizedStr = str;
        // Remove everything after padding - Node buffer ignores everything
        // after any padding whereas base64-js does not
        sanitizedStr = sanitizedStr.split("=")[0];
        // Remove invalid characters - Node buffer strips invalid characters
        // whereas base64-js replaces them with "A"
        sanitizedStr = sanitizedStr.replace(/[^\w+-/]/g, "");
        // Check for missing padding - Node buffer tolerates missing padding
        // whereas base64-js does not
        if (sanitizedStr.length % 4 !== 0) {
            const paddingArray = ["", "===", "==", "="];
            sanitizedStr += paddingArray[sanitizedStr.length % 4];
        }
        return sanitizedStr;
    }
}
//# sourceMappingURL=bufferBrowser.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/common-utils/lib/disposal.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@fluidframework/common-utils/lib/disposal.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "doIfNotDisposed": () => (/* binding */ doIfNotDisposed)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
function doIfNotDisposed(disposable, f) {
    return (...args) => {
        if (disposable.disposed) {
            throw new Error("Already disposed");
        }
        else {
            return f(...args);
        }
    };
}
//# sourceMappingURL=disposal.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/common-utils/lib/eventForwarder.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@fluidframework/common-utils/lib/eventForwarder.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventForwarder": () => (/* binding */ EventForwarder)
/* harmony export */ });
/* harmony import */ var _typedEventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typedEventEmitter */ "../../node_modules/@fluidframework/common-utils/lib/typedEventEmitter.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Base class used for forwarding events from a source EventEmitter.
 * This can be useful when all arbitrary listeners need to be removed,
 * but the primary source needs to stay intact.
 */
class EventForwarder extends _typedEventEmitter__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {
    constructor(source) {
        super();
        this.isDisposed = false;
        this.forwardingEvents = new Map();
        if (source !== undefined) {
            // NewListener event is raised whenever someone starts listening to this events, so
            // we keep track of events being listened to, and start forwarding from the source
            // event emitter per event listened to on this
            const removeListenerHandler = (event) => this.unforwardEvent(source, event);
            const newListenerHandler = (event) => this.forwardEvent(source, event);
            this.on(EventForwarder.removeListenerEvent, removeListenerHandler);
            this.on(EventForwarder.newListenerEvent, newListenerHandler);
        }
    }
    static isEmitterEvent(event) {
        return event === EventForwarder.newListenerEvent || event === EventForwarder.removeListenerEvent;
    }
    get disposed() { return this.isDisposed; }
    dispose() {
        this.isDisposed = true;
        for (const listenerRemovers of this.forwardingEvents.values()) {
            for (const listenerRemover of listenerRemovers.values()) {
                try {
                    listenerRemover();
                }
                catch (_a) {
                    // Should be fine because of removeAllListeners below
                }
            }
        }
        this.removeAllListeners();
        this.forwardingEvents.clear();
    }
    forwardEvent(source, ...events) {
        for (const event of events) {
            if (source !== undefined && event !== undefined && !EventForwarder.isEmitterEvent(event)) {
                let sources = this.forwardingEvents.get(event);
                if (sources === undefined) {
                    sources = new Map();
                    this.forwardingEvents.set(event, sources);
                }
                if (!sources.has(source)) {
                    const listener = (...args) => this.emit(event, ...args);
                    sources.set(source, () => source.off(event, listener));
                    source.on(event, listener);
                }
            }
        }
    }
    unforwardEvent(source, ...events) {
        for (const event of events) {
            if (event !== undefined && !EventForwarder.isEmitterEvent(event)) {
                const sources = this.forwardingEvents.get(event);
                if (sources === null || sources === void 0 ? void 0 : sources.has(source)) {
                    if (this.listenerCount(event) === 0) {
                        const listenerRemover = sources.get(source);
                        if (listenerRemover !== undefined) {
                            listenerRemover();
                        }
                        sources.delete(source);
                        if (sources.size === 0) {
                            this.forwardingEvents.delete(event);
                        }
                    }
                }
            }
        }
    }
}
EventForwarder.newListenerEvent = "newListener";
EventForwarder.removeListenerEvent = "removeListener";
//# sourceMappingURL=eventForwarder.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/common-utils/lib/heap.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@fluidframework/common-utils/lib/heap.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Heap": () => (/* binding */ Heap)
/* harmony export */ });
/* unused harmony export NumberComparer */
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A comparer for numbers
 */
const NumberComparer = {
    /**
     * The compare function for numbers,
     * @returns difference of the two number
     */
    compare: (a, b) => a - b,
    /**
     * The minimum value of a javascript number, which is Number.MIN_VALUE
     */
    min: Number.MIN_VALUE,
};
/**
 * Ordered Heap data structure implementation
 */
class Heap {
    /**
     * Creates an instance of Heap with comparer
     * @param comp - a comparer that specify how elements are ordered
     */
    constructor(comp) {
        this.comp = comp;
        this.L = [{ value: comp.min, position: 0 }];
    }
    /**
     * Return the smallest element in the heap as determined by the order of the comparer
     *
     * @returns heap node containing the smallest element
     */
    peek() {
        return this.L[1];
    }
    /**
     * Get and remove the smallest element in the heap as determined by the order of the comparer
     *
     * @returns the smallest value in the heap
     */
    get() {
        this.swap(1, this.count());
        const x = this.L.pop();
        this.fixdown(1);
        return x.value;
    }
    /**
     * Add a value to the heap
     *
     * @param x - value to add
     * @returns the heap node that contains the value
     */
    add(x) {
        const node = { value: x, position: this.L.length };
        this.L.push(node);
        this.fixup(this.count());
        return node;
    }
    /**
     * Allows for heap to be updated after a node's value changes
     */
    update(node) {
        const k = node.position;
        if (this.isGreaterThanParent(k)) {
            this.fixup(k);
        }
        else {
            this.fixdown(k);
        }
    }
    /**
     * Removes the given node from the heap
     *
     * @param node - the node to remove from the heap
     */
    remove(node) {
        // Move the node we want to remove to the end of the array
        const position = node.position;
        this.swap(node.position, this.L.length - 1);
        this.L.splice(this.L.length - 1);
        // Update the swapped node assuming we didn't remove the end of the list
        if (position !== this.L.length) {
            this.update(this.L[position]);
        }
    }
    /**
     * Get the number of elements in the Heap
     *
     * @returns the number of elements in the Heap
     */
    count() {
        return this.L.length - 1;
    }
    fixup(pos) {
        let k = pos;
        while (this.isGreaterThanParent(k)) {
            const parent = k >> 1;
            this.swap(k, parent);
            k = parent;
        }
    }
    isGreaterThanParent(k) {
        return k > 1 && (this.comp.compare(this.L[k >> 1].value, this.L[k].value) > 0);
    }
    fixdown(pos) {
        let k = pos;
        while ((k << 1) <= this.count()) {
            let j = k << 1;
            if ((j < this.count()) && (this.comp.compare(this.L[j].value, this.L[j + 1].value) > 0)) {
                j++;
            }
            if (this.comp.compare(this.L[k].value, this.L[j].value) <= 0) {
                break;
            }
            this.swap(k, j);
            k = j;
        }
    }
    swap(k, j) {
        const tmp = this.L[k];
        this.L[k] = this.L[j];
        this.L[k].position = k;
        this.L[j] = tmp;
        this.L[j].position = j;
    }
}
//# sourceMappingURL=heap.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/common-utils/lib/lazy.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@fluidframework/common-utils/lib/lazy.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Lazy": () => (/* binding */ Lazy)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
  * Helper class for lazy initialized values. Ensures the value is only generated once, and remain immutable
  */
class Lazy {
    /**
     * Instantiates an instance of Lazy<T>
     * @param valueGenerator - the function that will generate the value when value is accessed the first time
     */
    constructor(valueGenerator) {
        this.valueGenerator = valueGenerator;
        this._evaluated = false;
    }
    /**
     * Return true if the value as been generated, otherwise false
     */
    get evaluated() {
        return this._evaluated;
    }
    /**
     * Get the value. If this is the first call the value will be generated
     */
    get value() {
        if (!this._evaluated) {
            this._evaluated = true;
            this._value = this.valueGenerator();
        }
        return this._value;
    }
}
//# sourceMappingURL=lazy.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/common-utils/lib/logger.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@fluidframework/common-utils/lib/logger.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTelemetryNullLogger": () => (/* binding */ BaseTelemetryNullLogger)
/* harmony export */ });
/* unused harmony export TelemetryNullLogger */
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Null logger
 * It can be used in places where logger instance is required, but events should be not send over.
 */
class BaseTelemetryNullLogger {
    /**
     * Send an event with the logger
     *
     * @param event - the event to send
     */
    send(event) {
        return;
    }
}
/**
 * Null logger
 * It can be used in places where logger instance is required, but events should be not send over.
 */
class TelemetryNullLogger {
    send(event) {
    }
    sendTelemetryEvent(event, error) {
    }
    sendErrorEvent(event, error) {
    }
    sendPerformanceEvent(event, error) {
    }
    logGenericError(eventName, error) {
    }
    logException(event, exception) {
    }
    debugAssert(condition, event) {
    }
    shipAssert(condition, event) {
    }
}
//# sourceMappingURL=logger.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/common-utils/lib/performanceBrowser.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/common-utils/lib/performanceBrowser.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "performance": () => (/* binding */ performance)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const performance = ({"now":(() => 0)});
//# sourceMappingURL=performanceBrowser.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/common-utils/lib/promises.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@fluidframework/common-utils/lib/promises.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Deferred": () => (/* binding */ Deferred),
/* harmony export */   "LazyPromise": () => (/* binding */ LazyPromise)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A deferred creates a promise and the ability to resolve or reject it
 */
class Deferred {
    constructor() {
        this.completed = false;
        this.p = new Promise((resolve, reject) => {
            this.res = resolve;
            this.rej = reject;
        });
    }
    /**
     * Returns whether the underlying promise has been completed
     */
    get isCompleted() {
        return this.completed;
    }
    /**
     * Retrieves the underlying promise for the deferred
     *
     * @returns the underlying promise
     */
    get promise() {
        return this.p;
    }
    /**
     * Resolves the promise
     *
     * @param value - the value to resolve the promise with
     */
    resolve(value) {
        if (this.res !== undefined) {
            this.completed = true;
            this.res(value);
        }
    }
    /**
     * Rejects the promise
     *
     * @param value - the value to reject the promise with
     */
    reject(error) {
        if (this.rej !== undefined) {
            this.completed = true;
            this.rej(error);
        }
    }
}
/**
 * A lazy evaluated promise. The execute function is delayed until
 * the promise is used, e.g. await, then, catch ...
 * The execute function is only called once.
 * All calls are then proxied to the promise returned by the execute method.
 */
class LazyPromise {
    constructor(execute) {
        this.execute = execute;
    }
    get [Symbol.toStringTag]() {
        return this.getPromise()[Symbol.toStringTag];
    }
    async then(onfulfilled, onrejected) {
        return this.getPromise().then(...arguments);
    }
    async catch(onrejected) {
        return this.getPromise().catch(...arguments);
    }
    async finally(onfinally) {
        return this.getPromise().finally(...arguments);
    }
    async getPromise() {
        if (this.result === undefined) {
            this.result = this.execute();
        }
        return this.result;
    }
}
//# sourceMappingURL=promises.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/common-utils/lib/timer.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@fluidframework/common-utils/lib/timer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Timer": () => (/* binding */ Timer),
/* harmony export */   "PromiseTimer": () => (/* binding */ PromiseTimer)
/* harmony export */ });
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _promises__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./promises */ "../../node_modules/@fluidframework/common-utils/lib/promises.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * This class is a thin wrapper over setTimeout and clearTimeout which
 * makes it simpler to keep track of recurring timeouts with the same
 * or similar handlers and timeouts.
 */
class Timer {
    constructor(defaultTimeout, defaultHandler, getCurrentTick = () => Date.now()) {
        this.defaultTimeout = defaultTimeout;
        this.defaultHandler = defaultHandler;
        this.getCurrentTick = getCurrentTick;
    }
    /**
     * Returns true if the timer is running.
     */
    get hasTimer() {
        return !!this.runningState;
    }
    /**
     * Calls setTimeout and tracks the resulting timeout.
     * @param ms - overrides default timeout in ms
     * @param handler - overrides default handler
     */
    start(ms = this.defaultTimeout, handler = this.defaultHandler) {
        this.startCore(ms, handler, ms);
    }
    /**
     * Calls clearTimeout on the underlying timeout if running.
     */
    clear() {
        if (!this.runningState) {
            return;
        }
        clearTimeout(this.runningState.timeout);
        this.runningState = undefined;
    }
    /**
     * Restarts the timer with the new handler and duration.
     * If a new handler is passed, the original handler may
     * never execute.
     * This is a potentially more efficient way to clear and start
     * a new timer.
     * @param ms - overrides previous or default timeout in ms
     * @param handler - overrides previous or default handler
     */
    restart(ms, handler) {
        var _a, _b;
        if (!this.runningState) {
            // If restart is called first, it behaves as a call to start
            this.start(ms, handler);
        }
        else {
            const duration = ms !== null && ms !== void 0 ? ms : this.runningState.intendedDuration;
            const handlerToUse = (_b = handler !== null && handler !== void 0 ? handler : (_a = this.runningState.restart) === null || _a === void 0 ? void 0 : _a.handler) !== null && _b !== void 0 ? _b : this.runningState.handler;
            const remainingTime = this.calculateRemainingTime(this.runningState);
            if (duration < remainingTime) {
                // If remaining time exceeds restart duration, do a hard restart.
                // The existing timeout time is too long.
                this.start(duration, handlerToUse);
            }
            else if (duration === remainingTime) {
                // The existing timeout time is perfect, just update handler and data.
                this.runningState.handler = handlerToUse;
                this.runningState.restart = undefined;
                this.runningState.intendedDuration = duration;
            }
            else {
                // If restart duration exceeds remaining time, set restart info.
                // Existing timeout will start a new timeout for remaining time.
                this.runningState.restart = {
                    startTick: this.getCurrentTick(),
                    duration,
                    handler: handlerToUse,
                };
            }
        }
    }
    startCore(duration, handler, intendedDuration) {
        this.clear();
        this.runningState = {
            startTick: this.getCurrentTick(),
            duration,
            intendedDuration,
            handler,
            timeout: setTimeout(() => this.handler(), duration),
        };
    }
    handler() {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(!!this.runningState, 0x00a /* "Running timer missing handler" */);
        const restart = this.runningState.restart;
        if (restart !== undefined) {
            // Restart with remaining time
            const remainingTime = this.calculateRemainingTime(restart);
            this.startCore(remainingTime, () => restart.handler(), restart.duration);
        }
        else {
            // Run clear first, in case the handler decides to start again
            const handler = this.runningState.handler;
            this.clear();
            handler();
        }
    }
    calculateRemainingTime(runningTimeout) {
        const elapsedTime = this.getCurrentTick() - runningTimeout.startTick;
        return runningTimeout.duration - elapsedTime;
    }
}
/**
 * This class is a wrapper over setTimeout and clearTimeout which
 * makes it simpler to keep track of recurring timeouts with the
 * same handlers and timeouts, while also providing a promise that
 * resolves when it times out.
 */
class PromiseTimer {
    constructor(defaultTimeout, defaultHandler) {
        this.timer = new Timer(defaultTimeout, () => this.wrapHandler(defaultHandler));
    }
    get hasTimer() {
        return this.timer.hasTimer;
    }
    async start(ms, handler) {
        this.clear();
        this.deferred = new _promises__WEBPACK_IMPORTED_MODULE_1__.Deferred();
        this.timer.start(ms, handler ? () => this.wrapHandler(handler) : undefined);
        return this.deferred.promise;
    }
    clear() {
        this.timer.clear();
        if (this.deferred) {
            this.deferred.resolve({ timerResult: "cancel" });
            this.deferred = undefined;
        }
    }
    wrapHandler(handler) {
        handler();
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(!!this.deferred, 0x00b /* "Handler executed without deferred" */);
        this.deferred.resolve({ timerResult: "timeout" });
        this.deferred = undefined;
    }
}
//# sourceMappingURL=timer.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/common-utils/lib/trace.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@fluidframework/common-utils/lib/trace.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Trace": () => (/* binding */ Trace)
/* harmony export */ });
/* harmony import */ var _indexNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./indexNode */ "../../node_modules/@fluidframework/common-utils/lib/performanceBrowser.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Helper class for tracing performance of events
 * Time measurements are in milliseconds as a floating point with a decimal
 */
class Trace {
    constructor(startTick) {
        this.startTick = startTick;
        this.lastTick = startTick;
    }
    static start() {
        const startTick = _indexNode__WEBPACK_IMPORTED_MODULE_0__.performance.now();
        return new Trace(startTick);
    }
    trace() {
        const tick = _indexNode__WEBPACK_IMPORTED_MODULE_0__.performance.now();
        const event = {
            totalTimeElapsed: tick - this.startTick,
            duration: tick - this.lastTick,
            tick,
        };
        this.lastTick = tick;
        return event;
    }
}
//# sourceMappingURL=trace.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/common-utils/lib/typedEventEmitter.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/common-utils/lib/typedEventEmitter.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypedEventEmitter": () => (/* binding */ TypedEventEmitter)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Event Emitter helper class the supports emitting typed events
 */
class TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor() {
        super();
        this.addListener = super.addListener.bind(this);
        this.on = super.on.bind(this);
        this.once = super.once.bind(this);
        this.prependListener = super.prependListener.bind(this);
        this.prependOnceListener = super.prependOnceListener.bind(this);
        this.removeListener = super.removeListener.bind(this);
        this.off = super.off.bind(this);
    }
}
//# sourceMappingURL=typedEventEmitter.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/common-utils/lib/unreachable.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@fluidframework/common-utils/lib/unreachable.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unreachableCase": () => (/* binding */ unreachableCase)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This function can be used to assert at compile time that a given value has type never.
 * One common usage is in the default case of a switch block,
 * to ensure that all cases are explicitly handled.
 */
function unreachableCase(_, message = "Unreachable Case") {
    throw new Error(message);
}
//# sourceMappingURL=unreachable.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-definitions/lib/error.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-definitions/lib/error.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContainerErrorType": () => (/* binding */ ContainerErrorType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Different error types the Container may report out to the Host
 */
var ContainerErrorType;
(function (ContainerErrorType) {
    /**
     * Some error, most likely an exception caught by runtime and propagated to container as critical error
     */
    ContainerErrorType["genericError"] = "genericError";
    /**
     * Throttling error from server. Server is busy and is asking not to reconnect for some time
     */
    ContainerErrorType["throttlingError"] = "throttlingError";
    /**
     * Data loss error detected by Container / DeltaManager. Likely points to storage issue.
     */
    ContainerErrorType["dataCorruptionError"] = "dataCorruptionError";
    /**
     * Error encountered when processing an operation. May correlate with data corruption.
     */
    ContainerErrorType["dataProcessingError"] = "dataProcessingError";
})(ContainerErrorType || (ContainerErrorType = {}));
//# sourceMappingURL=error.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-definitions/lib/loader.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-definitions/lib/loader.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoaderHeader": () => (/* binding */ LoaderHeader)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Accepted header keys for requests coming to the Loader
 */
var LoaderHeader;
(function (LoaderHeader) {
    /**
     * Override the Loader's default caching behavior for this container.
     */
    LoaderHeader["cache"] = "fluid-cache";
    LoaderHeader["clientDetails"] = "fluid-client-details";
    /**
     * Start the container in a paused, unconnected state. Defaults to false
     */
    LoaderHeader["pause"] = "pause";
    LoaderHeader["reconnect"] = "fluid-reconnect";
    LoaderHeader["sequenceNumber"] = "fluid-sequence-number";
    /**
     * One of the following:
     * null or "null": use ops, no snapshots
     * undefined: fetch latest snapshot
     * otherwise, version sha to load snapshot
     */
    LoaderHeader["version"] = "version";
})(LoaderHeader || (LoaderHeader = {}));
//# sourceMappingURL=loader.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-definitions/lib/runtime.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-definitions/lib/runtime.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttachState": () => (/* binding */ AttachState),
/* harmony export */   "BindState": () => (/* binding */ BindState)
/* harmony export */ });
/* unused harmony export IRuntimeFactory */
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
// Represents the attachment state of the entity.
var AttachState;
(function (AttachState) {
    AttachState["Detached"] = "Detached";
    AttachState["Attaching"] = "Attaching";
    AttachState["Attached"] = "Attached";
})(AttachState || (AttachState = {}));
// Represents the bind state of the entity.
var BindState;
(function (BindState) {
    BindState["NotBound"] = "NotBound";
    BindState["Binding"] = "Binding";
    BindState["Bound"] = "Bound";
})(BindState || (BindState = {}));
const IRuntimeFactory = "IRuntimeFactory";
//# sourceMappingURL=runtime.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-loader/lib/audience.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-loader/lib/audience.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Audience": () => (/* binding */ Audience)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Audience represents all clients connected to the op stream.
 */
class Audience extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor() {
        super(...arguments);
        this.members = new Map();
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    /**
     * Adds a new client to the audience
     */
    addMember(clientId, details) {
        this.members.set(clientId, details);
        this.emit("addMember", clientId, details);
    }
    /**
     * Removes a client from the audience
     */
    removeMember(clientId) {
        this.members.delete(clientId);
        this.emit("removeMember", clientId);
    }
    /**
     * Retrieves all the members in the audience
     */
    getMembers() {
        return new Map(this.members);
    }
    /**
     * Retrieves a specific member of the audience
     */
    getMember(clientId) {
        return this.members.get(clientId);
    }
    /**
     * Clears the audience
     */
    clear() {
        const clientIds = this.members.keys();
        for (const clientId of clientIds) {
            this.removeMember(clientId);
        }
    }
}
//# sourceMappingURL=audience.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-loader/lib/connectionStateHandler.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-loader/lib/connectionStateHandler.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectionStateHandler": () => (/* binding */ ConnectionStateHandler)
/* harmony export */ });
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/eventEmitterWithErrorHandling.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/timer.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./container */ "../../node_modules/@fluidframework/container-loader/lib/container.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */



class ConnectionStateHandler extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.EventEmitterWithErrorHandling {
    constructor(handler, logger) {
        var _a;
        super();
        this.handler = handler;
        this.logger = logger;
        this._connectionState = _container__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected;
        this._clientSentOps = false;
        this.prevClientLeftTimer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.Timer((_a = 
        // Default is 90 sec for which we are going to wait for its own "leave" message.
        this.handler.maxClientLeaveWaitTime) !== null && _a !== void 0 ? _a : 90000, () => {
            this.leaveReceivedResult = false;
            this.applyForConnectedState("timeout");
        });
    }
    get connectionState() {
        return this._connectionState;
    }
    get connected() {
        return this.connectionState === _container__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connected;
    }
    get clientId() {
        return this._clientId;
    }
    get pendingClientId() {
        return this._pendingClientId;
    }
    // This is true when this client submitted any ops.
    clientSentOps(connectionMode) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this._connectionState === _container__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connected, 0x1d7 /* "Ops could only be sent when connected" */);
        this._clientSentOps = true;
        this.clientConnectionMode = connectionMode;
    }
    receivedAddMemberEvent(clientId) {
        // This is the only one that requires the pending client ID
        if (clientId === this.pendingClientId) {
            // Start the event in case we are waiting for leave or timeout.
            if (this.prevClientLeftTimer.hasTimer) {
                this.waitEvent = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__.PerformanceEvent.start(this.logger, {
                    eventName: "WaitBeforeClientLeave",
                    waitOnClientId: this._clientId,
                    hadOutstandingOps: this.handler.shouldClientJoinWrite(),
                });
            }
            this.applyForConnectedState("addMemberEvent");
        }
    }
    applyForConnectedState(source) {
        var _a;
        const protocolHandler = this.handler.protocolHandler();
        // Move to connected state only if we are in Connecting state, we have seen our join op
        // and there is no timer running which means we are not waiting for previous client to leave
        // or timeout has occured while doing so.
        if (this.pendingClientId !== this.clientId
            && this.pendingClientId !== undefined
            && protocolHandler !== undefined && protocolHandler.quorum.getMember(this.pendingClientId) !== undefined
            && !this.prevClientLeftTimer.hasTimer) {
            (_a = this.waitEvent) === null || _a === void 0 ? void 0 : _a.end({ leaveReceived: this.leaveReceivedResult, source });
            this.setConnectionState(_container__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connected);
        }
        else {
            // Adding this event temporarily so that we can get help debugging if something goes wrong.
            this.logger.sendTelemetryEvent({
                eventName: "connectedStateRejected",
                source,
                pendingClientId: this.pendingClientId,
                clientId: this.clientId,
                hasTimer: this.prevClientLeftTimer.hasTimer,
                inQuorum: protocolHandler !== undefined && this.pendingClientId !== undefined
                    && protocolHandler.quorum.getMember(this.pendingClientId) !== undefined,
            });
        }
    }
    receivedRemoveMemberEvent(clientId) {
        // If the client which has left was us, then finish the timer.
        if (this.clientId === clientId) {
            this.prevClientLeftTimer.clear();
            this.leaveReceivedResult = true;
            this.applyForConnectedState("removeMemberEvent");
        }
    }
    receivedDisconnectEvent(reason) {
        this.setConnectionState(_container__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected, reason);
    }
    receivedConnectEvent(connectionMode, details, opsBehind) {
        const oldState = this._connectionState;
        this._connectionState = _container__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connecting;
        // Stash the clientID to detect when transitioning from connecting (socket.io channel open) to connected
        // (have received the join message for the client ID)
        // This is especially important in the reconnect case. It's possible there could be outstanding
        // ops sent by this client, so we should keep the old client id until we see our own client's
        // join message. after we see the join message for out new connection with our new client id,
        // we know there can no longer be outstanding ops that we sent with the previous client id.
        this._pendingClientId = details.clientId;
        this.emit(_container__WEBPACK_IMPORTED_MODULE_1__.connectEventName, opsBehind);
        // Report telemetry after we set client id!
        this.handler.logConnectionStateChangeTelemetry(_container__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connecting, oldState);
        const protocolHandler = this.handler.protocolHandler();
        // Check if we already processed our own join op through delta storage!
        // we are fetching ops from storage in parallel to connecting to ordering service
        // Given async processes, it's possible that we have already processed our own join message before
        // connection was fully established.
        // Note that we might be still initializing quorum - connection is established proactively on load!
        if ((protocolHandler !== undefined && protocolHandler.quorum.getMember(details.clientId) !== undefined)
            || connectionMode === "read") {
            this.setConnectionState(_container__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connected);
        }
    }
    setConnectionState(value, reason) {
        var _a;
        if (this.connectionState === value) {
            // Already in the desired state - exit early
            this.logger.sendErrorEvent({ eventName: "setConnectionStateSame", value });
            return;
        }
        const oldState = this._connectionState;
        this._connectionState = value;
        if (value === _container__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connected) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(oldState === _container__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connecting, 0x1d8 /* "Should only transition from Connecting state" */);
            // Mark our old client should have left in the quorum if it's still there
            if (this._clientId !== undefined) {
                const client = (_a = this.handler.protocolHandler()) === null || _a === void 0 ? void 0 : _a.quorum.getMember(this._clientId);
                if (client !== undefined) {
                    client.shouldHaveLeft = true;
                }
            }
            this._clientId = this.pendingClientId;
            // Set _clientSentOps to false as this is a fresh connection.
            this._clientSentOps = false;
        }
        else if (value === _container__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected) {
            // Important as we process our own joinSession message through delta request
            this._pendingClientId = undefined;
            // Only wait for "leave" message if we have some outstanding ops and the client was write client as
            // server would not accept ops from read client. Also check if the timer is not already running as we
            // could receive "Disconnected" event multiple times without getting connected and in that case we
            // don't want to reset the timer as we still want to wait on original client which started this timer.
            // We also check the dirty state of this connection as we only want to wait for the client leave of the
            // client which created the ops. This helps with situation where a client disconnects immediately after
            // getting connected without sending any ops(from previous client). In this case, we would join as write
            // because there would be a diff between client seq number and clientSeqNumberObserved but then we don't
            // want to wait for newly disconnected client to leave as it has not sent any ops yet.
            if (this.handler.shouldClientJoinWrite()
                && this.clientConnectionMode === "write"
                && this.prevClientLeftTimer.hasTimer === false
                && this._clientSentOps) {
                this.leaveReceivedResult = undefined;
                this.prevClientLeftTimer.restart();
            }
            else {
                // Adding this event temporarily so that we can get help debugging if something goes wrong.
                this.logger.sendTelemetryEvent({
                    eventName: "noWaitOnDisconnected",
                    clientConnectionMode: this.clientConnectionMode,
                    hasTimer: this.prevClientLeftTimer.hasTimer,
                    clientSentOps: this._clientSentOps,
                    shouldClientJoinWrite: this.handler.shouldClientJoinWrite(),
                });
            }
        }
        if (this.handler.isContainerLoaded()) {
            this.handler.propagateConnectionState();
        }
        // Report telemetry after we set client id!
        this.handler.logConnectionStateChangeTelemetry(this._connectionState, oldState, reason);
    }
}
//# sourceMappingURL=connectionStateHandler.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-loader/lib/container.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-loader/lib/container.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "connectEventName": () => (/* binding */ connectEventName),
/* harmony export */   "ConnectionState": () => (/* binding */ ConnectionState),
/* harmony export */   "Container": () => (/* binding */ Container)
/* harmony export */ });
/* unused harmony exports waitContainerToCatchUp, CollabWindowTracker */
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/merge */ "../../node_modules/lodash/merge.js");
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/performanceBrowser.js");
/* harmony import */ var _fluidframework_core_interfaces__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @fluidframework/core-interfaces */ "../../node_modules/@fluidframework/core-interfaces/lib/fluidPackage.js");
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/container-definitions */ "../../node_modules/@fluidframework/container-definitions/lib/runtime.js");
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @fluidframework/container-utils */ "../../node_modules/@fluidframework/container-utils/lib/error.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/summaryForCreateNew.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/fluidResolvedUrl.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/buildSnapshotTree.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/blobCacheStorageService.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/readAndParse.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/network.js");
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/protocol-base */ "../../node_modules/@fluidframework/protocol-base/lib/protocol.js");
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @fluidframework/protocol-base */ "../../node_modules/@fluidframework/protocol-base/lib/quorum.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/protocol.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/storage.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/eventEmitterWithErrorHandling.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/events.js");
/* harmony import */ var _audience__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./audience */ "../../node_modules/@fluidframework/container-loader/lib/audience.js");
/* harmony import */ var _containerContext__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./containerContext */ "../../node_modules/@fluidframework/container-loader/lib/containerContext.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./debug */ "../../node_modules/@fluidframework/container-loader/lib/debug.js");
/* harmony import */ var _deltaManager__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./deltaManager */ "../../node_modules/@fluidframework/container-loader/lib/deltaManager.js");
/* harmony import */ var _deltaManagerProxy__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./deltaManagerProxy */ "../../node_modules/@fluidframework/container-loader/lib/deltaManagerProxy.js");
/* harmony import */ var _loader__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./loader */ "../../node_modules/@fluidframework/container-loader/lib/loader.js");
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./packageVersion */ "../../node_modules/@fluidframework/container-loader/lib/packageVersion.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils */ "../../node_modules/@fluidframework/container-loader/lib/utils.js");
/* harmony import */ var _connectionStateHandler__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./connectionStateHandler */ "../../node_modules/@fluidframework/container-loader/lib/connectionStateHandler.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
// eslint-disable-next-line import/no-internal-modules



















const detachedContainerRefSeqNumber = 0;
const connectEventName = "connect";
const dirtyContainerEvent = "dirty";
const savedContainerEvent = "saved";
var ConnectionState;
(function (ConnectionState) {
    /**
     * The document is no longer connected to the delta server
     */
    ConnectionState[ConnectionState["Disconnected"] = 0] = "Disconnected";
    /**
     * The document has an inbound connection but is still pending for outbound deltas
     */
    ConnectionState[ConnectionState["Connecting"] = 1] = "Connecting";
    /**
     * The document is fully connected
     */
    ConnectionState[ConnectionState["Connected"] = 2] = "Connected";
})(ConnectionState || (ConnectionState = {}));
/**
 * Waits until container connects to delta storage and gets up-to-date
 * Useful when resolving URIs and hitting 404, due to container being loaded from (stale) snapshot and not being
 * up to date. Host may chose to wait in such case and retry resolving URI.
 * Warning: Will wait infinitely for connection to establish if there is no connection.
 * May result in deadlock if Container.setAutoReconnect(false) is called and never switched back to auto-reconnect.
 * @returns true: container is up to date, it processed all the ops that were know at the time of first connection
 *          false: storage does not provide indication of how far the client is. Container processed
 *          all the ops known to it, but it maybe still behind.
 */
async function waitContainerToCatchUp(container) {
    // Make sure we stop waiting if container is closed.
    if (container.closed) {
        throw new Error("Container is closed");
    }
    return new Promise((accept, reject) => {
        const deltaManager = container.deltaManager;
        container.on("closed", reject);
        const waitForOps = () => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(container.connectionState !== ConnectionState.Disconnected, 0x0cd /* "Container disconnected while waiting for ops!" */);
            const hasCheckpointSequenceNumber = deltaManager.hasCheckpointSequenceNumber;
            const connectionOpSeqNumber = deltaManager.lastKnownSeqNumber;
            if (deltaManager.lastSequenceNumber === connectionOpSeqNumber) {
                accept(hasCheckpointSequenceNumber);
                return;
            }
            const callbackOps = (message) => {
                if (connectionOpSeqNumber <= message.sequenceNumber) {
                    accept(hasCheckpointSequenceNumber);
                    deltaManager.off("op", callbackOps);
                }
            };
            deltaManager.on("op", callbackOps);
        };
        if (container.connectionState !== ConnectionState.Disconnected) {
            waitForOps();
            return;
        }
        const callback = () => {
            deltaManager.off(connectEventName, callback);
            waitForOps();
        };
        deltaManager.on(connectEventName, callback);
        container.resume();
    });
}
class CollabWindowTracker {
    constructor(submit, activeConnection, NoopTimeFrequency = 2000, NoopCountFrequency = 300) {
        this.submit = submit;
        this.activeConnection = activeConnection;
        this.NoopTimeFrequency = NoopTimeFrequency;
        this.NoopCountFrequency = NoopCountFrequency;
        this.opsCountSinceNoop = 0;
    }
    /**
     * Schedules as ack to the server to update the reference sequence number
     */
    scheduleSequenceNumberUpdate(message, immediateNoOp) {
        // Exit early for inactive (not in quorum or not writers) clients.
        // They don't take part in the minimum sequence number calculation.
        if (!this.activeConnection()) {
            this.stopSequenceNumberUpdate();
            return;
        }
        // While processing a message, an immediate no-op can be requested.
        // i.e. to expedite approve or commit phase of quorum.
        if (immediateNoOp) {
            this.stopSequenceNumberUpdate();
            this.submit(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.NoOp, ""); // This can be anything other than null
            return;
        }
        // Filter out system messages.
        if ((0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_3__.isSystemMessage)(message)) {
            return;
        }
        // We don't acknowledge no-ops to avoid acknowledgement cycles (i.e. ack the MSN
        // update, which updates the MSN, then ack the update, etc...). Also, don't
        // count system messages in ops count.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(message.type !== _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.NoOp, 0x0ce /* "Don't acknowledge no-ops" */);
        if (this.lastNoopTime === undefined) {
            this.lastNoopTime = Date.now();
        }
        this.opsCountSinceNoop++;
        // If the ops count since last op is greater than NoopCountFrequency and time since last noop is
        // greater than NoopTimeFrequency, then send a Noop.
        // We will send a message(Noop) to update our reference sequence number upon receiving a server
        // operation. This allows the server to know our true reference sequence number and be able to
        // correctly update the minimum sequence number (MSN).
        if (this.opsCountSinceNoop >= this.NoopCountFrequency
            && Date.now() - this.lastNoopTime >= this.NoopTimeFrequency) {
            this.stopSequenceNumberUpdate();
            this.submit(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.NoOp, null);
        }
    }
    stopSequenceNumberUpdate() {
        this.opsCountSinceNoop = 0;
        this.lastNoopTime = undefined;
    }
}
class Container extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__.EventEmitterWithErrorHandling {
    constructor(loader, config) {
        var _a, _b;
        super();
        this.loader = loader;
        // Tells if container can reconnect on losing fist connection
        // If false, container gets closed on loss of connection.
        this._canReconnect = true;
        this.loaded = false;
        this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Detached;
        this.resumedOpProcessingAfterLoad = false;
        this.firstConnection = true;
        this.manualReconnectInProgress = false;
        this.connectionTransitionTimes = [];
        this.messageCountAfterDisconnection = 0;
        this.attachInProgress = false;
        this._dirtyContainer = false;
        this._closed = false;
        this.collabWindowTracker = new CollabWindowTracker((type, contents) => this._deltaManager.submit(type, contents), () => this.activeConnection(), (_a = this.loader.services.options) === null || _a === void 0 ? void 0 : _a.noopTimeFrequency, (_b = this.loader.services.options) === null || _b === void 0 ? void 0 : _b.noopCountFrequency);
        this._audience = new _audience__WEBPACK_IMPORTED_MODULE_6__.Audience();
        // Initialize from config
        this.containerUrl = config.containerUrl;
        this.clientDetailsOverride = config.clientDetailsOverride;
        this._id = config.id;
        this._resolvedUrl = config.resolvedUrl;
        if (config.canReconnect !== undefined) {
            this._canReconnect = config.canReconnect;
        }
        // Create logger for data stores to use
        const type = this.client.details.type;
        const interactive = this.client.details.capabilities.interactive;
        const clientType = `${interactive ? "interactive" : "noninteractive"}${type !== undefined && type !== "" ? `/${type}` : ""}`;
        // Need to use the property getter for docId because for detached flow we don't have the docId initially.
        // We assign the id later so property getter is used.
        this.subLogger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.ChildLogger.create(loader.services.subLogger, undefined, {
            all: {
                clientType,
                loaderVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_8__.pkgVersion,
                containerId: (0,uuid__WEBPACK_IMPORTED_MODULE_9__.default)(),
                docId: () => this.id,
                containerAttachState: () => this._attachState,
                containerLoaded: () => this.loaded,
            },
            // we need to be judicious with our logging here to avoid generting too much data
            // all data logged here should be broadly applicable, and not specific to a
            // specific error or class of errors
            error: {
                // load information to associate errors with the specific load point
                dmInitialSeqNumber: () => { var _a; return (_a = this._deltaManager) === null || _a === void 0 ? void 0 : _a.initialSequenceNumber; },
                dmLastKnownSeqNumber: () => { var _a; return (_a = this._deltaManager) === null || _a === void 0 ? void 0 : _a.lastKnownSeqNumber; },
                containerLoadedFromVersionId: () => { var _a; return (_a = this.loadedFromVersion) === null || _a === void 0 ? void 0 : _a.id; },
                containerLoadedFromVersionDate: () => { var _a; return (_a = this.loadedFromVersion) === null || _a === void 0 ? void 0 : _a.date; },
                // message information to associate errors with the specific execution state
                dmLastMsqSeqNumber: () => { var _a, _b; return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.sequenceNumber; },
                dmLastMsqSeqTimestamp: () => { var _a, _b; return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.timestamp; },
                dmLastMsqSeqClientId: () => { var _a, _b; return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.clientId; },
            },
        });
        // Prefix all events in this file with container-loader
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.ChildLogger.create(this.subLogger, "Container");
        this.connectionStateHandler = new _connectionStateHandler__WEBPACK_IMPORTED_MODULE_10__.ConnectionStateHandler({
            protocolHandler: () => this._protocolHandler,
            logConnectionStateChangeTelemetry: (value, oldState, reason) => this.logConnectionStateChangeTelemetry(value, oldState, reason),
            propagateConnectionState: () => this.propagateConnectionState(),
            isContainerLoaded: () => this.loaded,
            shouldClientJoinWrite: () => this._deltaManager.shouldJoinWrite(),
            maxClientLeaveWaitTime: this.loader.services.options.maxClientLeaveWaitTime,
        }, this.logger);
        this.connectionStateHandler.on(connectEventName, (opsBehind) => {
            this.emit(connectEventName, opsBehind);
        });
        this._deltaManager = this.createDeltaManager();
        // keep track of last time page was visible for telemetry
        if (typeof document === "object" && document !== null) {
            this.lastVisible = document.hidden ? _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_11__.performance.now() : undefined;
            document.addEventListener("visibilitychange", () => {
                if (document.hidden) {
                    this.lastVisible = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_11__.performance.now();
                }
                else {
                    // settimeout so this will hopefully fire after disconnect event if being hidden caused it
                    setTimeout(() => this.lastVisible = undefined, 0);
                }
            });
        }
        // We observed that most users of platform do not check Container.connected event on load, causing bugs.
        // As such, we are raising events when new listener pops up.
        // Note that we can raise both "disconnected" & "connect" events at the same time,
        // if we are in connecting stage.
        this.on("newListener", (event, listener) => {
            // Fire events on the end of JS turn, giving a chance for caller to be in consistent state.
            Promise.resolve().then(() => {
                switch (event) {
                    case dirtyContainerEvent:
                        if (this._dirtyContainer) {
                            listener(this._dirtyContainer);
                        }
                        break;
                    case savedContainerEvent:
                        if (!this._dirtyContainer) {
                            listener(this._dirtyContainer);
                        }
                        break;
                    case _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_12__.connectedEventName:
                        if (this.connected) {
                            listener(event, this.clientId);
                        }
                        break;
                    case _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_12__.disconnectedEventName:
                        if (!this.connected) {
                            listener(event);
                        }
                        break;
                    case connectEventName:
                        if (this.connectionState !== ConnectionState.Disconnected) {
                            listener(event);
                        }
                        break;
                    default:
                }
            }).catch((error) => {
                this.logger.sendErrorEvent({ eventName: "RaiseConnectedEventError" }, error);
            });
        });
    }
    /**
     * Load an existing container.
     */
    static async load(loader, loadOptions, pendingLocalState) {
        const container = new Container(loader, {
            containerUrl: loadOptions.containerUrl,
            clientDetailsOverride: loadOptions.clientDetailsOverride,
            id: loadOptions.docId,
            resolvedUrl: loadOptions.resolvedUrl,
            canReconnect: loadOptions.canReconnect,
        });
        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.PerformanceEvent.timedExecAsync(container.logger, { eventName: "Load" }, async (event) => {
            return new Promise((res, rej) => {
                const version = loadOptions.version;
                // always load unpaused with pending ops
                const pause = pendingLocalState !== undefined ? false : loadOptions.pause;
                const onClosed = (err) => {
                    // Depending where error happens, we can be attempting to connect to web socket
                    // and continuously retrying (consider offline mode)
                    // Host has no container to close, so it's prudent to do it here
                    const error = err !== null && err !== void 0 ? err : (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_13__.CreateContainerError)("Container closed without an error");
                    container.close(error);
                    rej(error);
                };
                container.on("closed", onClosed);
                container.load(version, pause === true, pendingLocalState)
                    .finally(() => {
                    container.removeListener("closed", onClosed);
                })
                    .then((props) => {
                    event.end(props);
                    res(container);
                }, (error) => {
                    const err = (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_13__.CreateContainerError)(error);
                    onClosed(err);
                });
            });
        });
    }
    /**
     * Create a new container in a detached state.
     */
    static async createDetached(loader, codeDetails) {
        const container = new Container(loader, {});
        await container.createDetached(codeDetails);
        return container;
    }
    /**
     * Create a new container in a detached state that is initialized with a
     * snapshot from a previous detached container.
     */
    static async rehydrateDetachedFromSnapshot(loader, snapshot) {
        const container = new Container(loader, {});
        await container.rehydrateDetachedFromSnapshot(snapshot);
        return container;
    }
    get storageService() {
        if (this._storageService === undefined) {
            throw new Error("Attempted to access storageService before it was defined");
        }
        return this._storageService;
    }
    get context() {
        if (this._context === undefined) {
            throw new Error("Attempted to access context before it was defined");
        }
        return this._context;
    }
    get protocolHandler() {
        if (this._protocolHandler === undefined) {
            throw new Error("Attempted to access protocolHandler before it was defined");
        }
        return this._protocolHandler;
    }
    get IFluidRouter() { return this; }
    get resolvedUrl() {
        return this._resolvedUrl;
    }
    get loadedFromVersion() {
        return this._loadedFromVersion;
    }
    /**
     * {@inheritDoc DeltaManager.readonly}
     * @deprecated - use readOnlyInfo
     */
    get readonly() {
        return this._deltaManager.readonly;
    }
    /**
     * {@inheritDoc DeltaManager.readonlyPermissions}
     * @deprecated - use readOnlyInfo
     */
    get readonlyPermissions() {
        return this._deltaManager.readonlyPermissions;
    }
    /**
     * {@inheritDoc DeltaManager.readOnlyInfo}
     */
    get readOnlyInfo() {
        return this._deltaManager.readOnlyInfo;
    }
    /**
     * {@inheritDoc DeltaManager.forceReadonly}
     */
    forceReadonly(readonly) {
        this._deltaManager.forceReadonly(readonly);
    }
    get closed() {
        return this._closed;
    }
    get id() {
        var _a;
        return (_a = this._id) !== null && _a !== void 0 ? _a : "";
    }
    get deltaManager() {
        return this._deltaManager;
    }
    get connectionState() {
        return this.connectionStateHandler.connectionState;
    }
    get connected() {
        return this.connectionStateHandler.connected;
    }
    /**
     * Service configuration details. If running in offline mode will be undefined otherwise will contain service
     * configuration details returned as part of the initial connection.
     */
    get serviceConfiguration() {
        return this._deltaManager.serviceConfiguration;
    }
    /**
     * The server provided id of the client.
     * Set once this.connected is true, otherwise undefined
     */
    get clientId() {
        return this.connectionStateHandler.clientId;
    }
    /**
     * The server provided claims of the client.
     * Set once this.connected is true, otherwise undefined
     */
    get scopes() {
        return this._deltaManager.scopes;
    }
    get clientDetails() {
        return this._deltaManager.clientDetails;
    }
    /**
     * @deprecated use codeDetails
     */
    get chaincodePackage() {
        return this.codeDetails;
    }
    get codeDetails() {
        var _a, _b;
        return (_b = (_a = this._context) === null || _a === void 0 ? void 0 : _a.codeDetails) !== null && _b !== void 0 ? _b : this.getCodeDetailsFromQuorum();
    }
    /**
     * Flag indicating whether the document already existed at the time of load
     */
    get existing() {
        return this._existing;
    }
    /**
     * Retrieves the audience associated with the document
     */
    get audience() {
        return this._audience;
    }
    /**
     * Returns true if container is dirty.
     * Which means data loss if container is closed at that same moment
     * Most likely that happens when there is no network connection to ordering service
     */
    get isDirty() {
        return this._dirtyContainer;
    }
    get serviceFactory() { return this.loader.services.documentServiceFactory; }
    get urlResolver() { return this.loader.services.urlResolver; }
    get options() { return this.loader.services.options; }
    get scope() { return this.loader.services.scope; }
    get codeLoader() { return this.loader.services.codeLoader; }
    /**
     * Retrieves the quorum associated with the document
     */
    getQuorum() {
        return this.protocolHandler.quorum;
    }
    close(error) {
        var _a, _b, _c;
        if (this._closed) {
            return;
        }
        this._closed = true;
        this.collabWindowTracker.stopSequenceNumberUpdate();
        this._deltaManager.close(error);
        (_a = this._protocolHandler) === null || _a === void 0 ? void 0 : _a.close();
        (_b = this._context) === null || _b === void 0 ? void 0 : _b.dispose(error !== undefined ? new Error(error.message) : undefined);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.connectionState === ConnectionState.Disconnected, 0x0cf /* "disconnect event was not raised!" */);
        if (error !== undefined) {
            // Log current sequence number - useful if we have access to a file to understand better
            // what op caused trouble (if it's related to op processing).
            // Runtime may provide sequence number as part of error object - this may not match DeltaManager
            // knowledge as old ops are processed when data stores / DDS are re-hydrated when delay-loaded
            this.logger.sendErrorEvent({
                eventName: "ContainerClose",
                sequenceNumber: (_c = error.sequenceNumber) !== null && _c !== void 0 ? _c : this._deltaManager.lastSequenceNumber,
            }, error);
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.loaded, 0x0d0 /* "Container in non-loaded state before close!" */);
            this.logger.sendTelemetryEvent({ eventName: "ContainerClose" });
        }
        this.emit("closed", error);
        this.removeAllListeners();
    }
    closeAndGetPendingLocalState() {
        // runtime matches pending ops to successful ones by clientId and client seq num, so we need to close the
        // container at the same time we get pending state, otherwise this container could reconnect and resubmit with
        // a new clientId and a future container using stale pending state without the new clientId would resubmit them
        this._deltaManager.close();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Attached, 0x0d1 /* "Container should be attached before close" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.resolvedUrl !== undefined && this.resolvedUrl.type === "fluid", 0x0d2 /* "resolved url should be valid Fluid url" */);
        const pendingState = {
            pendingRuntimeState: this.context.getPendingLocalState(),
            url: this.resolvedUrl.url,
        };
        this.close();
        return JSON.stringify(pendingState);
    }
    get attachState() {
        return this._attachState;
    }
    serialize() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Detached, 0x0d3 /* "Should only be called in detached container" */);
        const appSummary = this.context.createSummary();
        const protocolSummary = this.captureProtocolSummary();
        const snapshotTree = (0,_utils__WEBPACK_IMPORTED_MODULE_14__.convertProtocolAndAppSummaryToSnapshotTree)(protocolSummary, appSummary);
        return JSON.stringify(snapshotTree);
    }
    async attach(request) {
        var _a;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.loaded, 0x0d4 /* "not loaded" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.closed, 0x0d5 /* "closed" */);
        // If container is already attached or attach is in progress, return.
        if (this._attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Attached || this.attachInProgress) {
            return;
        }
        this.attachInProgress = true;
        try {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.deltaManager.inbound.length === 0, 0x0d6 /* "Inbound queue should be empty when attaching" */);
            // Only take a summary if the container is in detached state, otherwise we could have local changes.
            // In failed attach call, we would already have a summary cached.
            if (this._attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Detached) {
                // Get the document state post attach - possibly can just call attach but we need to change the
                // semantics around what the attach means as far as async code goes.
                const appSummary = this.context.createSummary();
                const protocolSummary = this.captureProtocolSummary();
                this.cachedAttachSummary = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.combineAppAndProtocolSummary)(appSummary, protocolSummary);
                // Set the state as attaching as we are starting the process of attaching container.
                // This should be fired after taking the summary because it is the place where we are
                // starting to attach the container to storage.
                // Also, this should only be fired in detached container.
                this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Attaching;
                this.emit("attaching");
            }
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!!this.cachedAttachSummary, 0x0d7 /* "Summary should be there either by this attach call or previous attach call!!" */);
            const createNewResolvedUrl = await this.urlResolver.resolve(request);
            (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_16__.ensureFluidResolvedUrl)(createNewResolvedUrl);
            // Actually go and create the resolved document
            if (this.service === undefined) {
                this.service = await this.serviceFactory.createContainer(this.cachedAttachSummary, createNewResolvedUrl, this.subLogger);
            }
            const resolvedUrl = this.service.resolvedUrl;
            (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_16__.ensureFluidResolvedUrl)(resolvedUrl);
            this._resolvedUrl = resolvedUrl;
            const url = await this.urlResolver.getAbsoluteUrl(resolvedUrl, "", (_a = this._context) === null || _a === void 0 ? void 0 : _a.codeDetails);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(url !== undefined, 0x0d8 /* "Container url undefined" */);
            this.containerUrl = url;
            const parsedUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_14__.parseUrl)(resolvedUrl.url);
            if (parsedUrl === undefined) {
                throw new Error("Unable to parse Url");
            }
            const [, docId] = parsedUrl.id.split("/");
            this._id = decodeURI(docId);
            if (this._storageService === undefined) {
                this._storageService = await this.getDocumentStorageService();
            }
            // This we can probably just pass the storage service to the blob manager - although ideally
            // there just isn't a blob manager
            this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Attached;
            this.emit("attached");
            this.cachedAttachSummary = undefined;
            // Propagate current connection state through the system.
            this.propagateConnectionState();
            if (!this.closed) {
                this.resumeInternal({ fetchOpsFromStorage: false, reason: "createDetached" });
            }
        }
        finally {
            this.attachInProgress = false;
        }
    }
    async request(path) {
        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.PerformanceEvent.timedExecAsync(this.logger, { eventName: "Request" }, async () => {
            return this.context.request(path);
        });
    }
    async snapshot(tagMessage, fullTree = false) {
        // Only snapshot once a code quorum has been established
        if (!this.protocolHandler.quorum.has("code") && !this.protocolHandler.quorum.has("code2")) {
            this.logger.sendTelemetryEvent({ eventName: "SkipSnapshot" });
            return;
        }
        // Stop inbound message processing while we complete the snapshot
        try {
            await this.deltaManager.inbound.pause();
            await this.snapshotCore(tagMessage, fullTree);
        }
        catch (ex) {
            this.logger.sendErrorEvent({ eventName: "SnapshotExceptionError" }, ex);
            throw ex;
        }
        finally {
            this.deltaManager.inbound.resume();
        }
    }
    setAutoReconnect(reconnect) {
        if (reconnect && this.closed) {
            throw new Error("Attempting to setAutoReconnect() a closed DeltaManager");
        }
        this._deltaManager.setAutomaticReconnect(reconnect);
        this.logger.sendTelemetryEvent({
            eventName: reconnect ? "AutoReconnectEnabled" : "AutoReconnectDisabled",
            connectionMode: this._deltaManager.connectionMode,
            connectionState: ConnectionState[this.connectionState],
        });
        // If container state is not attached and resumed, then don't connect to delta stream. Also don't set the
        // manual reconnection flag to true as we haven't made the initial connection yet.
        if (reconnect && this._attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Attached && this.resumedOpProcessingAfterLoad) {
            if (this.connectionState === ConnectionState.Disconnected) {
                // Only track this as a manual reconnection if we are truly the ones kicking it off.
                this.manualReconnectInProgress = true;
            }
            // Ensure connection to web socket
            this.connectToDeltaStream({ reason: "autoReconnect" }).catch((error) => {
                // All errors are reported through events ("error" / "disconnected") and telemetry in DeltaManager
                // So there shouldn't be a need to record error here.
                // But we have number of cases where reconnects do not happen, and no errors are recorded, so
                // adding this log point for easier diagnostics
                this.logger.sendTelemetryEvent({ eventName: "setAutoReconnectError" }, error);
            });
        }
    }
    resume() {
        if (!this.closed) {
            this.resumeInternal({ reason: "DocumentOpenResume" });
        }
    }
    resumeInternal(args) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.closed, 0x0d9 /* "Attempting to setAutoReconnect() a closed DeltaManager" */);
        // Resume processing ops
        if (!this.resumedOpProcessingAfterLoad) {
            this.resumedOpProcessingAfterLoad = true;
            this._deltaManager.inbound.resume();
            this._deltaManager.outbound.resume();
            this._deltaManager.inboundSignal.resume();
        }
        // Ensure connection to web socket
        // All errors are reported through events ("error" / "disconnected") and telemetry in DeltaManager
        this.connectToDeltaStream(args).catch(() => { });
    }
    get storage() {
        return this._storageService;
    }
    /**
     * Raise non-critical error to host. Calling this API will not close container.
     * For critical errors, please call Container.close(error).
     * @param error - an error to raise
     */
    raiseContainerWarning(warning) {
        // Some "warning" events come from outside the container and are logged
        // elsewhere (e.g. summarizing container). We shouldn't log these here.
        if (warning.logged !== true) {
            this.logContainerError(warning);
        }
        this.emit("warning", warning);
    }
    async reloadContext() {
        return this.reloadContextCore().catch((error) => {
            this.close((0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_13__.CreateContainerError)(error));
            throw error;
        });
    }
    hasNullRuntime() {
        return this.context.hasNullRuntime();
    }
    async getAbsoluteUrl(relativeUrl) {
        var _a;
        if (this.resolvedUrl === undefined) {
            return undefined;
        }
        return this.urlResolver.getAbsoluteUrl(this.resolvedUrl, relativeUrl, (_a = this._context) === null || _a === void 0 ? void 0 : _a.codeDetails);
    }
    async proposeCodeDetails(codeDetails) {
        if (!(0,_fluidframework_core_interfaces__WEBPACK_IMPORTED_MODULE_17__.isFluidCodeDetails)(codeDetails)) {
            throw new Error("Provided codeDetails are not IFluidCodeDetails");
        }
        if (this.codeLoader.IFluidCodeDetailsComparer) {
            const comparision = await this.codeLoader.IFluidCodeDetailsComparer.compare(codeDetails, this.getCodeDetailsFromQuorum());
            if (comparision !== undefined && comparision <= 0) {
                throw new Error("Proposed code details should be greater than the current");
            }
        }
        return this.getQuorum().propose("code", codeDetails)
            .then(() => true)
            .catch(() => false);
    }
    async reloadContextCore() {
        var _a, _b, _c;
        const codeDetails = this.getCodeDetailsFromQuorum();
        await Promise.all([
            this.deltaManager.inbound.pause(),
            this.deltaManager.inboundSignal.pause()
        ]);
        if ((await this.context.satisfies(codeDetails) === true) && !this.hasNullRuntime()) {
            this.deltaManager.inbound.resume();
            this.deltaManager.inboundSignal.resume();
            return;
        }
        let state = { hotSwap: false };
        if (this.options.hotSwapContext === true) {
            const prevState = await this.context.snapshotRuntimeState();
            state = { hotSwap: true, prevState };
        }
        this.context.dispose(new Error("ContextDisposedForReload"));
        // We always hot-swap, but we don't fire the contextDisposed event
        // if we are transitioning from a null runtime to a real runtime
        // with detached container we no longer need the null runtime, but for legacy
        // reasons need to keep it around (old documents without summary before code proposal).
        // client's shouldn't need to care about this transition, as it is a implementation detail.
        // if we didn't do this check, the clients would need to do it themselves,
        // which would futher spread the usage of the hasNullRuntime property
        // making it harder to deprecate.
        if (this.hasNullRuntime()) {
            if (!state.hotSwap) {
                state = { hotSwap: true, prevState: {} };
            }
        }
        else {
            this.emit("contextDisposed", codeDetails, (_a = this.context) === null || _a === void 0 ? void 0 : _a.codeDetails);
        }
        if (this.closed) {
            return;
        }
        if (!state.hotSwap) {
            this.close();
            return;
        }
        let snapshot;
        const blobs = new Map();
        if (state.prevState.snapshot !== undefined) {
            snapshot = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_18__.buildSnapshotTree)(state.prevState.snapshot.entries, blobs);
            /**
             * Should be removed / updated after issue #2914 is fixed.
             * There are currently two scenarios where this is called:
             * 1. When a new code proposal is accepted - This should be set to true before `this.loadContext` is
             * called which creates and loads the ContainerRuntime. This is because for "read" mode clients this
             * flag is false which causes ContainerRuntime to create the internal components again.
             * 2. When the first client connects in "write" mode - This happens when a client does not create the
             * Container in detached mode. In this case, when the code proposal is accepted, we come here and we
             * need to create the internal data stores in ContainerRuntime.
             * Once we move to using detached container everywhere, this can move outside this block.
             */
            this._existing = true;
        }
        if (blobs.size > 0) {
            const blobSize = (_b = this.storageService.policies) === null || _b === void 0 ? void 0 : _b.minBlobSize;
            this._storageService =
                new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_19__.BlobCacheStorageService(this.storageService, blobs);
            // ensure we did not lose that policy in the process of wrapping
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(blobSize === ((_c = this._storageService.policies) === null || _c === void 0 ? void 0 : _c.minBlobSize), 0x0da /* "blob size policy" */);
        }
        const attributes = {
            branch: this.id,
            minimumSequenceNumber: this._deltaManager.minimumSequenceNumber,
            sequenceNumber: this._deltaManager.lastSequenceNumber,
            term: this._deltaManager.referenceTerm,
        };
        await this.loadContext(codeDetails, attributes, snapshot, state.prevState);
        this.deltaManager.inbound.resume();
        this.deltaManager.inboundSignal.resume();
    }
    async snapshotCore(tagMessage, fullTree = false) {
        // Snapshots base document state and currently running context
        const root = this.snapshotBase();
        const dataStoreEntries = await this.context.snapshot(tagMessage, fullTree);
        // And then combine
        if (dataStoreEntries !== null) {
            root.entries.push(...dataStoreEntries.entries);
        }
        // Generate base snapshot message
        const deltaDetails = `${this._deltaManager.lastSequenceNumber}:${this._deltaManager.minimumSequenceNumber}`;
        const message = `Commit @${deltaDetails} ${tagMessage}`;
        // Pull in the prior version and snapshot tree to store against
        const lastVersion = await this.getVersion(this.id);
        const parents = lastVersion !== undefined ? [lastVersion.id] : [];
        // Write the full snapshot
        return this.storageService.write(root, parents, message, "");
    }
    snapshotBase() {
        const entries = [];
        const quorumSnapshot = this.protocolHandler.quorum.snapshot();
        entries.push({
            mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_20__.FileMode.File,
            path: "quorumMembers",
            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_20__.TreeEntry.Blob,
            value: {
                contents: JSON.stringify(quorumSnapshot.members),
                encoding: "utf-8",
            },
        });
        entries.push({
            mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_20__.FileMode.File,
            path: "quorumProposals",
            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_20__.TreeEntry.Blob,
            value: {
                contents: JSON.stringify(quorumSnapshot.proposals),
                encoding: "utf-8",
            },
        });
        entries.push({
            mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_20__.FileMode.File,
            path: "quorumValues",
            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_20__.TreeEntry.Blob,
            value: {
                contents: JSON.stringify(quorumSnapshot.values),
                encoding: "utf-8",
            },
        });
        // Save attributes for the document
        const documentAttributes = {
            branch: this.id,
            minimumSequenceNumber: this._deltaManager.minimumSequenceNumber,
            sequenceNumber: this._deltaManager.lastSequenceNumber,
            term: this._deltaManager.referenceTerm,
        };
        entries.push({
            mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_20__.FileMode.File,
            path: ".attributes",
            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_20__.TreeEntry.Blob,
            value: {
                contents: JSON.stringify(documentAttributes),
                encoding: "utf-8",
            },
        });
        // Output the tree
        const root = {
            entries,
        };
        return root;
    }
    async getVersion(version) {
        const versions = await this.storageService.getVersions(version, 1);
        return versions[0];
    }
    recordConnectStartTime() {
        if (this.connectionTransitionTimes[ConnectionState.Disconnected] === undefined) {
            this.connectionTransitionTimes[ConnectionState.Disconnected] = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_11__.performance.now();
        }
    }
    async connectToDeltaStream(args) {
        this.recordConnectStartTime();
        // All agents need "write" access, including summarizer.
        if (!this._canReconnect || !this.client.details.capabilities.interactive) {
            args.mode = "write";
        }
        return this._deltaManager.connect(args);
    }
    /**
     * Load container.
     *
     * @param specifiedVersion - one of the following
     *   - null: use ops, no snapshots
     *   - undefined - fetch latest snapshot
     *   - otherwise, version sha to load snapshot
     * @param pause - start the container in a paused state
     */
    async load(specifiedVersion, pause, pendingLocalState) {
        if (this._resolvedUrl === undefined) {
            throw new Error("Attempting to load without a resolved url");
        }
        this.service = await this.serviceFactory.createDocumentService(this._resolvedUrl, this.subLogger);
        let startConnectionP;
        // Ideally we always connect as "read" by default.
        // Currently that works with SPO & r11s, because we get "write" connection when connecting to non-existing file.
        // We should not rely on it by (one of them will address the issue, but we need to address both)
        // 1) switching create new flow to one where we create file by posting snapshot
        // 2) Fixing quorum workflows (have retry logic)
        // That all said, "read" does not work with memorylicious workflows (that opens two simultaneous
        // connections to same file) in two ways:
        // A) creation flow breaks (as one of the clients "sees" file as existing, and hits #2 above)
        // B) Once file is created, transition from view-only connection to write does not work - some bugs to be fixed.
        const connectionArgs = { reason: "DocumentOpen", mode: "write" };
        // Start websocket connection as soon as possible. Note that there is no op handler attached yet, but the
        // DeltaManager is resilient to this and will wait to start processing ops until after it is attached.
        if (!pause) {
            startConnectionP = this.connectToDeltaStream(connectionArgs);
            startConnectionP.catch((error) => { });
        }
        this._storageService = await this.getDocumentStorageService();
        this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Attached;
        // Fetch specified snapshot, but intentionally do not load from snapshot if specifiedVersion is null
        const { snapshot, versionId } = await this.fetchSnapshotTree(specifiedVersion);
        const attributes = await this.getDocumentAttributes(this.storageService, snapshot);
        // Attach op handlers to start processing ops
        this.attachDeltaManagerOpHandler(attributes);
        // ...load in the existing quorum
        // Initialize the protocol handler
        const protocolHandlerP = this.loadAndInitializeProtocolState(attributes, this.storageService, snapshot);
        let loadDetailsP;
        // Initialize document details - if loading a snapshot use that - otherwise we need to wait on
        // the initial details
        if (snapshot !== undefined) {
            this._existing = true;
            loadDetailsP = Promise.resolve();
        }
        else {
            if (startConnectionP === undefined) {
                startConnectionP = this.connectToDeltaStream(connectionArgs);
            }
            // Intentionally don't .catch on this promise - we'll let any error throw below in the await.
            loadDetailsP = startConnectionP.then((details) => {
                this._existing = details.existing;
            });
        }
        // LoadContext directly requires protocolHandler to be ready, and eventually calls
        // instantiateRuntime which will want to know existing state.  Wait for these promises to finish.
        [this._protocolHandler] = await Promise.all([protocolHandlerP, loadDetailsP]);
        const codeDetails = this.getCodeDetailsFromQuorum();
        await this.loadContext(codeDetails, attributes, snapshot, undefined, pendingLocalState);
        // Propagate current connection state through the system.
        this.propagateConnectionState();
        if (!pause) {
            this.resume();
        }
        // Internal context is fully loaded at this point
        this.loaded = true;
        return {
            existing: this._existing,
            sequenceNumber: attributes.sequenceNumber,
            version: versionId,
        };
    }
    async createDetached(source) {
        if (!(0,_fluidframework_core_interfaces__WEBPACK_IMPORTED_MODULE_17__.isFluidCodeDetails)(source)) {
            this.logger.send({
                eventName: "DetachCreateNotIFluidCodeDetails",
                category: "warning",
            });
        }
        const attributes = {
            branch: "",
            sequenceNumber: detachedContainerRefSeqNumber,
            term: 1,
            minimumSequenceNumber: 0,
        };
        // Seed the base quorum to be an empty list with a code quorum set
        const committedCodeProposal = {
            key: "code",
            value: source,
            approvalSequenceNumber: 0,
            commitSequenceNumber: 0,
            sequenceNumber: 0,
        };
        const members = [];
        const proposals = [];
        const values = [["code", committedCodeProposal]];
        this.attachDeltaManagerOpHandler(attributes);
        // We know this is create detached flow without snapshot.
        this._existing = false;
        // Need to just seed the source data in the code quorum. Quorum itself is empty
        this._protocolHandler = this.initializeProtocolState(attributes, members, proposals, values);
        // The load context - given we seeded the quorum - will be great
        await this.createDetachedContext(attributes);
        this.propagateConnectionState();
        this.loaded = true;
    }
    async rehydrateDetachedFromSnapshot(snapshotTree) {
        const attributes = await this.getDocumentAttributes(undefined, snapshotTree);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(attributes.sequenceNumber === 0, 0x0db /* "Seq number in detached container should be 0!!" */);
        this.attachDeltaManagerOpHandler(attributes);
        // We know this is create detached flow with snapshot.
        this._existing = true;
        // ...load in the existing quorum
        // Initialize the protocol handler
        this._protocolHandler =
            await this.loadAndInitializeProtocolState(attributes, undefined, snapshotTree);
        await this.createDetachedContext(attributes, snapshotTree);
        this.loaded = true;
        this.propagateConnectionState();
    }
    async getDocumentStorageService() {
        return this._deltaManager.connectToStorage();
    }
    async getDocumentAttributes(storage, tree) {
        if (tree === undefined) {
            return {
                branch: this.id,
                minimumSequenceNumber: 0,
                sequenceNumber: 0,
                term: 1,
            };
        }
        // Backward compatibility: old docs would have ".attributes" instead of "attributes"
        const attributesHash = ".protocol" in tree.trees
            ? tree.trees[".protocol"].blobs.attributes
            : tree.blobs[".attributes"];
        const attributes = storage !== undefined ? await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_21__.readAndParse)(storage, attributesHash)
            : (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_21__.readAndParseFromBlobs)(tree.trees[".protocol"].blobs, attributesHash);
        // Backward compatibility for older summaries with no term
        if (attributes.term === undefined) {
            attributes.term = 1;
        }
        return attributes;
    }
    async loadAndInitializeProtocolState(attributes, storage, snapshot) {
        let members = [];
        let proposals = [];
        let values = [];
        if (snapshot !== undefined) {
            const baseTree = ".protocol" in snapshot.trees ? snapshot.trees[".protocol"] : snapshot;
            if (storage !== undefined) {
                [members, proposals, values] = await Promise.all([
                    (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_21__.readAndParse)(storage, baseTree.blobs.quorumMembers),
                    (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_21__.readAndParse)(storage, baseTree.blobs.quorumProposals),
                    (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_21__.readAndParse)(storage, baseTree.blobs.quorumValues),
                ]);
            }
            else {
                members = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_21__.readAndParseFromBlobs)(snapshot.trees[".protocol"].blobs, baseTree.blobs.quorumMembers);
                proposals = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_21__.readAndParseFromBlobs)(snapshot.trees[".protocol"].blobs, baseTree.blobs.quorumProposals);
                values = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_21__.readAndParseFromBlobs)(snapshot.trees[".protocol"].blobs, baseTree.blobs.quorumValues);
            }
        }
        const protocolHandler = this.initializeProtocolState(attributes, members, proposals, values);
        return protocolHandler;
    }
    initializeProtocolState(attributes, members, proposals, values) {
        const protocol = new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_3__.ProtocolOpHandler(attributes.minimumSequenceNumber, attributes.sequenceNumber, attributes.term, members, proposals, values, (key, value) => this.submitMessage(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.Propose, { key, value }), (sequenceNumber) => this.submitMessage(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.Reject, sequenceNumber));
        const protocolLogger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.ChildLogger.create(this.subLogger, "ProtocolHandler");
        protocol.quorum.on("error", (error) => {
            protocolLogger.sendErrorEvent(error);
        });
        // Track membership changes and update connection state accordingly
        protocol.quorum.on("addMember", (clientId, details) => {
            this.connectionStateHandler.receivedAddMemberEvent(clientId);
        });
        protocol.quorum.on("removeMember", (clientId) => {
            this.connectionStateHandler.receivedRemoveMemberEvent(clientId);
        });
        protocol.quorum.on("addProposal", (proposal) => {
            if (proposal.key === "code" || proposal.key === "code2") {
                this.emit("codeDetailsProposed", proposal.value, proposal);
            }
        });
        protocol.quorum.on("approveProposal", (sequenceNumber, key, value) => {
            (0,_debug__WEBPACK_IMPORTED_MODULE_22__.debug)(`approved ${key}`);
            if (key === "code" || key === "code2") {
                (0,_debug__WEBPACK_IMPORTED_MODULE_22__.debug)(`codeProposal ${JSON.stringify(value)}`);
                if (!(0,_fluidframework_core_interfaces__WEBPACK_IMPORTED_MODULE_17__.isFluidCodeDetails)(value)) {
                    this.logger.send({
                        eventName: "CodeProposalNotIFluidCodeDetails",
                        category: "warning",
                    });
                }
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this.reloadContext();
            }
        });
        return protocol;
    }
    captureProtocolSummary() {
        const quorumSnapshot = this.protocolHandler.quorum.snapshot();
        // Save attributes for the document
        const documentAttributes = {
            branch: this.id,
            minimumSequenceNumber: this.protocolHandler.minimumSequenceNumber,
            sequenceNumber: this.protocolHandler.sequenceNumber,
            term: this.protocolHandler.term,
        };
        const summary = {
            tree: {
                attributes: {
                    content: JSON.stringify(documentAttributes),
                    type: 2 /* Blob */,
                },
                quorumMembers: {
                    content: JSON.stringify(quorumSnapshot.members),
                    type: 2 /* Blob */,
                },
                quorumProposals: {
                    content: JSON.stringify(quorumSnapshot.proposals),
                    type: 2 /* Blob */,
                },
                quorumValues: {
                    content: JSON.stringify(quorumSnapshot.values),
                    type: 2 /* Blob */,
                },
            },
            type: 1 /* Tree */,
        };
        return summary;
    }
    getCodeDetailsFromQuorum() {
        const quorum = this.protocolHandler.quorum;
        let pkg = quorum.get("code");
        // Back compat
        if (pkg === undefined) {
            pkg = quorum.get("code2");
        }
        return pkg;
    }
    get client() {
        var _a;
        const client = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.client) !== undefined
            ? this.options.client
            : {
                details: {
                    capabilities: { interactive: true },
                },
                mode: "read",
                permission: [],
                scopes: [],
                user: { id: "" },
            };
        if (this.clientDetailsOverride !== undefined) {
            lodash_merge__WEBPACK_IMPORTED_MODULE_0___default()(client.details, this.clientDetailsOverride);
        }
        return client;
    }
    /**
     * Returns true if connection is active, i.e. it's "write" connection and
     * container runtime was notified about this connection (i.e. we are up-to-date and could send ops).
     * This happens after client received its own joinOp and thus is in the quorum.
     * If it's not true, runtime is not in position to send ops.
     */
    activeConnection() {
        return this.connectionState === ConnectionState.Connected && this._deltaManager.connectionMode === "write";
    }
    createDeltaManager() {
        const deltaManager = new _deltaManager__WEBPACK_IMPORTED_MODULE_23__.DeltaManager(() => this.service, this.client, _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.ChildLogger.create(this.subLogger, "DeltaManager"), this._canReconnect, () => this.activeConnection());
        deltaManager.on(connectEventName, (details, opsBehind) => {
            var _a;
            this.connectionStateHandler.receivedConnectEvent(this._deltaManager.connectionMode, details, opsBehind);
            // Back-compat for new client and old server.
            this._audience.clear();
            for (const priorClient of (_a = details.initialClients) !== null && _a !== void 0 ? _a : []) {
                this._audience.addMember(priorClient.clientId, priorClient.client);
            }
        });
        deltaManager.once("submitOp", (message) => {
            this.connectionStateHandler.clientSentOps(this._deltaManager.connectionMode);
        });
        deltaManager.on("disconnect", (reason) => {
            this.manualReconnectInProgress = false;
            this.connectionStateHandler.receivedDisconnectEvent(reason);
        });
        deltaManager.on("throttled", (warning) => {
            this.raiseContainerWarning(warning);
        });
        deltaManager.on("readonly", (readonly) => {
            this.emit("readonly", readonly);
        });
        return deltaManager;
    }
    attachDeltaManagerOpHandler(attributes) {
        var _a;
        this._deltaManager.on("closed", (error) => {
            this.close(error);
        });
        // If we're the outer frame, do we want to do this?
        // Begin fetching any pending deltas once we know the base sequence #. Can this fail?
        // It seems like something, like reconnection, that we would want to retry but otherwise allow
        // the document to load
        this._deltaManager.attachOpHandler(attributes.minimumSequenceNumber, attributes.sequenceNumber, (_a = attributes.term) !== null && _a !== void 0 ? _a : 1, {
            process: (message) => this.processRemoteMessage(message),
            processSignal: (message) => {
                this.processSignal(message);
            },
        });
    }
    logConnectionStateChangeTelemetry(value, oldState, reason) {
        // Log actual event
        const time = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_11__.performance.now();
        this.connectionTransitionTimes[value] = time;
        const duration = time - this.connectionTransitionTimes[oldState];
        let durationFromDisconnected;
        let connectionMode;
        let connectionInitiationReason;
        let autoReconnect;
        let checkpointSequenceNumber;
        let sequenceNumber;
        let opsBehind;
        if (value === ConnectionState.Disconnected) {
            autoReconnect = this._deltaManager.reconnectMode;
        }
        else {
            connectionMode = this._deltaManager.connectionMode;
            sequenceNumber = this.deltaManager.lastSequenceNumber;
            if (value === ConnectionState.Connected) {
                durationFromDisconnected = time - this.connectionTransitionTimes[ConnectionState.Disconnected];
                durationFromDisconnected = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.TelemetryLogger.formatTick(durationFromDisconnected);
            }
            else {
                // This info is of most interest on establishing connection only.
                checkpointSequenceNumber = this.deltaManager.lastKnownSeqNumber;
                if (this.deltaManager.hasCheckpointSequenceNumber) {
                    opsBehind = checkpointSequenceNumber - sequenceNumber;
                }
            }
            if (this.firstConnection) {
                connectionInitiationReason = "InitialConnect";
            }
            else if (this.manualReconnectInProgress) {
                connectionInitiationReason = "ManualReconnect";
            }
            else {
                connectionInitiationReason = "AutoReconnect";
            }
        }
        this.logger.sendPerformanceEvent({
            eventName: `ConnectionStateChange_${ConnectionState[value]}`,
            from: ConnectionState[oldState],
            duration,
            durationFromDisconnected,
            reason,
            connectionInitiationReason,
            socketDocumentId: this._deltaManager.socketDocumentId,
            pendingClientId: this.connectionStateHandler.pendingClientId,
            clientId: this.clientId,
            connectionMode,
            autoReconnect,
            opsBehind,
            online: _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_24__.OnlineStatus[(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_24__.isOnline)()],
            lastVisible: this.lastVisible !== undefined ? _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_11__.performance.now() - this.lastVisible : undefined,
            checkpointSequenceNumber,
            sequenceNumber,
        });
        if (value === ConnectionState.Connected) {
            this.firstConnection = false;
            this.manualReconnectInProgress = false;
        }
    }
    propagateConnectionState() {
        const logOpsOnReconnect = this.connectionState === ConnectionState.Connected &&
            !this.firstConnection &&
            this._deltaManager.connectionMode === "write";
        if (logOpsOnReconnect) {
            this.messageCountAfterDisconnection = 0;
        }
        const state = this.connectionState === ConnectionState.Connected;
        if (!this.context.disposed) {
            this.context.setConnectionState(state, this.clientId);
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.protocolHandler !== undefined, 0x0dc /* "Protocol handler should be set here" */);
        this.protocolHandler.quorum.setConnectionState(state, this.clientId);
        (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_12__.raiseConnectedEvent)(this.logger, this, state, this.clientId);
        if (logOpsOnReconnect) {
            this.logger.sendTelemetryEvent({ eventName: "OpsSentOnReconnect", count: this.messageCountAfterDisconnection });
        }
    }
    submitContainerMessage(type, contents, batch, metadata) {
        const outboundMessageType = type;
        switch (outboundMessageType) {
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.Operation:
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.RemoteHelp:
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.Summarize:
                break;
            default:
                this.close((0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_13__.CreateContainerError)(`Runtime can't send arbitrary message type: ${type}`));
                return -1;
        }
        return this.submitMessage(type, contents, batch, metadata);
    }
    submitMessage(type, contents, batch, metadata) {
        if (this.connectionState !== ConnectionState.Connected) {
            this.logger.sendErrorEvent({ eventName: "SubmitMessageWithNoConnection", type });
            return -1;
        }
        this.messageCountAfterDisconnection += 1;
        this.collabWindowTracker.stopSequenceNumberUpdate();
        return this._deltaManager.submit(type, contents, batch, metadata);
    }
    processRemoteMessage(message) {
        // Check and report if we're getting messages from a clientId that we previously
        // flagged as shouldHaveLeft, or from a client that's not in the quorum but should be
        if (message.clientId != null) {
            let errorMsg;
            const client = this.getQuorum().getMember(message.clientId);
            if (client === undefined && message.type !== _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.ClientJoin) {
                errorMsg = "messageClientIdMissingFromQuorum";
            }
            else if ((client === null || client === void 0 ? void 0 : client.shouldHaveLeft) === true) {
                errorMsg = "messageClientIdShouldHaveLeft";
            }
            if (errorMsg !== undefined) {
                const error = new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_13__.DataCorruptionError(errorMsg, (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_13__.extractSafePropertiesFromMessage)(message));
                this.close((0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_13__.CreateContainerError)(error));
            }
        }
        const local = this.clientId === message.clientId;
        // Forward non system messages to the loaded runtime for processing
        if (!(0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_3__.isSystemMessage)(message)) {
            this.context.process(message, local, undefined);
        }
        // Allow the protocol handler to process the message
        const result = this.protocolHandler.processMessage(message, local);
        this.collabWindowTracker.scheduleSequenceNumberUpdate(message, result.immediateNoOp === true);
        this.emit("op", message);
        return result;
    }
    submitSignal(message) {
        this._deltaManager.submitSignal(JSON.stringify(message));
    }
    processSignal(message) {
        // No clientId indicates a system signal message.
        if (message.clientId === null) {
            const innerContent = message.content;
            if (innerContent.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.ClientJoin) {
                const newClient = innerContent.content;
                this._audience.addMember(newClient.clientId, newClient.client);
            }
            else if (innerContent.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.ClientLeave) {
                const leftClientId = innerContent.content;
                this._audience.removeMember(leftClientId);
            }
        }
        else {
            const local = this.clientId === message.clientId;
            this.context.processSignal(message, local);
        }
    }
    /**
     * Get the most recent snapshot, or a specific version.
     * @param specifiedVersion - The specific version of the snapshot to retrieve
     * @returns The snapshot requested, or the latest snapshot if no version was specified, plus version ID
     */
    async fetchSnapshotTree(specifiedVersion) {
        var _a;
        if (specifiedVersion === null) {
            return {};
        }
        const version = await this.getVersion(specifiedVersion !== null && specifiedVersion !== void 0 ? specifiedVersion : this.id);
        if (version === undefined && specifiedVersion !== undefined) {
            // We should have a defined version to load from if specified version requested
            this.logger.sendErrorEvent({ eventName: "NoVersionFoundWhenSpecified", id: specifiedVersion });
        }
        this._loadedFromVersion = version;
        const snapshot = (_a = await this.storageService.getSnapshotTree(version)) !== null && _a !== void 0 ? _a : undefined;
        if (snapshot === undefined && version !== undefined) {
            this.logger.sendErrorEvent({ eventName: "getSnapshotTreeFailed", id: version.id });
        }
        return { snapshot, versionId: version === null || version === void 0 ? void 0 : version.id };
    }
    async loadContext(codeDetails, attributes, snapshot, previousRuntimeState = {}, pendingLocalState) {
        var _a, _b;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(((_a = this._context) === null || _a === void 0 ? void 0 : _a.disposed) !== false, 0x0dd /* "Existing context not disposed" */);
        // If this assert fires, our state tracking is likely not synchronized between COntainer & runtime.
        if (this._dirtyContainer) {
            this.logger.sendErrorEvent({ eventName: "DirtyContainerReloadContainer" });
        }
        // The relative loader will proxy requests to '/' to the loader itself assuming no non-cache flags
        // are set. Global requests will still go directly to the loader
        const loader = new _loader__WEBPACK_IMPORTED_MODULE_25__.RelativeLoader(this.loader, () => this.containerUrl);
        const previousCodeDetails = (_b = this._context) === null || _b === void 0 ? void 0 : _b.codeDetails;
        this._context = await _containerContext__WEBPACK_IMPORTED_MODULE_26__.ContainerContext.createOrLoad(this, this.scope, this.codeLoader, codeDetails, snapshot, attributes, new _deltaManagerProxy__WEBPACK_IMPORTED_MODULE_27__.DeltaManagerProxy(this._deltaManager), new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_28__.QuorumProxy(this.protocolHandler.quorum), loader, (warning) => this.raiseContainerWarning(warning), (type, contents, batch, metadata) => this.submitContainerMessage(type, contents, batch, metadata), (message) => this.submitSignal(message), (error) => this.close(error), Container.version, previousRuntimeState, (dirty) => {
            this._dirtyContainer = dirty;
            this.emit(dirty ? dirtyContainerEvent : savedContainerEvent);
        }, pendingLocalState);
        loader.resolveContainer(this);
        this.emit("contextChanged", codeDetails, previousCodeDetails);
    }
    /**
     * Creates a new, unattached container context
     */
    async createDetachedContext(attributes, snapshot) {
        const codeDetails = this.getCodeDetailsFromQuorum();
        if (codeDetails === undefined) {
            throw new Error("pkg should be provided in create flow!!");
        }
        await this.loadContext(codeDetails, attributes, snapshot);
    }
    // Please avoid calling it directly.
    // raiseContainerWarning() is the right flow for most cases
    logContainerError(warning) {
        this.logger.sendErrorEvent({ eventName: "ContainerWarning" }, warning);
    }
}
Container.version = "^0.1.0";
//# sourceMappingURL=container.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-loader/lib/containerContext.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-loader/lib/containerContext.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContainerContext": () => (/* binding */ ContainerContext)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/container-definitions */ "../../node_modules/@fluidframework/container-definitions/lib/runtime.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/promises.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _nullRuntime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nullRuntime */ "../../node_modules/@fluidframework/container-loader/lib/nullRuntime.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */




const PackageNotFactoryError = "Code package does not implement IRuntimeFactory";
class ContainerContext {
    constructor(container, scope, codeLoader, codeDetails, _baseSnapshot, attributes, deltaManager, quorum, loader, raiseContainerWarning, submitFn, submitSignalFn, closeFn, version, previousRuntimeState, updateDirtyContainerState, pendingLocalState) {
        this.container = container;
        this.scope = scope;
        this.codeLoader = codeLoader;
        this.codeDetails = codeDetails;
        this._baseSnapshot = _baseSnapshot;
        this.attributes = attributes;
        this.deltaManager = deltaManager;
        this.quorum = quorum;
        this.loader = loader;
        this.raiseContainerWarning = raiseContainerWarning;
        this.submitFn = submitFn;
        this.submitSignalFn = submitSignalFn;
        this.closeFn = closeFn;
        this.version = version;
        this.previousRuntimeState = previousRuntimeState;
        this.updateDirtyContainerState = updateDirtyContainerState;
        this.pendingLocalState = pendingLocalState;
        this._disposed = false;
        this.fluidModuleP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.LazyPromise(async () => {
            if (this.codeDetails === undefined) {
                const fluidExport = new _nullRuntime__WEBPACK_IMPORTED_MODULE_1__.NullChaincode();
                return {
                    fluidExport,
                };
            }
            const fluidModule = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, { eventName: "CodeLoad" }, async () => this.codeLoader.load(this.codeDetails));
            return fluidModule;
        });
        this.logger = container.subLogger;
        this.attachListener();
    }
    static async createOrLoad(container, scope, codeLoader, codeDetails, baseSnapshot, attributes, deltaManager, quorum, loader, raiseContainerWarning, submitFn, submitSignalFn, closeFn, version, previousRuntimeState, updateDirtyContainerState, pendingLocalState) {
        const context = new ContainerContext(container, scope, codeLoader, codeDetails, baseSnapshot, attributes, deltaManager, quorum, loader, raiseContainerWarning, submitFn, submitSignalFn, closeFn, version, previousRuntimeState, updateDirtyContainerState, pendingLocalState);
        await context.load();
        return context;
    }
    get id() {
        return this.container.id;
    }
    get clientId() {
        return this.container.clientId;
    }
    get clientDetails() {
        return this.container.clientDetails;
    }
    get existing() {
        return this.container.existing;
    }
    get branch() {
        return this.attributes.branch;
    }
    get connected() {
        return this.container.connected;
    }
    get canSummarize() {
        return "summarize" in this.runtime;
    }
    get serviceConfiguration() {
        return this.container.serviceConfiguration;
    }
    get audience() {
        return this.container.audience;
    }
    get options() {
        return this.container.options;
    }
    get configuration() {
        const config = {
            scopes: this.container.scopes,
        };
        return config;
    }
    get baseSnapshot() {
        return this._baseSnapshot;
    }
    get storage() {
        return this.container.storage;
    }
    get runtime() {
        if (this._runtime === undefined) {
            throw new Error("Attempted to access runtime before it was defined");
        }
        return this._runtime;
    }
    get disposed() {
        return this._disposed;
    }
    attachListener() {
        this.container.once("attaching", () => {
            var _a, _b;
            (_b = (_a = this._runtime) === null || _a === void 0 ? void 0 : _a.setAttachState) === null || _b === void 0 ? void 0 : _b.call(_a, _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Attaching);
        });
        this.container.once("attached", () => {
            var _a, _b;
            (_b = (_a = this._runtime) === null || _a === void 0 ? void 0 : _a.setAttachState) === null || _b === void 0 ? void 0 : _b.call(_a, _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Attached);
        });
    }
    dispose(error) {
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        this.runtime.dispose(error);
        this.quorum.dispose();
        this.deltaManager.dispose();
    }
    async snapshot(tagMessage = "", fullTree = false) {
        return this.runtime.snapshot(tagMessage, fullTree);
    }
    getLoadedFromVersion() {
        return this.container.loadedFromVersion;
    }
    /**
     * Snapshot and close the runtime, and return its state if available
     */
    async snapshotRuntimeState() {
        return this.runtime.stop();
    }
    get attachState() {
        return this.container.attachState;
    }
    createSummary() {
        return this.runtime.createSummary();
    }
    setConnectionState(connected, clientId) {
        const runtime = this.runtime;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(connected === this.connected, 0x0de /* "Mismatch in connection state while setting" */);
        runtime.setConnectionState(connected, clientId);
    }
    process(message, local, context) {
        this.runtime.process(message, local, context);
    }
    processSignal(message, local) {
        this.runtime.processSignal(message, local);
    }
    async request(path) {
        return this.runtime.request(path);
    }
    async reloadContext() {
        return this.container.reloadContext();
    }
    hasNullRuntime() {
        return this.runtime instanceof _nullRuntime__WEBPACK_IMPORTED_MODULE_1__.NullRuntime;
    }
    async getAbsoluteUrl(relativeUrl) {
        return this.container.getAbsoluteUrl(relativeUrl);
    }
    getPendingLocalState() {
        return this.runtime.getPendingLocalState();
    }
    /**
     * Determines if the current code details of the context
     * satisfy the incoming constraint code details
     */
    async satisfies(constraintCodeDetails) {
        const comparers = [];
        const maybeCompareCodeLoader = this.codeLoader;
        if (maybeCompareCodeLoader.IFluidCodeDetailsComparer !== undefined) {
            comparers.push(maybeCompareCodeLoader.IFluidCodeDetailsComparer);
        }
        const maybeCompareExport = (await this.fluidModuleP).fluidExport;
        if ((maybeCompareExport === null || maybeCompareExport === void 0 ? void 0 : maybeCompareExport.IFluidCodeDetailsComparer) !== undefined) {
            comparers.push(maybeCompareExport.IFluidCodeDetailsComparer);
        }
        // if there are not comparers it is not possible to know
        // if the current satisfy the incoming, so return false,
        // as assuming they do not satisfy is safer .e.g we will
        // reload, rather than potentially running with
        // incompatible code
        if (comparers.length === 0) {
            return false;
        }
        for (const comparer of comparers) {
            const satisfies = await comparer.satisfies(this.codeDetails, constraintCodeDetails);
            if (satisfies === false) {
                return false;
            }
        }
        return true;
    }
    async load() {
        const maybeFactory = (await this.fluidModuleP).fluidExport.IRuntimeFactory;
        if (maybeFactory === undefined) {
            throw new Error(PackageNotFactoryError);
        }
        this._runtime = await maybeFactory.instantiateRuntime(this);
    }
}
//# sourceMappingURL=containerContext.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-loader/lib/debug.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-loader/lib/debug.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debug": () => (/* binding */ debug)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "../../node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packageVersion */ "../../node_modules/@fluidframework/container-loader/lib/packageVersion.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


const debug = debug__WEBPACK_IMPORTED_MODULE_0___default()("fluid:container-loader");
debug(`Package: ${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgName} - Version: ${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgVersion}`);
//# sourceMappingURL=debug.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-loader/lib/deltaManager.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-loader/lib/deltaManager.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeltaManager": () => (/* binding */ DeltaManager)
/* harmony export */ });
/* unused harmony export ReconnectMode */
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @fluidframework/container-definitions */ "../../node_modules/@fluidframework/container-definitions/lib/error.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/typedEventEmitter.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/performanceBrowser.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/events.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @fluidframework/driver-definitions */ "../../node_modules/@fluidframework/driver-definitions/lib/storage.js");
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @fluidframework/protocol-base */ "../../node_modules/@fluidframework/protocol-base/lib/protocol.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/scopes.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/protocol.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/network.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/parallelRequests.js");
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/container-utils */ "../../node_modules/@fluidframework/container-utils/lib/error.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./debug */ "../../node_modules/@fluidframework/container-loader/lib/debug.js");
/* harmony import */ var _deltaQueue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./deltaQueue */ "../../node_modules/@fluidframework/container-loader/lib/deltaQueue.js");
/* harmony import */ var _networkUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./networkUtils */ "../../node_modules/@fluidframework/container-loader/lib/networkUtils.js");
/* harmony import */ var _retriableDocumentStorageService__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./retriableDocumentStorageService */ "../../node_modules/@fluidframework/container-loader/lib/retriableDocumentStorageService.js");
/* harmony import */ var _prefetchDocumentStorageService__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./prefetchDocumentStorageService */ "../../node_modules/@fluidframework/container-loader/lib/prefetchDocumentStorageService.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */














const MaxReconnectDelaySeconds = 8;
const InitialReconnectDelaySeconds = 1;
const MissingFetchDelaySeconds = 0.1;
const MaxFetchDelaySeconds = 10;
const MaxBatchDeltas = 5000; // Please see Issue #5211 for data around batch sizing
const DefaultChunkSize = 16 * 1024;
function getNackReconnectInfo(nackContent) {
    const reason = `Nack: ${nackContent.message}`;
    const canRetry = nackContent.code !== 403;
    return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.createGenericNetworkError)(reason, canRetry, nackContent.retryAfter, nackContent.code);
}
function createReconnectError(prefix, err) {
    const error = (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.CreateContainerError)(err);
    const error2 = Object.create(error);
    error2.message = `${prefix}: ${error.message}`;
    error2.canRetry = true;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return error2;
}
var ReconnectMode;
(function (ReconnectMode) {
    ReconnectMode["Never"] = "Never";
    ReconnectMode["Disabled"] = "Disabled";
    ReconnectMode["Enabled"] = "Enabled";
})(ReconnectMode || (ReconnectMode = {}));
/**
 * Implementation of IDocumentDeltaConnection that does not support submitting
 * or receiving ops. Used in storage-only mode.
 */
class NoDeltaStream extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.TypedEventEmitter {
    constructor() {
        super(...arguments);
        this.clientId = "storage-only client";
        this.claims = {
            scopes: [_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.ScopeType.DocRead],
        };
        this.mode = "read";
        this.existing = true;
        this.maxMessageSize = 0;
        this.version = "";
        this.initialMessages = [];
        this.initialSignals = [];
        this.initialClients = [];
        this.serviceConfiguration = undefined;
        this.checkpointSequenceNumber = undefined;
    }
    submit(messages) {
        this.emit("nack", this.clientId, messages.map((operation) => {
            return {
                operation,
                content: { message: "Cannot submit with storage-only connection", code: 403 },
            };
        }));
    }
    submitSignal(message) {
        this.emit("nack", this.clientId, {
            operation: message,
            content: { message: "Cannot submit signal with storage-only connection", code: 403 },
        });
    }
    close() {
    }
}
/**
 * Manages the flow of both inbound and outbound messages. This class ensures that shared objects receive delta
 * messages in order regardless of possible network conditions or timings causing out of order delivery.
 */
class DeltaManager extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.TypedEventEmitter {
    constructor(serviceProvider, client, logger, reconnectAllowed, _active) {
        super();
        this.serviceProvider = serviceProvider;
        this.client = client;
        this.logger = logger;
        this._active = _active;
        // tracks host requiring read-only mode.
        this._forceReadonly = false;
        this.pending = [];
        this.fetching = false;
        // The minimum sequence number and last sequence number received from the server
        this.minSequenceNumber = 0;
        // There are three numbers we track
        // * lastQueuedSequenceNumber is the last queued sequence number. If there are gaps in seq numbers, then this number
        //   is not updated until we cover that gap, so it increases each time by 1.
        // * lastObservedSeqNumber is  an estimation of last known sequence number for container in storage. It's initially
        //   populated at web socket connection time (if storage provides that info) and is  updated once ops shows up.
        //   It's never less than lastQueuedSequenceNumber
        // * lastProcessedSequenceNumber - last processed sequence number
        this.lastQueuedSequenceNumber = 0;
        this.lastObservedSeqNumber = 0;
        this.lastProcessedSequenceNumber = 0;
        this.baseTerm = 0;
        // The sequence number we initially loaded from
        this.initSequenceNumber = 0;
        this.clientSequenceNumber = 0;
        this.clientSequenceNumberObserved = 0;
        this.closed = false;
        this.deltaStreamDelayId = (0,uuid__WEBPACK_IMPORTED_MODULE_4__.default)();
        this.deltaStorageDelayId = (0,uuid__WEBPACK_IMPORTED_MODULE_4__.default)();
        this.messageBuffer = [];
        this.connectFirstConnection = true;
        this.throttlingIdSet = new Set();
        this.timeTillThrottling = 0;
        // True if current connection has checkpoint information
        // I.e. we know how far behind the client was at the time of establishing connection
        this._hasCheckpointSequenceNumber = false;
        this.opHandler = (documentId, messages) => {
            if (messages instanceof Array) {
                this.enqueueMessages(messages);
            }
            else {
                this.enqueueMessages([messages]);
            }
        };
        this.signalHandler = (message) => {
            this._inboundSignal.push(message);
        };
        // Always connect in write mode after getting nacked.
        this.nackHandler = (documentId, messages) => {
            const message = messages[0];
            // TODO: we should remove this check when service updates?
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (this._readonlyPermissions) {
                this.close((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.createWriteError)("WriteOnReadOnlyDocument"));
            }
            // check message.content for Back-compat with old service.
            const reconnectInfo = message.content !== undefined
                ? getNackReconnectInfo(message.content) :
                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.createGenericNetworkError)(`Nack: unknown reason`, true);
            if (this.reconnectMode !== ReconnectMode.Enabled) {
                this.logger.sendErrorEvent({
                    eventName: "NackWithNoReconnect",
                    reason: reconnectInfo.message,
                    mode: this.connectionMode,
                });
            }
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.reconnectOnError("write", reconnectInfo);
        };
        // Connection mode is always read on disconnect/error unless the system mode was write.
        this.disconnectHandler = (disconnectReason) => {
            // Note: we might get multiple disconnect calls on same socket, as early disconnect notification
            // ("server_disconnect", ODSP-specific) is mapped to "disconnect"
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.reconnectOnError(this.defaultReconnectionMode, createReconnectError("Disconnect", disconnectReason));
        };
        this.errorHandler = (error) => {
            // Observation based on early pre-production telemetry:
            // We are getting transport errors from WebSocket here, right before or after "disconnect".
            // This happens only in Firefox.
            (0,_networkUtils__WEBPACK_IMPORTED_MODULE_5__.logNetworkFailure)(this.logger, { eventName: "DeltaConnectionError" }, error);
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.reconnectOnError(this.defaultReconnectionMode, createReconnectError("error", error));
        };
        this.pongHandler = (latency) => {
            this.emit("pong", latency);
        };
        this.clientDetails = this.client.details;
        this.defaultReconnectionMode = this.client.mode;
        this._reconnectMode = reconnectAllowed ? ReconnectMode.Enabled : ReconnectMode.Never;
        this._inbound = new _deltaQueue__WEBPACK_IMPORTED_MODULE_6__.DeltaQueue((op) => {
            this.processInboundMessage(op);
        });
        this._inbound.on("error", (error) => {
            this.close((0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.CreateProcessingError)(error, this.lastMessage));
        });
        // Outbound message queue. The outbound queue is represented as a queue of an array of ops. Ops contained
        // within an array *must* fit within the maxMessageSize and are guaranteed to be ordered sequentially.
        this._outbound = new _deltaQueue__WEBPACK_IMPORTED_MODULE_6__.DeltaQueue((messages) => {
            if (this.connection === undefined) {
                throw new Error("Attempted to submit an outbound message without connection");
            }
            this.connection.submit(messages);
        });
        this._outbound.on("error", (error) => {
            this.close((0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.CreateContainerError)(error));
        });
        // Inbound signal queue
        this._inboundSignal = new _deltaQueue__WEBPACK_IMPORTED_MODULE_6__.DeltaQueue((message) => {
            if (this.handler === undefined) {
                throw new Error("Attempted to process an inbound signal without a handler attached");
            }
            this.handler.processSignal({
                clientId: message.clientId,
                content: JSON.parse(message.content),
            });
        });
        this._inboundSignal.on("error", (error) => {
            this.close((0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.CreateContainerError)(error));
        });
        // Require the user to start the processing
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this._inbound.pause();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this._outbound.pause();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this._inboundSignal.pause();
    }
    get active() { return this._active(); }
    get disposed() { return this.closed; }
    get IDeltaSender() { return this; }
    /**
     * Tells if  current connection has checkpoint information.
     * I.e. we know how far behind the client was at the time of establishing connection
     */
    get hasCheckpointSequenceNumber() {
        // Valid to be called only if we have active connection.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.connection !== undefined, 0x0df /* "Missing active connection" */);
        return this._hasCheckpointSequenceNumber;
    }
    get inbound() {
        return this._inbound;
    }
    get outbound() {
        return this._outbound;
    }
    get inboundSignal() {
        return this._inboundSignal;
    }
    get initialSequenceNumber() {
        return this.initSequenceNumber;
    }
    get lastSequenceNumber() {
        return this.lastProcessedSequenceNumber;
    }
    get lastMessage() {
        return this.lastProcessedMessage;
    }
    get lastKnownSeqNumber() {
        return this.lastObservedSeqNumber;
    }
    get referenceTerm() {
        return this.baseTerm;
    }
    get minimumSequenceNumber() {
        return this.minSequenceNumber;
    }
    get maxMessageSize() {
        var _a, _b, _c, _d, _e;
        return (_e = (_c = (_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.serviceConfiguration) === null || _b === void 0 ? void 0 : _b.maxMessageSize) !== null && _c !== void 0 ? _c : (_d = this.connection) === null || _d === void 0 ? void 0 : _d.maxMessageSize) !== null && _e !== void 0 ? _e : DefaultChunkSize;
    }
    get version() {
        if (this.connection === undefined) {
            throw new Error("Cannot check version without a connection");
        }
        return this.connection.version;
    }
    get serviceConfiguration() {
        var _a;
        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.serviceConfiguration;
    }
    get scopes() {
        var _a;
        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.claims.scopes;
    }
    get socketDocumentId() {
        var _a;
        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.claims.documentId;
    }
    /**
     * The current connection mode, initially read.
     */
    get connectionMode() {
        if (this.connection === undefined) {
            return "read";
        }
        return this.connection.mode;
    }
    /**
     * Tells if container is in read-only mode.
     * Data stores should listen for "readonly" notifications and disallow user
     * making changes to data stores.
     * Readonly state can be because of no storage write permission,
     * or due to host forcing readonly mode for container.
     * It is undefined if we have not yet established websocket connection
     * and do not know if user has write access to a file.
     * @deprecated - use readOnlyInfo
     */
    get readonly() {
        if (this._forceReadonly) {
            return true;
        }
        return this._readonlyPermissions;
    }
    /**
     * Tells if user has no write permissions for file in storage
     * It is undefined if we have not yet established websocket connection
     * and do not know if user has write access to a file.
     * @deprecated - use readOnlyInfo
     */
    get readonlyPermissions() {
        return this._readonlyPermissions;
    }
    get readOnlyInfo() {
        const storageOnly = this.connection !== undefined && this.connection instanceof NoDeltaStream;
        if (storageOnly || this._forceReadonly || this._readonlyPermissions === true) {
            return {
                readonly: true,
                forced: this._forceReadonly,
                permissions: this._readonlyPermissions,
                storageOnly,
            };
        }
        return { readonly: this._readonlyPermissions };
    }
    /**
     * Automatic reconnecting enabled or disabled.
     * If set to Never, then reconnecting will never be allowed.
     */
    get reconnectMode() {
        return this._reconnectMode;
    }
    shouldJoinWrite() {
        return this.clientSequenceNumber !== this.clientSequenceNumberObserved;
    }
    async connectToStorage() {
        var _a, _b, _c;
        if (this.storageService !== undefined) {
            return this.storageService;
        }
        const service = this.serviceProvider();
        if (service === undefined) {
            throw new Error("Not attached");
        }
        let storageService = await service.connectToStorage();
        // Enable prefetching for the service unless it has a caching policy set otherwise:
        if (((_a = storageService.policies) === null || _a === void 0 ? void 0 : _a.caching) !== _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_8__.LoaderCachingPolicy.NoCaching) {
            storageService = new _prefetchDocumentStorageService__WEBPACK_IMPORTED_MODULE_9__.PrefetchDocumentStorageService(storageService);
        }
        this.storageService = new _retriableDocumentStorageService__WEBPACK_IMPORTED_MODULE_10__.RetriableDocumentStorageService(storageService, this, this.logger);
        // ensure we did not lose that policy in the process of wrapping
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(((_b = storageService.policies) === null || _b === void 0 ? void 0 : _b.minBlobSize) === ((_c = this.storageService.policies) === null || _c === void 0 ? void 0 : _c.minBlobSize), 0x0e0 /* "lost minBlobSize policy" */);
        return this.storageService;
    }
    /**
     * Enables or disables automatic reconnecting.
     * Will throw an error if reconnectMode set to Never.
     */
    setAutomaticReconnect(reconnect) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this._reconnectMode !== ReconnectMode.Never, 0x0e1 /* "Cannot toggle automatic reconnect if reconnect is set to Never." */);
        this._reconnectMode = reconnect ? ReconnectMode.Enabled : ReconnectMode.Disabled;
    }
    /**
     * Sends signal to runtime (and data stores) to be read-only.
     * Hosts may have read only views, indicating to data stores that no edits are allowed.
     * This is independent from this._readonlyPermissions (permissions) and this.connectionMode
     * (server can return "write" mode even when asked for "read")
     * Leveraging same "readonly" event as runtime & data stores should behave the same in such case
     * as in read-only permissions.
     * But this.active can be used by some DDSes to figure out if ops can be sent
     * (for example, read-only view still participates in code proposals / upgrades decisions)
     *
     * Forcing Readonly does not prevent DDS from generating ops. It is up to user code to honour
     * the readonly flag. If ops are generated, they will accumulate locally and not be sent. If
     * there are pending in the outbound queue, it will stop sending until force readonly is
     * cleared.
     *
     * @param readonly - set or clear force readonly.
     */
    forceReadonly(readonly) {
        const oldValue = this.readonly;
        this._forceReadonly = readonly;
        if (oldValue !== this.readonly) {
            let reconnect = false;
            if (this.readonly === true) {
                // If we switch to readonly while connected, we should disconnect first
                // See comment in the "readonly" event handler to deltaManager set up by
                // the ContainerRuntime constructor
                reconnect = this.disconnectFromDeltaStream("Force readonly");
            }
            (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_11__.safeRaiseEvent)(this, this.logger, "readonly", this.readonly);
            if (reconnect) {
                // reconnect if we disconnected from before.
                this.triggerConnect({ reason: "forceReadonly", mode: "read", fetchOpsFromStorage: false });
            }
        }
    }
    set_readonlyPermissions(readonly) {
        const oldValue = this.readonly;
        this._readonlyPermissions = readonly;
        if (oldValue !== this.readonly) {
            (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_11__.safeRaiseEvent)(this, this.logger, "readonly", this.readonly);
        }
    }
    dispose() {
        throw new Error("Not implemented.");
    }
    /**
     * Sets the sequence number from which inbound messages should be returned
     */
    attachOpHandler(minSequenceNumber, sequenceNumber, term, handler) {
        (0,_debug__WEBPACK_IMPORTED_MODULE_12__.debug)("Attached op handler", sequenceNumber);
        this.initSequenceNumber = sequenceNumber;
        this.lastProcessedSequenceNumber = sequenceNumber;
        this.baseTerm = term;
        this.minSequenceNumber = minSequenceNumber;
        this.lastQueuedSequenceNumber = sequenceNumber;
        this.lastObservedSeqNumber = sequenceNumber;
        // We will use same check in other places to make sure all the seq number above are set properly.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.handler === undefined, 0x0e2 /* "DeltaManager already has attached op handler!" */);
        this.handler = handler;
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!!this.handler, 0x0e3 /* "Newly set op handler is null/undefined!" */);
        this._inbound.resume();
        this._inboundSignal.resume();
        // We could have connected to delta stream before getting here
        // If so, it's time to process any accumulated ops
        // Or request OPs from snapshot / or point zero (if we have no ops at all)
        if (this.pending.length > 0) {
            this.processPendingOps("DocumentOpen");
        }
        else if (this.connection !== undefined || this.connectionP !== undefined) {
            this.fetchMissingDeltas("DocumentOpen", this.lastQueuedSequenceNumber);
        }
    }
    static detailsFromConnection(connection) {
        return {
            claims: connection.claims,
            clientId: connection.clientId,
            existing: connection.existing,
            checkpointSequenceNumber: connection.checkpointSequenceNumber,
            get initialClients() { return connection.initialClients; },
            maxMessageSize: connection.maxMessageSize,
            mode: connection.mode,
            serviceConfiguration: connection.serviceConfiguration,
            version: connection.version,
        };
    }
    async connect(args) {
        const connection = await this.connectCore(args);
        return DeltaManager.detailsFromConnection(connection);
    }
    /**
     * Start the connection. Any error should result in container being close.
     * And report the error if it excape for any reason.
     * @param args - The connection arguments
     */
    triggerConnect(args) {
        this.connectCore(args).catch((err) => {
            // Errors are raised as "error" event and close container.
            // Have a catch-all case in case we missed something
            if (!this.closed) {
                this.logger.sendErrorEvent({ eventName: "ConnectException" }, err);
            }
        });
    }
    async connectCore(args) {
        var _a, _b, _c;
        if (this.connection !== undefined) {
            return this.connection;
        }
        if (this.connectionP !== undefined) {
            return this.connectionP;
        }
        const fetchOpsFromStorage = (_a = args.fetchOpsFromStorage) !== null && _a !== void 0 ? _a : true;
        let requestedMode = (_b = args.mode) !== null && _b !== void 0 ? _b : this.defaultReconnectionMode;
        // if we have any non-acked ops from last connection, reconnect as "write".
        // without that we would connect in view-only mode, which will result in immediate
        // firing of "connected" event from Container and switch of current clientId (as tracked
        // by all DDSes). This will make it impossible to figure out if ops actually made it through,
        // so DDSes will immediately resubmit all pending ops, and some of them will be duplicates, corrupting document
        if (this.shouldJoinWrite()) {
            requestedMode = "write";
        }
        // Note: There is race condition here.
        // We want to issue request to storage as soon as possible, to
        // reduce latency of becoming current, thus this code here.
        // But there is no ordering between fetching OPs and connection to delta stream
        // As result, we might be behind by the time we connect to delta stream
        // In case of r/w connection, that's not an issue, because we will hear our
        // own "join" message and realize any gap client has in ops.
        // But for view-only connection, we have no such signal, and with no traffic
        // on the wire, we might be always behind.
        // See comment at the end of setupNewSuccessfulConnection()
        this.logger.debugAssert(this.handler !== undefined || fetchOpsFromStorage); // on boot, always fetch ops!
        if (fetchOpsFromStorage && this.handler !== undefined) {
            this.fetchMissingDeltas(args.reason, this.lastQueuedSequenceNumber);
        }
        const docService = this.serviceProvider();
        if (docService === undefined) {
            throw new Error("Container is not attached");
        }
        if (((_c = docService.policies) === null || _c === void 0 ? void 0 : _c.storageOnly) === true) {
            const connection = new NoDeltaStream();
            this.connectionP = new Promise((resolve) => {
                this.setupNewSuccessfulConnection(connection, "read");
                resolve(connection);
            });
            return this.connectionP;
        }
        // The promise returned from connectCore will settle with a resolved connection or reject with error
        const connectCore = async () => {
            let connection;
            let delay = InitialReconnectDelaySeconds;
            let connectRepeatCount = 0;
            const connectStartTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_13__.performance.now();
            // This loop will keep trying to connect until successful, with a delay between each iteration.
            while (connection === undefined) {
                if (this.closed) {
                    throw new Error("Attempting to connect a closed DeltaManager");
                }
                connectRepeatCount++;
                try {
                    this.client.mode = requestedMode;
                    connection = await docService.connectToDeltaStream(this.client);
                }
                catch (origError) {
                    const error = (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.CreateContainerError)(origError);
                    // Socket.io error when we connect to wrong socket, or hit some multiplexing bug
                    if (!(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.canRetryOnError)(origError)) {
                        this.close(error);
                        // eslint-disable-next-line @typescript-eslint/no-throw-literal
                        throw error;
                    }
                    // Log error once - we get too many errors in logs when we are offline,
                    // and unfortunately there is no reliable way to detect that.
                    if (connectRepeatCount === 1) {
                        (0,_networkUtils__WEBPACK_IMPORTED_MODULE_5__.logNetworkFailure)(this.logger, {
                            delay,
                            eventName: "DeltaConnectionFailureToConnect",
                        }, origError);
                    }
                    const retryDelayFromError = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.getRetryDelayFromError)(origError);
                    delay = retryDelayFromError !== null && retryDelayFromError !== void 0 ? retryDelayFromError : Math.min(delay * 2, MaxReconnectDelaySeconds);
                    if (retryDelayFromError !== undefined) {
                        this.emitDelayInfo(this.deltaStreamDelayId, retryDelayFromError, error);
                    }
                    await (0,_networkUtils__WEBPACK_IMPORTED_MODULE_5__.waitForConnectedState)(delay * 1000);
                }
            }
            // If we retried more than once, log an event about how long it took
            if (connectRepeatCount > 1) {
                this.logger.sendTelemetryEvent({
                    attempts: connectRepeatCount,
                    duration: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_14__.TelemetryLogger.formatTick(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_13__.performance.now() - connectStartTime),
                    eventName: "MultipleDeltaConnectionFailures",
                });
            }
            this.setupNewSuccessfulConnection(connection, requestedMode);
            return connection;
        };
        // This promise settles as soon as we know the outcome of the connection attempt
        this.connectionP = new Promise((resolve, reject) => {
            // Regardless of how the connection attempt concludes, we'll clear the promise and remove the listener
            // Reject the connection promise if the DeltaManager gets closed during connection
            const cleanupAndReject = (error) => {
                this.connectionP = undefined;
                this.removeListener("closed", cleanupAndReject);
                reject(error);
            };
            this.on("closed", cleanupAndReject);
            // Attempt the connection
            connectCore().then((connection) => {
                this.connectionP = undefined;
                this.removeListener("closed", cleanupAndReject);
                resolve(connection);
            }).catch(cleanupAndReject);
        });
        return this.connectionP;
    }
    flush() {
        if (this.messageBuffer.length === 0) {
            return;
        }
        // The prepareFlush event allows listeners to append metadata to the batch prior to submission.
        this.emit("prepareSend", this.messageBuffer);
        this._outbound.push(this.messageBuffer);
        this.messageBuffer = [];
    }
    /**
     * Submits the given delta returning the client sequence number for the message. Contents is the actual
     * contents of the message. appData is optional metadata that can be attached to the op by the app.
     *
     * If batch is set to true then the submit will be batched - and as a result guaranteed to be ordered sequentially
     * in the global sequencing space. The batch will be flushed either when flush is called or when a non-batched
     * op is submitted.
     */
    submit(type, contents, batch = false, metadata) {
        // TODO need to fail if gets too large
        // const serializedContent = JSON.stringify(this.messageBuffer);
        // const maxOpSize = this.context.deltaManager.maxMessageSize;
        var _a, _b;
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        if (this.readonly) {
            this.close((0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.CreateContainerError)("Op is sent in read-only document state"));
            return -1;
        }
        // reset clientSequenceNumber if we are using new clientId.
        // we keep info about old connection as long as possible to be able to account for all non-acked ops
        // that we pick up on next connection.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!!this.connection, 0x0e4 /* "Lost old connection!" */);
        if (this.lastSubmittedClientId !== ((_a = this.connection) === null || _a === void 0 ? void 0 : _a.clientId)) {
            this.lastSubmittedClientId = (_b = this.connection) === null || _b === void 0 ? void 0 : _b.clientId;
            this.clientSequenceNumber = 0;
            this.clientSequenceNumberObserved = 0;
        }
        const service = this.clientDetails.type === undefined || this.clientDetails.type === ""
            ? "unknown"
            : this.clientDetails.type;
        // Start adding trace for the op.
        const traces = [
            {
                action: "start",
                service,
                timestamp: Date.now(),
            }
        ];
        const message = {
            clientSequenceNumber: ++this.clientSequenceNumber,
            contents: JSON.stringify(contents),
            metadata,
            referenceSequenceNumber: this.lastProcessedSequenceNumber,
            traces,
            type,
        };
        this.emit("submitOp", message);
        if (!batch) {
            this.flush();
            this.messageBuffer.push(message);
            this.flush();
        }
        else {
            this.messageBuffer.push(message);
        }
        return message.clientSequenceNumber;
    }
    submitSignal(content) {
        if (this.connection !== undefined) {
            this.connection.submitSignal(content);
        }
        else {
            this.logger.sendErrorEvent({ eventName: "submitSignalDisconnected" });
        }
    }
    async getDeltas(telemetryEventSuffix, from, // exclusive
    to, // exclusive
    callback) {
        const docService = this.serviceProvider();
        if (docService === undefined) {
            throw new Error("Delta manager is not attached");
        }
        if (this.deltaStorageP === undefined) {
            this.deltaStorageP = docService.connectToDeltaStorage();
        }
        const telemetryEvent = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_14__.PerformanceEvent.start(this.logger, {
            eventName: `GetDeltas_${telemetryEventSuffix}`,
            from,
            to,
        });
        let deltasRetrievedTotal = 0;
        let requests = 0;
        let lastFetch;
        const manager = new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.ParallelRequests(from + 1, // from is exclusive, but ParallelRequests uses inclusive left
        to, // exclusive right
        MaxBatchDeltas, this.logger, async (request, _from, _to, strongTo) => {
            requests++;
            return this.getSingleOpBatch(request, _from, _to, telemetryEvent, strongTo);
        }, (deltas) => {
            deltasRetrievedTotal += deltas.length;
            lastFetch = deltas[deltas.length - 1].sequenceNumber;
            _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_14__.PerformanceEvent.timedExec(this.logger, { eventName: "GetDeltas_OpProcessing", count: deltas.length }, () => callback(deltas), { end: true, cancel: "error" });
        });
        // Staging: starting with no concurrency, listening for feedback first.
        // In future releases we will switch to actual concurrency
        await manager.run(1 /* concurrency */);
        telemetryEvent.end({
            lastFetch,
            deltasRetrievedTotal,
            requests,
            lastQueuedSequenceNumber: this.lastQueuedSequenceNumber,
        });
    }
    /**
     * Retrieve single batch of ops
     * @param request - request index
     * @param from - inclusive boundary
     * @param to - exclusive boundary
     * @param telemetryEvent - telemetry event used to track consecutive batch of requests
     * @param strongTo - tells if ops in range from...to have to be there and have to be retrieved.
     * If false, returning less ops would mean we reached end of file.
     * @returns - an object with resulting ops and cancellation / partial result flags
     */
    async getSingleOpBatch(request, from, to, telemetryEvent, strongTo) {
        let deltaStorage;
        let lastSuccessTime;
        let retry = 0;
        const deltas = [];
        let deltasRetrievedTotal = 0;
        const nothing = { partial: false, cancel: true, payload: [] };
        const start = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_13__.performance.now();
        while (!this.closed) {
            retry++;
            let delay = Math.min(MaxFetchDelaySeconds, MissingFetchDelaySeconds * Math.pow(2, retry));
            let canRetry = false;
            try {
                // Connect to the delta storage endpoint
                if (deltaStorage === undefined) {
                    deltaStorage = await this.deltaStorageP;
                }
                // Issue async request for deltas - limit the number fetched to MaxBatchDeltas
                canRetry = true;
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(deltaStorage !== undefined, 0x0e5 /* "delta storage undefined while getting single batch!" */);
                // left is inclusive for ParallelRequests, but exclusive for IDocumentDeltaStorageService
                // right is exclusive for both
                const deltasP = deltaStorage.get(from - 1, to);
                const { messages, partialResult } = await deltasP;
                deltas.push(...messages);
                const deltasRetrievedLast = messages.length;
                deltasRetrievedTotal += deltasRetrievedLast;
                if (deltasRetrievedLast !== 0 || !strongTo) {
                    telemetryEvent.reportProgress({
                        chunkDeltas: deltasRetrievedTotal,
                        chunkFrom: from,
                        chunkTo: to,
                        chunkRequests: retry,
                        chunkDuration: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_14__.TelemetryLogger.formatTick(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_13__.performance.now() - start),
                    });
                    return { payload: deltas, cancel: false, partial: partialResult };
                }
                // Storage does not have ops we need.
                // Attempt to fetch more deltas. If we didn't receive any in the previous call we up our retry
                // count since something prevented us from seeing those deltas
                if (lastSuccessTime === undefined) {
                    lastSuccessTime = Date.now();
                }
                else if (Date.now() - lastSuccessTime > 30000) {
                    // If we are connected and receiving proper responses from server, but can't get any ops back,
                    // then give up after some time. This likely indicates the issue with ordering service not flushing
                    // ops to storage quick enough, and possibly waiting for summaries, while summarizer can't get
                    // current as it can't get ops.
                    telemetryEvent.cancel({
                        category: "error",
                        error: "too many retries",
                        retry,
                        request,
                        deltasRetrievedTotal,
                        replayFrom: from,
                        to,
                    });
                    this.close((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.createGenericNetworkError)("Failed to retrieve ops from storage: giving up after too many retries", false /* canRetry */));
                    return nothing;
                }
            }
            catch (origError) {
                canRetry = canRetry && (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.canRetryOnError)(origError);
                const error = (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.CreateContainerError)(origError);
                lastSuccessTime = undefined;
                (0,_networkUtils__WEBPACK_IMPORTED_MODULE_5__.logNetworkFailure)(this.logger, {
                    eventName: "GetDeltas_Error",
                    fetchTo: to,
                    from,
                    request,
                    retry,
                }, origError);
                if (!canRetry) {
                    // It's game over scenario.
                    telemetryEvent.cancel({ category: "error" }, origError);
                    this.close(error);
                    return nothing;
                }
                const retryAfter = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.getRetryDelayFromError)(origError);
                if (retryAfter !== undefined && retryAfter >= 0) {
                    this.emitDelayInfo(this.deltaStorageDelayId, retryAfter, error);
                    delay = retryAfter;
                }
            }
            if (to !== undefined && this.lastQueuedSequenceNumber >= to) {
                // the client caught up while we were trying to fetch ops from storage
                // bail out since we no longer need to request these ops
                return nothing;
            }
            await (0,_networkUtils__WEBPACK_IMPORTED_MODULE_5__.waitForConnectedState)(delay * 1000);
        }
        // Might need to change to non-error event
        telemetryEvent.cancel({ error: "container closed" });
        return nothing;
    }
    /**
     * Closes the connection and clears inbound & outbound queues.
     */
    close(error) {
        var _a;
        if (this.closed) {
            return;
        }
        this.closed = true;
        (_a = this.storageService) === null || _a === void 0 ? void 0 : _a.dispose();
        // This raises "disconnect" event if we have active connection.
        this.disconnectFromDeltaStream(error !== undefined ? `${error.message}` : "Container closed");
        this._inbound.clear();
        this._outbound.clear();
        this._inboundSignal.clear();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this._inbound.pause();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this._inboundSignal.pause();
        // Drop pending messages - this will ensure catchUp() does not go into infinite loop
        this.pending = [];
        // Notify everyone we are in read-only state.
        // Useful for data stores in case we hit some critical error,
        // to switch to a mode where user edits are not accepted
        this.set_readonlyPermissions(true);
        // This needs to be the last thing we do (before removing listeners), as it causes
        // Container to dispose context and break ability of data stores / runtime to "hear"
        // from delta manager, including notification (above) about readonly state.
        this.emit("closed", error);
        this.removeAllListeners();
    }
    refreshDelayInfo(id) {
        this.throttlingIdSet.delete(id);
        if (this.throttlingIdSet.size === 0) {
            this.timeTillThrottling = 0;
        }
    }
    emitDelayInfo(id, delaySeconds, error) {
        const timeNow = Date.now();
        this.throttlingIdSet.add(id);
        if (delaySeconds > 0 && (timeNow + delaySeconds > this.timeTillThrottling)) {
            this.timeTillThrottling = timeNow + delaySeconds;
            const throttlingError = {
                errorType: _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_16__.ContainerErrorType.throttlingError,
                message: `Service busy/throttled: ${error.message}`,
                retryAfterSeconds: delaySeconds,
            };
            this.emit("throttled", throttlingError);
        }
    }
    /**
     * Once we've successfully gotten a connection, we need to set up state, attach event listeners, and process
     * initial messages.
     * @param connection - The newly established connection
     */
    setupNewSuccessfulConnection(connection, requestedMode) {
        var _a;
        // Old connection should have been cleaned up before establishing a new one
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.connection === undefined, 0x0e6 /* "old connection exists on new connection setup" */);
        this.connection = connection;
        // Does information in scopes & mode matches?
        // If we asked for "write" and got "read", then file is read-only
        // But if we ask read, server can still give us write.
        const readonly = !connection.claims.scopes.includes(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.ScopeType.DocWrite);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(requestedMode === "read" || readonly === (this.connectionMode === "read"), 0x0e7 /* "claims/connectionMode mismatch" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!readonly || this.connectionMode === "read", 0x0e8 /* "readonly perf with write connection" */);
        this.set_readonlyPermissions(readonly);
        this.refreshDelayInfo(this.deltaStreamDelayId);
        if (this.closed) {
            // Raise proper events, Log telemetry event and close connection.
            this.disconnectFromDeltaStream(`Disconnect on close`);
            return;
        }
        // We cancel all ops on lost of connectivity, and rely on DDSes to resubmit them.
        // Semantics are not well defined for batches (and they are broken right now on disconnects anyway),
        // but it's safe to assume (until better design is put into place) that batches should not exist
        // across multiple connections. Right now we assume runtime will not submit any ops in disconnected
        // state. As requirements change, so should these checks.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.messageBuffer.length === 0, 0x0e9 /* "messageBuffer is not empty on new connection" */);
        this._outbound.resume();
        connection.on("op", this.opHandler);
        connection.on("signal", this.signalHandler);
        connection.on("nack", this.nackHandler);
        connection.on("disconnect", this.disconnectHandler);
        connection.on("error", this.errorHandler);
        connection.on("pong", this.pongHandler);
        const initialMessages = connection.initialMessages;
        this._hasCheckpointSequenceNumber = false;
        // Some storages may provide checkpointSequenceNumber to identify how far client is behind.
        const checkpointSequenceNumber = connection.checkpointSequenceNumber;
        if (checkpointSequenceNumber !== undefined) {
            this._hasCheckpointSequenceNumber = true;
            this.updateLatestKnownOpSeqNumber(checkpointSequenceNumber);
        }
        // Update knowledge of how far we are behind, before raising "connect" event
        // This is duplication of what enqueueMessages() does, but we have to raise event before we get there,
        // so duplicating update logic here as well.
        if (initialMessages.length > 0) {
            this._hasCheckpointSequenceNumber = true;
            this.updateLatestKnownOpSeqNumber(initialMessages[initialMessages.length - 1].sequenceNumber);
        }
        // Notify of the connection
        // WARNING: This has to happen before processInitialMessages() call below.
        // If not, we may not update Container.pendingClientId in time before seeing our own join session op.
        this.emit("connect", DeltaManager.detailsFromConnection(connection), this._hasCheckpointSequenceNumber ? this.lastKnownSeqNumber - this.lastSequenceNumber : undefined);
        this.processInitialMessages(initialMessages, (_a = connection.initialSignals) !== null && _a !== void 0 ? _a : [], this.connectFirstConnection ? "InitialOps" : "ReconnectOps");
        // If we got some initial ops, then we know the gap and call above fetched ops to fill it.
        // Same is true for "write" mode even if we have no ops - we will get self "join" ops very very soon.
        // However if we are connecting as view-only, then there is no good signal to realize if client is behind.
        // Thus we have to hit storage to see if any ops are there.
        if (initialMessages.length === 0) {
            if (checkpointSequenceNumber !== undefined) {
                // We know how far we are behind (roughly). If it's non-zero gap, fetch ops right away.
                if (checkpointSequenceNumber > this.lastQueuedSequenceNumber) {
                    this.fetchMissingDeltas("AfterConnection", this.lastQueuedSequenceNumber);
                }
                // we do not know the gap, and we will not learn about it if socket is quite - have to ask.
            }
            else if (connection.mode !== "write") {
                this.fetchMissingDeltas("AfterConnection", this.lastQueuedSequenceNumber);
            }
        }
        this.connectFirstConnection = false;
    }
    /**
     * Disconnect the current connection.
     * @param reason - Text description of disconnect reason to emit with disconnect event
     */
    disconnectFromDeltaStream(reason) {
        if (this.connection === undefined) {
            return false;
        }
        const connection = this.connection;
        // Avoid any re-entrancy - clear object reference
        this.connection = undefined;
        // Remove listeners first so we don't try to retrigger this flow accidentally through reconnectOnError
        connection.off("op", this.opHandler);
        connection.off("signal", this.signalHandler);
        connection.off("nack", this.nackHandler);
        connection.off("disconnect", this.disconnectHandler);
        connection.off("error", this.errorHandler);
        connection.off("pong", this.pongHandler);
        // We cancel all ops on lost of connectivity, and rely on DDSes to resubmit them.
        // Semantics are not well defined for batches (and they are broken right now on disconnects anyway),
        // but it's safe to assume (until better design is put into place) that batches should not exist
        // across multiple connections. Right now we assume runtime will not submit any ops in disconnected
        // state. As requirements change, so should these checks.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.messageBuffer.length === 0, 0x0ea /* "messageBuffer is not empty on disconnect" */);
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this._outbound.pause();
        this._outbound.clear();
        this.emit("disconnect", reason);
        connection.close();
        return true;
    }
    /**
     * Disconnect the current connection and reconnect.
     * @param connection - The connection that wants to reconnect - no-op if it's different from this.connection
     * @param requestedMode - Read or write
     * @param reconnectInfo - Error reconnect information including whether or not to reconnect
     * @returns A promise that resolves when the connection is reestablished or we stop trying
     */
    async reconnectOnError(requestedMode, error) {
        // We quite often get protocol errors before / after observing nack/disconnect
        // we do not want to run through same sequence twice.
        // If we're already disconnected/disconnecting it's not appropriate to call this again.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.connection !== undefined, 0x0eb /* "Missing connection for reconnect" */);
        this.disconnectFromDeltaStream(error.message);
        // If reconnection is not an option, close the DeltaManager
        const canRetry = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.canRetryOnError)(error);
        if (this.reconnectMode === ReconnectMode.Never || !canRetry) {
            // Do not raise container error if we are closing just because we lost connection.
            // Those errors (like IdleDisconnect) would show up in telemetry dashboards and
            // are very misleading, as first initial reaction - some logic is broken.
            this.close(canRetry ? undefined : error);
        }
        // If closed then we can't reconnect
        if (this.closed) {
            return;
        }
        if (this.reconnectMode === ReconnectMode.Enabled) {
            const delay = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.getRetryDelayFromError)(error);
            if (delay !== undefined) {
                this.emitDelayInfo(this.deltaStreamDelayId, delay, error);
                await (0,_networkUtils__WEBPACK_IMPORTED_MODULE_5__.waitForConnectedState)(delay * 1000);
            }
            this.triggerConnect({ reason: "reconnect", mode: requestedMode, fetchOpsFromStorage: false });
        }
    }
    processInitialMessages(messages, signals, reason) {
        if (messages.length > 0) {
            this.catchUp(messages, reason);
        }
        for (const signal of signals) {
            this._inboundSignal.push(signal);
        }
    }
    // returns parts of message (in string format) that should never change for a given message.
    // Used for message comparison. It attempts to avoid comparing fields that potentially may differ.
    // for example, it's not clear if serverMetadata or timestamp property is a property of message or server state.
    // We only extract the most obvious fields that are sufficient (with high probability) to detect sequence number
    // reuse.
    // Also payload goes to telemetry, so no PII, including content!!
    // Note: It's possible for a duplicate op to be broadcasted and have everything the same except the timestamp.
    comparableMessagePayload(m) {
        return `${m.clientId}-${m.type}-${m.minimumSequenceNumber}-${m.referenceSequenceNumber}-${m.timestamp}`;
    }
    enqueueMessages(messages, telemetryEventSuffix = "OutOfOrderMessage") {
        var _a, _b, _c;
        if (this.handler === undefined) {
            // We did not setup handler yet.
            // This happens when we connect to web socket faster than we get attributes for container
            // and thus faster than attachOpHandler() is called
            // this.lastProcessedSequenceNumber is still zero, so we can't rely on this.fetchMissingDeltas()
            // to do the right thing.
            this.pending = this.pending.concat(messages);
            return;
        }
        let duplicateStart;
        let duplicateEnd;
        let duplicateCount = 0;
        if (messages.length > 0) {
            this.updateLatestKnownOpSeqNumber(messages[messages.length - 1].sequenceNumber);
        }
        const n = (_a = this.previouslyProcessedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(n === undefined || n === this.lastQueuedSequenceNumber, 0x0ec /* "Unexpected value for previously processed message's sequence number" */);
        for (const message of messages) {
            // Check that the messages are arriving in the expected order
            if (message.sequenceNumber <= this.lastQueuedSequenceNumber) {
                duplicateCount++;
                if (duplicateStart === undefined || duplicateStart > message.sequenceNumber) {
                    duplicateStart = message.sequenceNumber;
                }
                if (duplicateEnd === undefined || duplicateEnd < message.sequenceNumber) {
                    duplicateEnd = message.sequenceNumber;
                }
                // Validate that we do not have data loss, i.e. sequencing is reset and started again
                // with numbers that this client already observed before.
                if (((_b = this.previouslyProcessedMessage) === null || _b === void 0 ? void 0 : _b.sequenceNumber) === message.sequenceNumber) {
                    const message1 = this.comparableMessagePayload(this.previouslyProcessedMessage);
                    const message2 = this.comparableMessagePayload(message);
                    if (message1 !== message2) {
                        const error = new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.DataCorruptionError("Two messages with same seq# and different payload!", {
                            clientId: (_c = this.connection) === null || _c === void 0 ? void 0 : _c.clientId,
                            sequenceNumber: message.sequenceNumber,
                            message1,
                            message2,
                        });
                        this.close(error);
                    }
                }
            }
            else if (message.sequenceNumber !== this.lastQueuedSequenceNumber + 1) {
                this.pending.push(message);
                this.fetchMissingDeltas(telemetryEventSuffix, this.lastQueuedSequenceNumber, message.sequenceNumber);
            }
            else {
                this.lastQueuedSequenceNumber = message.sequenceNumber;
                this.previouslyProcessedMessage = message;
                this._inbound.push(message);
                if (this.pending.length > 0) {
                    // we processed a correctly sequenced inbound op while some are pending
                    // pending might include ops after the current sequence number, so process them now
                    this.processPendingOps(`EnqueueMessages_${telemetryEventSuffix}`);
                }
            }
        }
        if (duplicateCount !== 0) {
            this.logger.sendTelemetryEvent({
                eventName: `DuplicateMessages_${telemetryEventSuffix}`,
                start: duplicateStart,
                end: duplicateEnd,
                count: duplicateCount,
            });
        }
    }
    processInboundMessage(message) {
        var _a, _b;
        const startTime = Date.now();
        this.lastProcessedMessage = message;
        // All non-system messages are coming from some client, and should have clientId
        // System messages may have no clientId (but some do, like propose, noop, summarize)
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(message.clientId !== undefined
            || (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_17__.isSystemMessage)(message), 0x0ed /* "non-system message have to have clientId" */);
        // if we have connection, and message is local, then we better treat is as local!
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.connection === undefined
            || this.connection.clientId !== message.clientId
            || this.lastSubmittedClientId === message.clientId, 0x0ee /* "Not accounting local messages correctly" */);
        if (this.lastSubmittedClientId !== undefined && this.lastSubmittedClientId === message.clientId) {
            const clientSequenceNumber = message.clientSequenceNumber;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.clientSequenceNumberObserved < clientSequenceNumber, 0x0ef /* "client seq# not growing" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(clientSequenceNumber <= this.clientSequenceNumber, 0x0f0 /* "Incoming local client seq# > generated by this client" */);
            this.clientSequenceNumberObserved = clientSequenceNumber;
        }
        // TODO Remove after SPO picks up the latest build.
        if (typeof message.contents === "string"
            && message.contents !== ""
            && message.type !== _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_18__.MessageType.ClientLeave) {
            message.contents = JSON.parse(message.contents);
        }
        // Add final ack trace.
        if (message.traces !== undefined && message.traces.length > 0) {
            const service = this.clientDetails.type === undefined || this.clientDetails.type === ""
                ? "unknown"
                : this.clientDetails.type;
            message.traces.push({
                action: "end",
                service,
                timestamp: Date.now(),
            });
        }
        // Watch the minimum sequence number and be ready to update as needed
        if (this.minSequenceNumber > message.minimumSequenceNumber) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.DataCorruptionError("msn moves backwards", Object.assign(Object.assign({}, extractLogSafeMessageProperties(message)), { clientId: (_a = this.connection) === null || _a === void 0 ? void 0 : _a.clientId }));
        }
        this.minSequenceNumber = message.minimumSequenceNumber;
        if (message.sequenceNumber !== this.lastProcessedSequenceNumber + 1) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.DataCorruptionError("non-seq seq#", Object.assign(Object.assign({}, extractLogSafeMessageProperties(message)), { clientId: (_b = this.connection) === null || _b === void 0 ? void 0 : _b.clientId }));
        }
        this.lastProcessedSequenceNumber = message.sequenceNumber;
        // Back-compat for older server with no term
        if (message.term === undefined) {
            message.term = 1;
        }
        this.baseTerm = message.term;
        if (this.handler === undefined) {
            throw new Error("Attempted to process an inbound message without a handler attached");
        }
        this.handler.process(message);
        const endTime = Date.now();
        this.emit("op", message, endTime - startTime);
    }
    /**
     * Retrieves the missing deltas between the given sequence numbers
     */
    fetchMissingDeltas(telemetryEventSuffix, fromArg, to) {
        var _a;
        // Exit out early if we're already fetching deltas
        if (this.fetching) {
            return;
        }
        if (this.closed) {
            this.logger.sendTelemetryEvent({ eventName: "fetchMissingDeltasClosedConnection" });
            return;
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(fromArg === this.lastQueuedSequenceNumber, 0x0f1 /* "from arg" */);
        let from = fromArg;
        const n = (_a = this.previouslyProcessedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber;
        if (n !== undefined) {
            // If we already processed at least one op, then we have this.previouslyProcessedMessage populated
            // and can use it to validate that we are operating on same file, i.e. it was not overwritten.
            // Knowing about this mechanism, we could ask for op we already observed to increase validation.
            // This is especially useful when coming out of offline mode or loading from
            // very old cached (by client / driver) snapshot.
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(n === fromArg, 0x0f2 /* "previouslyProcessedMessage" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(from > 0, 0x0f3 /* "not positive" */);
            from--;
        }
        this.fetching = true;
        this.getDeltas(telemetryEventSuffix, from, to, (messages) => {
            this.refreshDelayInfo(this.deltaStorageDelayId);
            this.enqueueMessages(messages, telemetryEventSuffix);
        }).finally(() => {
            this.refreshDelayInfo(this.deltaStorageDelayId);
            this.fetching = false;
        }).catch((error) => {
            this.logger.sendErrorEvent({ eventName: "GetDeltas_Exception" }, error);
        });
    }
    catchUp(messages, telemetryEventSuffix) {
        const props = {
            eventName: `CatchUp_${telemetryEventSuffix}`,
            messageCount: messages.length,
            pendingCount: this.pending.length,
        };
        if (messages.length !== 0) {
            props.from = messages[0].sequenceNumber;
            props.to = messages[messages.length - 1].sequenceNumber;
            props.messageGap = this.handler !== undefined ? props.from - this.lastQueuedSequenceNumber - 1 : undefined;
        }
        this.logger.sendPerformanceEvent(props);
        this.enqueueMessages(messages, telemetryEventSuffix);
    }
    /**
     * Sorts pending ops and attempts to apply them
     */
    processPendingOps(telemetryEventSuffix) {
        if (this.handler !== undefined) {
            const pendingSorted = this.pending.sort((a, b) => a.sequenceNumber - b.sequenceNumber);
            this.pending = [];
            this.enqueueMessages(pendingSorted, telemetryEventSuffix);
        }
    }
    updateLatestKnownOpSeqNumber(seq) {
        if (this.lastObservedSeqNumber < seq) {
            this.lastObservedSeqNumber = seq;
        }
    }
}
// TODO: move this elsewhere and use it more broadly for DataCorruptionError/DataProcessingError
function extractLogSafeMessageProperties(message) {
    const safeProps = {
        messageClientId: message.clientId,
        sequenceNumber: message.sequenceNumber,
        clientSequenceNumber: message.clientSequenceNumber,
        referenceSequenceNumber: message.referenceSequenceNumber,
        minimumSequenceNumber: message.minimumSequenceNumber,
        messageTimestamp: message.timestamp,
    };
    return safeProps;
}
//# sourceMappingURL=deltaManager.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-loader/lib/deltaManagerProxy.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-loader/lib/deltaManagerProxy.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeltaManagerProxy": () => (/* binding */ DeltaManagerProxy)
/* harmony export */ });
/* unused harmony export DeltaQueueProxy */
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/eventForwarder.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Proxy to the real IDeltaQueue - used to restrict access
 */
class DeltaQueueProxy extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.EventForwarder {
    constructor(queue) {
        super(queue);
        this.queue = queue;
    }
    get paused() {
        return this.queue.paused;
    }
    get length() {
        return this.queue.length;
    }
    get idle() {
        return this.queue.idle;
    }
    peek() {
        return this.queue.peek();
    }
    toArray() {
        return this.queue.toArray();
    }
    // back-compat: usage removed in 0.33, remove in future versions
    async systemPause() {
        return this.pause();
    }
    async pause() {
        return this.queue.pause();
    }
    // back-compat: usage removed in 0.33, remove in future versions
    async systemResume() {
        return this.resume();
    }
    async resume() {
        this.queue.resume();
    }
}
/**
 * Proxy to the real IDeltaManager - used to restrict access
 */
class DeltaManagerProxy extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.EventForwarder {
    constructor(deltaManager) {
        super(deltaManager);
        this.deltaManager = deltaManager;
        this.inbound = new DeltaQueueProxy(deltaManager.inbound);
        this.outbound = new DeltaQueueProxy(deltaManager.outbound);
        this.inboundSignal = new DeltaQueueProxy(deltaManager.inboundSignal);
    }
    get IDeltaSender() {
        return this;
    }
    get minimumSequenceNumber() {
        return this.deltaManager.minimumSequenceNumber;
    }
    get lastSequenceNumber() {
        return this.deltaManager.lastSequenceNumber;
    }
    get lastMessage() {
        return this.deltaManager.lastMessage;
    }
    get lastKnownSeqNumber() {
        return this.deltaManager.lastKnownSeqNumber;
    }
    get initialSequenceNumber() {
        return this.deltaManager.initialSequenceNumber;
    }
    get hasCheckpointSequenceNumber() {
        return this.deltaManager.hasCheckpointSequenceNumber;
    }
    get clientDetails() {
        return this.deltaManager.clientDetails;
    }
    get version() {
        return this.deltaManager.version;
    }
    get maxMessageSize() {
        return this.deltaManager.maxMessageSize;
    }
    get serviceConfiguration() {
        return this.deltaManager.serviceConfiguration;
    }
    get active() {
        return this.deltaManager.active;
    }
    get readonly() {
        return this.deltaManager.readonly;
    }
    get readOnlyInfo() {
        return this.deltaManager.readOnlyInfo;
    }
    dispose() {
        this.inbound.dispose();
        this.outbound.dispose();
        this.inboundSignal.dispose();
        super.dispose();
    }
    close() {
        return this.deltaManager.close();
    }
    submitSignal(content) {
        return this.deltaManager.submitSignal(content);
    }
    flush() {
        return this.deltaManager.flush();
    }
}
//# sourceMappingURL=deltaManagerProxy.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-loader/lib/deltaQueue.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-loader/lib/deltaQueue.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeltaQueue": () => (/* binding */ DeltaQueue)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/typedEventEmitter.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/promises.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/performanceBrowser.js");
/* harmony import */ var double_ended_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-ended-queue */ "../../node_modules/double-ended-queue/js/deque.js");
/* harmony import */ var double_ended_queue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(double_ended_queue__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


class DeltaQueue extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.TypedEventEmitter {
    /**
     * @param worker - A callback to process a delta.
     * @param logger - For logging telemetry.
     */
    constructor(worker) {
        super();
        this.worker = worker;
        this.isDisposed = false;
        this.q = new (double_ended_queue__WEBPACK_IMPORTED_MODULE_0___default())();
        /**
         * Tracks the number of pause requests for the queue
         * The DeltaQueue is create initially paused.
         */
        this.pauseCount = 1;
    }
    get disposed() {
        return this.isDisposed;
    }
    /**
     * @returns True if the queue is paused, false if not.
     */
    get paused() {
        return this.pauseCount !== 0;
    }
    get length() {
        return this.q.length;
    }
    get idle() {
        return this.processingDeferred === undefined && this.q.length === 0;
    }
    dispose() {
        throw new Error("Not implemented.");
        this.isDisposed = true;
    }
    clear() {
        this.q.clear();
    }
    peek() {
        return this.q.peekFront();
    }
    toArray() {
        return this.q.toArray();
    }
    push(task) {
        this.q.push(task);
        this.emit("push", task);
        this.ensureProcessing();
    }
    async pause() {
        this.pauseCount++;
        // If called from within the processing loop, we are in the middle of processing an op. Return a promise
        // that will resolve when processing has actually stopped.
        if (this.processingDeferred !== undefined) {
            return this.processingDeferred.promise;
        }
    }
    resume() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.pauseCount > 0, 0x0f4 /* "Nonzero pause-count on resume()" */);
        this.pauseCount--;
        if (!this.paused) {
            this.ensureProcessing();
        }
    }
    /**
     * There are several actions that may need to kick off delta processing, so we want to guard against
     * accidental reentrancy. ensureProcessing can be called safely to start the processing loop if it is
     * not already started.
     */
    ensureProcessing() {
        if (this.processingDeferred === undefined) {
            this.processingDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Deferred();
            // Use a resolved promise to start the processing on a separate stack.
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            Promise.resolve().then(() => {
                this.processDeltas();
                if (this.processingDeferred !== undefined) {
                    this.processingDeferred.resolve();
                    this.processingDeferred = undefined;
                }
            });
        }
    }
    /**
     * Executes the delta processing loop until a stop condition is reached.
     */
    processDeltas() {
        const start = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.performance.now();
        let count = 0;
        // For grouping to work we must process all local messages immediately and in the single turn.
        // So loop over them until no messages to process, we have become paused, or hit an error.
        while (!(this.q.length === 0 || this.paused || this.error !== undefined)) {
            // Get the next message in the queue
            const next = this.q.shift();
            count++;
            // Process the message.
            try {
                // We know next is defined since we did a length check just prior to shifting.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.worker(next);
                this.emit("op", next);
            }
            catch (error) {
                this.error = error;
                this.emit("error", error);
            }
        }
        if (this.q.length === 0) {
            this.emit("idle", count, _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.performance.now() - start);
        }
    }
}
//# sourceMappingURL=deltaQueue.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-loader/lib/loader.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-loader/lib/loader.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RelativeLoader": () => (/* binding */ RelativeLoader),
/* harmony export */   "Loader": () => (/* binding */ Loader)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/container-definitions */ "../../node_modules/@fluidframework/container-definitions/lib/loader.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/promises.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/performanceBrowser.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/debugLogger.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/multiUrlResolver.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/multiDocumentServiceFactory.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/fluidResolvedUrl.js");
/* harmony import */ var _container__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./container */ "../../node_modules/@fluidframework/container-loader/lib/container.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./debug */ "../../node_modules/@fluidframework/container-loader/lib/debug.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils */ "../../node_modules/@fluidframework/container-loader/lib/utils.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */









function canUseCache(request) {
    if (request.headers === undefined) {
        return true;
    }
    return request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderHeader.cache] !== false;
}
class RelativeLoader extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    /**
     * BaseRequest is the original request that triggered the load. This URL is used in case credentials need
     * to be fetched again.
     */
    constructor(loader, containerUrl) {
        super();
        this.loader = loader;
        this.containerUrl = containerUrl;
        // Because the loader is passed to the container during construction we need to resolve the target container
        // after construction.
        this.containerDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.Deferred();
    }
    get IFluidRouter() { return this; }
    async resolve(request) {
        if (request.url.startsWith("/")) {
            // If no headers are set that require a reload make use of the same object
            const container = await this.containerDeferred.promise;
            return container;
        }
        return this.loader.resolve(request);
    }
    async request(request) {
        const containerUrl = this.containerUrl();
        if (request.url.startsWith("/")) {
            let container;
            if (canUseCache(request)) {
                container = await this.containerDeferred.promise;
            }
            else if (containerUrl === undefined) {
                throw new Error("Container url is not provided");
            }
            else {
                container = await this.loader.resolve({ url: containerUrl, headers: request.headers });
            }
            return container.request(request);
        }
        return this.loader.request(request);
    }
    resolveContainer(container) {
        this.containerDeferred.resolve(container);
    }
}
function createCachedResolver(resolver) {
    const cacheResolver = Object.create(resolver);
    const resolveCache = new Map();
    cacheResolver.resolve = async (request) => {
        if (!canUseCache(request)) {
            return resolver.resolve(request);
        }
        if (!resolveCache.has(request.url)) {
            resolveCache.set(request.url, resolver.resolve(request));
        }
        return resolveCache.get(request.url);
    };
    return cacheResolver;
}
/**
 * Manages Fluid resource loading
 */
class Loader extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor(loaderProps) {
        var _a, _b, _c;
        super();
        this.containers = new Map();
        const scope = Object.assign({}, loaderProps.scope);
        if (((_a = loaderProps.options) === null || _a === void 0 ? void 0 : _a.provideScopeLoader) === true) {
            scope.ILoader = this;
        }
        this.services = {
            urlResolver: createCachedResolver(_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__.MultiUrlResolver.create(loaderProps.urlResolver)),
            documentServiceFactory: _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.MultiDocumentServiceFactory.create(loaderProps.documentServiceFactory),
            codeLoader: loaderProps.codeLoader,
            options: (_b = loaderProps.options) !== null && _b !== void 0 ? _b : {},
            scope,
            subLogger: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.DebugLogger.mixinDebugLogger("fluid:telemetry", loaderProps.logger, { all: { loaderId: (0,uuid__WEBPACK_IMPORTED_MODULE_6__.default)() } }),
            proxyLoaderFactories: (_c = loaderProps.proxyLoaderFactories) !== null && _c !== void 0 ? _c : new Map(),
        };
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.ChildLogger.create(this.services.subLogger, "Loader");
    }
    /**
     * @deprecated use constructor with loader props
     */
    static _create(resolver, documentServiceFactory, codeLoader, options, scope, proxyLoaderFactories, logger) {
        return new Loader({
            urlResolver: _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__.MultiUrlResolver.create(resolver),
            documentServiceFactory: _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.MultiDocumentServiceFactory.create(documentServiceFactory),
            codeLoader,
            options,
            scope,
            proxyLoaderFactories,
            logger,
        });
    }
    get IFluidRouter() { return this; }
    async createDetachedContainer(codeDetails) {
        (0,_debug__WEBPACK_IMPORTED_MODULE_8__.debug)(`Container creating in detached state: ${_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now()} `);
        const container = await _container__WEBPACK_IMPORTED_MODULE_10__.Container.createDetached(this, codeDetails);
        if (this.cachingEnabled) {
            container.once("attached", () => {
                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__.ensureFluidResolvedUrl)(container.resolvedUrl);
                const parsedUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_12__.parseUrl)(container.resolvedUrl.url);
                if (parsedUrl !== undefined) {
                    this.addToContainerCache(parsedUrl.id, Promise.resolve(container));
                }
            });
        }
        return container;
    }
    async rehydrateDetachedContainerFromSnapshot(snapshot) {
        (0,_debug__WEBPACK_IMPORTED_MODULE_8__.debug)(`Container creating in detached state: ${_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now()} `);
        return _container__WEBPACK_IMPORTED_MODULE_10__.Container.rehydrateDetachedFromSnapshot(this, JSON.parse(snapshot));
    }
    async resolve(request, pendingLocalState) {
        const eventName = pendingLocalState === undefined ? "Resolve" : "ResolveWithPendingState";
        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.PerformanceEvent.timedExecAsync(this.logger, { eventName }, async () => {
            const resolved = await this.resolveCore(request, pendingLocalState !== undefined ? JSON.parse(pendingLocalState) : undefined);
            return resolved.container;
        });
    }
    async request(request) {
        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.PerformanceEvent.timedExecAsync(this.logger, { eventName: "Request" }, async () => {
            const resolved = await this.resolveCore(request);
            return resolved.container.request({ url: `${resolved.parsed.path}${resolved.parsed.query}` });
        });
    }
    getKeyForContainerCache(request, parsedUrl) {
        var _a;
        const key = ((_a = request.headers) === null || _a === void 0 ? void 0 : _a[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderHeader.version]) !== undefined
            ? `${parsedUrl.id}@${request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderHeader.version]}`
            : parsedUrl.id;
        return key;
    }
    addToContainerCache(key, containerP) {
        this.containers.set(key, containerP);
        containerP.then((container) => {
            // If the container is closed or becomes closed after we resolve it, remove it from the cache.
            if (container.closed) {
                this.containers.delete(key);
            }
            else {
                container.once("closed", () => {
                    this.containers.delete(key);
                });
            }
        }).catch((error) => { console.error("Error during caching Container on the Loader", error); });
    }
    async resolveCore(request, pendingLocalState) {
        const resolvedAsFluid = await this.services.urlResolver.resolve(request);
        (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__.ensureFluidResolvedUrl)(resolvedAsFluid);
        // Parse URL into data stores
        const parsed = (0,_utils__WEBPACK_IMPORTED_MODULE_12__.parseUrl)(resolvedAsFluid.url);
        if (parsed === undefined) {
            throw new Error(`Invalid URL ${resolvedAsFluid.url}`);
        }
        if (pendingLocalState !== undefined) {
            const parsedPendingUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_12__.parseUrl)(pendingLocalState.url);
            if ((parsedPendingUrl === null || parsedPendingUrl === void 0 ? void 0 : parsedPendingUrl.id) !== parsed.id ||
                (parsedPendingUrl === null || parsedPendingUrl === void 0 ? void 0 : parsedPendingUrl.path.replace(/\/$/, "")) !== parsed.path.replace(/\/$/, "")) {
                const message = `URL ${resolvedAsFluid.url} does not match pending state URL ${pendingLocalState.url}`;
                throw new Error(message);
            }
        }
        // parseUrl's id is expected to be of format "tenantId/docId"
        const [, docId] = parsed.id.split("/");
        const { canCache, fromSequenceNumber } = this.parseHeader(parsed, request);
        const shouldCache = pendingLocalState !== undefined ? false : canCache;
        let container;
        if (shouldCache) {
            const key = this.getKeyForContainerCache(request, parsed);
            const maybeContainer = await this.containers.get(key);
            if (maybeContainer !== undefined) {
                container = maybeContainer;
            }
            else {
                const containerP = this.loadContainer(docId, request, resolvedAsFluid);
                this.addToContainerCache(key, containerP);
                container = await containerP;
            }
        }
        else {
            container =
                await this.loadContainer(docId, request, resolvedAsFluid, pendingLocalState === null || pendingLocalState === void 0 ? void 0 : pendingLocalState.pendingRuntimeState);
        }
        if (container.deltaManager.lastSequenceNumber <= fromSequenceNumber) {
            await new Promise((resolve, reject) => {
                function opHandler(message) {
                    if (message.sequenceNumber > fromSequenceNumber) {
                        resolve();
                        container.removeListener("op", opHandler);
                    }
                }
                container.on("op", opHandler);
            });
        }
        return { container, parsed };
    }
    get cachingEnabled() {
        return this.services.options.cache !== false;
    }
    canCacheForRequest(headers) {
        return this.cachingEnabled && headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderHeader.cache] !== false;
    }
    parseHeader(parsed, request) {
        var _a, _b;
        let fromSequenceNumber = -1;
        request.headers = (_a = request.headers) !== null && _a !== void 0 ? _a : {};
        const headerSeqNum = request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderHeader.sequenceNumber];
        if (headerSeqNum !== undefined) {
            fromSequenceNumber = headerSeqNum;
        }
        // If set in both query string and headers, use query string
        request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderHeader.version] = (_b = parsed.version) !== null && _b !== void 0 ? _b : request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderHeader.version];
        // Version === null means not use any snapshot.
        if (request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderHeader.version] === "null") {
            request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderHeader.version] = null;
        }
        const canCache = this.canCacheForRequest(request.headers);
        (0,_debug__WEBPACK_IMPORTED_MODULE_8__.debug)(`${canCache} ${request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderHeader.version]}`);
        return {
            canCache,
            fromSequenceNumber,
        };
    }
    async loadContainer(encodedDocId, request, resolved, pendingLocalState) {
        var _a, _b, _c, _d;
        const docId = decodeURI(encodedDocId);
        return _container__WEBPACK_IMPORTED_MODULE_10__.Container.load(this, {
            canReconnect: (_a = request.headers) === null || _a === void 0 ? void 0 : _a[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderHeader.reconnect],
            clientDetailsOverride: (_b = request.headers) === null || _b === void 0 ? void 0 : _b[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderHeader.clientDetails],
            containerUrl: request.url,
            docId,
            resolvedUrl: resolved,
            version: (_c = request.headers) === null || _c === void 0 ? void 0 : _c[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderHeader.version],
            pause: (_d = request.headers) === null || _d === void 0 ? void 0 : _d[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderHeader.pause],
        }, pendingLocalState);
    }
}
//# sourceMappingURL=loader.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-loader/lib/networkUtils.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-loader/lib/networkUtils.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "logNetworkFailure": () => (/* binding */ logNetworkFailure),
/* harmony export */   "waitForConnectedState": () => (/* binding */ waitForConnectedState)
/* harmony export */ });
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/network.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

function logNetworkFailure(logger, event, error) {
    var _a, _b;
    const newEvent = Object.assign({}, event);
    newEvent.online = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.isOnline)();
    if ((error === null || error === void 0 ? void 0 : error.online) !== undefined) {
        newEvent.online = error.online;
    }
    if (typeof navigator === "object" && navigator !== null) {
        const nav = navigator;
        const connection = (_b = (_a = nav.connection) !== null && _a !== void 0 ? _a : nav.mozConnection) !== null && _b !== void 0 ? _b : nav.webkitConnection;
        if (connection !== null && typeof connection === "object") {
            newEvent.connectionType = connection.type;
        }
    }
    // If we are online, log it as an error, such that we look at it ASAP.
    // But if we  are offline, log non-error event - we will remove
    // it in the future once confident it's right thing to do.
    // Note: Unfortunately false positives happen in here (i.e. cable disconnected, but it reports true)!
    newEvent.category = newEvent.online === _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.OnlineStatus.Online ? "error" : "generic";
    logger.sendTelemetryEvent(newEvent, error);
}
/**
 * Wait for browser to get to connected state.
 * If connected, waits minimum of minDelay anyway (between network retries)
 * If disconnected, polls every 30 seconds anyway, to make sure we are not getting stuck because of wrong signal
 * Note that browsers will have false positives (like having Hyper-V adapter on machine,
 * or machine connected to router that is not connected to internet)
 * But there should be no false negatives.
 * The only exception - Opera returns false when user enters "Work Offline" mode, regardless of actual connectivity.
 */
// eslint-disable-next-line @typescript-eslint/promise-function-async
function waitForConnectedState(minDelay) {
    // Use this frequency to poll even when we are offline and able to setup online/offline listener
    // This is mostly safety net
    const offlinePollFrequency = 30000;
    return new Promise((resolve) => {
        let listener = resolve;
        let delay = minDelay;
        if ((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.isOnline)() === _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.OnlineStatus.Offline) {
            if ((window === null || window === void 0 ? void 0 : window.addEventListener) !== undefined) {
                listener = () => {
                    resolve();
                    window.removeEventListener("online", listener);
                };
                window.addEventListener("online", listener, false);
                delay = Math.max(minDelay, offlinePollFrequency);
            }
        }
        setTimeout(listener, delay);
    });
}
//# sourceMappingURL=networkUtils.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-loader/lib/nullRuntime.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-loader/lib/nullRuntime.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NullRuntime": () => (/* binding */ NullRuntime),
/* harmony export */   "NullChaincode": () => (/* binding */ NullChaincode)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

class NullRuntime extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor() {
        super();
        this._disposed = false;
    }
    get IFluidSerializer() {
        throw new Error("Not implemented");
    }
    get IFluidHandleContext() {
        throw new Error("Not implemented");
    }
    get disposed() { return this._disposed; }
    dispose() {
        this._disposed = true;
    }
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    snapshot(tagMessage) {
        return Promise.resolve(null);
    }
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    summarize(fullTree = false) {
        return Promise.resolve({
            tree: {},
            type: 1 /* Tree */,
        });
    }
    setConnectionState(connected, clientId) {
        return;
    }
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    stop() {
        return Promise.resolve({});
    }
    createSummary() {
        return {
            tree: {},
            type: 1 /* Tree */,
        };
    }
    setAttachState(attachState) {
        throw new Error("Null Runtime should not be attached");
    }
    async request(request) {
        return { status: 404, mimeType: "text/plain", value: "NullRuntime can't resolve" };
    }
    process(message, local, context) {
        throw new Error("Null runtime should not receive messages");
    }
    processSignal(message, local) {
        // Null runtime can receive signals but it's okay to miss those.
        return;
    }
    getPendingLocalState() {
        throw new Error("Null runtime should not be asked for pending state");
    }
}
class NullChaincode {
    async instantiateRuntime(context) {
        return new NullRuntime();
    }
    get IRuntimeFactory() { return this; }
}
//# sourceMappingURL=nullRuntime.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-loader/lib/packageVersion.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-loader/lib/packageVersion.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pkgName": () => (/* binding */ pkgName),
/* harmony export */   "pkgVersion": () => (/* binding */ pkgVersion)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
const pkgName = "@fluidframework/container-loader";
const pkgVersion = "0.37.4";
//# sourceMappingURL=packageVersion.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-loader/lib/prefetchDocumentStorageService.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-loader/lib/prefetchDocumentStorageService.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrefetchDocumentStorageService": () => (/* binding */ PrefetchDocumentStorageService)
/* harmony export */ });
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/documentStorageServiceProxy.js");
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/driver-definitions */ "../../node_modules/@fluidframework/driver-definitions/lib/storage.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debug */ "../../node_modules/@fluidframework/container-loader/lib/debug.js");



class PrefetchDocumentStorageService extends _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.DocumentStorageServiceProxy {
    constructor() {
        super(...arguments);
        // BlobId -> blob prefetchCache cache
        this.prefetchCache = new Map();
        this.prefetchEnabled = true;
    }
    get policies() {
        const policies = this.internalStorageService.policies;
        if (policies) {
            return Object.assign(Object.assign({}, policies), { caching: _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderCachingPolicy.NoCaching });
        }
    }
    async getSnapshotTree(version) {
        const p = this.internalStorageService.getSnapshotTree(version);
        if (this.prefetchEnabled) {
            // We don't care if the prefetch succeed
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            p.then((tree) => {
                if (tree === null || tree === undefined) {
                    return;
                }
                this.prefetchTree(tree);
            });
        }
        return p;
    }
    async readBlob(blobId) {
        return this.cachedRead(blobId);
    }
    stopPrefetch() {
        this.prefetchEnabled = false;
        this.prefetchCache.clear();
    }
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    cachedRead(blobId) {
        if (this.prefetchEnabled) {
            const prefetchedBlobP = this.prefetchCache.get(blobId);
            if (prefetchedBlobP !== undefined) {
                return prefetchedBlobP;
            }
            const prefetchedBlobPFromStorage = this.internalStorageService.readBlob(blobId);
            this.prefetchCache.set(blobId, prefetchedBlobPFromStorage);
            return prefetchedBlobPFromStorage;
        }
        return this.internalStorageService.readBlob(blobId);
    }
    prefetchTree(tree) {
        const secondary = [];
        this.prefetchTreeCore(tree, secondary);
        for (const blob of secondary) {
            // We don't care if the prefetch succeed
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.cachedRead(blob);
        }
    }
    prefetchTreeCore(tree, secondary) {
        for (const blobKey of Object.keys(tree.blobs)) {
            const blob = tree.blobs[blobKey];
            if (blobKey.startsWith(".") || blobKey === "header" || blobKey.startsWith("quorum")) {
                if (blob !== null) {
                    // We don't care if the prefetch succeed
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.cachedRead(blob);
                }
            }
            else if (!blobKey.startsWith("deltas")) {
                if (blob !== null) {
                    secondary.push(blob);
                }
            }
        }
        for (const commit of Object.keys(tree.commits)) {
            this.getVersions(tree.commits[commit], 1)
                // eslint-disable-next-line @typescript-eslint/promise-function-async
                .then((moduleCommit) => this.getSnapshotTree(moduleCommit[0]))
                .catch((error) => (0,_debug__WEBPACK_IMPORTED_MODULE_2__.debug)("Ignored cached read error", error));
        }
        for (const subTree of Object.keys(tree.trees)) {
            this.prefetchTreeCore(tree.trees[subTree], secondary);
        }
    }
}
//# sourceMappingURL=prefetchDocumentStorageService.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-loader/lib/retriableDocumentStorageService.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-loader/lib/retriableDocumentStorageService.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RetriableDocumentStorageService": () => (/* binding */ RetriableDocumentStorageService)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/container-utils */ "../../node_modules/@fluidframework/container-utils/lib/error.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/network.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/bufferBrowser.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/performanceBrowser.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-browser/v4.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */




class RetriableDocumentStorageService {
    constructor(internalStorageService, deltaManager, logger) {
        this.internalStorageService = internalStorageService;
        this.deltaManager = deltaManager;
        this.logger = logger;
        this.disposed = false;
    }
    get policies() {
        return this.internalStorageService.policies;
    }
    dispose() {
        this.disposed = true;
    }
    get repositoryUrl() {
        return this.internalStorageService.repositoryUrl;
    }
    async getSnapshotTree(version) {
        return this.readWithRetry(async () => this.internalStorageService.getSnapshotTree(version), "getSnapshotTree");
    }
    async read(blobId) {
        return this.readWithRetry(async () => (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.bufferToString)(await this.internalStorageService.readBlob(blobId), "base64"), "read");
    }
    async readBlob(id) {
        return this.readWithRetry(async () => this.internalStorageService.readBlob(id), "readBlob");
    }
    async getVersions(versionId, count) {
        return this.readWithRetry(async () => this.internalStorageService.getVersions(versionId, count), "getVersions");
    }
    async write(tree, parents, message, ref) {
        return this.readWithRetry(async () => this.internalStorageService.write(tree, parents, message, ref), "write");
    }
    async uploadSummaryWithContext(summary, context) {
        return this.readWithRetry(async () => this.internalStorageService.uploadSummaryWithContext(summary, context), "uploadSummaryWithContext");
    }
    async downloadSummary(handle) {
        return this.readWithRetry(async () => this.internalStorageService.downloadSummary(handle), "downloadSummary");
    }
    async createBlob(file) {
        return this.readWithRetry(async () => this.internalStorageService.createBlob(file), "createBlob");
    }
    async delay(timeMs) {
        return new Promise((resolve) => setTimeout(() => resolve(), timeMs));
    }
    async readWithRetry(api, fetchCallName) {
        var _a;
        let result;
        let success = false;
        let retryAfter = 1; // has to be positive!
        let numRetries = 0;
        const startTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.performance.now();
        let lastError;
        let id;
        do {
            try {
                result = await api();
                if (id !== undefined) {
                    this.deltaManager.refreshDelayInfo(id);
                }
                success = true;
            }
            catch (err) {
                if (this.disposed) {
                    // eslint-disable-next-line @typescript-eslint/no-throw-literal
                    throw (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_2__.CreateContainerError)("Storage service disposed!!");
                }
                // If it is not retriable, then just throw the error.
                if (!(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__.canRetryOnError)(err)) {
                    this.logger.sendErrorEvent({
                        eventName: `Storage_${fetchCallName}`,
                        retry: numRetries,
                        duration: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.performance.now() - startTime,
                    }, err);
                    throw err;
                }
                numRetries++;
                lastError = err;
                // If the error is throttling error, then wait for the specified time before retrying.
                // If the waitTime is not specified, then we start with retrying immediately to max of 8s.
                retryAfter = (_a = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__.getRetryDelayFromError)(err)) !== null && _a !== void 0 ? _a : Math.min(retryAfter * 2, 8000);
                if (id === undefined) {
                    id = (0,uuid__WEBPACK_IMPORTED_MODULE_4__.default)();
                }
                this.deltaManager.emitDelayInfo(id, retryAfter, (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_2__.CreateContainerError)(err));
                await this.delay(retryAfter);
            }
        } while (!success);
        if (numRetries > 0) {
            this.logger.sendTelemetryEvent({
                eventName: `Storage_${fetchCallName}`,
                retry: numRetries,
                duration: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.performance.now() - startTime,
            }, lastError);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return result;
    }
}
//# sourceMappingURL=retriableDocumentStorageService.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-loader/lib/utils.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-loader/lib/utils.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseUrl": () => (/* binding */ parseUrl),
/* harmony export */   "convertProtocolAndAppSummaryToSnapshotTree": () => (/* binding */ convertProtocolAndAppSummaryToSnapshotTree)
/* harmony export */ });
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url */ "../../node_modules/url/url.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/base64Encoding.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/bufferBrowser.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-browser/v4.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */



function parseUrl(url) {
    var _a;
    const parsed = (0,url__WEBPACK_IMPORTED_MODULE_0__.parse)(url, true);
    if (typeof parsed.pathname !== "string") {
        throw new Error("Failed to parse pathname");
    }
    const query = (_a = parsed.search) !== null && _a !== void 0 ? _a : "";
    const regex = /^\/([^/]*\/[^/]*)(\/?.*)$/;
    const match = regex.exec(parsed.pathname);
    return ((match === null || match === void 0 ? void 0 : match.length) === 3)
        ? { id: match[1], path: match[2], query, version: parsed.query.version }
        : undefined;
}
/**
 * Converts summary tree (for upload) to snapshot tree (for download).
 * Summary tree blobs contain contents, but snapshot tree blobs normally
 * contain IDs pointing to storage. This will create 2 blob entries in the
 * snapshot tree for each blob in the summary tree. One will be the regular
 * path pointing to a uniquely generated ID. Then there will be another
 * entry with the path as that uniquely generated ID, and value as the
 * blob contents as a base-64 string.
 * @param summary - summary to convert
 */
function convertSummaryToSnapshotWithEmbeddedBlobContents(summary) {
    const treeNode = {
        blobs: {},
        trees: {},
        commits: {},
        id: (0,uuid__WEBPACK_IMPORTED_MODULE_1__.default)(),
    };
    const keys = Object.keys(summary.tree);
    for (const key of keys) {
        const summaryObject = summary.tree[key];
        switch (summaryObject.type) {
            case 1 /* Tree */: {
                treeNode.trees[key] = convertSummaryToSnapshotWithEmbeddedBlobContents(summaryObject);
                break;
            }
            case 2 /* Blob */: {
                const blobId = (0,uuid__WEBPACK_IMPORTED_MODULE_1__.default)();
                treeNode.blobs[key] = blobId;
                treeNode.blobs[blobId] = typeof summaryObject.content === "string" ?
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.fromUtf8ToBase64)(summaryObject.content) :
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.bufferToString)(summaryObject.content, "base64");
                break;
            }
            case 3 /* Handle */:
                throw new Error("No handles should be there in summary in detached container!!");
                break;
            default: {
                throw new Error(`Unknown tree type ${summaryObject.type}`);
            }
        }
    }
    return treeNode;
}
/**
 * Combine and convert protocol and app summary tree to format which is readable by container while rehydrating.
 * @param protocolSummaryTree - Protocol Summary Tree
 * @param appSummaryTree - App Summary Tree
 */
function convertProtocolAndAppSummaryToSnapshotTree(protocolSummaryTree, appSummaryTree) {
    // Shallow copy is fine, since we are doing a deep clone below.
    const combinedSummary = {
        type: 1 /* Tree */,
        tree: Object.assign({}, appSummaryTree.tree),
    };
    combinedSummary.tree[".protocol"] = protocolSummaryTree;
    const snapshotTree = convertSummaryToSnapshotWithEmbeddedBlobContents(combinedSummary);
    return snapshotTree;
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime-definitions/dist/containerRuntime.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime-definitions/dist/containerRuntime.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IContainerRuntime = void 0;
exports.IContainerRuntime = "IContainerRuntime";
//# sourceMappingURL=containerRuntime.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime-definitions/dist/containerRuntimeDirtyable.js":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime-definitions/dist/containerRuntimeDirtyable.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IContainerRuntimeDirtyable = void 0;
exports.IContainerRuntimeDirtyable = "IContainerRuntimeDirtyable";
//# sourceMappingURL=containerRuntimeDirtyable.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime-definitions/dist/index.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime-definitions/dist/index.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./containerRuntime */ "../../node_modules/@fluidframework/container-runtime-definitions/dist/containerRuntime.js"), exports);
__exportStar(__webpack_require__(/*! ./containerRuntimeDirtyable */ "../../node_modules/@fluidframework/container-runtime-definitions/dist/containerRuntimeDirtyable.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/blobManager.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/blobManager.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlobManager": () => (/* binding */ BlobManager)
/* harmony export */ });
/* unused harmony export BlobHandle */
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/protocol-base */ "../../node_modules/@fluidframework/protocol-base/lib/blobs.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHandleContextUtils.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * This class represents blob (long string)
 * This object is used only when creating (writing) new blob and serialization purposes.
 * De-serialization process goes through FluidObjectHandle and request flow:
 * DataObject.request() recognizes requests in the form of `/blobs/<id>`
 * and loads blob.
 */
class BlobHandle {
    constructor(path, routeContext, get, attachGraphCallback) {
        this.path = path;
        this.routeContext = routeContext;
        this.get = get;
        this.attachGraphCallback = attachGraphCallback;
        this.absolutePath = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.generateHandleContextPath)(path, this.routeContext);
    }
    get IFluidHandle() { return this; }
    get isAttached() {
        return this.attachGraphCallback === undefined;
    }
    attachGraph() {
        if (this.attachGraphCallback) {
            this.attachGraphCallback();
            this.attachGraphCallback = undefined;
        }
    }
    bind(handle) {
        throw new Error("Cannot bind to blob handle");
    }
}
class BlobManager {
    constructor(routeContext, getStorage, attachBlobCallback, logger) {
        this.routeContext = routeContext;
        this.getStorage = getStorage;
        this.attachBlobCallback = attachBlobCallback;
        this.logger = logger;
        this.pendingBlobIds = new Set();
        this.blobIds = new Set();
    }
    async getBlob(blobId) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.blobIds.has(blobId) || this.pendingBlobIds.has(blobId), 0x11f /* "requesting unknown blobs" */);
        return new BlobHandle(`${BlobManager.basePath}/${blobId}`, this.routeContext, async () => this.getStorage().readBlob(blobId), undefined);
    }
    async createBlob(blob) {
        const response = await this.getStorage().createBlob(blob);
        const handle = new BlobHandle(`${BlobManager.basePath}/${response.id}`, this.routeContext, async () => this.getStorage().readBlob(response.id), () => this.attachBlobCallback(response.id));
        // Note - server will de-dup blobs, so we might get existing blobId!
        if (!this.blobIds.has(response.id)) {
            this.pendingBlobIds.add(response.id);
        }
        return handle;
    }
    addBlobId(blobId) {
        this.blobIds.add(blobId);
        this.pendingBlobIds.delete(blobId);
    }
    /**
     * Load a set of previously attached blob IDs from a previous snapshot. Note
     * that BlobManager tracking and reporting attached blobs is a temporary
     * solution since storage expects attached blobs to be reported and any that
     * are not reported as attached may be GCed. In the future attached blob
     * IDs will be collected at summarization time, and runtime will not care
     * about the existence or specific formatting of this tree in returned
     * snapshots.
     *
     * @param blobsTree - Tree containing IDs of previously attached blobs. This
     * corresponds to snapshot() below. We look for the IDs in the blob entries
     * of the tree since the both the r11s and SPO drivers replace the
     * attachment types returned in snapshot() with blobs.
     */
    load(blobsTree) {
        let count = 0;
        if (blobsTree) {
            const values = Object.values(blobsTree.blobs);
            count = values.length;
            values.map((entry) => this.addBlobId(entry));
        }
        this.logger.sendTelemetryEvent({ eventName: "ExternalBlobsInSnapshot", count });
    }
    snapshot() {
        const entries = [...this.blobIds].map((id) => new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_2__.AttachmentTreeEntry(id, id));
        return { entries };
    }
}
BlobManager.basePath = "_blobs";
//# sourceMappingURL=blobManager.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/connectionTelemetry.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/connectionTelemetry.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReportOpPerfTelemetry": () => (/* binding */ ReportOpPerfTelemetry)
/* harmony export */ });
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/performanceBrowser.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


class OpPerfTelemetry {
    constructor(clientId, deltaManager, logger) {
        this.clientId = clientId;
        this.deltaManager = deltaManager;
        this.pongCount = 0;
        this.socketLatency = 0;
        this.firstConnection = true;
        this.bootTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();
        this.connectionStartTime = 0;
        this.gap = 0;
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(logger, "OpPerf");
        this.deltaManager.on("pong", (latency) => this.recordPingTime(latency));
        this.deltaManager.on("submitOp", (message) => this.beforeOpSubmit(message));
        this.deltaManager.on("op", (message) => this.afterProcessingOp(message));
        this.deltaManager.on("connect", (details, opsBehind) => {
            this.clientId = details.clientId;
            if (opsBehind !== undefined) {
                this.connectionOpSeqNumber = this.deltaManager.lastKnownSeqNumber;
                this.gap = opsBehind;
                this.connectionStartTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();
                // We might be already up-today. If so, report it right away.
                if (this.gap <= 0) {
                    this.reportGettingUpToDate();
                }
            }
        });
        this.deltaManager.on("disconnect", () => {
            this.clientSequenceNumberForLatencyStatistics = undefined;
            this.connectionOpSeqNumber = undefined;
            this.firstConnection = false;
        });
        this.deltaManager.inbound.on("idle", (count, duration) => {
            // Do not want to log zero for sure.
            // We are more interested in aggregates, so logging only if we are processing some number of ops
            // Cut-off is arbitrary - can be increased or decreased based on amount of data collected and questions we
            // want to get answered
            // back-compat: Once 0.36 loader version saturates (count & duration args were added there),
            // we can remove typeof check.
            if (typeof count === "number" && count >= 100) {
                this.logger.sendPerformanceEvent({
                    eventName: "GetDeltas_OpProcessing",
                    count,
                    duration,
                });
            }
        });
    }
    reportGettingUpToDate() {
        this.connectionOpSeqNumber = undefined;
        this.logger.sendPerformanceEvent({
            eventName: "ConnectionSpeed",
            duration: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now() - this.connectionStartTime,
            ops: this.gap,
            // track time to connect only for first connection.
            timeToConnect: this.firstConnection ?
                _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.formatTick(this.connectionStartTime - this.bootTime) :
                undefined,
            firstConnection: this.firstConnection,
        });
    }
    recordPingTime(latency) {
        this.pongCount++;
        this.socketLatency += latency;
        const aggregateCount = 100;
        if (this.pongCount === aggregateCount) {
            this.logger.sendTelemetryEvent({ eventName: "DeltaLatency", value: this.socketLatency / aggregateCount });
            this.pongCount = 0;
            this.socketLatency = 0;
        }
    }
    beforeOpSubmit(message) {
        // start with first client op and measure latency every 500 client ops
        if (this.clientSequenceNumberForLatencyStatistics === undefined && message.clientSequenceNumber % 500 === 1) {
            this.opSendTimeForLatencyStatistics = Date.now();
            this.clientSequenceNumberForLatencyStatistics = message.clientSequenceNumber;
        }
    }
    afterProcessingOp(message) {
        const sequenceNumber = message.sequenceNumber;
        if (sequenceNumber === this.connectionOpSeqNumber) {
            this.reportGettingUpToDate();
        }
        // Record collab window max size after every 1000th op.
        if (sequenceNumber % 1000 === 0) {
            if (this.opSendTimeForLatencyStatisticsForMsnStatistics !== undefined) {
                this.logger.sendPerformanceEvent({
                    eventName: "MsnStatistics",
                    sequenceNumber,
                    msnDistance: this.deltaManager.lastSequenceNumber - this.deltaManager.minimumSequenceNumber,
                    duration: message.timestamp - this.opSendTimeForLatencyStatisticsForMsnStatistics,
                });
            }
            this.opSendTimeForLatencyStatisticsForMsnStatistics = message.timestamp;
        }
        if (this.clientId === message.clientId &&
            this.clientSequenceNumberForLatencyStatistics === message.clientSequenceNumber) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.opSendTimeForLatencyStatistics !== undefined, 0x120 /* "Undefined latency statistics (op send time)" */);
            this.logger.sendPerformanceEvent({
                eventName: "OpRoundtripTime",
                sequenceNumber,
                duration: Date.now() - this.opSendTimeForLatencyStatistics,
            });
            this.clientSequenceNumberForLatencyStatistics = undefined;
        }
    }
}
function ReportOpPerfTelemetry(clientId, deltaManager, logger) {
    new OpPerfTelemetry(clientId, deltaManager, logger);
}
//# sourceMappingURL=connectionTelemetry.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/containerHandleContext.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/containerHandleContext.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContainerFluidHandleContext": () => (/* binding */ ContainerFluidHandleContext)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/container-definitions */ "../../node_modules/@fluidframework/container-definitions/lib/runtime.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHandleContextUtils.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


class ContainerFluidHandleContext {
    /**
     * Creates a new ContainerFluidHandleContext.
     * @param path - The path to this handle relative to the routeContext.
     * @param runtime - The IRuntime object this context represents.
     * @param routeContext - The parent IFluidHandleContext that has a route to this handle.
     */
    constructor(path, runtime, routeContext) {
        this.path = path;
        this.runtime = runtime;
        this.routeContext = routeContext;
        this.absolutePath = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.generateHandleContextPath)(path, this.routeContext);
    }
    get IFluidRouter() { return this; }
    get IFluidHandleContext() { return this; }
    attachGraph() {
        throw new Error("can't attach container runtime form within container!");
    }
    get isAttached() {
        return this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.AttachState.Detached;
    }
    async resolveHandle(request) {
        return this.runtime.resolveHandle(request);
    }
}
//# sourceMappingURL=containerHandleContext.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/containerRuntime.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/containerRuntime.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContainerMessageType": () => (/* binding */ ContainerMessageType),
/* harmony export */   "ContainerRuntime": () => (/* binding */ ContainerRuntime)
/* harmony export */ });
/* unused harmony exports isRuntimeMessage, unpackRuntimeMessage, ScheduleManager, agentSchedulerId */
/* harmony import */ var _fluidframework_agent_scheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/agent-scheduler */ "../../node_modules/@fluidframework/agent-scheduler/lib/scheduler.js");
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @fluidframework/container-definitions */ "../../node_modules/@fluidframework/container-definitions/lib/runtime.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/typedEventEmitter.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/unreachable.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/trace.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/events.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/blobAggregationStorage.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/readAndParse.js");
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @fluidframework/container-utils */ "../../node_modules/@fluidframework/container-utils/lib/error.js");
/* harmony import */ var _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @fluidframework/garbage-collector */ "../../node_modules/@fluidframework/garbage-collector/lib/garbageCollector.js");
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @fluidframework/protocol-base */ "../../node_modules/@fluidframework/protocol-base/lib/blobs.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/protocol.js");
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @fluidframework/runtime-definitions */ "../../node_modules/@fluidframework/runtime-definitions/dist/index.js");
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/serializer.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/summarizerNode/summarizerNodeWithGc.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/requestParser.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHelpers.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/summaryUtils.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _containerHandleContext__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./containerHandleContext */ "../../node_modules/@fluidframework/container-runtime/lib/containerHandleContext.js");
/* harmony import */ var _dataStoreRegistry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dataStoreRegistry */ "../../node_modules/@fluidframework/container-runtime/lib/dataStoreRegistry.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./debug */ "../../node_modules/@fluidframework/container-runtime/lib/debug.js");
/* harmony import */ var _summarizer__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./summarizer */ "../../node_modules/@fluidframework/container-runtime/lib/summarizer.js");
/* harmony import */ var _summaryManager__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./summaryManager */ "../../node_modules/@fluidframework/container-runtime/lib/summaryManager.js");
/* harmony import */ var _deltaScheduler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./deltaScheduler */ "../../node_modules/@fluidframework/container-runtime/lib/deltaScheduler.js");
/* harmony import */ var _connectionTelemetry__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./connectionTelemetry */ "../../node_modules/@fluidframework/container-runtime/lib/connectionTelemetry.js");
/* harmony import */ var _pendingStateManager__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./pendingStateManager */ "../../node_modules/@fluidframework/container-runtime/lib/pendingStateManager.js");
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./packageVersion */ "../../node_modules/@fluidframework/container-runtime/lib/packageVersion.js");
/* harmony import */ var _blobManager__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./blobManager */ "../../node_modules/@fluidframework/container-runtime/lib/blobManager.js");
/* harmony import */ var _dataStores__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./dataStores */ "../../node_modules/@fluidframework/container-runtime/lib/dataStores.js");
/* harmony import */ var _summaryFormat__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./summaryFormat */ "../../node_modules/@fluidframework/container-runtime/lib/summaryFormat.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
























var ContainerMessageType;
(function (ContainerMessageType) {
    // An op to be delivered to store
    ContainerMessageType["FluidDataStoreOp"] = "component";
    // Creates a new store
    ContainerMessageType["Attach"] = "attach";
    // Chunked operation.
    ContainerMessageType["ChunkedOp"] = "chunkedOp";
    ContainerMessageType["BlobAttach"] = "blobAttach";
})(ContainerMessageType || (ContainerMessageType = {}));
// Consider idle 5s of no activity. And snapshot if a minute has gone by with no snapshot.
const IdleDetectionTime = 5000;
const DefaultSummaryConfiguration = {
    idleTime: IdleDetectionTime,
    maxTime: IdleDetectionTime * 12,
    // Snapshot if 1000 ops received since last snapshot.
    maxOps: 1000,
    // Wait 2 minutes for summary ack
    maxAckWaitTime: 120000,
};
function isRuntimeMessage(message) {
    switch (message.type) {
        case ContainerMessageType.FluidDataStoreOp:
        case ContainerMessageType.ChunkedOp:
        case ContainerMessageType.Attach:
        case ContainerMessageType.BlobAttach:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Operation:
            return true;
        default:
            return false;
    }
}
function unpackRuntimeMessage(message) {
    if (message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Operation) {
        // legacy op format?
        if (message.contents.address !== undefined && message.contents.type === undefined) {
            message.type = ContainerMessageType.FluidDataStoreOp;
        }
        else {
            // new format
            const innerContents = message.contents;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(innerContents.type !== undefined, 0x121 /* "Undefined inner contents type!" */);
            message.type = innerContents.type;
            message.contents = innerContents.contents;
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(isRuntimeMessage(message), 0x122 /* "Message to unpack is not proper runtime message" */);
    }
    else {
        // Legacy format, but it's already "unpacked",
        // i.e. message.type is actually ContainerMessageType.
        // Nothing to do in such case.
    }
    return message;
}
class ScheduleManager {
    constructor(deltaManager, emitter, logger) {
        this.deltaManager = deltaManager;
        this.emitter = emitter;
        this.logger = logger;
        this.localPaused = false;
        this.deltaScheduler = new _deltaScheduler__WEBPACK_IMPORTED_MODULE_2__.DeltaScheduler(this.deltaManager, _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.ChildLogger.create(this.logger, "DeltaScheduler"));
        // Listen for delta manager sends and add batch metadata to messages
        this.deltaManager.on("prepareSend", (messages) => {
            if (messages.length === 0) {
                return;
            }
            // First message will have the batch flag set to true if doing a batched send
            const firstMessageMetadata = messages[0].metadata;
            if (!firstMessageMetadata || !firstMessageMetadata.batch) {
                return;
            }
            // If the batch contains only a single op, clear the batch flag.
            if (messages.length === 1) {
                delete firstMessageMetadata.batch;
                return;
            }
            // Set the batch flag to false on the last message to indicate the end of the send batch
            const lastMessage = messages[messages.length - 1];
            lastMessage.metadata = Object.assign(Object.assign({}, lastMessage.metadata), { batch: false });
        });
        // Listen for updates and peek at the inbound
        this.deltaManager.inbound.on("push", (message) => {
            this.trackPending(message);
            this.updatePauseState(message.sequenceNumber);
        });
        const allPending = this.deltaManager.inbound.toArray();
        for (const pending of allPending) {
            this.trackPending(pending);
        }
        // Based on track pending update the pause state
        this.updatePauseState(this.deltaManager.lastSequenceNumber);
    }
    beginOperation(message) {
        var _a;
        if (this.batchClientId !== message.clientId) {
            // As a back stop for any bugs marking the end of a batch - if the client ID flipped, we
            // consider the previous batch over.
            if (this.batchClientId) {
                this.emitter.emit("batchEnd", "Did not receive real batchEnd message", undefined);
                this.deltaScheduler.batchEnd();
                this.logger.sendTelemetryEvent({
                    eventName: "BatchEndNotReceived",
                    clientId: this.batchClientId,
                    sequenceNumber: message.sequenceNumber,
                });
            }
            // This could be the beginning of a new batch or an individual message.
            this.emitter.emit("batchBegin", message);
            this.deltaScheduler.batchBegin();
            const batch = (_a = message === null || message === void 0 ? void 0 : message.metadata) === null || _a === void 0 ? void 0 : _a.batch;
            if (batch) {
                this.batchClientId = message.clientId;
            }
            else {
                this.batchClientId = undefined;
            }
        }
    }
    endOperation(error, message) {
        var _a;
        if (error) {
            this.batchClientId = undefined;
            this.emitter.emit("batchEnd", error, message);
            this.deltaScheduler.batchEnd();
            return;
        }
        this.updatePauseState(message.sequenceNumber);
        const batch = (_a = message === null || message === void 0 ? void 0 : message.metadata) === null || _a === void 0 ? void 0 : _a.batch;
        // If no batchClientId has been set then we're in an individual batch. Else, if we get
        // batch end metadata, this is end of the current batch.
        if (!this.batchClientId || batch === false) {
            this.batchClientId = undefined;
            this.emitter.emit("batchEnd", undefined, message);
            this.deltaScheduler.batchEnd();
            return;
        }
    }
    setPaused(localPaused) {
        // Return early if no change in value
        if (this.localPaused === localPaused) {
            return;
        }
        this.localPaused = localPaused;
        if (localPaused) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.deltaManager.inbound.pause();
        }
        else {
            this.deltaManager.inbound.resume();
        }
    }
    updatePauseState(sequenceNumber) {
        // If the inbound queue is ever empty we pause it and wait for new events
        if (this.deltaManager.inbound.length === 0) {
            this.setPaused(true);
            return;
        }
        // If no message has caused the pause flag to be set, or the next message up is not the one we need to pause at
        // then we simply continue processing
        if (!this.pauseSequenceNumber || sequenceNumber + 1 < this.pauseSequenceNumber) {
            this.setPaused(false);
        }
        else {
            // Otherwise the next message requires us to pause
            this.setPaused(true);
        }
    }
    trackPending(message) {
        const metadata = message.metadata;
        // Protocol messages are never part of a runtime batch of messages
        if (!isRuntimeMessage(message)) {
            this.pauseSequenceNumber = undefined;
            this.pauseClientId = undefined;
            return;
        }
        const batchMetadata = metadata ? metadata.batch : undefined;
        // If the client ID changes then we can move the pause point. If it stayed the same then we need to check.
        if (this.pauseClientId === message.clientId) {
            if (batchMetadata !== undefined) {
                // If batchMetadata is not undefined then if it's true we've begun a new batch - if false we've ended
                // the previous one
                this.pauseSequenceNumber = batchMetadata ? message.sequenceNumber : undefined;
                this.pauseClientId = batchMetadata ? this.pauseClientId : undefined;
            }
        }
        else {
            // We check the batch flag for the new clientID - if true we pause otherwise we reset the tracking data
            this.pauseSequenceNumber = batchMetadata ? message.sequenceNumber : undefined;
            this.pauseClientId = batchMetadata ? message.clientId : undefined;
        }
    }
}
const agentSchedulerId = "_scheduler";
// Wraps the provided list of packages and augments with some system level services.
class ContainerRuntimeDataStoreRegistry extends _dataStoreRegistry__WEBPACK_IMPORTED_MODULE_4__.FluidDataStoreRegistry {
    constructor(namedEntries) {
        super([
            ...namedEntries,
            _fluidframework_agent_scheduler__WEBPACK_IMPORTED_MODULE_5__.AgentSchedulerFactory.registryEntry,
        ]);
    }
}
/**
 * Represents the runtime of the container. Contains helper functions/state of the container.
 * It will define the store level mappings.
 */
class ContainerRuntime extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.TypedEventEmitter {
    constructor(context, registry, metadata, chunks, runtimeOptions = {
        generateSummaries: true,
    }, containerScope, logger, requestHandler, _storage) {
        var _a, _b;
        super();
        this.context = context;
        this.registry = registry;
        this.containerScope = containerScope;
        this.logger = logger;
        this.requestHandler = requestHandler;
        this._storage = _storage;
        // back-compat: Used by loader in <= 0.35
        this.runtimeVersion = _packageVersion__WEBPACK_IMPORTED_MODULE_7__.pkgVersion;
        this._flushMode = _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__.FlushMode.Automatic;
        this.needsFlush = false;
        this.flushTrigger = false;
        // Always matched IAgentScheduler.leader property
        this._leader = false;
        this.paused = false;
        this._disposed = false;
        this.dirtyContainer = false;
        this.emitDirtyDocumentEvent = true;
        /**
         * Used to apply stashed ops at their reference sequence number.
         * Normal op processing is synchronous, but rebasing is async since the
         * data store may not be loaded yet, so we pause DeltaManager between ops.
         * It's also important that we see each op so we know all stashed ops have
         * been applied by "connected" event, but process() doesn't see system ops,
         * so we listen directly from DeltaManager instead.
         */
        this.onOp = (op) => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.paused, 0x128 /* "Container should not already be paused before applying stashed ops" */);
            this.paused = true;
            this.scheduleManager.setPaused(true);
            const stashP = this.pendingStateManager.applyStashedOpsAt(op.sequenceNumber);
            stashP.then(() => {
                this.paused = false;
                this.scheduleManager.setPaused(false);
            }, (error) => {
                this.closeFn((0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_9__.CreateContainerError)(error));
            });
        };
        this.runtimeOptions = Object.assign({ disableIsolatedChannels: true }, runtimeOptions);
        this._connected = this.context.connected;
        this.chunkMap = new Map(chunks);
        this.IFluidHandleContext = new _containerHandleContext__WEBPACK_IMPORTED_MODULE_10__.ContainerFluidHandleContext("", this);
        this.IFluidSerializer = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__.FluidSerializer(this.IFluidHandleContext);
        this._logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.ChildLogger.create(this.logger, "ContainerRuntime");
        this.latestSummaryAck = {
            proposalHandle: undefined,
            ackHandle: (_a = this.context.getLoadedFromVersion()) === null || _a === void 0 ? void 0 : _a.id,
        };
        const loadedFromSequenceNumber = this.deltaManager.initialSequenceNumber;
        this.summarizerNode = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_12__.createRootSummarizerNodeWithGC)(this.logger, 
        // Summarize function to call when summarize is called. Summarizer node always tracks summary state.
        async (fullTree, trackState) => this.summarizeInternal(fullTree, trackState), 
        // Latest change sequence number, no changes since summary applied yet
        loadedFromSequenceNumber, 
        // Summary reference sequence number, undefined if no summary yet
        context.baseSnapshot ? loadedFromSequenceNumber : undefined, {
            // Must set to false to prevent sending summary handle which would be pointing to
            // a summary with an older protocol state.
            canReuseHandle: false,
            // Must set to true to throw on any data stores failure that was too severe to be handled.
            // We also are not decoding the base summaries at the root.
            throwOnFailure: true,
            // If GC is disabled, let the summarizer node know so that it does not track GC state.
            gcDisabled: this.runtimeOptions.disableGC,
        });
        if (this.context.baseSnapshot) {
            this.summarizerNode.loadBaseSummaryWithoutDifferential(this.context.baseSnapshot);
        }
        this.dataStores = new _dataStores__WEBPACK_IMPORTED_MODULE_13__.DataStores((0,_dataStores__WEBPACK_IMPORTED_MODULE_13__.getSummaryForDatastores)(context.baseSnapshot, metadata), this, (attachMsg) => this.submit(ContainerMessageType.Attach, attachMsg), (id, createParam) => (summarizeInternal, getGCDataFn, getInitialGCSummaryDetailsFn) => this.summarizerNode.createChild(summarizeInternal, id, createParam, undefined, getGCDataFn, getInitialGCSummaryDetailsFn), this._logger);
        this.blobManager = new _blobManager__WEBPACK_IMPORTED_MODULE_14__.BlobManager(this.IFluidHandleContext, () => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_15__.AttachState.Detached, 0x123 /* "Blobs NYI in detached container mode" */);
            return this.storage;
        }, (blobId) => this.submit(ContainerMessageType.BlobAttach, undefined, undefined, { blobId }), this.logger);
        this.blobManager.load((_b = context.baseSnapshot) === null || _b === void 0 ? void 0 : _b.trees[_summaryFormat__WEBPACK_IMPORTED_MODULE_16__.blobsTreeName]);
        this.scheduleManager = new ScheduleManager(context.deltaManager, this, _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.ChildLogger.create(this.logger, "ScheduleManager"));
        this.deltaSender = this.deltaManager;
        this.pendingStateManager = new _pendingStateManager__WEBPACK_IMPORTED_MODULE_17__.PendingStateManager(this, async (type, content) => this.applyStashedOp(type, content), context.pendingLocalState);
        this.context.quorum.on("removeMember", (clientId) => {
            this.clearPartialChunks(clientId);
        });
        this.context.quorum.on("addProposal", (proposal) => {
            if (proposal.key === "code" || proposal.key === "code2") {
                this.emit("codeDetailsProposed", proposal.value, proposal);
            }
        });
        if (this.context.previousRuntimeState === undefined || this.context.previousRuntimeState.state === undefined) {
            this.previousState = {};
        }
        else {
            this.previousState = this.context.previousRuntimeState.state;
        }
        // We always create the summarizer in the case that we are asked to generate summaries. But this may
        // want to be on demand instead.
        // Don't use optimizations when generating summaries with a document loaded using snapshots.
        // This will ensure we correctly convert old documents.
        this.summarizer = new _summarizer__WEBPACK_IMPORTED_MODULE_18__.Summarizer("/_summarizer", this /* ISummarizerRuntime */, () => this.summaryConfiguration, this /* ISummarizerInternalsProvider */, this.IFluidHandleContext, this.previousState.summaryCollection);
        // Create the SummaryManager and mark the initial state
        this.summaryManager = new _summaryManager__WEBPACK_IMPORTED_MODULE_19__.SummaryManager(context, this.runtimeOptions.generateSummaries !== false, this.logger, (summarizer) => { this.nextSummarizerP = summarizer; }, this.previousState.nextSummarizerP, !!this.previousState.reload, this.runtimeOptions.initialSummarizerDelayMs);
        if (this.connected) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.summaryManager.setConnected(this.context.clientId);
        }
        this.deltaManager.on("readonly", (readonly) => {
            // we accumulate ops while being in read-only state.
            // once user gets write permissions and we have active connection, flush all pending ops.
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(readonly === this.deltaManager.readonly, 0x124 /* "inconsistent readonly property/event state" */);
            // We need to be very careful with when we (re)send pending ops, to ensure that we only send ops
            // when we either never send an op, or attempted to send it but we know for sure it was not
            // sequenced by server and will never be sequenced (i.e. was lost)
            // For loss of connection, we wait for our own "join" op and use it a a barrier to know all the
            // ops that made it from previous connection, before switching clientId and raising "connected" event
            // But with read-only permissions, if we transition between read-only and r/w states while on same
            // connection, then we have no good signal to tell us when it's safe to send ops we accumulated while
            // being in read-only state.
            // For that reason, we support getting to read-only state only when disconnected. This ensures that we
            // can rely on same safety mechanism and resend ops only when we establish new connection.
            // This is applicable for read-only permissions (event is raised before connection is properly registered),
            // but it's an extra requirement for Container.forceReadonly() API
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!readonly || !this.connected, 0x125 /* "Unsafe to transition to read-only state!" */);
            this.replayPendingStates();
        });
        if (context.pendingLocalState !== undefined) {
            this.deltaManager.on("op", this.onOp);
        }
        (0,_connectionTelemetry__WEBPACK_IMPORTED_MODULE_20__.ReportOpPerfTelemetry)(this.context.clientId, this.deltaManager, this.logger);
    }
    get IContainerRuntime() { return this; }
    get IContainerRuntimeDirtyable() { return this; }
    get IFluidRouter() { return this; }
    /**
     * Load the stores from a snapshot and returns the runtime.
     * @param context - Context of the container.
     * @param registry - Mapping to the stores.
     * @param requestHandlers - Request handlers for the container runtime
     * @param runtimeOptions - Additional options to be passed to the runtime
     */
    static async load(context, registryEntries, requestHandler, runtimeOptions, containerScope = context.scope) {
        var _a;
        const logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.ChildLogger.create(context.logger, undefined, {
            all: {
                runtimeVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_7__.pkgVersion,
            },
        });
        let storage = context.storage;
        if (context.baseSnapshot) {
            // This will patch snapshot in place!
            // If storage is provided, it will wrap storage with BlobAggregationStorage that can
            // pack & unpack aggregated blobs.
            // Note that if storage is provided later by loader layer, we will wrap storage in this.storage getter.
            // BlobAggregationStorage is smart enough for double-wrapping to be no-op
            if (context.storage) {
                const aggrStorage = _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_21__.BlobAggregationStorage.wrap(context.storage, logger);
                await aggrStorage.unpackSnapshot(context.baseSnapshot);
                storage = aggrStorage;
            }
            else {
                await _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_21__.BlobAggregationStorage.unpackSnapshot(context.baseSnapshot);
            }
        }
        const registry = new ContainerRuntimeDataStoreRegistry(registryEntries);
        const tryFetchBlob = async (blobName) => {
            var _a;
            const blobId = (_a = context.baseSnapshot) === null || _a === void 0 ? void 0 : _a.blobs[blobName];
            if (context.baseSnapshot && blobId) {
                return storage ?
                    (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_22__.readAndParse)(storage, blobId) :
                    (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_22__.readAndParseFromBlobs)(context.baseSnapshot.blobs, blobId);
            }
        };
        const chunks = (_a = await tryFetchBlob(_summaryFormat__WEBPACK_IMPORTED_MODULE_16__.chunksBlobName)) !== null && _a !== void 0 ? _a : [];
        const metadata = await tryFetchBlob(_summaryFormat__WEBPACK_IMPORTED_MODULE_16__.metadataBlobName);
        const runtime = new ContainerRuntime(context, registry, metadata, chunks, runtimeOptions, containerScope, logger, requestHandler, storage);
        // Create all internal data stores if not already existing on storage or loaded a detached
        // container from snapshot(ex. draft mode).
        if (!context.existing) {
            await runtime.createRootDataStore(_fluidframework_agent_scheduler__WEBPACK_IMPORTED_MODULE_5__.AgentSchedulerFactory.type, agentSchedulerId);
        }
        runtime.subscribeToLeadership();
        return runtime;
    }
    get id() {
        return this.context.id;
    }
    get existing() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.context.existing;
    }
    get options() {
        return this.context.options;
    }
    get clientId() {
        return this.context.clientId;
    }
    get clientDetails() {
        return this.context.clientDetails;
    }
    get deltaManager() {
        return this.context.deltaManager;
    }
    get storage() {
        // This code is plain wrong. It lies that it never returns undefined!!!
        // All callers should be fixed, as this API is called in detached state of container when we have
        // no storage and it's passed down the stack without right typing.
        if (!this._storage && this.context.storage) {
            // Note: BlobAggregationStorage is smart enough for double-wrapping to be no-op
            this._storage = _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_21__.BlobAggregationStorage.wrap(this.context.storage, this.logger);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this._storage;
    }
    get reSubmitFn() {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        return this.reSubmit;
    }
    get closeFn() {
        return this.context.closeFn;
    }
    get loader() {
        return this.context.loader;
    }
    get flushMode() {
        return this._flushMode;
    }
    get scope() {
        return this.containerScope;
    }
    get IFluidDataStoreRegistry() {
        return this.registry;
    }
    get attachState() {
        return this.context.attachState;
    }
    /**
     * Returns true if generating summaries with isolated channels is
     * explicitly disabled. This only affects how summaries are written.
     */
    get disableIsolatedChannels() {
        return !!this.runtimeOptions.disableIsolatedChannels;
    }
    get connected() {
        return this._connected;
    }
    get leader() {
        return this._leader;
    }
    get summarizerClientId() {
        return this.summaryManager.summarizer;
    }
    get summaryConfiguration() {
        var _a, _b;
        return Object.assign(Object.assign(Object.assign({}, DefaultSummaryConfiguration), (_b = (_a = this.context) === null || _a === void 0 ? void 0 : _a.serviceConfiguration) === null || _b === void 0 ? void 0 : _b.summary), this.runtimeOptions.summaryConfigOverrides);
    }
    get disposed() { return this._disposed; }
    dispose(error) {
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        this.logger.sendTelemetryEvent({
            eventName: "ContainerRuntimeDisposed",
            category: "generic",
            isDirty: this.isDirty,
            lastSequenceNumber: this.deltaManager.lastSequenceNumber,
            attachState: this.attachState,
            message: error === null || error === void 0 ? void 0 : error.message,
        });
        this.summaryManager.dispose();
        this.summarizer.dispose();
        this.dataStores.dispose();
        this.emit("dispose");
        this.removeAllListeners();
    }
    get IFluidTokenProvider() {
        if (this.options && this.options.intelligence) {
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            return {
                intelligence: this.options.intelligence,
            };
        }
        return undefined;
    }
    get IFluidConfiguration() {
        return this.context.configuration;
    }
    /**
     * Notifies this object about the request made to the container.
     * @param request - Request made to the handler.
     */
    async request(request) {
        try {
            const parser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_23__.RequestParser.create(request);
            const id = parser.pathParts[0];
            if (id === "_summarizer" && parser.pathParts.length === 1) {
                return {
                    status: 200,
                    mimeType: "fluid/object",
                    value: this.summarizer,
                };
            }
            if (this.requestHandler !== undefined) {
                return this.requestHandler(parser, this);
            }
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_24__.create404Response)(request);
        }
        catch (error) {
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_24__.exceptionToResponse)(error);
        }
    }
    /**
     * Resolves URI representing handle
     * @param request - Request made to the handler.
     */
    async resolveHandle(request) {
        var _a, _b;
        try {
            const requestParser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_23__.RequestParser.create(request);
            const id = requestParser.pathParts[0];
            if (id === "_channels") {
                return this.resolveHandle(requestParser.createSubRequest(1));
            }
            if (id === _blobManager__WEBPACK_IMPORTED_MODULE_14__.BlobManager.basePath && requestParser.isLeaf(2)) {
                const handle = await this.blobManager.getBlob(requestParser.pathParts[1]);
                if (handle) {
                    return {
                        status: 200,
                        mimeType: "fluid/object",
                        value: handle.get(),
                    };
                }
                else {
                    return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_24__.create404Response)(request);
                }
            }
            else if (requestParser.pathParts.length > 0) {
                /**
                 * If this an external app request with "externalRequest" header, we need to return an error if the
                 * data store being requested is marked as unreferenced as per the data store's initial summary.
                 *
                 * This is a workaround to handle scenarios where a data store shared with an external app is deleted
                 * and marked as unreferenced by GC. Returning an error will fail to load the data store for the app.
                 */
                const wait = typeof ((_a = request.headers) === null || _a === void 0 ? void 0 : _a.wait) === "boolean" ? request.headers.wait : undefined;
                const dataStore = ((_b = request.headers) === null || _b === void 0 ? void 0 : _b.externalRequest) ? await this.getDataStoreIfInitiallyReferenced(id, wait)
                    : await this.getDataStore(id, wait);
                const subRequest = requestParser.createSubRequest(1);
                // We always expect createSubRequest to include a leading slash, but asserting here to protect against
                // unintentionally modifying the url if that changes.
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(subRequest.url.startsWith("/"), 0x126 /* "Expected createSubRequest url to include a leading slash" */);
                return dataStore.IFluidRouter.request(subRequest);
            }
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_24__.create404Response)(request);
        }
        catch (error) {
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_24__.exceptionToResponse)(error);
        }
    }
    formMetadata() {
        return {
            summaryFormatVersion: 1,
            disableIsolatedChannels: this.disableIsolatedChannels || undefined,
        };
    }
    /**
     * Retrieves the runtime for a data store if it's referenced as per the initially summary that it is loaded with.
     * This is a workaround to handle scenarios where a data store shared with an external app is deleted and marked
     * as unreferenced by GC.
     * @param id - Id supplied during creating the data store.
     * @param wait - True if you want to wait for it.
     * @returns the data store runtime if the data store exists and is initially referenced; undefined otherwise.
     */
    async getDataStoreIfInitiallyReferenced(id, wait = true) {
        const dataStoreContext = await this.dataStores.getDataStore(id, wait);
        // The data store is referenced if used routes in the initial summary has a route to self.
        // Older documents may not have used routes in the summary. They are considered referenced.
        const usedRoutes = (await dataStoreContext.getInitialGCSummaryDetails()).usedRoutes;
        if (usedRoutes === undefined || usedRoutes.includes("") || usedRoutes.includes("/")) {
            return dataStoreContext.realize();
        }
        // The data store is unreferenced. Throw a 404 response exception.
        const request = { url: id };
        throw (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_24__.responseToException)((0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_24__.create404Response)(request), request);
    }
    /**
     * Notifies this object to take the snapshot of the container.
     * @deprecated - Use summarize to get summary of the container runtime.
     */
    async snapshot() {
        const root = { entries: [] };
        const entries = await this.dataStores.snapshot();
        if (this.disableIsolatedChannels) {
            root.entries = root.entries.concat(entries);
        }
        else {
            root.entries.push(new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_25__.TreeTreeEntry(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__.channelsTreeName, { entries }));
            root.entries.push(new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_25__.BlobTreeEntry(_summaryFormat__WEBPACK_IMPORTED_MODULE_16__.metadataBlobName, JSON.stringify(this.formMetadata())));
        }
        if (this.chunkMap.size > 0) {
            root.entries.push(new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_25__.BlobTreeEntry(_summaryFormat__WEBPACK_IMPORTED_MODULE_16__.chunksBlobName, JSON.stringify([...this.chunkMap])));
        }
        return root;
    }
    addContainerBlobsToSummary(summaryTree) {
        if (!this.disableIsolatedChannels) {
            (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_26__.addBlobToSummary)(summaryTree, _summaryFormat__WEBPACK_IMPORTED_MODULE_16__.metadataBlobName, JSON.stringify(this.formMetadata()));
        }
        if (this.chunkMap.size > 0) {
            const content = JSON.stringify([...this.chunkMap]);
            (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_26__.addBlobToSummary)(summaryTree, _summaryFormat__WEBPACK_IMPORTED_MODULE_16__.chunksBlobName, content);
        }
        const blobsTree = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_26__.convertToSummaryTree)(this.blobManager.snapshot(), false);
        (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_26__.addTreeToSummary)(summaryTree, _summaryFormat__WEBPACK_IMPORTED_MODULE_16__.blobsTreeName, blobsTree);
    }
    async stop() {
        this.verifyNotClosed();
        // Reload would not work properly with local changes.
        // First, summarizing code likely does not work (i.e. read - produced unknown result)
        // in presence of local changes.
        // On top of that newly reloaded runtime likely would not be dirty, while it has some changes.
        // And container would assume it's dirty (as there was no notification changing state)
        if (this.dirtyContainer) {
            this.logger.sendErrorEvent({ eventName: "DirtyContainerReloadRuntime" });
        }
        const snapshot = await this.snapshot();
        const state = {
            reload: true,
            summaryCollection: this.summarizer.summaryCollection,
            nextSummarizerP: this.nextSummarizerP,
            nextSummarizerD: this.nextSummarizerD,
        };
        this.dispose(new Error("ContainerRuntimeStopped"));
        return { snapshot, state };
    }
    replayPendingStates() {
        // We need to be able to send ops to replay states
        if (!this.canSendOps()) {
            return;
        }
        // We need to temporary clear the dirty flags and disable
        // dirty state change events to detect whether replaying ops
        // has any effect.
        // Save the old state, reset to false, disable event emit
        const oldState = this.dirtyContainer;
        this.dirtyContainer = false;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.emitDirtyDocumentEvent, 0x127 /* "dirty document event not set on replay" */);
        this.emitDirtyDocumentEvent = false;
        let newState;
        try {
            // replay the ops
            this.pendingStateManager.replayPendingStates();
        }
        finally {
            // Save the new start and restore the old state, re-enable event emit
            newState = this.dirtyContainer;
            this.dirtyContainer = oldState;
            this.emitDirtyDocumentEvent = true;
        }
        // Officially transition from the old state to the new state.
        this.updateDocumentDirtyState(newState);
    }
    async applyStashedOp(type, op) {
        switch (type) {
            case ContainerMessageType.FluidDataStoreOp:
                return this.dataStores.applyStashedOp(op);
            case ContainerMessageType.Attach:
                return this.dataStores.applyStashedAttachOp(op);
            case ContainerMessageType.BlobAttach:
                return;
            case ContainerMessageType.ChunkedOp:
                throw new Error(`chunkedOp not expected here`);
            default:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_27__.unreachableCase)(type, `Unknown ContainerMessageType: ${type}`);
        }
    }
    setConnectionState(connected, clientId) {
        this.verifyNotClosed();
        // There might be no change of state due to Container calling this API after loading runtime.
        const changeOfState = this._connected !== connected;
        this._connected = connected;
        if (changeOfState) {
            this.deltaManager.off("op", this.onOp);
            this.context.pendingLocalState = undefined;
            this.replayPendingStates();
        }
        this.dataStores.setConnectionState(connected, clientId);
        (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_28__.raiseConnectedEvent)(this._logger, this, connected, clientId);
        if (connected) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!!clientId, 0x129 /* "Missing clientId" */);
            this.summaryManager.setConnected(clientId);
        }
        else {
            this.summaryManager.setDisconnected();
        }
    }
    process(messageArg, local) {
        var _a;
        this.verifyNotClosed();
        // If it's not message for runtime, bail out right away.
        if (!isRuntimeMessage(messageArg)) {
            return;
        }
        // Do shallow copy of message, as methods below will modify it.
        // There might be multiple container instances receiving same message
        // We do not need to make deep copy, as each layer will just replace message.content itself,
        // but would not modify contents details
        let message = Object.assign({}, messageArg);
        let error;
        // Surround the actual processing of the operation with messages to the schedule manager indicating
        // the beginning and end. This allows it to emit appropriate events and/or pause the processing of new
        // messages once a batch has been fully processed.
        this.scheduleManager.beginOperation(message);
        try {
            message = unpackRuntimeMessage(message);
            // Chunk processing must come first given that we will transform the message to the unchunked version
            // once all pieces are available
            message = this.processRemoteChunkedMessage(message);
            // Call the PendingStateManager to process messages.
            const { localAck, localOpMetadata } = this.pendingStateManager.processMessage(message, local);
            // If there are no more pending messages after processing a local message,
            // the document is no longer dirty.
            if (!this.pendingStateManager.hasPendingMessages()) {
                this.updateDocumentDirtyState(false);
            }
            switch (message.type) {
                case ContainerMessageType.Attach:
                    this.dataStores.processAttachMessage(message, local || localAck);
                    break;
                case ContainerMessageType.FluidDataStoreOp:
                    // if localAck === true, treat this as a local op because it's one we sent on a previous container
                    this.dataStores.processFluidDataStoreOp(message, local || localAck, localOpMetadata);
                    break;
                case ContainerMessageType.BlobAttach:
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)((_a = message === null || message === void 0 ? void 0 : message.metadata) === null || _a === void 0 ? void 0 : _a.blobId, 0x12a /* "Missing blob id on metadata" */);
                    this.blobManager.addBlobId(message.metadata.blobId);
                    break;
                default:
            }
            this.emit("op", message);
        }
        catch (e) {
            error = e;
            throw e;
        }
        finally {
            this.scheduleManager.endOperation(error, message);
        }
    }
    processSignal(message, local) {
        const envelope = message.content;
        const transformed = {
            clientId: message.clientId,
            content: envelope.contents.content,
            type: envelope.contents.type,
        };
        if (envelope.address === undefined) {
            // No address indicates a container signal message.
            this.emit("signal", transformed, local);
            return;
        }
        this.dataStores.processSignal(envelope.address, transformed, local);
    }
    async getRootDataStore(id, wait = true) {
        const context = await this.dataStores.getDataStore(id, wait);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(await context.isRoot(), 0x12b /* "did not get root data store" */);
        return context.realize();
    }
    async getDataStore(id, wait = true) {
        return (await this.dataStores.getDataStore(id, wait)).realize();
    }
    notifyDataStoreInstantiated(context) {
        const fluidDataStorePkgName = context.packagePath[context.packagePath.length - 1];
        const registryPath = `/${context.packagePath.slice(0, context.packagePath.length - 1).join("/")}`;
        this.emit("fluidDataStoreInstantiated", fluidDataStorePkgName, registryPath, !context.existing);
    }
    setFlushMode(mode) {
        if (mode === this._flushMode) {
            return;
        }
        // If switching to manual mode add a warning trace indicating the underlying loader does not support
        // this feature yet. Can remove in 0.9.
        if (!this.deltaSender && mode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__.FlushMode.Manual) {
            (0,_debug__WEBPACK_IMPORTED_MODULE_29__.debug)("DeltaManager does not yet support flush modes");
            return;
        }
        // Flush any pending batches if switching back to automatic
        if (mode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__.FlushMode.Automatic) {
            this.flush();
        }
        this._flushMode = mode;
        // Let the PendingStateManager know that FlushMode has been updated.
        this.pendingStateManager.onFlushModeUpdated(mode);
    }
    flush() {
        if (!this.deltaSender) {
            (0,_debug__WEBPACK_IMPORTED_MODULE_29__.debug)("DeltaManager does not yet support flush modes");
            return;
        }
        // Let the PendingStateManager know that there was an attempt to flush messages.
        // Note that this should happen before the `this.needsFlush` check below because in the scenario where we are
        // not connected, `this.needsFlush` will be false but the PendingStateManager might have pending messages and
        // hence needs to track this.
        this.pendingStateManager.onFlush();
        // If flush has already been called then exit early
        if (!this.needsFlush) {
            return;
        }
        this.needsFlush = false;
        return this.deltaSender.flush();
    }
    orderSequentially(callback) {
        // If flush mode is already manual we are either
        // nested in another orderSequentially, or
        // the app is flushing manually, in which
        // case this invocation doesn't own
        // flushing.
        if (this.flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__.FlushMode.Manual) {
            callback();
        }
        else {
            const savedFlushMode = this.flushMode;
            this.setFlushMode(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__.FlushMode.Manual);
            try {
                callback();
            }
            finally {
                this.flush();
                this.setFlushMode(savedFlushMode);
            }
        }
    }
    async createDataStore(pkg) {
        return this._createDataStore(pkg, false /* isRoot */);
    }
    async createRootDataStore(pkg, rootDataStoreId) {
        const fluidDataStore = await this._createDataStore(pkg, true /* isRoot */, rootDataStoreId);
        fluidDataStore.bindToContext();
        return fluidDataStore;
    }
    createDetachedRootDataStore(pkg, rootDataStoreId) {
        return this.dataStores.createDetachedDataStoreCore(pkg, true, rootDataStoreId);
    }
    createDetachedDataStore(pkg) {
        return this.dataStores.createDetachedDataStoreCore(pkg, false);
    }
    async _createDataStoreWithProps(pkg, props, id = (0,uuid__WEBPACK_IMPORTED_MODULE_30__.default)(), isRoot = false) {
        return this.dataStores._createFluidDataStoreContext(Array.isArray(pkg) ? pkg : [pkg], id, isRoot, props).realize();
    }
    async _createDataStore(pkg, isRoot, id = (0,uuid__WEBPACK_IMPORTED_MODULE_30__.default)()) {
        return this.dataStores._createFluidDataStoreContext(Array.isArray(pkg) ? pkg : [pkg], id, isRoot).realize();
    }
    canSendOps() {
        return this.connected && !this.deltaManager.readonly;
    }
    getQuorum() {
        return this.context.quorum;
    }
    getAudience() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.context.audience;
    }
    raiseContainerWarning(warning) {
        this.context.raiseContainerWarning(warning);
    }
    /**
     * @deprecated - // back-compat: marked deprecated in 0.35
     * Returns true of document is dirty, i.e. there are some pending local changes that
     * either were not sent out to delta stream or were not yet acknowledged.
     */
    isDocumentDirty() {
        return this.dirtyContainer;
    }
    /**
     * Returns true of container is dirty, i.e. there are some pending local changes that
     * either were not sent out to delta stream or were not yet acknowledged.
     */
    get isDirty() {
        return this.dirtyContainer;
    }
    /**
     * Will return true for any message that affect the dirty state of this document
     * This function can be used to filter out any runtime operations that should not be affecting whether or not
     * the IFluidDataStoreRuntime.isDirty call returns true/false
     * @param type - The type of ContainerRuntime message that is being checked
     * @param contents - The contents of the message that is being verified
     */
    isMessageDirtyable(message) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(isRuntimeMessage(message) === true, 0x12c /* "Message passed for dirtyable check should be a container runtime message" */);
        return this.isContainerMessageDirtyable(message.type, message.contents);
    }
    isContainerMessageDirtyable(type, contents) {
        if (type === ContainerMessageType.Attach) {
            const attachMessage = contents;
            if (attachMessage.id === agentSchedulerId) {
                return false;
            }
        }
        else if (type === ContainerMessageType.FluidDataStoreOp) {
            const envelope = contents;
            if (envelope.address === agentSchedulerId) {
                return false;
            }
        }
        return true;
    }
    /**
     * Submits the signal to be sent to other clients.
     * @param type - Type of the signal.
     * @param content - Content of the signal.
     */
    submitSignal(type, content) {
        this.verifyNotClosed();
        const envelope = { address: undefined, contents: { type, content } };
        return this.context.submitSignalFn(envelope);
    }
    submitDataStoreSignal(address, type, content) {
        const envelope = { address, contents: { type, content } };
        return this.context.submitSignalFn(envelope);
    }
    setAttachState(attachState) {
        if (attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_15__.AttachState.Attaching) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_15__.AttachState.Attaching, 0x12d /* "Container Context should already be in attaching state" */);
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_15__.AttachState.Attached, 0x12e /* "Container Context should already be in attached state" */);
        }
        this.dataStores.setAttachState(attachState);
    }
    createSummary() {
        const summarizeResult = this.dataStores.createSummary();
        if (!this.disableIsolatedChannels) {
            // Wrap data store summaries in .channels subtree.
            (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_16__.wrapSummaryInChannelsTree)(summarizeResult);
        }
        this.addContainerBlobsToSummary(summarizeResult);
        return summarizeResult.summary;
    }
    async getAbsoluteUrl(relativeUrl) {
        if (this.context.getAbsoluteUrl === undefined) {
            throw new Error("Driver does not implement getAbsoluteUrl");
        }
        if (this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_15__.AttachState.Attached) {
            return undefined;
        }
        return this.context.getAbsoluteUrl(relativeUrl);
    }
    async collectGarbage(logger) {
        await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.timedExecAsync(logger, { eventName: "GarbageCollection" }, async (event) => {
            const gcStats = {};
            try {
                // Get the container's GC data and run GC on the reference graph in it.
                const gcData = await this.dataStores.getGCData(this.runtimeOptions.runFullGC === true);
                const { referencedNodeIds, deletedNodeIds } = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_31__.runGarbageCollection)(gcData.gcNodes, ["/"], this.logger);
                // Update stats to be reported in the peformance event.
                gcStats.deletedGCNodes = deletedNodeIds.length;
                gcStats.totalGCNodes = referencedNodeIds.length + gcStats.deletedGCNodes;
                // Update our summarizer node's used routes. Updating used routes in summarizer node before
                // summarizing is required and asserted by the the summarizer node. We are the root and are
                // always referenced, so the used routes is only self-route (empty string).
                this.summarizerNode.updateUsedRoutes([""]);
                // Remove this node's route ("/") and notify data stores of routes that are used in it.
                const usedRoutes = referencedNodeIds.filter((id) => { return id !== "/"; });
                this.dataStores.updateUsedRoutes(usedRoutes);
            }
            catch (error) {
                event.cancel(gcStats, error);
                throw error;
            }
            event.end(gcStats);
        });
    }
    async summarizeInternal(fullTree, trackState) {
        const summarizeResult = await this.dataStores.summarize(fullTree, trackState);
        let pathPartsForChildren;
        if (!this.disableIsolatedChannels) {
            // Wrap data store summaries in .channels subtree.
            (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_16__.wrapSummaryInChannelsTree)(summarizeResult);
            pathPartsForChildren = [_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__.channelsTreeName];
        }
        this.addContainerBlobsToSummary(summarizeResult);
        return Object.assign(Object.assign({}, summarizeResult), { id: "", pathPartsForChildren });
    }
    /**
     * Returns a summary of the runtime at the current sequence number.
     */
    async summarize(options) {
        const { runGC, fullTree = false, trackState, summaryLogger } = options;
        if (runGC) {
            await this.collectGarbage(summaryLogger);
        }
        const summarizeResult = await this.summarizerNode.summarize(fullTree, trackState);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(summarizeResult.summary.type === 1 /* Tree */, 0x12f /* "Container Runtime's summarize should always return a tree" */);
        return summarizeResult;
    }
    /** Implementation of ISummarizerInternalsProvider.generateSummary */
    async generateSummary(options) {
        const { fullTree, refreshLatestAck, summaryLogger } = options;
        const summaryRefSeqNum = this.deltaManager.lastSequenceNumber;
        const message = `Summary @${summaryRefSeqNum}:${this.deltaManager.minimumSequenceNumber}`;
        this.summarizerNode.startSummary(summaryRefSeqNum, summaryLogger);
        try {
            await this.deltaManager.inbound.pause();
            const attemptData = {
                referenceSequenceNumber: summaryRefSeqNum,
                submitted: false,
            };
            if (!this.connected) {
                // If summarizer loses connection it will never reconnect
                return Object.assign(Object.assign({}, attemptData), { reason: "disconnected" });
            }
            const trace = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_32__.Trace.start();
            const summarizeResult = await this.summarize({
                runGC: !this.runtimeOptions.disableGC,
                fullTree,
                trackState: true,
                summaryLogger,
            });
            const generateData = {
                summaryStats: summarizeResult.stats,
                generateDuration: trace.trace().duration,
            };
            if (!this.connected) {
                return Object.assign(Object.assign(Object.assign({}, attemptData), generateData), { reason: "disconnected" });
            }
            // Ensure that lastSequenceNumber has not changed after pausing
            const lastSequenceNumber = this.deltaManager.lastSequenceNumber;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(lastSequenceNumber === summaryRefSeqNum, 0x130 /* `lastSequenceNumber changed while paused. ${lastSequenceNumber} !== ${summaryRefSeqNum}` */);
            const handle = await this.storage.uploadSummaryWithContext(summarizeResult.summary, Object.assign(Object.assign({}, this.latestSummaryAck), { referenceSequenceNumber: summaryRefSeqNum }));
            if (refreshLatestAck) {
                const version = await this.getVersionFromStorage(this.id);
                await this.refreshLatestSummaryAck(undefined, version.id, _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.ChildLogger.create(summaryLogger, undefined, { all: { safeSummary: true } }), version);
            }
            const parent = this.latestSummaryAck.ackHandle;
            const summaryMessage = {
                handle,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                head: parent,
                message,
                parents: parent ? [parent] : [],
            };
            const uploadData = {
                handle,
                uploadDuration: trace.trace().duration,
            };
            if (!this.connected) {
                return Object.assign(Object.assign(Object.assign(Object.assign({}, attemptData), generateData), uploadData), { reason: "disconnected" });
            }
            // We need the summary op's reference sequence number to match our summary sequence number
            // Otherwise we'll get the wrong sequence number stamped on the summary's .protocol attributes
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.deltaManager.lastSequenceNumber === summaryRefSeqNum, `lastSequenceNumber changed before the summary op could be submitted. `
                + `${this.deltaManager.lastSequenceNumber} !== ${summaryRefSeqNum}`);
            const clientSequenceNumber = this.submitSystemMessage(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Summarize, summaryMessage);
            this.summarizerNode.completeSummary(handle);
            return Object.assign(Object.assign(Object.assign(Object.assign({}, attemptData), generateData), uploadData), { submitted: true, clientSequenceNumber, submitOpDuration: trace.trace().duration });
        }
        finally {
            // Cleanup wip summary in case of failure
            this.summarizerNode.clearSummary();
            // Restart the delta manager
            this.deltaManager.inbound.resume();
        }
    }
    processRemoteChunkedMessage(message) {
        if (message.type !== ContainerMessageType.ChunkedOp) {
            return message;
        }
        const clientId = message.clientId;
        const chunkedContent = message.contents;
        this.addChunk(clientId, chunkedContent);
        if (chunkedContent.chunkId === chunkedContent.totalChunks) {
            const newMessage = Object.assign({}, message);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const serializedContent = this.chunkMap.get(clientId).join("");
            newMessage.contents = JSON.parse(serializedContent);
            newMessage.type = chunkedContent.originalType;
            this.clearPartialChunks(clientId);
            return newMessage;
        }
        return message;
    }
    addChunk(clientId, chunkedContent) {
        let map = this.chunkMap.get(clientId);
        if (map === undefined) {
            map = [];
            this.chunkMap.set(clientId, map);
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(chunkedContent.chunkId === map.length + 1, 0x131 /* "Mismatch between new chunkId and expected chunkMap" */); // 1-based indexing
        map.push(chunkedContent.contents);
    }
    clearPartialChunks(clientId) {
        if (this.chunkMap.has(clientId)) {
            this.chunkMap.delete(clientId);
        }
    }
    updateDocumentDirtyState(dirty) {
        if (this.dirtyContainer === dirty) {
            return;
        }
        this.dirtyContainer = dirty;
        if (this.emitDirtyDocumentEvent) {
            // back-compat: dirtyDocument & savedDocument deprecated in 0.35.
            this.emit(dirty ? "dirtyDocument" : "savedDocument");
            this.emit(dirty ? "dirty" : "saved");
            // back-compat: Loader API added in 0.35 only
            if (this.context.updateDirtyContainerState !== undefined) {
                this.context.updateDirtyContainerState(dirty);
            }
        }
    }
    submitDataStoreOp(id, contents, localOpMetadata = undefined) {
        const envelope = {
            address: id,
            contents,
        };
        this.submit(ContainerMessageType.FluidDataStoreOp, envelope, localOpMetadata);
    }
    async uploadBlob(blob) {
        return this.blobManager.createBlob(blob);
    }
    submit(type, content, localOpMetadata = undefined, opMetadata = undefined) {
        this.verifyNotClosed();
        if (this.context.pendingLocalState !== undefined) {
            this.closeFn((0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_9__.CreateContainerError)("op submitted while processing pending initial state"));
        }
        // There should be no ops in detached container state!
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_15__.AttachState.Detached, 0x132 /* "sending ops in detached container" */);
        let clientSequenceNumber = -1;
        let opMetadataInternal = opMetadata;
        if (this.canSendOps()) {
            const serializedContent = JSON.stringify(content);
            const maxOpSize = this.context.deltaManager.maxMessageSize;
            // If in manual flush mode we will trigger a flush at the next turn break
            if (this.flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__.FlushMode.Manual && !this.needsFlush) {
                opMetadataInternal = Object.assign(Object.assign({}, opMetadata), { batch: true });
                this.needsFlush = true;
                // Use Promise.resolve().then() to queue a microtask to detect the end of the turn and force a flush.
                if (!this.flushTrigger) {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    Promise.resolve().then(() => {
                        this.flushTrigger = false;
                        this.flush();
                    });
                }
            }
            // Note: Chunking will increase content beyond maxOpSize because we JSON'ing JSON payload -
            // there will be a lot of escape characters that can make it up to 2x bigger!
            // This is Ok, because DeltaManager.shouldSplit() will have 2 * maxMessageSize limit
            if (!serializedContent || serializedContent.length <= maxOpSize) {
                clientSequenceNumber = this.submitRuntimeMessage(type, content, 
                /* batch: */ this._flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__.FlushMode.Manual, opMetadataInternal);
            }
            else {
                clientSequenceNumber = this.submitChunkedMessage(type, serializedContent, maxOpSize);
            }
        }
        // Let the PendingStateManager know that a message was submitted.
        this.pendingStateManager.onSubmitMessage(type, clientSequenceNumber, this.deltaManager.lastSequenceNumber, content, localOpMetadata, opMetadataInternal);
        if (this.isContainerMessageDirtyable(type, content)) {
            this.updateDocumentDirtyState(true);
        }
    }
    submitChunkedMessage(type, content, maxOpSize) {
        const contentLength = content.length;
        const chunkN = Math.floor((contentLength - 1) / maxOpSize) + 1;
        let offset = 0;
        let clientSequenceNumber = 0;
        for (let i = 1; i <= chunkN; i = i + 1) {
            const chunkedOp = {
                chunkId: i,
                contents: content.substr(offset, maxOpSize),
                originalType: type,
                totalChunks: chunkN,
            };
            offset += maxOpSize;
            clientSequenceNumber = this.submitRuntimeMessage(ContainerMessageType.ChunkedOp, chunkedOp, false);
        }
        return clientSequenceNumber;
    }
    submitSystemMessage(type, contents) {
        this.verifyNotClosed();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.connected, 0x133 /* "Container disconnected when trying to submit system message" */);
        // System message should not be sent in the middle of the batch.
        // That said, we can preserve existing behavior by not flushing existing buffer.
        // That might be not what caller hopes to get, but we can look deeper if telemetry tells us it's a problem.
        const middleOfBatch = this.flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__.FlushMode.Manual && this.needsFlush;
        if (middleOfBatch) {
            this._logger.sendErrorEvent({ eventName: "submitSystemMessageError", type });
        }
        return this.context.submitFn(type, contents, middleOfBatch);
    }
    submitRuntimeMessage(type, contents, batch, appData) {
        const payload = { type, contents };
        return this.context.submitFn(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Operation, payload, batch, appData);
    }
    /**
     * Throw an error if the runtime is closed.  Methods that are expected to potentially
     * be called after dispose due to asynchrony should not call this.
     */
    verifyNotClosed() {
        if (this._disposed) {
            throw new Error("Runtime is closed");
        }
    }
    /**
     * Finds the right store and asks it to resubmit the message. This typically happens when we
     * reconnect and there are pending messages.
     * @param content - The content of the original message.
     * @param localOpMetadata - The local metadata associated with the original message.
     */
    reSubmit(type, content, localOpMetadata, opMetadata) {
        switch (type) {
            case ContainerMessageType.FluidDataStoreOp:
                // For Operations, call resubmitDataStoreOp which will find the right store
                // and trigger resubmission on it.
                this.dataStores.resubmitDataStoreOp(content, localOpMetadata);
                break;
            case ContainerMessageType.Attach:
                this.submit(type, content, localOpMetadata);
                break;
            case ContainerMessageType.ChunkedOp:
                throw new Error(`chunkedOp not expected here`);
            case ContainerMessageType.BlobAttach:
                this.submit(type, content, localOpMetadata, opMetadata);
                break;
            default:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_27__.unreachableCase)(type, `Unknown ContainerMessageType: ${type}`);
        }
    }
    subscribeToLeadership() {
        if (this.context.clientDetails.capabilities.interactive) {
            this.getScheduler().then((scheduler) => {
                const LeaderTaskId = "leader";
                // Each client expresses interest to be a leader.
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                scheduler.pick(LeaderTaskId, async () => {
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this._leader, 0x134 /* "Client is already leader" */);
                    this.updateLeader(true);
                });
                scheduler.on("lost", (key) => {
                    if (key === LeaderTaskId) {
                        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this._leader, 0x135 /* "Got leader key but client is not leader" */);
                        this._leader = false;
                        this.updateLeader(false);
                    }
                });
            }).catch((err) => {
                this.closeFn((0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_9__.CreateContainerError)(err));
            });
        }
    }
    /**
     * @deprecated starting in 0.36. The AgentScheduler can be requested directly, though this will also be removed in
     * a future release when an alternative is available: containerRuntime.request(\{ url: "/_scheduler" \}).
     * getTaskManager should be removed in 0.38.
     */
    async getTaskManager() {
        console.error("getTaskManager is deprecated.");
        const agentScheduler = await this.getScheduler();
        // Prior versions would return a TaskManager, which was an IProvideAgentScheduler -- returning this for back
        // compat.  Wrapping the agentScheduler in an IProvideAgentScheduler will help catch any cases where customers
        // try to call other TaskManager functionality.
        return { IAgentScheduler: agentScheduler };
    }
    async getScheduler() {
        return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_24__.requestFluidObject)(await this.getDataStore(agentSchedulerId, true), "");
    }
    updateLeader(leadership) {
        this._leader = leadership;
        if (this.leader) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.clientId === undefined || this.connected && this.deltaManager && this.deltaManager.active, 0x136 /* "Leader must either have undefined clientId or be connected with active delta manager!" */);
            this.emit("leader");
        }
        else {
            this.emit("notleader");
        }
        this.dataStores.updateLeader();
    }
    /** Implementation of ISummarizerInternalsProvider.refreshLatestSummaryAck */
    async refreshLatestSummaryAck(proposalHandle, ackHandle, summaryLogger, version) {
        this.latestSummaryAck = { proposalHandle, ackHandle };
        const getSnapshot = async () => {
            const perfEvent = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.start(summaryLogger, {
                eventName: "RefreshLatestSummaryGetSnapshot",
                hasVersion: !!version,
            });
            const stats = {};
            let snapshot;
            try {
                const trace = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_32__.Trace.start();
                const versionToUse = version !== null && version !== void 0 ? version : await this.getVersionFromStorage(ackHandle);
                stats.getVersionDuration = trace.trace().duration;
                snapshot = await this.getSnapshotFromStorage(versionToUse);
                stats.getSnapshotDuration = trace.trace().duration;
            }
            catch (error) {
                perfEvent.cancel(stats, error);
                throw error;
            }
            perfEvent.end(stats);
            return snapshot;
        };
        await this.summarizerNode.refreshLatestSummary(proposalHandle, getSnapshot, async (id) => (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_22__.readAndParse)(this.storage, id), summaryLogger);
    }
    async getVersionFromStorage(versionId) {
        const versions = await this.storage.getVersions(versionId, 1);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!!versions && !!versions[0], 0x137 /* "Failed to get version from storage" */);
        return versions[0];
    }
    async getSnapshotFromStorage(version) {
        const snapshot = await this.storage.getSnapshotTree(version);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!!snapshot, 0x138 /* "Failed to get snapshot from storage" */);
        return snapshot;
    }
    getPendingLocalState() {
        return this.pendingStateManager.getLocalState();
    }
}
//# sourceMappingURL=containerRuntime.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/dataStoreContext.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/dataStoreContext.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAttributesBlob": () => (/* binding */ createAttributesBlob),
/* harmony export */   "RemotedFluidDataStoreContext": () => (/* binding */ RemotedFluidDataStoreContext),
/* harmony export */   "LocalFluidDataStoreContext": () => (/* binding */ LocalFluidDataStoreContext),
/* harmony export */   "LocalDetachedFluidDataStoreContext": () => (/* binding */ LocalDetachedFluidDataStoreContext)
/* harmony export */ });
/* unused harmony exports FluidDataStoreContext, LocalFluidDataStoreContextBase */
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/container-definitions */ "../../node_modules/@fluidframework/container-definitions/lib/runtime.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/typedEventEmitter.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/promises.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/readAndParse.js");
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/protocol-base */ "../../node_modules/@fluidframework/protocol-base/lib/blobs.js");
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @fluidframework/runtime-definitions */ "../../node_modules/@fluidframework/runtime-definitions/dist/index.js");
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/summaryUtils.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _summaryFormat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./summaryFormat */ "../../node_modules/@fluidframework/container-runtime/lib/summaryFormat.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */








function createAttributes(pkg, isRootDataStore, disableIsolatedChannels) {
    const stringifiedPkg = JSON.stringify(pkg);
    return disableIsolatedChannels ? {
        pkg: stringifiedPkg,
        snapshotFormatVersion: "0.1",
        isRootDataStore,
    } : {
        pkg: stringifiedPkg,
        summaryFormatVersion: 2,
        isRootDataStore,
    };
}
function createAttributesBlob(pkg, isRootDataStore, disableIsolatedChannels) {
    const attributes = createAttributes(pkg, isRootDataStore, disableIsolatedChannels);
    return new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_0__.BlobTreeEntry(_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.dataStoreAttributesBlobName, JSON.stringify(attributes));
}
/**
 * Represents the context for the store. This context is passed to the store runtime.
 */
class FluidDataStoreContext extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.TypedEventEmitter {
    constructor(_containerRuntime, id, existing, storage, scope, createSummarizerNode, bindState, isLocalDataStore, bindChannel, pkg) {
        super();
        this._containerRuntime = _containerRuntime;
        this.id = id;
        this.existing = existing;
        this.storage = storage;
        this.scope = scope;
        this.bindState = bindState;
        this.isLocalDataStore = isLocalDataStore;
        this.pkg = pkg;
        this._disposed = false;
        this.detachedRuntimeCreation = false;
        this.loaded = false;
        this.pending = [];
        // URIs use slashes as delimiters. Handles use URIs.
        // Thus having slashes in types almost guarantees trouble down the road!
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(id.indexOf("/") === -1, 0x13a /* `Data store ID contains slash: ${id}` */);
        this._attachState = this.containerRuntime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Detached && existing ?
            this.containerRuntime.attachState : _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Detached;
        this.bindToContext = () => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.bindState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.NotBound, 0x13b /* "datastore context is already in bound state" */);
            this.bindState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.Binding;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channel !== undefined, 0x13c /* "undefined channel on datastore context" */);
            bindChannel(this.channel);
            this.bindState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.Bound;
        };
        const thisSummarizeInternal = async (fullTree, trackState) => this.summarizeInternal(fullTree, trackState);
        this.summarizerNode = createSummarizerNode(thisSummarizeInternal, async (fullGC) => this.getGCDataInternal(fullGC), async () => this.getInitialGCSummaryDetails());
    }
    get documentId() {
        return this._containerRuntime.id;
    }
    get packagePath() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pkg !== undefined, 0x139 /* "Undefined package path" */);
        return this.pkg;
    }
    get options() {
        return this._containerRuntime.options;
    }
    get clientId() {
        return this._containerRuntime.clientId;
    }
    get deltaManager() {
        return this._containerRuntime.deltaManager;
    }
    get connected() {
        return this._containerRuntime.connected;
    }
    get leader() {
        return this._containerRuntime.leader;
    }
    get loader() {
        return this._containerRuntime.loader;
    }
    get containerRuntime() {
        return this._containerRuntime;
    }
    get isLoaded() {
        return this.loaded;
    }
    get baseSnapshot() {
        return this._baseSnapshot;
    }
    get disposed() { return this._disposed; }
    get attachState() {
        return this._attachState;
    }
    get IFluidDataStoreRegistry() {
        return this.registry;
    }
    async isRoot() {
        return (await this.getInitialSnapshotDetails()).isRootDataStore;
    }
    get disableIsolatedChannels() {
        return this._containerRuntime.disableIsolatedChannels;
    }
    dispose() {
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        // Dispose any pending runtime after it gets fulfilled
        if (this.channelDeferred) {
            this.channelDeferred.promise.then((runtime) => {
                runtime.dispose();
            }).catch((error) => {
                this._containerRuntime.logger.sendErrorEvent({ eventName: "ChannelDisposeError", fluidDataStoreId: this.id }, error);
            });
        }
    }
    rejectDeferredRealize(reason, packageName) {
        throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.LoggingError(reason, { packageName: { value: packageName, tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.TelemetryDataTag.PackageData } });
    }
    async realize() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.detachedRuntimeCreation, 0x13d /* "Detached runtime creation on realize()" */);
        if (!this.channelDeferred) {
            this.channelDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.Deferred();
            this.realizeCore().catch((error) => {
                var _a;
                (_a = this.channelDeferred) === null || _a === void 0 ? void 0 : _a.reject(error);
            });
        }
        return this.channelDeferred.promise;
    }
    async factoryFromPackagePath(packages) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pkg === packages, 0x13e /* "Unexpected package path" */);
        if (packages === undefined) {
            this.rejectDeferredRealize("packages is undefined");
        }
        let entry;
        let registry = this._containerRuntime.IFluidDataStoreRegistry;
        let lastPkg;
        for (const pkg of packages) {
            if (!registry) {
                this.rejectDeferredRealize("No registry for package", lastPkg);
            }
            lastPkg = pkg;
            entry = await registry.get(pkg);
            if (!entry) {
                this.rejectDeferredRealize("Registry does not contain entry for the package", pkg);
            }
            registry = entry.IFluidDataStoreRegistry;
        }
        const factory = entry === null || entry === void 0 ? void 0 : entry.IFluidDataStoreFactory;
        if (factory === undefined) {
            this.rejectDeferredRealize("Can't find factory for package", lastPkg);
        }
        return { factory, registry };
    }
    async realizeCore() {
        const details = await this.getInitialSnapshotDetails();
        // Base snapshot is the baseline where pending ops are applied to.
        // It is important that this be in sync with the pending ops, and also
        // that it is set here, before bindRuntime is called.
        this._baseSnapshot = details.snapshot;
        const packages = details.pkg;
        const { factory, registry } = await this.factoryFromPackagePath(packages);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.registry === undefined, 0x13f /* "datastore context registry is already set" */);
        this.registry = registry;
        const channel = await factory.instantiateDataStore(this);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(channel !== undefined, 0x140 /* "undefined channel on datastore context" */);
        this.bindRuntime(channel);
    }
    /**
     * Notifies this object about changes in the connection state.
     * @param value - New connection state.
     * @param clientId - ID of the client. It's old ID when in disconnected state and
     * it's new client ID when we are connecting or connected.
     */
    setConnectionState(connected, clientId) {
        this.verifyNotClosed();
        // Connection events are ignored if the store is not yet loaded
        if (!this.loaded) {
            return;
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.connected === connected, 0x141 /* "Unexpected connected state" */);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.channel.setConnectionState(connected, clientId);
    }
    process(messageArg, local, localOpMetadata) {
        var _a, _b;
        this.verifyNotClosed();
        const innerContents = messageArg.contents;
        const message = Object.assign(Object.assign({}, messageArg), { type: innerContents.type, contents: innerContents.content });
        this.summarizerNode.recordChange(message);
        if (this.loaded) {
            return (_a = this.channel) === null || _a === void 0 ? void 0 : _a.process(message, local, localOpMetadata);
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!local, 0x142 /* "local store channel is not loaded" */);
            (_b = this.pending) === null || _b === void 0 ? void 0 : _b.push(message);
        }
    }
    processSignal(message, local) {
        var _a;
        this.verifyNotClosed();
        // Signals are ignored if the store is not yet loaded
        if (!this.loaded) {
            return;
        }
        (_a = this.channel) === null || _a === void 0 ? void 0 : _a.processSignal(message, local);
    }
    getQuorum() {
        return this._containerRuntime.getQuorum();
    }
    getAudience() {
        return this._containerRuntime.getAudience();
    }
    /**
     * Returns a summary at the current sequence number.
     * @param fullTree - true to bypass optimizations and force a full summary tree
     * @param trackState - This tells whether we should track state from this summary.
     */
    async summarize(fullTree = false, trackState = true) {
        return this.summarizerNode.summarize(fullTree, trackState);
    }
    async summarizeInternal(fullTree, trackState) {
        await this.realize();
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const summarizeResult = await this.channel.summarize(fullTree, trackState);
        let pathPartsForChildren;
        if (!this.disableIsolatedChannels) {
            // Wrap dds summaries in .channels subtree.
            (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.wrapSummaryInChannelsTree)(summarizeResult);
            pathPartsForChildren = [_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.channelsTreeName];
        }
        // Add data store's attributes to the summary.
        const { pkg, isRootDataStore } = await this.getInitialSnapshotDetails();
        const attributes = createAttributes(pkg, isRootDataStore, this.disableIsolatedChannels);
        (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_8__.addBlobToSummary)(summarizeResult, _summaryFormat__WEBPACK_IMPORTED_MODULE_1__.dataStoreAttributesBlobName, JSON.stringify(attributes));
        // Add GC details to the summary.
        const gcDetails = {
            usedRoutes: this.summarizerNode.usedRoutes,
            gcData: summarizeResult.gcData,
        };
        (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_8__.addBlobToSummary)(summarizeResult, _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.gcBlobKey, JSON.stringify(gcDetails));
        // If we are not referenced, update the summary tree to indicate that.
        if (!this.summarizerNode.isReferenced()) {
            summarizeResult.summary.unreferenced = true;
        }
        return Object.assign(Object.assign({}, summarizeResult), { id: this.id, pathPartsForChildren });
    }
    /**
     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this data store
     * including any of its child channel contexts. Each node has a set of outbound routes to other GC nodes in the
     * document.
     * If there is no new data in this data store since the last summary, previous GC data is used.
     * If there is new data, the GC data is generated again (by calling getGCDataInternal).
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        return this.summarizerNode.getGCData(fullGC);
    }
    /**
     * Generates data used for garbage collection. This is called when there is new data since last summary. It
     * realizes the data store and calls into each channel context to get its GC data.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCDataInternal(fullGC = false) {
        await this.realize();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channel !== undefined, 0x143 /* "Channel should not be undefined when running GC" */);
        return this.channel.getGCData(fullGC);
    }
    /**
     * After GC has run, called to notify the data store of routes used in it. These are used for the following:
     * 1. To identify if this data store is being referenced in the document or not.
     * 2. To determine if it needs to re-summarize in case used routes changed since last summary.
     * 3. These are added to the summary generated by the data store.
     * 4. To notify child contexts of their used routes. This is done immediately if the data store is loaded. Else,
     *    it is done when realizing the data store.
     * @param usedRoutes - The routes that are used in this data store.
     */
    updateUsedRoutes(usedRoutes) {
        // Currently, only data stores can be collected. Once we have GC at DDS layer, the DDS' in the data store will
        // also be notified of their used routes. See - https://github.com/microsoft/FluidFramework/issues/4611
        // Update the used routes in this data store's summarizer node.
        this.summarizerNode.updateUsedRoutes(usedRoutes);
        // If we are loaded, call the channel so it can update the used routes of the child contexts.
        // If we are not loaded, we will update this when we are realized.
        if (this.loaded) {
            this.updateChannelUsedRoutes();
        }
    }
    /**
     * Updates the used routes of the channel and its child contexts. The channel must be loaded before calling this.
     * It is called in these two scenarions:
     * 1. When the used routes of the data store is updated and the data store is loaded.
     * 2. When the data store is realized. This updates the channel's used routes as per last GC run.
     */
    updateChannelUsedRoutes() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.loaded, 0x144 /* "Channel should be loaded when updating used routes" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channel !== undefined, 0x145 /* "Channel should be present when data store is loaded" */);
        // Remove the route to this data store, if it exists.
        const usedChannelRoutes = this.summarizerNode.usedRoutes.filter((id) => { return id !== "/" && id !== ""; });
        this.channel.updateUsedRoutes(usedChannelRoutes);
    }
    /**
     * @deprecated 0.18.Should call request on the runtime directly
     */
    async request(request) {
        const runtime = await this.realize();
        return runtime.request(request);
    }
    submitMessage(type, content, localOpMetadata) {
        this.verifyNotClosed();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.channel, 0x146 /* "Channel must exist when submitting message" */);
        const fluidDataStoreContent = {
            content,
            type,
        };
        this._containerRuntime.submitDataStoreOp(this.id, fluidDataStoreContent, localOpMetadata);
    }
    /**
     * This is called from a SharedSummaryBlock that does not generate ops but only wants to be part of the summary.
     * It indicates that there is data in the object that needs to be summarized.
     * We will update the latestSequenceNumber of the summary tracker of this
     * store and of the object's channel.
     *
     * @param address - The address of the channel that is dirty.
     *
     */
    setChannelDirty(address) {
        this.verifyNotClosed();
        // Get the latest sequence number.
        const latestSequenceNumber = this.deltaManager.lastSequenceNumber;
        this.summarizerNode.invalidate(latestSequenceNumber);
        const channelSummarizerNode = this.summarizerNode.getChild(address);
        if (channelSummarizerNode) {
            channelSummarizerNode.invalidate(latestSequenceNumber); // TODO: lazy load problem?
        }
    }
    submitSignal(type, content) {
        this.verifyNotClosed();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.channel, 0x147 /* "Channel must exist on submitting signal" */);
        return this._containerRuntime.submitDataStoreSignal(this.id, type, content);
    }
    raiseContainerWarning(warning) {
        this.containerRuntime.raiseContainerWarning(warning);
    }
    /**
     * Updates the leader.
     * @param leadership - Whether this client is the new leader or not.
     */
    updateLeader(leadership) {
        // Leader events are ignored if the store is not yet loaded
        if (!this.loaded) {
            return;
        }
        if (leadership) {
            this.emit("leader");
        }
        else {
            this.emit("notleader");
        }
    }
    bindRuntime(channel) {
        var _a;
        if (this.channel) {
            throw new Error("Runtime already bound");
        }
        try {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.detachedRuntimeCreation, 0x148 /* "Detached runtime creation on runtime bind" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channelDeferred !== undefined, 0x149 /* "Undefined channel defferal" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pkg !== undefined, 0x14a /* "Undefined package path" */);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const pending = this.pending;
            if (pending.length > 0) {
                // Apply all pending ops
                for (const op of pending) {
                    channel.process(op, false, undefined /* localOpMetadata */);
                }
            }
            this.pending = undefined;
            // And now mark the runtime active
            this.loaded = true;
            this.channel = channel;
            // Freeze the package path to ensure that someone doesn't modify it when it is
            // returned in packagePath().
            Object.freeze(this.pkg);
            /**
             * Update the used routes of the channel. If GC has run before this data store was realized, we will have
             * the used routes saved. So, this will ensure that all the child contexts have up-to-date used routes as
             * per the last time GC was run.
             * Also, this data store may have been realized during summarize. In that case, the child contexts need to
             * have their used routes updated to determine if its needs to summarize again and to add it to the summary.
             */
            this.updateChannelUsedRoutes();
            // And notify the pending promise it is now available
            this.channelDeferred.resolve(this.channel);
        }
        catch (error) {
            (_a = this.channelDeferred) === null || _a === void 0 ? void 0 : _a.reject(error);
        }
        // notify the runtime if they want to propagate up. Used for logging.
        this._containerRuntime.notifyDataStoreInstantiated(this);
    }
    async getAbsoluteUrl(relativeUrl) {
        if (this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Attached) {
            return undefined;
        }
        return this._containerRuntime.getAbsoluteUrl(relativeUrl);
    }
    reSubmit(contents, localOpMetadata) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.channel, 0x14b /* "Channel must exist when resubmitting ops" */);
        const innerContents = contents;
        this.channel.reSubmit(innerContents.type, innerContents.content, localOpMetadata);
    }
    async applyStashedOp(contents) {
        if (!this.channel) {
            await this.realize();
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.channel, 0x14c /* "Channel must exist when rebasing ops" */);
        const innerContents = contents;
        return this.channel.applyStashedOp(innerContents.content);
    }
    verifyNotClosed() {
        if (this._disposed) {
            throw new Error("Context is closed");
        }
    }
    getCreateChildSummarizerNodeFn(id, createParam) {
        return (summarizeInternal, getGCDataFn, getInitialGCSummaryDetailsFn) => this.summarizerNode.createChild(summarizeInternal, id, createParam, 
        // DDS will not create failure summaries
        { throwOnFailure: true }, getGCDataFn, getInitialGCSummaryDetailsFn);
    }
    async uploadBlob(blob) {
        return this.containerRuntime.uploadBlob(blob);
    }
}
class RemotedFluidDataStoreContext extends FluidDataStoreContext {
    constructor(id, initSnapshotValue, runtime, storage, scope, createSummarizerNode, pkg) {
        super(runtime, id, true, storage, scope, createSummarizerNode, _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.Bound, false, () => {
            throw new Error("Already attached");
        }, pkg);
        this.initSnapshotValue = initSnapshotValue;
        this.initialSnapshotDetailsP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.LazyPromise(async () => {
            var _a, _b;
            let tree;
            let isRootDataStore = true;
            if (typeof this.initSnapshotValue === "string") {
                const commit = (await this.storage.getVersions(this.initSnapshotValue, 1))[0];
                tree = (_a = await this.storage.getSnapshotTree(commit)) !== null && _a !== void 0 ? _a : undefined;
            }
            else {
                tree = this.initSnapshotValue;
            }
            const localReadAndParse = async (id) => (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_9__.readAndParse)(this.storage, id);
            if (tree) {
                const loadedSummary = await this.summarizerNode.loadBaseSummary(tree, localReadAndParse);
                tree = loadedSummary.baseSummary;
                // Prepend outstanding ops to pending queue of ops to process.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.pending = loadedSummary.outstandingOps.concat(this.pending);
            }
            if (!!tree && tree.blobs[_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.dataStoreAttributesBlobName] !== undefined) {
                // Need to rip through snapshot and use that to populate extraBlobs
                const attributes = await localReadAndParse(tree.blobs[_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.dataStoreAttributesBlobName]);
                let pkgFromSnapshot;
                // Use the snapshotFormatVersion to determine how the pkg is encoded in the snapshot.
                // For snapshotFormatVersion = "0.1" (1) or above, pkg is jsonified, otherwise it is just a string.
                const formatVersion = (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.getAttributesFormatVersion)(attributes);
                if (formatVersion < 1) {
                    if (attributes.pkg.startsWith("[\"") && attributes.pkg.endsWith("\"]")) {
                        pkgFromSnapshot = JSON.parse(attributes.pkg);
                    }
                    else {
                        pkgFromSnapshot = [attributes.pkg];
                    }
                }
                else {
                    pkgFromSnapshot = JSON.parse(attributes.pkg);
                }
                this.pkg = pkgFromSnapshot;
                /**
                 * If there is no isRootDataStore in the attributes blob, set it to true. This will ensure that
                 * data stores in older documents are not garbage collected incorrectly. This may lead to additional
                 * roots in the document but they won't break.
                 */
                isRootDataStore = (_b = attributes.isRootDataStore) !== null && _b !== void 0 ? _b : true;
                if ((0,_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.hasIsolatedChannels)(attributes)) {
                    tree = tree.trees[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.channelsTreeName];
                }
            }
            return {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                pkg: this.pkg,
                snapshot: tree,
                isRootDataStore,
            };
        });
        this.gcDetailsInInitialSummaryP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.LazyPromise(async () => {
            // If the initial snapshot is undefined or string, the snapshot is in old format and won't have GC details.
            if (!(!this.initSnapshotValue || typeof this.initSnapshotValue === "string")
                && this.initSnapshotValue.blobs[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.gcBlobKey] !== undefined) {
                return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_9__.readAndParse)(this.storage, this.initSnapshotValue.blobs[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.gcBlobKey]);
            }
            else {
                return {};
            }
        });
    }
    async getInitialSnapshotDetails() {
        return this.initialSnapshotDetailsP;
    }
    async getInitialGCSummaryDetails() {
        return this.gcDetailsInInitialSummaryP;
    }
    generateAttachMessage() {
        throw new Error("Cannot attach remote store");
    }
}
/**
 * Base class for detached & attached context classes
 */
class LocalFluidDataStoreContextBase extends FluidDataStoreContext {
    constructor(id, pkg, runtime, storage, scope, createSummarizerNode, bindChannel, snapshotTree, isRootDataStore, 
    /**
     * @deprecated 0.16 Issue #1635, #3631
     */
    createProps) {
        super(runtime, id, snapshotTree !== undefined ? true : false, storage, scope, createSummarizerNode, snapshotTree ? _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.Bound : _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.NotBound, true, bindChannel, pkg);
        this.snapshotTree = snapshotTree;
        this.isRootDataStore = isRootDataStore;
        this.createProps = createProps;
        this.attachListeners();
    }
    attachListeners() {
        this.once("attaching", () => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Detached, 0x14d /* "Should move from detached to attaching" */);
            this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Attaching;
        });
        this.once("attached", () => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Attaching, 0x14e /* "Should move from attaching to attached" */);
            this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Attached;
        });
    }
    generateAttachMessage() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channel !== undefined, 0x14f /* "There should be a channel when generating attach message" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pkg !== undefined, 0x150 /* "pkg should be available in local data store context" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.isRootDataStore !== undefined, 0x151 /* "isRootDataStore should be available in local data store context" */);
        const summarizeResult = this.channel.getAttachSummary();
        if (!this.disableIsolatedChannels) {
            // Wrap dds summaries in .channels subtree.
            (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.wrapSummaryInChannelsTree)(summarizeResult);
        }
        // Add data store's attributes to the summary.
        const attributes = createAttributes(this.pkg, this.isRootDataStore, this.disableIsolatedChannels);
        (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_8__.addBlobToSummary)(summarizeResult, _summaryFormat__WEBPACK_IMPORTED_MODULE_1__.dataStoreAttributesBlobName, JSON.stringify(attributes));
        // Add GC details to the summary.
        const gcDetails = {
            usedRoutes: this.summarizerNode.usedRoutes,
            gcData: summarizeResult.gcData,
        };
        (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_8__.addBlobToSummary)(summarizeResult, _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.gcBlobKey, JSON.stringify(gcDetails));
        // Attach message needs the summary in ITree format. Convert the ISummaryTree into an ITree.
        const snapshot = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_8__.convertSummaryTreeToITree)(summarizeResult.summary);
        const message = {
            id: this.id,
            snapshot,
            type: this.pkg[this.pkg.length - 1],
        };
        return message;
    }
    async getInitialSnapshotDetails() {
        var _a;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pkg !== undefined, 0x152 /* "pkg should be available in local data store" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.isRootDataStore !== undefined, 0x153 /* "isRootDataStore should be available in local data store" */);
        const snapshot = this.disableIsolatedChannels
            ? this.snapshotTree
            : (_a = this.snapshotTree) === null || _a === void 0 ? void 0 : _a.trees[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.channelsTreeName];
        return {
            pkg: this.pkg,
            snapshot,
            isRootDataStore: this.isRootDataStore,
        };
    }
    async getInitialGCSummaryDetails() {
        // Local data store does not have initial summary.
        return {};
    }
}
/**
 * context implementation for "attached" data store runtime.
 * Various workflows (snapshot creation, requests) result in .realize() being called
 * on context, resulting in instantiation and attachment of runtime.
 * Runtime is created using data store factory that is associated with this context.
 */
class LocalFluidDataStoreContext extends LocalFluidDataStoreContextBase {
    constructor(id, pkg, runtime, storage, scope, createSummarizerNode, bindChannel, snapshotTree, isRootDataStore, 
    /**
     * @deprecated 0.16 Issue #1635, #3631
     */
    createProps) {
        super(id, pkg, runtime, storage, scope, createSummarizerNode, bindChannel, snapshotTree, isRootDataStore, createProps);
    }
}
/**
 * Detached context. Data Store runtime will be attached to it by attachRuntime() call
 * Before attachment happens, this context is not associated with particular type of runtime
 * or factory, i.e. it's package path is undefined.
 * Attachment process provides all missing parts - package path, data store runtime, and data store factory
 */
class LocalDetachedFluidDataStoreContext extends LocalFluidDataStoreContextBase {
    constructor(id, pkg, runtime, storage, scope, createSummarizerNode, bindChannel, snapshotTree, isRootDataStore) {
        super(id, pkg, runtime, storage, scope, createSummarizerNode, bindChannel, snapshotTree, isRootDataStore);
        this.detachedRuntimeCreation = true;
    }
    async attachRuntime(registry, dataStoreRuntime) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.detachedRuntimeCreation, 0x154 /* "runtime creation is already attached" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channelDeferred === undefined, 0x155 /* "channel deferral is already set" */);
        const factory = registry.IFluidDataStoreFactory;
        const entry = await this.factoryFromPackagePath(this.pkg);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(entry.factory === factory, 0x156 /* "Unexpected factory for package path" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.registry === undefined, 0x157 /* "datastore registry already attached" */);
        this.registry = entry.registry;
        this.detachedRuntimeCreation = false;
        this.channelDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.Deferred();
        super.bindRuntime(dataStoreRuntime);
        if (this.isRootDataStore) {
            dataStoreRuntime.bindToContext();
        }
    }
    async getInitialSnapshotDetails() {
        if (this.detachedRuntimeCreation) {
            throw new Error("Detached Fluid Data Store context can't be realized! Please attach runtime first!");
        }
        return super.getInitialSnapshotDetails();
    }
}
//# sourceMappingURL=dataStoreContext.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/dataStoreContexts.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/dataStoreContexts.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataStoreContexts": () => (/* binding */ DataStoreContexts)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/lazy.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/promises.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


class DataStoreContexts {
    constructor(baseLogger) {
        this.notBoundContexts = new Set();
        /** Attached and loaded context proxies */
        this._contexts = new Map();
        /**
         * List of pending context waiting either to be bound or to arrive from another client.
         * This covers the case where a local context has been created but not yet bound,
         * or the case where a client knows a store will exist and is waiting on its creation,
         * so that a caller may await the deferred's promise until such a time as the context is fully ready.
         * This is a superset of _contexts, since contexts remain here once the Deferred resolves.
         */
        this.deferredContexts = new Map();
        this.disposeOnce = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Lazy(() => {
            // close/stop all store contexts
            for (const [fluidDataStoreId, contextD] of this.deferredContexts) {
                contextD.promise.then((context) => {
                    context.dispose();
                }).catch((contextError) => {
                    this._logger.sendErrorEvent({
                        eventName: "FluidDataStoreContextDisposeError",
                        fluidDataStoreId,
                    }, contextError);
                });
            }
        });
        this.dispose = () => this.disposeOnce.value;
        this._logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(baseLogger);
    }
    [Symbol.iterator]() {
        return this._contexts.entries();
    }
    get disposed() { return this.disposeOnce.evaluated; }
    notBoundLength() {
        return this.notBoundContexts.size;
    }
    isNotBound(id) {
        return this.notBoundContexts.has(id);
    }
    has(id) {
        return this._contexts.has(id);
    }
    get(id) {
        return this._contexts.get(id);
    }
    /**
     * Return the unbound local context with the given id,
     * or undefined if it's not found or not unbound.
     */
    getUnbound(id) {
        const context = this._contexts.get(id);
        if (context === undefined || !this.notBoundContexts.has(id)) {
            return undefined;
        }
        return this._contexts.get(id);
    }
    /**
     * Add the given context, marking it as to-be-bound
     */
    addUnbound(context) {
        const id = context.id;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this._contexts.has(id), 0x158 /* "Creating store with existing ID" */);
        this._contexts.set(id, context);
        this.notBoundContexts.add(id);
        this.ensureDeferred(id);
    }
    /**
     * Get the context with the given id, once it exists locally and is attached.
     * e.g. If created locally, it must be bound, or if created remotely then it's fine as soon as it's sync'd in.
     * @param id The id of the context to get
     * @param wait If false, return undefined if the context isn't present and ready now. Otherwise, wait for it.
     */
    async getBoundOrRemoted(id, wait) {
        const deferredContext = this.ensureDeferred(id);
        if (!wait && !deferredContext.isCompleted) {
            return undefined;
        }
        return deferredContext.promise;
    }
    ensureDeferred(id) {
        const deferred = this.deferredContexts.get(id);
        if (deferred) {
            return deferred;
        }
        const newDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Deferred();
        this.deferredContexts.set(id, newDeferred);
        return newDeferred;
    }
    /**
     * Update this context as bound
     */
    bind(id) {
        const removed = this.notBoundContexts.delete(id);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(removed, 0x159 /* "The given id was not found in notBoundContexts to delete" */);
        this.resolveDeferred(id);
    }
    /**
     * Triggers the deferred to resolve, indicating the context is not local-only
     * @param id - The id of the context to resolve to
     */
    resolveDeferred(id) {
        const context = this._contexts.get(id);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!context, 0x15a /* "Cannot find context to resolve to" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.notBoundContexts.has(id), 0x15b /* "Expected this id to already be removed from notBoundContexts" */);
        const deferred = this.deferredContexts.get(id);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!deferred, 0x15c /* "Cannot find deferred to resolve" */);
        deferred.resolve(context);
    }
    /**
     * Add the given context, marking it as not local-only.
     * This could be because it's a local context that's been bound, or because it's a remote context.
     * @param context - The context to add
     */
    addBoundOrRemoted(context) {
        const id = context.id;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this._contexts.has(id), 0x15d /* "Creating store with existing ID" */);
        this._contexts.set(id, context);
        // Resolve the deferred immediately since this context is not unbound
        this.ensureDeferred(id);
        this.resolveDeferred(id);
    }
}
//# sourceMappingURL=dataStoreContexts.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/dataStoreRegistry.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/dataStoreRegistry.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FluidDataStoreRegistry": () => (/* binding */ FluidDataStoreRegistry)
/* harmony export */ });
class FluidDataStoreRegistry {
    constructor(namedEntries) {
        this.map = new Map(namedEntries);
    }
    get IFluidDataStoreRegistry() { return this; }
    async get(name) {
        if (this.map.has(name)) {
            return this.map.get(name);
        }
        return undefined;
    }
}
//# sourceMappingURL=dataStoreRegistry.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/dataStores.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/dataStores.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataStores": () => (/* binding */ DataStores),
/* harmony export */   "getSummaryForDatastores": () => (/* binding */ getSummaryForDatastores)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @fluidframework/container-utils */ "../../node_modules/@fluidframework/container-utils/lib/error.js");
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/runtime-definitions */ "../../node_modules/@fluidframework/runtime-definitions/dist/index.js");
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHelpers.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/summaryUtils.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/container-definitions */ "../../node_modules/@fluidframework/container-definitions/lib/runtime.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/readAndParse.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/buildSnapshotTree.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/blobCacheStorageService.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/lazy.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @fluidframework/protocol-base */ "../../node_modules/@fluidframework/protocol-base/lib/blobs.js");
/* harmony import */ var _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @fluidframework/garbage-collector */ "../../node_modules/@fluidframework/garbage-collector/lib/utils.js");
/* harmony import */ var _dataStoreContexts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dataStoreContexts */ "../../node_modules/@fluidframework/container-runtime/lib/dataStoreContexts.js");
/* harmony import */ var _dataStoreContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dataStoreContext */ "../../node_modules/@fluidframework/container-runtime/lib/dataStoreContext.js");
/* harmony import */ var _summaryFormat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./summaryFormat */ "../../node_modules/@fluidframework/container-runtime/lib/summaryFormat.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */













/**
 * This class encapsulates data store handling. Currently it is only used by the container runtime,
 * but eventually could be hosted on any channel once we formalize the channel api boundary.
 */
class DataStores {
    constructor(baseSnapshot, runtime, submitAttachFn, getCreateChildSummarizerNodeFn, baseLogger, contexts = new _dataStoreContexts__WEBPACK_IMPORTED_MODULE_0__.DataStoreContexts(baseLogger)) {
        var _a;
        this.baseSnapshot = baseSnapshot;
        this.runtime = runtime;
        this.submitAttachFn = submitAttachFn;
        this.getCreateChildSummarizerNodeFn = getCreateChildSummarizerNodeFn;
        this.contexts = contexts;
        // Stores tracked by the Domain
        this.pendingAttach = new Map();
        // 0.24 back-compat attachingBeforeSummary
        this.attachOpFiredForDataStore = new Set();
        this.disposeOnce = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Lazy(() => this.contexts.dispose());
        this.dispose = () => this.disposeOnce.value;
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.ChildLogger.create(baseLogger);
        // Extract stores stored inside the snapshot
        const fluidDataStores = new Map();
        if (baseSnapshot) {
            for (const [key, value] of Object.entries(baseSnapshot.trees)) {
                fluidDataStores.set(key, value);
            }
        }
        // Create a context for each of them
        for (const [key, value] of fluidDataStores) {
            let dataStoreContext;
            // If we have a detached container, then create local data store contexts.
            if (this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Detached) {
                dataStoreContext = new _dataStoreContext__WEBPACK_IMPORTED_MODULE_4__.RemotedFluidDataStoreContext(key, value, this.runtime, this.runtime.storage, this.runtime.scope, this.getCreateChildSummarizerNodeFn(key, { type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__.CreateSummarizerNodeSource.FromSummary }));
            }
            else {
                if (typeof value !== "object") {
                    throw new Error("Snapshot should be there to load from!!");
                }
                const snapshotTree = value;
                // Need to rip through snapshot.
                const attributes = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_6__.readAndParseFromBlobs)(snapshotTree.blobs, snapshotTree.blobs[_summaryFormat__WEBPACK_IMPORTED_MODULE_7__.dataStoreAttributesBlobName]);
                // Use the snapshotFormatVersion to determine how the pkg is encoded in the snapshot.
                // For snapshotFormatVersion = "0.1" (1) or above, pkg is jsonified, otherwise it is just a string.
                // However the feature of loading a detached container from snapshot, is added when the
                // snapshotFormatVersion is at least "0.1" (1), so we don't expect it to be anything else.
                const formatVersion = (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_7__.getAttributesFormatVersion)(attributes);
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.assert)(formatVersion > 0, 0x1d5 /* `Invalid snapshot format version ${attributes.snapshotFormatVersion}` */);
                const pkgFromSnapshot = JSON.parse(attributes.pkg);
                dataStoreContext = new _dataStoreContext__WEBPACK_IMPORTED_MODULE_4__.LocalFluidDataStoreContext(key, pkgFromSnapshot, this.runtime, this.runtime.storage, this.runtime.scope, this.getCreateChildSummarizerNodeFn(key, { type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__.CreateSummarizerNodeSource.FromSummary }), (cr) => this.bindFluidDataStore(cr), snapshotTree, (_a = 
                // If there is no isRootDataStore in the attributes blob, set it to true. This ensures that data
                // stores in older documents are not garbage collected incorrectly. This may lead to additional
                // roots in the document but they won't break.
                attributes.isRootDataStore) !== null && _a !== void 0 ? _a : true);
            }
            this.contexts.addBoundOrRemoted(dataStoreContext);
        }
    }
    processAttachMessage(message, local) {
        var _a, _b;
        const attachMessage = message.contents;
        // The local object has already been attached
        if (local) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.assert)(this.pendingAttach.has(attachMessage.id), 0x15e /* "Local object does not have matching attach message id" */);
            (_a = this.contexts.get(attachMessage.id)) === null || _a === void 0 ? void 0 : _a.emit("attached");
            this.pendingAttach.delete(attachMessage.id);
            return;
        }
        // If a non-local operation then go and create the object, otherwise mark it as officially attached.
        if (this.contexts.has(attachMessage.id)) {
            const error = new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_9__.DataCorruptionError("Duplicate data store created with existing ID", {
                sequenceNumber: message.sequenceNumber,
                clientId: message.clientId,
                referenceSequenceNumber: message.referenceSequenceNumber,
            });
            this.logger.sendErrorEvent({ eventName: "DuplicateDataStoreId" }, error);
            throw error;
        }
        const flatBlobs = new Map();
        let snapshotTree;
        if (attachMessage.snapshot) {
            snapshotTree = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_10__.buildSnapshotTree)(attachMessage.snapshot.entries, flatBlobs);
        }
        // Include the type of attach message which is the pkg of the store to be
        // used by RemotedFluidDataStoreContext in case it is not in the snapshot.
        const pkg = [attachMessage.type];
        const remotedFluidDataStoreContext = new _dataStoreContext__WEBPACK_IMPORTED_MODULE_4__.RemotedFluidDataStoreContext(attachMessage.id, snapshotTree, this.runtime, new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__.BlobCacheStorageService(this.runtime.storage, flatBlobs), this.runtime.scope, this.getCreateChildSummarizerNodeFn(attachMessage.id, {
            type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__.CreateSummarizerNodeSource.FromAttach,
            sequenceNumber: message.sequenceNumber,
            snapshot: (_b = attachMessage.snapshot) !== null && _b !== void 0 ? _b : {
                entries: [(0,_dataStoreContext__WEBPACK_IMPORTED_MODULE_4__.createAttributesBlob)(pkg, true /* isRootDataStore */, this.runtime.disableIsolatedChannels)],
            },
        }), pkg);
        // Resolve pending gets and store off any new ones
        this.contexts.addBoundOrRemoted(remotedFluidDataStoreContext);
        // Equivalent of nextTick() - Prefetch once all current ops have completed
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        Promise.resolve().then(async () => remotedFluidDataStoreContext.realize());
    }
    bindFluidDataStore(fluidDataStoreRuntime) {
        const id = fluidDataStoreRuntime.id;
        const localContext = this.contexts.getUnbound(id);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.assert)(!!localContext, 0x15f /* "Could not find unbound context to bind" */);
        // If the container is detached, we don't need to send OP or add to pending attach because
        // we will summarize it while uploading the create new summary and make it known to other
        // clients.
        if (this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Detached) {
            localContext.emit("attaching");
            const message = localContext.generateAttachMessage();
            this.pendingAttach.set(id, message);
            this.submitAttachFn(message);
            this.attachOpFiredForDataStore.add(id);
        }
        this.contexts.bind(fluidDataStoreRuntime.id);
    }
    createDetachedDataStoreCore(pkg, isRoot, id = (0,uuid__WEBPACK_IMPORTED_MODULE_12__.default)()) {
        const context = new _dataStoreContext__WEBPACK_IMPORTED_MODULE_4__.LocalDetachedFluidDataStoreContext(id, pkg, this.runtime, this.runtime.storage, this.runtime.scope, this.getCreateChildSummarizerNodeFn(id, { type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__.CreateSummarizerNodeSource.Local }), (cr) => this.bindFluidDataStore(cr), undefined, isRoot);
        this.contexts.addUnbound(context);
        return context;
    }
    _createFluidDataStoreContext(pkg, id, isRoot, props) {
        const context = new _dataStoreContext__WEBPACK_IMPORTED_MODULE_4__.LocalFluidDataStoreContext(id, pkg, this.runtime, this.runtime.storage, this.runtime.scope, this.getCreateChildSummarizerNodeFn(id, { type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__.CreateSummarizerNodeSource.Local }), (cr) => this.bindFluidDataStore(cr), undefined, isRoot, props);
        this.contexts.addUnbound(context);
        return context;
    }
    get disposed() { return this.disposeOnce.evaluated; }
    updateLeader() {
        for (const [, context] of this.contexts) {
            context.updateLeader(this.runtime.leader);
        }
    }
    resubmitDataStoreOp(content, localOpMetadata) {
        const envelope = content;
        const context = this.contexts.get(envelope.address);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.assert)(!!context, 0x160 /* "There should be a store context for the op" */);
        context.reSubmit(envelope.contents, localOpMetadata);
    }
    async applyStashedOp(content) {
        const envelope = content;
        const context = this.contexts.get(envelope.address);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.assert)(!!context, 0x161 /* "There should be a store context for the op" */);
        return context.applyStashedOp(envelope.contents);
    }
    async applyStashedAttachOp(message) {
        this.pendingAttach.set(message.id, message);
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        this.processAttachMessage({ contents: message }, false);
    }
    processFluidDataStoreOp(message, local, localMessageMetadata) {
        const envelope = message.contents;
        const transformed = Object.assign(Object.assign({}, message), { contents: envelope.contents });
        const context = this.contexts.get(envelope.address);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.assert)(!!context, 0x162 /* "There should be a store context for the op" */);
        context.process(transformed, local, localMessageMetadata);
    }
    async getDataStore(id, wait) {
        const context = await this.contexts.getBoundOrRemoted(id, wait);
        if (context === undefined) {
            // The requested data store does not exits. Throw a 404 response exception.
            const request = { url: id };
            throw (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_13__.responseToException)((0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_13__.create404Response)(request), request);
        }
        return context;
    }
    processSignal(address, message, local) {
        const context = this.contexts.get(address);
        if (!context) {
            // Attach message may not have been processed yet
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.assert)(!local, 0x163 /* "Missing datastore for local signal" */);
            this.logger.sendTelemetryEvent({
                eventName: "SignalFluidDataStoreNotFound",
                fluidDataStoreId: address,
            });
            return;
        }
        context.processSignal(message, local);
    }
    setConnectionState(connected, clientId) {
        for (const [fluidDataStore, context] of this.contexts) {
            try {
                context.setConnectionState(connected, clientId);
            }
            catch (error) {
                this.logger.sendErrorEvent({
                    eventName: "SetConnectionStateError",
                    clientId,
                    fluidDataStore,
                }, error);
            }
        }
    }
    setAttachState(attachState) {
        let eventName;
        if (attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Attaching) {
            eventName = "attaching";
        }
        else {
            eventName = "attached";
        }
        for (const [, context] of this.contexts) {
            // Fire only for bounded stores.
            if (!this.contexts.isNotBound(context.id)) {
                context.emit(eventName);
            }
        }
    }
    /**
     * Notifies this object to take the snapshot of the container.
     * @deprecated - Use summarize to get summary of the container runtime.
     */
    async snapshot() {
        // Iterate over each store and ask it to snapshot
        const fluidDataStoreSnapshotsP = Array.from(this.contexts).map(async ([fluidDataStoreId, value]) => {
            const summaryTree = await value.summarize(true /* fullTree */, false /* trackState */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.assert)(summaryTree.summary.type === 1 /* Tree */, 0x164 /* "summarize should always return a tree when fullTree is true" */);
            // back-compat summary - Remove this once snapshot is removed.
            const snapshot = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_14__.convertSummaryTreeToITree)(summaryTree.summary);
            // If ID exists then previous commit is still valid
            return {
                fluidDataStoreId,
                snapshot,
            };
        });
        const entries = [];
        // Add in module references to the store snapshots
        const fluidDataStoreSnapshots = await Promise.all(fluidDataStoreSnapshotsP);
        // Sort for better diffing of snapshots (in replay tool, used to find bugs in snapshotting logic)
        fluidDataStoreSnapshots.sort((a, b) => a === null || a === void 0 ? void 0 : a.fluidDataStoreId.localeCompare(b.fluidDataStoreId));
        for (const fluidDataStoreSnapshot of fluidDataStoreSnapshots) {
            entries.push(new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_15__.TreeTreeEntry(fluidDataStoreSnapshot.fluidDataStoreId, fluidDataStoreSnapshot.snapshot));
        }
        return entries;
    }
    async summarize(fullTree, trackState) {
        const gcDataBuilder = new _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_16__.GCDataBuilder();
        const summaryBuilder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_14__.SummaryTreeBuilder();
        // Iterate over each store and ask it to snapshot
        await Promise.all(Array.from(this.contexts)
            .filter(([_, context]) => {
            // Summarizer works only with clients with no local changes!
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.assert)(context.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Attaching, 0x165 /* "Summarizer cannot work if client has local changes" */);
            return context.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Attached;
        }).map(async ([contextId, context]) => {
            const contextSummary = await context.summarize(fullTree, trackState);
            summaryBuilder.addWithStats(contextId, contextSummary);
            // Prefix the child's id to the ids of its GC nodest. This gradually builds the id of each node to
            // be a path from the root.
            gcDataBuilder.prefixAndAddNodes(contextId, contextSummary.gcData.gcNodes);
        }));
        // Get the outbound routes and add a GC node for this channel.
        gcDataBuilder.addNode("/", await this.getOutboundRoutes());
        return Object.assign(Object.assign({}, summaryBuilder.getSummaryTree()), { gcData: gcDataBuilder.getGCData() });
    }
    createSummary() {
        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_14__.SummaryTreeBuilder();
        // Attaching graph of some stores can cause other stores to get bound too.
        // So keep taking summary until no new stores get bound.
        let notBoundContextsLength;
        do {
            const builderTree = builder.summary.tree;
            notBoundContextsLength = this.contexts.notBoundLength();
            // Iterate over each data store and ask it to snapshot
            Array.from(this.contexts)
                .filter(([key, _]) => 
            // Take summary of bounded data stores only, make sure we haven't summarized them already
            // and no attach op has been fired for that data store because for loader versions <= 0.24
            // we set attach state as "attaching" before taking createNew summary.
            !(this.contexts.isNotBound(key)
                || builderTree[key]
                || this.attachOpFiredForDataStore.has(key)))
                .map(([key, value]) => {
                let dataStoreSummary;
                if (value.isLoaded) {
                    const snapshot = value.generateAttachMessage().snapshot;
                    dataStoreSummary = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_14__.convertToSummaryTree)(snapshot, true);
                }
                else {
                    // If this data store is not yet loaded, then there should be no changes in the snapshot from
                    // which it was created as it is detached container. So just use the previous snapshot.
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.assert)(!!this.baseSnapshot, 0x166 /* "BaseSnapshot should be there as detached container loaded from snapshot" */);
                    dataStoreSummary = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_14__.convertSnapshotTreeToSummaryTree)(this.baseSnapshot.trees[key]);
                }
                builder.addWithStats(key, dataStoreSummary);
            });
        } while (notBoundContextsLength !== this.contexts.notBoundLength());
        return builder.getSummaryTree();
    }
    /**
     * Generates data used for garbage collection. It does the following:
     * 1. Calls into each child data store context to get its GC data.
     * 2. Prefixs the child context's id to the GC nodes in the child's GC data. This makes sure that the node can be
     *    idenfied as belonging to the child.
     * 3. Adds a GC node for this channel to the nodes received from the children. All these nodes together represent
     *    the GC data of this channel.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        const builder = new _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_16__.GCDataBuilder();
        // Iterate over each store and get their GC data.
        await Promise.all(Array.from(this.contexts)
            .filter(([_, context]) => {
            // Get GC data only for attached contexts. Detached contexts are not connected in the GC reference
            // graph so any references they might have won't be connected as well.
            return context.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Attached;
        }).map(async ([contextId, context]) => {
            const contextGCData = await context.getGCData(fullGC);
            // Prefix the child's id to the ids of its GC nodes so they can be identified as belonging to the child.
            // This also gradually builds the id of each node to be a path from the root.
            builder.prefixAndAddNodes(contextId, contextGCData.gcNodes);
        }));
        // Get the outbound routes and add a GC node for this channel.
        builder.addNode("/", await this.getOutboundRoutes());
        return builder.getGCData();
    }
    /**
     * After GC has run, called to notify this Container's data stores of routes that are used in it.
     * @param usedRoutes - The routes that are used in all data stores in this Container.
     */
    updateUsedRoutes(usedRoutes) {
        var _a;
        // Get a map of data store ids to routes used in it.
        const usedDataStoreRoutes = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_16__.getChildNodesUsedRoutes)(usedRoutes);
        // Verify that the used routes are correct.
        for (const [id] of usedDataStoreRoutes) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.assert)(this.contexts.has(id), 0x167 /* "Used route does not belong to any known data store" */);
        }
        // Update the used routes in each data store. Used routes is empty for unused data stores.
        for (const [contextId, context] of this.contexts) {
            context.updateUsedRoutes((_a = usedDataStoreRoutes.get(contextId)) !== null && _a !== void 0 ? _a : []);
        }
    }
    /**
     * Returns the outbound routes of this channel. Only root data stores are considered referenced and their paths are
     * part of outbound routes.
     */
    async getOutboundRoutes() {
        const outboundRoutes = [];
        for (const [contextId, context] of this.contexts) {
            const isRootDataStore = await context.isRoot();
            if (isRootDataStore) {
                outboundRoutes.push(`/${contextId}`);
            }
        }
        return outboundRoutes;
    }
}
function getSummaryForDatastores(snapshot, metadata) {
    if (!snapshot) {
        return undefined;
    }
    if ((0,_summaryFormat__WEBPACK_IMPORTED_MODULE_7__.rootHasIsolatedChannels)(metadata)) {
        const datastoresSnapshot = snapshot.trees[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__.channelsTreeName];
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.assert)(!!datastoresSnapshot, 0x168 /* `expected ${channelsTreeName} tree in snapshot` */);
        return datastoresSnapshot;
    }
    else {
        // back-compat: strip out all non-datastore paths before giving to DataStores object.
        const datastoresTrees = {};
        for (const [key, value] of Object.entries(snapshot.trees)) {
            if (!_summaryFormat__WEBPACK_IMPORTED_MODULE_7__.nonDataStorePaths.includes(key)) {
                datastoresTrees[key] = value;
            }
        }
        return Object.assign(Object.assign({}, snapshot), { trees: datastoresTrees });
    }
}
//# sourceMappingURL=dataStores.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/debug.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/debug.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debug": () => (/* binding */ debug)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "../../node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packageVersion */ "../../node_modules/@fluidframework/container-runtime/lib/packageVersion.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


const debug = debug__WEBPACK_IMPORTED_MODULE_0___default()("fluid:process-loader");
debug(`Package: ${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgName} - Version: ${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgVersion}`);
//# sourceMappingURL=debug.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/deltaScheduler.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/deltaScheduler.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeltaScheduler": () => (/* binding */ DeltaScheduler)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/performanceBrowser.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * DeltaScheduler is responsible for the scheduling of inbound delta queue in cases where there
 * is more than one op a particular run of the queue. It does not schedule if there is just one
 * op or just one batch in the run. It does the following two things:
 * 1. If the ops have been processed for more than a specific amount of time, it pauses the queue
 *    and calls setTimeout to schedule a resume of the queue. This ensures that we don't block
 *    the JS thread for a long time processing ops synchronously (for example, when catching up
 *    ops right after boot or catching up ops / delayed realizing data stores by summarizer).
 * 2. If we scheduled a particular run of the queue, it logs telemetry for the number of ops
 *    processed, the time and number of turns it took to process the ops.
 */
class DeltaScheduler {
    constructor(deltaManager, logger) {
        this.logger = logger;
        // The increase in time for processing ops after each turn.
        this.processingTimeIncrement = 10;
        this.totalProcessingTime = DeltaScheduler.processingTime;
        // This keeps track of whether the delta scheduler is scheduling a particular run of the
        // the inbound delta queue. Basically, every time the delta queue starts processing with
        // more than one op, this will be set to true until the run completes.
        this.isScheduling = false;
        // This keeps track of the number of times inbound queue has been scheduled. After a particular
        // count, we log telemetry for the number of ops processed, the time and number of turns it took
        // to process the ops.
        this.schedulingCount = 0;
        this.deltaManager = deltaManager;
        this.deltaManager.inbound.on("idle", () => { this.inboundQueueIdle(); });
    }
    batchBegin() {
        if (!this.processingStartTime) {
            this.processingStartTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();
        }
    }
    batchEnd() {
        if (this.shouldRunScheduler()) {
            if (!this.isScheduling) {
                this.isScheduling = true;
                // Every 2000th time we are scheduling the inbound queue, we log telemetry for the
                // number of ops processed, the time and number of turns it took to process the ops.
                if (this.schedulingCount % 2000 === 0) {
                    this.schedulingLog = {
                        numberOfOps: this.deltaManager.inbound.length,
                        numberOfTurns: 1,
                        totalProcessingTime: 0,
                    };
                }
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const elapsedTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now() - this.processingStartTime;
            if (elapsedTime > this.totalProcessingTime) {
                // We have processed ops for more than the total processing time. So, pause the
                // queue, yield the thread and schedule a resume.
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this.deltaManager.inbound.pause();
                setTimeout(() => {
                    this.deltaManager.inbound.resume();
                });
                this.processingStartTime = undefined;
                // Increase the total processing time. Keep doing this after each turn until all the ops have
                // been processed. This way we keep the responsiveness at the beginning while also making sure
                // that all the ops process fairly quickly.
                this.totalProcessingTime += this.processingTimeIncrement;
                // If we are logging the telemetry this time, update the telemetry log object.
                if (this.schedulingLog) {
                    this.schedulingLog.numberOfTurns++;
                    this.schedulingLog.totalProcessingTime += elapsedTime;
                }
            }
        }
    }
    inboundQueueIdle() {
        if (this.schedulingLog) {
            // Add the time taken for processing the final ops to the total processing time in the
            // telemetry log object.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.schedulingLog.totalProcessingTime += _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now() - this.processingStartTime;
            this.logger.sendTelemetryEvent({
                eventName: "InboundOpsProcessingTime",
                numberOfOps: this.schedulingLog.numberOfOps,
                numberOfTurns: this.schedulingLog.numberOfTurns,
                processingTime: this.schedulingLog.totalProcessingTime,
            });
            this.schedulingLog = undefined;
        }
        // If we scheduled this batch of the inbound queue, increment the counter that tracks the
        // number of times we have done this.
        if (this.isScheduling) {
            this.isScheduling = false;
            this.schedulingCount++;
        }
        // Reset the processing times.
        this.processingStartTime = undefined;
        this.totalProcessingTime = DeltaScheduler.processingTime;
    }
    /**
     * This function tells whether we should run the scheduler.
     */
    shouldRunScheduler() {
        // If there are still ops in the queue after the one we are processing now, we should
        // run the scheduler.
        return this.deltaManager.inbound.length > 0;
    }
}
// The time for processing ops in a single turn.
DeltaScheduler.processingTime = 20;
//# sourceMappingURL=deltaScheduler.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/packageVersion.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/packageVersion.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pkgName": () => (/* binding */ pkgName),
/* harmony export */   "pkgVersion": () => (/* binding */ pkgVersion)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
const pkgName = "@fluidframework/container-runtime";
const pkgVersion = "0.37.4";
//# sourceMappingURL=packageVersion.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/pendingStateManager.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/pendingStateManager.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PendingStateManager": () => (/* binding */ PendingStateManager)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/container-utils */ "../../node_modules/@fluidframework/container-utils/lib/error.js");
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/runtime-definitions */ "../../node_modules/@fluidframework/runtime-definitions/dist/index.js");
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var double_ended_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-ended-queue */ "../../node_modules/double-ended-queue/js/deque.js");
/* harmony import */ var double_ended_queue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(double_ended_queue__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _containerRuntime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./containerRuntime */ "../../node_modules/@fluidframework/container-runtime/lib/containerRuntime.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */





/**
 * PendingStateManager is responsible for maintaining the messages that have not been sent or have not yet been
 * acknowledged by the server. It also maintains the batch information for both automatically and manually flushed
 * batches along with the messages.
 * When the Container reconnects, it replays the pending states, which includes setting the FlushMode, manual flushing
 * of messages and triggering resubmission of unacked ops.
 *
 * It verifies that all the ops are acked, are received in the right order and batch information is correct.
 */
class PendingStateManager {
    constructor(containerRuntime, applyStashedOp, initialState) {
        var _a;
        this.containerRuntime = containerRuntime;
        this.applyStashedOp = applyStashedOp;
        this.pendingStates = new (double_ended_queue__WEBPACK_IMPORTED_MODULE_0___default())();
        // Maintains the count of messages that are currently unacked.
        this.pendingMessagesCount = 0;
        // Indicates whether we are processing a batch.
        this.isProcessingBatch = false;
        this.initialStates = new (double_ended_queue__WEBPACK_IMPORTED_MODULE_0___default())((_a = initialState === null || initialState === void 0 ? void 0 : initialState.pendingStates) !== null && _a !== void 0 ? _a : []);
        this.initialClientId = initialState === null || initialState === void 0 ? void 0 : initialState.clientId;
        // get client sequence number of first actual message
        this.initialClientSeqNum = -1;
        for (let i = 0; i < this.initialStates.length; ++i) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const state = this.initialStates.get(i);
            if (state.type === "message") {
                this.initialClientSeqNum = state.clientSequenceNumber;
                break;
            }
        }
    }
    get connected() {
        return this.containerRuntime.connected;
    }
    /**
     * Called to check if there are any pending messages in the pending state queue.
     * @returns A boolean indicating whether there are messages or not.
     */
    hasPendingMessages() {
        return this.pendingMessagesCount !== 0;
    }
    getLocalState() {
        if (this.hasPendingMessages()) {
            return {
                clientId: this.clientId,
                pendingStates: this.pendingStates.toArray().map(
                // delete localOpMetadata since it may not be serializable
                // and will be regenerated by applyStashedOp()
                (state) => state.type === "message" ? Object.assign(Object.assign({}, state), { localOpMetadata: undefined }) : state),
            };
        }
    }
    /**
     * Called when a message is submitted locally. Adds the message and the associated details to the pending state
     * queue.
     * @param type - The container message type.
     * @param clientSequenceNumber - The clientSequenceNumber associated with the message.
     * @param content - The message content.
     * @param localOpMetadata - The local metadata associated with the message.
     */
    onSubmitMessage(type, clientSequenceNumber, referenceSequenceNumber, content, localOpMetadata, opMetadata) {
        const pendingMessage = {
            type: "message",
            messageType: type,
            clientSequenceNumber,
            referenceSequenceNumber,
            content,
            localOpMetadata,
            opMetadata,
        };
        this.pendingStates.push(pendingMessage);
        this.pendingMessagesCount++;
    }
    /**
     * Called when the FlushMode is updated. Adds the FlushMode to the pending state queue.
     * @param flushMode - The flushMode that was updated.
     */
    onFlushModeUpdated(flushMode) {
        if (flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_1__.FlushMode.Automatic) {
            const previousState = this.pendingStates.peekBack();
            // We don't have to track a previous "flush" state because FlushMode.Automatic flushes the messages. So,
            // just tracking this FlushMode.Automatic is enough.
            if ((previousState === null || previousState === void 0 ? void 0 : previousState.type) === "flush") {
                this.pendingStates.removeBack();
            }
            // If no messages were sent between FlushMode.Manual and FlushMode.Automatic, then we do not have to track
            // both these states. Remove FlushMode.Manual from the pending queue and return.
            if ((previousState === null || previousState === void 0 ? void 0 : previousState.type) === "flushMode" && previousState.flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_1__.FlushMode.Manual) {
                this.pendingStates.removeBack();
                return;
            }
        }
        const pendingFlushMode = {
            type: "flushMode",
            flushMode,
        };
        this.pendingStates.push(pendingFlushMode);
    }
    /**
     * Called when flush() is called on the ContainerRuntime to manually flush messages.
     */
    onFlush() {
        // If the FlushMode is Automatic, we should not track this flush call as it is only applicable when FlushMode
        // is Manual.
        if (this.containerRuntime.flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_1__.FlushMode.Automatic) {
            return;
        }
        // If the previous state is not a message, we don't have to track this flush call as there is nothing to flush.
        const previousState = this.pendingStates.peekBack();
        if ((previousState === null || previousState === void 0 ? void 0 : previousState.type) !== "message") {
            return;
        }
        // Note that because of the checks above and the checks in onFlushModeUpdated(), we can be sure that a "flush"
        // state always has a "message" before and after it. So, it marks the end of a batch and the beginning of a
        // new one.
        const pendingFlush = {
            type: "flush",
        };
        this.pendingStates.push(pendingFlush);
    }
    /**
     * Applies stashed ops at their reference sequence number so they are ready to be ACKed or resubmitted
     */
    async applyStashedOpsAt(seqNum) {
        // apply stashed ops at sequence number
        while (!this.initialStates.isEmpty()) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const nextState = this.initialStates.peekFront();
            if (nextState.type === "message") {
                if (nextState.referenceSequenceNumber > seqNum) {
                    break; // nothing left to do at this sequence number
                }
                else if (nextState.referenceSequenceNumber > 0 && nextState.referenceSequenceNumber < seqNum) {
                    throw new Error("loaded from snapshot too recent to apply stashed ops");
                }
                // applyStashedOp will cause the DDS to behave as if it has sent the op but not actually send it
                const localOpMetadata = await this.applyStashedOp(nextState.messageType, nextState.content);
                nextState.localOpMetadata = localOpMetadata;
            }
            // then we push onto pendingStates which will cause PendingStateManager to resubmit when we connect
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.pendingStates.push(this.initialStates.shift());
        }
    }
    /**
     * Processes a local message once it's ack'd by the server to verify that there was no data corruption and that
     * the batch information was preserved for batch messages. Also process remote messages that might have been
     * sent from a previous container.
     * @param message - The messsage that got ack'd and needs to be processed.
     */
    processMessage(message, local) {
        // Do not process chunked ops until all pieces are available.
        if (message.type === _containerRuntime__WEBPACK_IMPORTED_MODULE_2__.ContainerMessageType.ChunkedOp) {
            return { localAck: false, localOpMetadata: undefined };
        }
        if (local) {
            return { localAck: false, localOpMetadata: this.processPendingLocalMessage(message) };
        }
        else {
            return this.processRemoteMessage(message);
        }
    }
    /**
     * Listens for ACKs of stashed ops
     */
    processRemoteMessage(message) {
        // if this is an ack for a stashed op, dequeue one message.
        // we should have seen its ref seq num by now and the DDS should be ready for it to be ACKed
        if (message.clientId === this.initialClientId && message.clientSequenceNumber >= this.initialClientSeqNum) {
            while (!this.pendingStates.isEmpty()) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const nextState = this.pendingStates.shift();
                // if it's not a message just drop it and keep looking
                if (nextState.type === "message") {
                    return { localAck: true, localOpMetadata: nextState.localOpMetadata };
                }
            }
        }
        return { localAck: false, localOpMetadata: undefined };
    }
    /**
     * Processes a local message once its ack'd by the server. It verifies that there was no data corruption and that
     * the batch information was preserved for batch messages.
     * @param message - The messsage that got ack'd and needs to be processed.
     */
    processPendingLocalMessage(message) {
        // Pre-processing part - This may be the start of a batch.
        this.maybeProcessBatchBegin(message);
        // Get the next state from the pending queue and verify that it is of type "message".
        const pendingState = this.peekNextPendingState();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(pendingState.type === "message", 0x169 /* "No pending message found for this remote message" */);
        this.pendingStates.shift();
        // Processing part - Verify that there has been no data corruption.
        // The clientSequenceNumber of the incoming message must match that of the pending message.
        if (pendingState.clientSequenceNumber !== message.clientSequenceNumber) {
            // Close the container because this indicates data corruption.
            const error = new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.DataCorruptionError("Unexpected ack received", {
                clientId: message.clientId,
                sequenceNumber: message.sequenceNumber,
                clientSequenceNumber: message.clientSequenceNumber,
                expectedClientSequenceNumber: pendingState.clientSequenceNumber,
            });
            this.containerRuntime.closeFn(error);
            return;
        }
        this.pendingMessagesCount--;
        // Post-processing part - If we are processing a batch then this could be the last message in the batch.
        if (this.isProcessingBatch) {
            this.maybeProcessBatchEnd(message);
        }
        return pendingState.localOpMetadata;
    }
    /**
     * This message could be the first message in batch. If so, set batch state marking the beginning of a batch.
     * @param message - The message that is being processed.
     */
    maybeProcessBatchBegin(message) {
        const pendingState = this.peekNextPendingState();
        if (pendingState.type !== "flush" && pendingState.type !== "flushMode") {
            return;
        }
        // If the pending state is of type "flushMode", it must be Manual since Automatic flush mode is processed
        // after a message is processed and not before.
        if (pendingState.type === "flushMode") {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(pendingState.flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_1__.FlushMode.Manual, 0x16a /* "Flush mode should be manual when processing batch begin" */);
        }
        // We should not already be processing a batch and there should be no pending batch begin message.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.isProcessingBatch && this.pendingBatchBeginMessage === undefined, 0x16b /* "The pending batch state indicates we are already processing a batch" */);
        // Set the pending batch state indicating we have started processing a batch.
        this.pendingBatchBeginMessage = message;
        this.isProcessingBatch = true;
        // Remove this pending state from the queue as we have processed it.
        this.pendingStates.shift();
    }
    maybeProcessBatchEnd(message) {
        var _a, _b;
        const nextPendingState = this.peekNextPendingState();
        if (nextPendingState.type !== "flush" && nextPendingState.type !== "flushMode") {
            return;
        }
        // If the next pending state is of type "flushMode", it must be Automatic and if so, we need to remove it from
        // the queue.
        // Note that we do not remove the type "flush" from the queue because it indicates the end of one batch and the
        // beginning of a new one. So, it will removed when the next batch begin is processed.
        if (nextPendingState.type === "flushMode") {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(nextPendingState.flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_1__.FlushMode.Automatic, 0x16c /* "Flush mode is set to Manual in the middle of processing a batch" */);
            this.pendingStates.shift();
        }
        // There should be a pending batch begin message.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pendingBatchBeginMessage !== undefined, 0x16d /* "There is no pending batch begin message" */);
        // Get the batch begin metadata from the first message in the batch.
        const batchBeginMetadata = (_a = this.pendingBatchBeginMessage.metadata) === null || _a === void 0 ? void 0 : _a.batch;
        // There could be just a single message in the batch. If so, it should not have any batch metadata. If there
        // are multiple messages in the batch, verify that we got the correct batch begin and end metadata.
        if (this.pendingBatchBeginMessage === message) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(batchBeginMetadata === undefined, 0x16e /* "Batch with single message should not have batch metadata" */);
        }
        else {
            // Get the batch metadata from the last message in the batch.
            const batchEndMetadata = (_b = message.metadata) === null || _b === void 0 ? void 0 : _b.batch;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(batchBeginMetadata === true, 0x16f /* "Did not receive batch begin metadata" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(batchEndMetadata === false, 0x170 /* "Did not receive batch end metadata" */);
        }
        // Clear the pending batch state now that we have processed the entire batch.
        this.pendingBatchBeginMessage = undefined;
        this.isProcessingBatch = false;
    }
    /**
     * Returns the next pending state from the pending state queue.
     */
    peekNextPendingState() {
        const nextPendingState = this.pendingStates.peekFront();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!nextPendingState, 0x171 /* "No pending state found for the remote message" */);
        return nextPendingState;
    }
    /**
     * Called when the Container's connection state changes. If the Container gets connected, it replays all the pending
     * states in its queue. This includes setting the FlushMode and triggering resubmission of unacked ops.
     */
    replayPendingStates() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.connected, 0x172 /* "The connection state is not consistent with the runtime" */);
        // This assert suggests we are about to send same ops twice, which will result in data loss.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.clientId !== this.containerRuntime.clientId, 0x173 /* "replayPendingStates called twice for same clientId!" */);
        this.clientId = this.containerRuntime.clientId;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.initialStates.isEmpty(), 0x174 /* "initial states should be empty before replaying pending" */);
        let pendingStatesCount = this.pendingStates.length;
        if (pendingStatesCount === 0) {
            return;
        }
        // Reset the pending message count because all these messages will be removed from the queue.
        this.pendingMessagesCount = 0;
        // Save the current FlushMode so that we can revert it back after replaying the states.
        const savedFlushMode = this.containerRuntime.flushMode;
        // Process exactly `pendingStatesCount` items in the queue as it represents the number of states that were
        // pending when we connected. This is important because the `reSubmitFn` might add more items in the queue
        // which must not be replayed.
        while (pendingStatesCount > 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const pendingState = this.pendingStates.shift();
            switch (pendingState.type) {
                case "message":
                    {
                        this.containerRuntime.reSubmitFn(pendingState.messageType, pendingState.content, pendingState.localOpMetadata, pendingState.opMetadata);
                    }
                    break;
                case "flushMode":
                    {
                        this.containerRuntime.setFlushMode(pendingState.flushMode);
                    }
                    break;
                case "flush":
                    {
                        this.containerRuntime.flush();
                    }
                    break;
                default:
                    break;
            }
            pendingStatesCount--;
        }
        // Revert the FlushMode.
        this.containerRuntime.setFlushMode(savedFlushMode);
    }
}
//# sourceMappingURL=pendingStateManager.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/runWhileConnectedCoordinator.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/runWhileConnectedCoordinator.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RunWhileConnectedCoordinator": () => (/* binding */ RunWhileConnectedCoordinator)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/promises.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Helper class to coordinate something that needs to run only while connected.
 * This provides promises that resolve as it starts or stops.  Stopping happens
 * when disconnected or if stop() is called.
 */
class RunWhileConnectedCoordinator {
    constructor(runtime) {
        this.runtime = runtime;
        this.everConnected = false;
        this.stopDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        // Try to determine if the runtime has ever been connected
        if (this.runtime.connected) {
            this.everConnected = true;
        }
        else {
            this.runtime.once("connected", () => this.everConnected = true);
        }
        this.runtime.on("disconnected", () => {
            // Sometimes the initial connection state is raised as disconnected
            if (!this.everConnected) {
                return;
            }
            this.stop();
        });
    }
    /**
     * Starts and waits for a promise which resolves when connected.
     * The promise will also resolve if stopped either externally or by disconnect.
     * The return value indicates whether the start is successful or not.
     */
    async waitStart() {
        if (!this.runtime.connected) {
            if (this.everConnected) {
                // We will not try to reconnect, so we are done running
                return { started: false, message: "DisconnectedBeforeRun" };
            }
            const waitConnected = new Promise((resolve) => this.runtime.once("connected", resolve));
            await Promise.race([waitConnected, this.stopDeferred.promise]);
            if (!this.runtime.connected) {
                // If still not connected, no need to start running
                return { started: false, message: "NeverConnectedBeforeRun" };
            }
        }
        if (this.runtime.clientId === undefined) {
            throw Error("clientId should be defined if connected.");
        }
        return { started: true, clientId: this.runtime.clientId };
    }
    /**
     * Returns a promise that resolves once stopped either externally or by disconnect.
     */
    async waitStopped() {
        return this.stopDeferred.promise;
    }
    /**
     * Stops running.
     */
    stop() {
        this.stopDeferred.resolve();
    }
}
//# sourceMappingURL=runWhileConnectedCoordinator.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/summarizer.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/summarizer.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSummarizingWarning": () => (/* binding */ createSummarizingWarning),
/* harmony export */   "Summarizer": () => (/* binding */ Summarizer)
/* harmony export */ });
/* unused harmony exports ISummarizer, SummarizingWarning, RunningSummarizer */
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/timer.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/promises.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @fluidframework/container-utils */ "../../node_modules/@fluidframework/container-utils/lib/error.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/protocol.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHelpers.js");
/* harmony import */ var _runWhileConnectedCoordinator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./runWhileConnectedCoordinator */ "../../node_modules/@fluidframework/container-runtime/lib/runWhileConnectedCoordinator.js");
/* harmony import */ var _summaryCollection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./summaryCollection */ "../../node_modules/@fluidframework/container-runtime/lib/summaryCollection.js");
/* harmony import */ var _summarizerHandle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./summarizerHandle */ "../../node_modules/@fluidframework/container-runtime/lib/summarizerHandle.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */









// Send some telemetry if generate summary takes too long
const maxSummarizeTimeoutTime = 20000; // 20 sec
const maxSummarizeTimeoutCount = 5; // Double and resend 5 times
const maxSummarizeAckWaitTime = 120000; // 2 minutes
const minOpsForLastSummary = 50;
const ISummarizer = "ISummarizer";
const summarizingError = "summarizingError";
class SummarizingWarning extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.LoggingError {
    constructor(errorMessage, logged = false) {
        super(errorMessage);
        this.logged = logged;
        this.errorType = summarizingError;
        this.canRetry = true;
    }
}
const createSummarizingWarning = (details, logged) => new SummarizingWarning(details, logged);
const checkNotTimeout = (something) => {
    if (something === undefined) {
        return false;
    }
    return something.timerResult === undefined;
};
/**
 * This class contains the heuristics for when to summarize.
 */
class SummarizerHeuristics {
    constructor(configuration, trySummarize, 
    /**
     * Last received op sequence number
     */
    lastOpSeqNumber, firstAck) {
        this.configuration = configuration;
        this.trySummarize = trySummarize;
        this.lastOpSeqNumber = lastOpSeqNumber;
        this._lastAttempted = firstAck;
        this._lastAcked = firstAck;
        this.idleTimer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.Timer(this.configuration.idleTime, () => this.trySummarize("idle"));
    }
    /**
     * Last sent summary attempt
     */
    get lastAttempted() {
        return this._lastAttempted;
    }
    /**
     * Last acked summary attempt
     */
    get lastAcked() {
        return this._lastAcked;
    }
    /**
     * Sets the last attempted summary and last acked summary.
     * @param lastSummary - last acked summary
     */
    initialize(lastSummary) {
        this._lastAttempted = lastSummary;
        this._lastAcked = lastSummary;
    }
    /**
     * Records a summary attempt. If the attempt was successfully sent,
     * provide the reference sequence number, otherwise it will be set
     * to the last seen op sequence number.
     * @param refSequenceNumber - reference sequence number of sent summary
     */
    recordAttempt(refSequenceNumber) {
        this._lastAttempted = {
            refSequenceNumber: refSequenceNumber !== null && refSequenceNumber !== void 0 ? refSequenceNumber : this.lastOpSeqNumber,
            summaryTime: Date.now(),
        };
    }
    /**
     * Mark the last sent summary attempt as acked.
     */
    ackLastSent() {
        this._lastAcked = this.lastAttempted;
    }
    /**
     * Runs the heuristic to determine if it should try to summarize.
     */
    run() {
        this.idleTimer.clear();
        const timeSinceLastSummary = Date.now() - this.lastAcked.summaryTime;
        const opCountSinceLastSummary = this.lastOpSeqNumber - this.lastAcked.refSequenceNumber;
        if (timeSinceLastSummary > this.configuration.maxTime) {
            this.trySummarize("maxTime");
        }
        else if (opCountSinceLastSummary > this.configuration.maxOps) {
            this.trySummarize("maxOps");
        }
        else {
            this.idleTimer.restart();
        }
    }
    /**
     * Disposes of resources.
     */
    dispose() {
        this.idleTimer.clear();
    }
}
/**
 * An instance of RunningSummarizer manages the heuristics for summarizing.
 * Until disposed, the instance of RunningSummarizer can assume that it is
 * in a state of running, meaning it is connected and initialized.  It keeps
 * track of summaries that it is generating as they are broadcast and acked/nacked.
 */
class RunningSummarizer {
    constructor(clientId, onBehalfOfClientId, baseLogger, summaryWatcher, configuration, internalsProvider, lastOpSeqNumber, firstAck, immediateSummary = false, raiseSummarizingError, summaryCollection) {
        var _a;
        this.clientId = clientId;
        this.onBehalfOfClientId = onBehalfOfClientId;
        this.summaryWatcher = summaryWatcher;
        this.configuration = configuration;
        this.internalsProvider = internalsProvider;
        this.immediateSummary = immediateSummary;
        this.raiseSummarizingError = raiseSummarizingError;
        this.stopping = false;
        this._disposed = false;
        this.summarizeCount = 0;
        this.tryWhileSummarizing = false;
        /**
         * RunningSummarizer's logger includes the sequenced index of the current summary on each event.
         * If some other Summarizer code wants that event on their logs they can get it here,
         * but only if they're logging about that same summary.
         * @param summaryOpRefSeq - RefSeq number of the summary op, to ensure the log correlation will be correct
         */
        this.tryGetCorrelatedLogger = (summaryOpRefSeq) => this.heuristics.lastAttempted.refSequenceNumber === summaryOpRefSeq
            ? this.logger
            : undefined;
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(baseLogger, "Running", { all: { summaryGenTag: () => this.summarizeCount } });
        this.heuristics = new SummarizerHeuristics(configuration, (reason) => this.trySummarize(reason), lastOpSeqNumber, firstAck);
        this.summarizeTimer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.Timer(maxSummarizeTimeoutTime, () => this.summarizeTimerHandler(maxSummarizeTimeoutTime, 1));
        // Cap the maximum amount of time client will wait for a summarize op ack to maxSummarizeAckWaitTime
        const maxAckWaitTime = Math.min(this.configuration.maxAckWaitTime, maxSummarizeAckWaitTime);
        this.pendingAckTimer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.PromiseTimer(maxAckWaitTime, () => {
            this.raiseSummarizingError("SummaryAckWaitTimeout");
            // Note: summaryGenTag (from ChildLogger definition) may be 0,
            // since this code path is hit when RunningSummarizer first starts up,
            // before this instance has kicked off a new summarize run.
            this.logger.sendErrorEvent({
                eventName: "SummaryAckWaitTimeout",
                maxAckWaitTime,
                refSequenceNumber: this.heuristics.lastAttempted.refSequenceNumber,
                summarySequenceNumber: this.heuristics.lastAttempted.summarySequenceNumber,
                timePending: Date.now() - this.heuristics.lastAttempted.summaryTime,
            });
        });
        // back-compat 0.34 noSetPendingAckTimerTimeoutCallback
        (_a = summaryCollection.setPendingAckTimerTimeoutCallback) === null || _a === void 0 ? void 0 : _a.call(summaryCollection, maxAckWaitTime, () => {
            if (this.pendingAckTimer.hasTimer) {
                this.logger.sendTelemetryEvent({
                    eventName: "MissingSummaryAckFoundByOps",
                    refSequenceNumber: this.heuristics.lastAttempted.refSequenceNumber,
                    summarySequenceNumber: this.heuristics.lastAttempted.summarySequenceNumber,
                });
                this.pendingAckTimer.clear();
            }
        });
    }
    static async start(clientId, onBehalfOfClientId, logger, summaryWatcher, configuration, internalsProvider, lastOpSeqNumber, firstAck, immediateSummary, raiseSummarizingError, summaryCollection) {
        const summarizer = new RunningSummarizer(clientId, onBehalfOfClientId, logger, summaryWatcher, configuration, internalsProvider, lastOpSeqNumber, firstAck, immediateSummary, raiseSummarizingError, summaryCollection);
        await summarizer.waitStart();
        // Run the heuristics after starting
        if (immediateSummary) {
            summarizer.trySummarize("immediate");
        }
        else {
            summarizer.heuristics.run();
        }
        return summarizer;
    }
    get disposed() { return this._disposed; }
    dispose() {
        this.summaryWatcher.dispose();
        this.heuristics.dispose();
        this.summarizeTimer.clear();
        this.pendingAckTimer.clear();
        this._disposed = true;
    }
    handleSystemOp(op) {
        switch (op.type) {
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.MessageType.ClientLeave: {
                const leavingClientId = JSON.parse(op.data);
                if (leavingClientId === this.clientId || leavingClientId === this.onBehalfOfClientId) {
                    // Ignore summarizer leave messages, to make sure not to start generating
                    // a summary as the summarizer is leaving
                    return;
                }
                // Leave ops for any other client fall through to handle normally
            }
            // Intentional fallthrough
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.MessageType.ClientJoin:
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.MessageType.Propose:
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.MessageType.Reject: {
                // Synchronously handle quorum ops like regular ops
                this.handleOp(undefined, op);
                return;
            }
            default: {
                return;
            }
        }
    }
    handleOp(error, op) {
        if (error !== undefined) {
            return;
        }
        this.heuristics.lastOpSeqNumber = op.sequenceNumber;
        // Check for ops requesting summary
        if (op.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.MessageType.Save) {
            this.trySummarize(`;${op.clientId}: ${op.contents}`);
        }
        else {
            this.heuristics.run();
        }
    }
    async waitStop() {
        var _a, _b;
        if (this.disposed) {
            return;
        }
        if (this.stopping) {
            await ((_a = this.summarizing) === null || _a === void 0 ? void 0 : _a.promise);
            return;
        }
        this.stopping = true;
        const outstandingOps = this.heuristics.lastOpSeqNumber - this.heuristics.lastAcked.refSequenceNumber;
        if (outstandingOps > minOpsForLastSummary) {
            this.trySummarize("lastSummary");
            // This resolves when the current pending summary is acked or fails.
            // We wait for the result in case a safe summary is needed, and to get
            // better telemetry.
            await ((_b = this.summarizing) === null || _b === void 0 ? void 0 : _b.promise);
        }
    }
    async waitStart() {
        // Wait no longer than ack timeout for all pending
        const maybeLastAck = await Promise.race([
            this.summaryWatcher.waitFlushed(),
            this.pendingAckTimer.start(),
        ]);
        this.pendingAckTimer.clear();
        if (checkNotTimeout(maybeLastAck)) {
            this.heuristics.initialize({
                refSequenceNumber: maybeLastAck.summaryOp.referenceSequenceNumber,
                summaryTime: maybeLastAck.summaryOp.timestamp,
                summarySequenceNumber: maybeLastAck.summaryOp.sequenceNumber,
            });
        }
    }
    trySummarize(reason) {
        if (this.summarizing !== undefined) {
            // We can't summarize if we are already
            this.tryWhileSummarizing = true;
            return;
        }
        // GenerateSummary could take some time
        // mark that we are currently summarizing to prevent concurrent summarizing
        this.summarizing = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Deferred();
        (async () => {
            const result = await this.summarize(reason, false);
            if (result !== true) {
                // On nack or error, try again in safe mode
                await this.summarize(reason, true);
            }
        })().finally(() => {
            var _a;
            (_a = this.summarizing) === null || _a === void 0 ? void 0 : _a.resolve();
            this.summarizing = undefined;
            if (this.tryWhileSummarizing && !this.stopping && !this.disposed) {
                this.tryWhileSummarizing = false;
                this.heuristics.run();
            }
        }).catch((error) => {
            this.logger.sendErrorEvent({ eventName: "UnexpectedSummarizeError" }, error);
        });
    }
    /**
     * Generates summary and listens for broadcast and ack/nack.
     * Returns true for ack, false for nack, and undefined for failure or timeout.
     * @param reason - reason for summarizing
     * @param safe - true to generate summary in safe mode
     */
    async summarize(reason, safe) {
        this.summarizeTimer.start();
        try {
            return await this.summarizeCore(reason, safe);
        }
        finally {
            this.summarizeTimer.clear();
            this.pendingAckTimer.clear();
        }
    }
    async summarizeCore(reason, safe) {
        ++this.summarizeCount;
        // Wait to generate and send summary
        const summaryData = await this.generateSummaryWithLogging(reason, safe);
        this.heuristics.recordAttempt(summaryData === null || summaryData === void 0 ? void 0 : summaryData.referenceSequenceNumber);
        if (!summaryData || !summaryData.submitted) {
            // Did not send the summary op
            this.raiseSummarizingError("Error while generating or submitting summary");
            return undefined;
        }
        const pendingTimeoutP = this.pendingAckTimer.start().catch(() => undefined);
        const summary = this.summaryWatcher.watchSummary(summaryData.clientSequenceNumber);
        // Wait for broadcast
        const summaryOp = await Promise.race([summary.waitBroadcast(), pendingTimeoutP]);
        if (!checkNotTimeout(summaryOp)) {
            return undefined;
        }
        this.heuristics.lastAttempted.summarySequenceNumber = summaryOp.sequenceNumber;
        this.logger.sendTelemetryEvent({
            eventName: "SummaryOp",
            timeWaiting: Date.now() - this.heuristics.lastAttempted.summaryTime,
            refSequenceNumber: summaryOp.referenceSequenceNumber,
            summarySequenceNumber: summaryOp.sequenceNumber,
            handle: summaryOp.contents.handle,
        });
        // Wait for ack/nack
        const ackNack = await Promise.race([summary.waitAckNack(), pendingTimeoutP]);
        if (!checkNotTimeout(ackNack)) {
            return undefined;
        }
        this.logger.sendTelemetryEvent({
            eventName: ackNack.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.MessageType.SummaryAck ? "SummaryAck" : "SummaryNack",
            category: ackNack.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.MessageType.SummaryAck ? "generic" : "error",
            timeWaiting: Date.now() - this.heuristics.lastAttempted.summaryTime,
            summarySequenceNumber: ackNack.contents.summaryProposal.summarySequenceNumber,
            error: ackNack.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.MessageType.SummaryNack ? ackNack.contents.errorMessage : undefined,
            handle: ackNack.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.MessageType.SummaryAck ? ackNack.contents.handle : undefined,
        });
        this.pendingAckTimer.clear();
        // Update for success
        if (ackNack.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.MessageType.SummaryAck) {
            this.heuristics.ackLastSent();
            // since we need a full summary after context reload, we only clear this on ack
            this.immediateSummary = false;
            return true;
        }
        else {
            this.raiseSummarizingError("SummaryNack");
            return false;
        }
    }
    async generateSummaryWithLogging(message, safe) {
        const summarizingEvent = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.PerformanceEvent.start(this.logger, {
            eventName: "GenerateSummary",
            message,
            timeSinceLastAttempt: Date.now() - this.heuristics.lastAttempted.summaryTime,
            timeSinceLastSummary: Date.now() - this.heuristics.lastAcked.summaryTime,
            safe: safe || undefined,
        });
        // Wait for generate/send summary
        let summaryData;
        try {
            summaryData = await this.internalsProvider.generateSummary({
                fullTree: this.immediateSummary || safe,
                refreshLatestAck: safe,
                summaryLogger: this.logger,
            });
        }
        catch (error) {
            summarizingEvent.cancel({ category: "error" }, error);
            return;
        }
        this.summarizeTimer.clear();
        if (!summaryData) {
            summarizingEvent.cancel();
            return;
        }
        const telemetryProps = Object.assign(Object.assign(Object.assign({}, summaryData), summaryData.summaryStats), { refSequenceNumber: summaryData.referenceSequenceNumber, opsSinceLastAttempt: summaryData.referenceSequenceNumber - this.heuristics.lastAttempted.refSequenceNumber, opsSinceLastSummary: summaryData.referenceSequenceNumber - this.heuristics.lastAcked.refSequenceNumber });
        telemetryProps.summaryStats = undefined;
        telemetryProps.referenceSequenceNumber = undefined;
        if (summaryData.submitted) {
            summarizingEvent.end(telemetryProps);
        }
        else {
            summarizingEvent.cancel(telemetryProps);
        }
        return summaryData;
    }
    summarizeTimerHandler(time, count) {
        this.logger.sendPerformanceEvent({
            eventName: "SummarizeTimeout",
            timeoutTime: time,
            timeoutCount: count,
        });
        if (count < maxSummarizeTimeoutCount) {
            // Double and start a new timer
            const nextTime = time * 2;
            this.summarizeTimer.start(nextTime, () => this.summarizeTimerHandler(nextTime, count + 1));
        }
    }
}
/**
 * Summarizer is responsible for coordinating when to send generate and send summaries.
 * It is the main entry point for summary work.
 */
class Summarizer extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor(url, runtime, configurationGetter, internalsProvider, handleContext, summaryCollection) {
        var _a;
        super();
        this.runtime = runtime;
        this.configurationGetter = configurationGetter;
        this.internalsProvider = internalsProvider;
        this.immediateSummary = false;
        this.stopped = false;
        this.stopDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Deferred();
        this._disposed = false;
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(this.runtime.logger, "Summarizer");
        this.runCoordinator = new _runWhileConnectedCoordinator__WEBPACK_IMPORTED_MODULE_5__.RunWhileConnectedCoordinator(runtime);
        if (summaryCollection) {
            // summarize immediately because we just went through context reload
            this.immediateSummary = true;
            this.summaryCollection = summaryCollection;
        }
        else {
            this.summaryCollection = new _summaryCollection__WEBPACK_IMPORTED_MODULE_6__.SummaryCollection(this.runtime.deltaManager.initialSequenceNumber, this.logger);
        }
        this.runtime.deltaManager.inbound.on("op", (op) => this.summaryCollection.handleOp(op));
        (_a = this.runtime.previousState.nextSummarizerD) === null || _a === void 0 ? void 0 : _a.resolve(this);
        this.innerHandle = new _summarizerHandle__WEBPACK_IMPORTED_MODULE_7__.SummarizerHandle(this, url, handleContext);
    }
    get IFluidLoadable() { return this; }
    get IFluidRouter() { return this; }
    get IFluidRunnable() { return this; }
    get ISummarizer() { return this; }
    get handle() { return this.innerHandle; }
    async run(onBehalfOf) {
        try {
            await this.runCore(onBehalfOf);
        }
        catch (error) {
            const err2 = Object.assign(Object.assign({ logged: false }, (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_8__.CreateContainerError)(error)), { errorType: summarizingError });
            this.emit("summarizingError", err2);
            throw error;
        }
        finally {
            // Cleanup after running
            if (this.runtime.connected) {
                if (this.runningSummarizer) {
                    await this.runningSummarizer.waitStop();
                }
                this.runtime.closeFn();
            }
            this.dispose();
        }
    }
    /**
     * Stops the summarizer from running.  This will complete
     * the run promise, and also close the container.
     * @param reason - reason code for stopping
     */
    stop(reason) {
        if (this.stopped) {
            // already stopping
            return;
        }
        this.stopped = true;
        this.logger.sendTelemetryEvent({
            eventName: "StoppingSummarizer",
            onBehalfOf: this.onBehalfOfClientId,
            reason,
        });
        this.stopDeferred.resolve();
    }
    updateOnBehalfOf(onBehalfOf) {
        this.onBehalfOfClientId = onBehalfOf;
    }
    async request(request) {
        if (request.url === "/" || request.url === "") {
            return {
                mimeType: "fluid/object",
                status: 200,
                value: this,
            };
        }
        return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_9__.create404Response)(request);
    }
    async runCore(onBehalfOf) {
        this.onBehalfOfClientId = onBehalfOf;
        const startResult = await this.runCoordinator.waitStart();
        if (startResult.started === false) {
            this.logger.sendTelemetryEvent({
                eventName: "NotStarted",
                reason: startResult.message,
                onBehalfOf,
            });
            return;
        }
        if (this.runtime.deltaManager.active === false) {
            this.logger.sendTelemetryEvent({
                eventName: "NotStarted",
                reason: "CannotWrite",
                onBehalfOf,
            });
            return;
        }
        if (this.runtime.summarizerClientId !== this.onBehalfOfClientId
            && this.runtime.summarizerClientId !== this.runtime.clientId) {
            // Verify that this client's computed summarizer matches the client this was spawned
            // on behalf of.  If not, fallback on the following logic before stopping:
            // If we are not oldest client in quorum, another client will take over as summarizer.
            // We want to make sure we at least try to summarize in case server is rejecting ops,
            // so if we are the oldest client, we will still go through and try to summarize at least once.
            // We also don't want to end up with two summarizer clients running at the same time,
            // so we bypass running altogether if this client isn't the oldest.
            this.logger.sendTelemetryEvent({
                eventName: "NotStarted",
                reason: "DifferentComputedSummarizer",
                computedSummarizer: this.runtime.summarizerClientId,
                onBehalfOf,
                clientId: this.runtime.clientId,
            });
            return;
        }
        // Initialize values and first ack (time is not exact)
        this.logger.sendTelemetryEvent({
            eventName: "RunningSummarizer",
            onBehalfOf,
            initSummarySeqNumber: this.summaryCollection.initialSequenceNumber,
        });
        const initialAttempt = {
            refSequenceNumber: this.summaryCollection.initialSequenceNumber,
            summaryTime: Date.now(),
        };
        const runningSummarizer = await RunningSummarizer.start(startResult.clientId, onBehalfOf, this.logger, this.summaryCollection.createWatcher(startResult.clientId), this.configurationGetter(), this /* Pick<ISummarizerInternalsProvider, "generateSummary"> */, this.runtime.deltaManager.lastSequenceNumber, initialAttempt, this.immediateSummary, (description) => {
            if (!this._disposed) {
                this.emit("summarizingError", createSummarizingWarning(`Summarizer: ${description}`, true));
            }
        }, this.summaryCollection);
        this.runningSummarizer = runningSummarizer;
        this.immediateSummary = false;
        // Handle summary acks
        this.handleSummaryAcks().catch((error) => {
            this.logger.sendErrorEvent({ eventName: "HandleSummaryAckFatalError" }, error);
            // Raise error to parent container.
            this.emit("summarizingError", createSummarizingWarning("Summarizer: HandleSummaryAckFatalError", true));
            this.stop("HandleSummaryAckFatalError");
        });
        // Listen for ops
        this.systemOpListener = (op) => runningSummarizer.handleSystemOp(op);
        this.runtime.deltaManager.inbound.on("op", this.systemOpListener);
        this.opListener = (error, op) => runningSummarizer.handleOp(error, op);
        this.runtime.on("batchEnd", this.opListener);
        await Promise.race([
            this.runCoordinator.waitStopped(),
            this.stopDeferred.promise,
        ]);
    }
    /**
     * Disposes of resources after running.  This cleanup will
     * clear any outstanding timers and reset some of the state
     * properties.
     */
    dispose() {
        this._disposed = true;
        if (this.runningSummarizer) {
            this.runningSummarizer.dispose();
            this.runningSummarizer = undefined;
        }
        if (this.systemOpListener) {
            this.runtime.deltaManager.inbound.off("op", this.systemOpListener);
        }
        if (this.opListener) {
            this.runtime.removeListener("batchEnd", this.opListener);
        }
    }
    async setSummarizer() {
        this.runtime.nextSummarizerD = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Deferred();
        return this.runtime.nextSummarizerD.promise;
    }
    /** Implementation of SummarizerInternalsProvider.generateSummary */
    async generateSummary(options) {
        if (this.onBehalfOfClientId !== this.runtime.summarizerClientId
            && this.runtime.clientId !== this.runtime.summarizerClientId) {
            // We are no longer the summarizer; a different client is, so we should stop ourself
            this.stop("parentNoLongerSummarizer");
            return undefined;
        }
        return this.internalsProvider.generateSummary(options);
    }
    async handleSummaryAcks() {
        var _a;
        let refSequenceNumber = this.summaryCollection.initialSequenceNumber;
        while (this.runningSummarizer) {
            const summaryLogger = (_a = this.runningSummarizer.tryGetCorrelatedLogger(refSequenceNumber)) !== null && _a !== void 0 ? _a : this.logger;
            try {
                const ack = await this.summaryCollection.waitSummaryAck(refSequenceNumber);
                refSequenceNumber = ack.summaryOp.referenceSequenceNumber;
                await this.internalsProvider.refreshLatestSummaryAck(ack.summaryOp.contents.handle, ack.summaryAckNack.contents.handle, summaryLogger);
            }
            catch (error) {
                summaryLogger.sendErrorEvent({ eventName: "HandleSummaryAckError", refSequenceNumber }, error);
            }
            refSequenceNumber++;
        }
    }
}
//# sourceMappingURL=summarizer.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/summarizerHandle.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/summarizerHandle.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummarizerHandle": () => (/* binding */ SummarizerHandle)
/* harmony export */ });
/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/datastore */ "../../node_modules/@fluidframework/datastore/lib/fluidHandle.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

// TODO #2425 Expose Summarizer handle as FluidObjectHandle w/ tests
class SummarizerHandle extends _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__.FluidObjectHandle {
    async get() {
        throw Error("Do not try to get a summarizer object from the handle. Reference it directly.");
    }
    attach() {
        return;
    }
    bind(handle) {
        return;
    }
}
//# sourceMappingURL=summarizerHandle.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/summaryCollection.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/summaryCollection.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummaryCollection": () => (/* binding */ SummaryCollection)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/promises.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/protocol.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


var SummaryState;
(function (SummaryState) {
    SummaryState[SummaryState["Local"] = 0] = "Local";
    SummaryState[SummaryState["Broadcast"] = 1] = "Broadcast";
    SummaryState[SummaryState["Acked"] = 2] = "Acked";
    SummaryState[SummaryState["Nacked"] = -1] = "Nacked";
})(SummaryState || (SummaryState = {}));
class Summary {
    constructor(clientId, clientSequenceNumber) {
        this.clientId = clientId;
        this.clientSequenceNumber = clientSequenceNumber;
        this.state = SummaryState.Local;
        this.defSummaryOp = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        this.defSummaryAck = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
    }
    static createLocal(clientId, clientSequenceNumber) {
        return new Summary(clientId, clientSequenceNumber);
    }
    static createFromOp(op) {
        const summary = new Summary(op.clientId, op.clientSequenceNumber);
        summary.broadcast(op);
        return summary;
    }
    get summaryOp() { return this._summaryOp; }
    get summaryAckNack() { return this._summaryAckNack; }
    hasBeenAcked() {
        return this.state === SummaryState.Acked;
    }
    broadcast(op) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.state === SummaryState.Local, 0x175 /* "Can only broadcast if summarizer starts in local state" */);
        this._summaryOp = op;
        this.defSummaryOp.resolve();
        this.state = SummaryState.Broadcast;
        return true;
    }
    ackNack(op) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.state === SummaryState.Broadcast, 0x176 /* "Can only ack/nack if summarizer is in broadcasting state" */);
        this._summaryAckNack = op;
        this.defSummaryAck.resolve();
        this.state = op.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.SummaryAck ? SummaryState.Acked : SummaryState.Nacked;
        return true;
    }
    async waitBroadcast() {
        await this.defSummaryOp.promise;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this._summaryOp;
    }
    async waitAckNack() {
        await this.defSummaryAck.promise;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this._summaryAckNack;
    }
}
/**
 * This class watches summaries created by a specific client.
 * It should be created and managed from a SummaryCollection.
 */
class ClientSummaryWatcher {
    constructor(clientId, summaryCollection) {
        this.clientId = clientId;
        this.summaryCollection = summaryCollection;
        // key: clientSeqNum
        this.localSummaries = new Map();
        this._disposed = false;
    }
    get disposed() { return this._disposed; }
    /**
     * Watches for a specific sent summary op.
     * @param clientSequenceNumber - client sequence number of sent summary op
     */
    watchSummary(clientSequenceNumber) {
        let summary = this.localSummaries.get(clientSequenceNumber);
        if (!summary) {
            summary = Summary.createLocal(this.clientId, clientSequenceNumber);
            this.localSummaries.set(summary.clientSequenceNumber, summary);
        }
        return summary;
    }
    /**
     * Waits until all of the pending summaries in the underlying SummaryCollection
     * are acked/nacked.
     */
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    waitFlushed() {
        return this.summaryCollection.waitFlushed();
    }
    /**
     * Gets a watched summary or returns undefined if not watched.
     * @param clientSequenceNumber - client sequence number of sent summary op
     */
    tryGetSummary(clientSequenceNumber) {
        return this.localSummaries.get(clientSequenceNumber);
    }
    /**
     * Starts watching a summary made by this client.
     * @param summary - summary to start watching
     */
    setSummary(summary) {
        this.localSummaries.set(summary.clientSequenceNumber, summary);
    }
    dispose() {
        this.summaryCollection.removeWatcher(this.clientId);
        this._disposed = true;
    }
}
/**
 * Data structure that looks at the op stream to track summaries as they
 * are broadcast, acked and nacked.
 * It provides functionality for watching specific summaries.
 */
class SummaryCollection {
    constructor(initialSequenceNumber, logger) {
        this.initialSequenceNumber = initialSequenceNumber;
        this.logger = logger;
        // key: clientId
        this.summaryWatchers = new Map();
        // key: summarySeqNum
        this.pendingSummaries = new Map();
        this.refreshWaitNextAck = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
    }
    get latestAck() { return this.lastAck; }
    /**
     * Creates and returns a summary watcher for a specific client.
     * This will allow for local sent summaries to be better tracked.
     * @param clientId - client id for watcher
     */
    createWatcher(clientId) {
        const watcher = new ClientSummaryWatcher(clientId, this);
        this.summaryWatchers.set(clientId, watcher);
        return watcher;
    }
    removeWatcher(clientId) {
        this.summaryWatchers.delete(clientId);
    }
    setPendingAckTimerTimeoutCallback(maxAckWaitTime, timeoutCallback) {
        this.maxAckWaitTime = maxAckWaitTime;
        this.pendingAckTimerTimeoutCallback = timeoutCallback;
    }
    /**
     * Returns a promise that resolves once all pending summary ops
     * have been acked or nacked.
     */
    async waitFlushed() {
        while (this.pendingSummaries.size > 0) {
            // eslint-disable-next-line @typescript-eslint/promise-function-async
            const promises = Array.from(this.pendingSummaries, ([, summary]) => summary.waitAckNack());
            await Promise.all(promises);
        }
        return this.lastAck;
    }
    /**
     * Returns a promise that resolves once a summary is acked that has a reference
     * sequence number greater than or equal to the passed in sequence number.
     * @param referenceSequenceNumber - reference sequence number to wait for
     * @returns The latest acked summary
     */
    async waitSummaryAck(referenceSequenceNumber) {
        while (!this.lastAck || this.lastAck.summaryOp.referenceSequenceNumber < referenceSequenceNumber) {
            await this.refreshWaitNextAck.promise;
        }
        return this.lastAck;
    }
    /**
     * Handler for ops; only handles ops relating to summaries.
     * @param op - op message to handle
     */
    handleOp(op) {
        var _a;
        switch (op.type) {
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.Summarize: {
                this.handleSummaryOp(op);
                return;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.SummaryAck: {
                this.handleSummaryAck(op);
                return;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.SummaryNack: {
                this.handleSummaryNack(op);
                return;
            }
            default: {
                // If the difference between timestamp of current op and last summary op is greater than
                // the maxAckWaitTime, then we need to inform summarizer to not wait and summarize
                // immediately as we have already waited for maxAckWaitTime.
                const lastOpTimestamp = op.timestamp;
                if (this.lastSummaryTimestamp !== undefined &&
                    this.maxAckWaitTime !== undefined &&
                    lastOpTimestamp - this.lastSummaryTimestamp >= this.maxAckWaitTime) {
                    (_a = this.pendingAckTimerTimeoutCallback) === null || _a === void 0 ? void 0 : _a.call(this);
                }
                return;
            }
        }
    }
    handleSummaryOp(op) {
        let summary;
        // Check if summary already being watched, broadcast if so
        const watcher = this.summaryWatchers.get(op.clientId);
        if (watcher) {
            summary = watcher.tryGetSummary(op.clientSequenceNumber);
            if (summary) {
                summary.broadcast(op);
            }
        }
        // If not watched, create from op
        if (!summary) {
            summary = Summary.createFromOp(op);
            if (watcher) {
                watcher.setSummary(summary);
            }
        }
        this.pendingSummaries.set(op.sequenceNumber, summary);
        this.lastSummaryTimestamp = op.timestamp;
    }
    handleSummaryAck(op) {
        const seq = op.contents.summaryProposal.summarySequenceNumber;
        const summary = this.pendingSummaries.get(seq);
        if (!summary) {
            // Summary ack without an op should be rare. We could fetch the
            // reference sequence number from the snapshot, but instead we
            // will not emit this ack. It should be the case that the summary
            // op that this ack is for is earlier than this file was loaded
            // from. i.e. initialSequenceNumber > summarySequenceNumber.
            // We really don't care about it for now, since it is older than
            // the one we loaded from.
            if (seq >= this.initialSequenceNumber) {
                // Potential causes for it to be later than our initialSequenceNumber
                // are that the summaryOp was nacked then acked, double-acked, or
                // the summarySequenceNumber is incorrect.
                this.logger.sendErrorEvent({
                    eventName: "SummaryAckWithoutOp",
                    sequenceNumber: op.sequenceNumber,
                    summarySequenceNumber: seq,
                    initialSequenceNumber: this.initialSequenceNumber,
                });
            }
            return;
        }
        summary.ackNack(op);
        this.pendingSummaries.delete(seq);
        // Track latest ack
        if (!this.lastAck || seq > this.lastAck.summaryAckNack.contents.summaryProposal.summarySequenceNumber) {
            this.lastAck = summary;
            this.refreshWaitNextAck.resolve();
            this.refreshWaitNextAck = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        }
    }
    handleSummaryNack(op) {
        const seq = op.contents.summaryProposal.summarySequenceNumber;
        const summary = this.pendingSummaries.get(seq);
        if (summary) {
            summary.ackNack(op);
            this.pendingSummaries.delete(seq);
        }
    }
}
//# sourceMappingURL=summaryCollection.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/summaryFormat.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/summaryFormat.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAttributesFormatVersion": () => (/* binding */ getAttributesFormatVersion),
/* harmony export */   "hasIsolatedChannels": () => (/* binding */ hasIsolatedChannels),
/* harmony export */   "metadataBlobName": () => (/* binding */ metadataBlobName),
/* harmony export */   "chunksBlobName": () => (/* binding */ chunksBlobName),
/* harmony export */   "blobsTreeName": () => (/* binding */ blobsTreeName),
/* harmony export */   "rootHasIsolatedChannels": () => (/* binding */ rootHasIsolatedChannels),
/* harmony export */   "nonDataStorePaths": () => (/* binding */ nonDataStorePaths),
/* harmony export */   "dataStoreAttributesBlobName": () => (/* binding */ dataStoreAttributesBlobName),
/* harmony export */   "wrapSummaryInChannelsTree": () => (/* binding */ wrapSummaryInChannelsTree)
/* harmony export */ });
/* unused harmony exports getMetadataFormatVersion, protocolTreeName */
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/runtime-definitions */ "../../node_modules/@fluidframework/runtime-definitions/dist/index.js");
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

function getAttributesFormatVersion(attributes) {
    if (attributes.summaryFormatVersion) {
        /**
         * Version 2+: Introduces .channels trees for isolation of
         * channel trees from data store objects.
         */
        return attributes.summaryFormatVersion;
    }
    else if (attributes.snapshotFormatVersion === "0.1") {
        /**
         * Version 1: from this version the pkg within the data store
         * attributes blob is a JSON array rather than a string.
         */
        return 1;
    }
    /**
     * Version 0: format version is missing from summary.
     * This indicates it is an older version.
     */
    return 0;
}
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function hasIsolatedChannels(attributes) {
    return !!attributes.summaryFormatVersion && !attributes.disableIsolatedChannels;
}
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function getMetadataFormatVersion(metadata) {
    var _a;
    /**
     * Version 1+: Introduces .metadata blob and .channels trees for isolation of
     * data store trees from container-level objects.
     *
     * Version 0: metadata blob missing; format version is missing from summary.
     * This indicates it is an older version.
     */
    return (_a = metadata === null || metadata === void 0 ? void 0 : metadata.summaryFormatVersion) !== null && _a !== void 0 ? _a : 0;
}
const metadataBlobName = ".metadata";
const chunksBlobName = ".chunks";
const blobsTreeName = ".blobs";
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function rootHasIsolatedChannels(metadata) {
    return !!metadata && !metadata.disableIsolatedChannels;
}
const protocolTreeName = ".protocol";
/**
 * List of tree IDs at the container level which are reserved.
 * This is for older versions of summaries that do not yet have an
 * isolated data stores namespace. Without the namespace, this must
 * be used to prevent name collisions with data store IDs.
 */
const nonDataStorePaths = [protocolTreeName, ".logTail", ".serviceProtocol", blobsTreeName];
const dataStoreAttributesBlobName = ".component";
/**
 * Modifies summary tree and stats to put tree under .channels tree.
 * Converts from: {
 *     type: SummaryType.Tree,
 *     tree: { a: {...}, b: {...}, c: {...} },
 * }
 * to: {
 *     type: SummaryType.Tree,
 *     tree: {
 *         ".channels": {
 *             type: SummaryType.Tree,
 *             tree: { a: {...}, b: {...}, c: {...} }
 *         },
 *     },
 * }
 * And adds +1 to treeNodeCount in stats.
 * @param summarizeResult - summary tree and stats to modify
 */
function wrapSummaryInChannelsTree(summarizeResult) {
    summarizeResult.summary = {
        type: 1 /* Tree */,
        tree: { [_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.channelsTreeName]: summarizeResult.summary },
    };
    summarizeResult.stats.treeNodeCount++;
}
//# sourceMappingURL=summaryFormat.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-runtime/lib/summaryManager.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-runtime/lib/summaryManager.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummaryManager": () => (/* binding */ SummaryManager)
/* harmony export */ });
/* unused harmony export summarizerClientType */
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/heap.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/timer.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/container-definitions */ "../../node_modules/@fluidframework/container-definitions/lib/loader.js");
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @fluidframework/driver-definitions */ "../../node_modules/@fluidframework/driver-definitions/lib/urlResolver.js");
/* harmony import */ var _summarizer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./summarizer */ "../../node_modules/@fluidframework/container-runtime/lib/summarizer.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */






const summarizerClientType = "summarizer";
class ClientComparer {
    constructor() {
        this.min = {
            clientId: "",
            sequenceNumber: -1,
            isSummarizer: false,
        };
    }
    compare(a, b) {
        return a.sequenceNumber - b.sequenceNumber;
    }
}
class QuorumHeap {
    constructor() {
        this.heap = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Heap((new ClientComparer()));
        this.heapMembers = new Map();
        this.summarizerCount = 0;
    }
    addClient(clientId, client) {
        var _a;
        // Have to undefined-check client.details for backwards compatibility
        const isSummarizer = ((_a = client.client.details) === null || _a === void 0 ? void 0 : _a.type) === summarizerClientType;
        const heapNode = this.heap.add({ clientId, sequenceNumber: client.sequenceNumber, isSummarizer });
        this.heapMembers.set(clientId, heapNode);
        if (isSummarizer) {
            this.summarizerCount++;
        }
    }
    removeClient(clientId) {
        const member = this.heapMembers.get(clientId);
        if (member) {
            this.heap.remove(member);
            this.heapMembers.delete(clientId);
            if (member.value.isSummarizer) {
                this.summarizerCount--;
            }
        }
    }
    getFirstClientId() {
        return this.heap.count() > 0 ? this.heap.peek().value.clientId : undefined;
    }
    getSummarizerCount() {
        return this.summarizerCount;
    }
}
var SummaryManagerState;
(function (SummaryManagerState) {
    SummaryManagerState[SummaryManagerState["Off"] = 0] = "Off";
    SummaryManagerState[SummaryManagerState["Starting"] = 1] = "Starting";
    SummaryManagerState[SummaryManagerState["Running"] = 2] = "Running";
    SummaryManagerState[SummaryManagerState["Stopping"] = 3] = "Stopping";
    SummaryManagerState[SummaryManagerState["Disabled"] = -1] = "Disabled";
})(SummaryManagerState || (SummaryManagerState = {}));
const defaultInitialDelayMs = 5000;
const opsToBypassInitialDelay = 4000;
const defaultThrottleDelayWindowMs = 60 * 1000;
const defaultThrottleMaxDelayMs = 30 * 1000;
// default throttling function increases exponentially (0ms, 20ms, 60ms, 140ms, etc)
const defaultThrottleDelayFunction = (n) => 20 * (Math.pow(2, n) - 1);
/**
 * Used to give increasing delay times for throttling a single functionality.
 * Delay is based on previous attempts within specified time window, ignoring actual delay time.
 */
class Throttler {
    constructor(delayWindowMs, maxDelayMs, delayFunction) {
        this.delayWindowMs = delayWindowMs;
        this.maxDelayMs = maxDelayMs;
        this.delayFunction = delayFunction;
        this.startTimes = [];
    }
    get attempts() {
        return this.startTimes.length;
    }
    getDelay() {
        const now = Date.now();
        this.startTimes = this.startTimes.filter((t) => now - t < this.delayWindowMs);
        const delayMs = Math.min(this.delayFunction(this.startTimes.length), this.maxDelayMs);
        this.startTimes.push(now);
        this.startTimes = this.startTimes.map((t) => t + delayMs); // account for delay time
        if (delayMs === this.maxDelayMs) {
            // we hit max delay so adding more won't affect anything
            // shift off oldest time to stop this array from growing forever
            this.startTimes.shift();
        }
        return delayMs;
    }
}
class SummaryManager extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor(context, summariesEnabled, parentLogger, setNextSummarizer, nextSummarizerP, immediateSummary = false, initialDelayMs = defaultInitialDelayMs) {
        var _a, _b;
        super();
        this.context = context;
        this.summariesEnabled = summariesEnabled;
        this.setNextSummarizer = setNextSummarizer;
        this.nextSummarizerP = nextSummarizerP;
        this.quorumHeap = new QuorumHeap();
        this.connected = false;
        this.state = SummaryManagerState.Off;
        this._disposed = false;
        this.startThrottler = new Throttler(defaultThrottleDelayWindowMs, defaultThrottleMaxDelayMs, defaultThrottleDelayFunction);
        this.opsUntilFirstConnect = -1;
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.ChildLogger.create(parentLogger, "SummaryManager", { all: { clientId: () => this.latestClientId } });
        this.connected = context.connected;
        if (this.connected) {
            this.setClientId(context.clientId);
        }
        const members = context.quorum.getMembers();
        for (const [clientId, client] of members) {
            this.quorumHeap.addClient(clientId, client);
        }
        context.quorum.on("addMember", (clientId, details) => {
            if (this.opsUntilFirstConnect === -1 && clientId === this.clientId) {
                this.opsUntilFirstConnect = details.sequenceNumber - this.context.deltaManager.initialSequenceNumber;
            }
            this.quorumHeap.addClient(clientId, details);
            this.refreshSummarizer();
        });
        context.quorum.on("removeMember", (clientId) => {
            this.quorumHeap.removeClient(clientId);
            this.refreshSummarizer();
        });
        this.initialDelayTimer = immediateSummary ? undefined : new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.PromiseTimer(initialDelayMs, () => { });
        this.initialDelayP = (_b = (_a = this.initialDelayTimer) === null || _a === void 0 ? void 0 : _a.start()) !== null && _b !== void 0 ? _b : Promise.resolve();
        this.refreshSummarizer();
    }
    get summarizer() {
        return this.summarizerClientId;
    }
    get disposed() {
        return this._disposed;
    }
    setConnected(clientId) {
        this.updateConnected(true, clientId);
    }
    setDisconnected() {
        this.updateConnected(false);
    }
    setClientId(clientId) {
        this.clientId = clientId;
        if (clientId !== undefined) {
            this.latestClientId = clientId;
            if (this.runningSummarizer !== undefined) {
                this.runningSummarizer.updateOnBehalfOf(clientId);
            }
        }
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    updateConnected(connected, clientId) {
        if (this.connected === connected) {
            return;
        }
        this.connected = connected;
        this.setClientId(clientId);
        this.refreshSummarizer();
    }
    getShouldSummarizeState() {
        if (!this.connected) {
            return { shouldSummarize: false, stopReason: "parentNotConnected" };
        }
        else if (this.clientId !== this.summarizer) {
            return { shouldSummarize: false, stopReason: "parentShouldNotSummarize" };
        }
        else if (this.disposed) {
            return { shouldSummarize: false, stopReason: "disposed" };
        }
        else if (this.nextSummarizerP !== undefined) {
            // This client has just come from a context reload, which means its
            // summarizer client did as well.  We need to call start to rebind them.
            return { shouldSummarize: true, shouldStart: true };
        }
        else if (this.quorumHeap.getSummarizerCount() > 0) {
            // Need to wait for any other existing summarizer clients to close,
            // because they can live longer than their parent container.
            return { shouldSummarize: true, shouldStart: false };
        }
        else {
            return { shouldSummarize: true, shouldStart: true };
        }
    }
    refreshSummarizer() {
        // Compute summarizer
        const newSummarizerClientId = this.quorumHeap.getFirstClientId();
        if (newSummarizerClientId !== this.summarizerClientId) {
            this.summarizerClientId = newSummarizerClientId;
            this.emit("summarizer", newSummarizerClientId);
        }
        // Transition states depending on shouldSummarize, which is a calculated
        // property that is only true if this client is connected and has the
        // computed summarizer client id
        const shouldSummarizeState = this.getShouldSummarizeState();
        switch (this.state) {
            case SummaryManagerState.Off: {
                if (shouldSummarizeState.shouldSummarize && shouldSummarizeState.shouldStart) {
                    this.start();
                }
                return;
            }
            case SummaryManagerState.Starting: {
                // Cannot take any action until summarizer is created
                // state transition will occur after creation
                return;
            }
            case SummaryManagerState.Running: {
                if (shouldSummarizeState.shouldSummarize === false) {
                    this.stop(shouldSummarizeState.stopReason);
                }
                return;
            }
            case SummaryManagerState.Stopping: {
                // Cannot take any action until running summarizer finishes
                // state transition will occur after it stops
                return;
            }
            case SummaryManagerState.Disabled: {
                // Never switch away from disabled state
                return;
            }
            default: {
                return;
            }
        }
    }
    raiseContainerWarning(warning) {
        this.context.raiseContainerWarning(warning);
    }
    start() {
        if (!this.summariesEnabled) {
            // If we should never summarize, lock in disabled state
            this.logger.sendTelemetryEvent({ eventName: "SummariesDisabled" });
            this.state = SummaryManagerState.Disabled;
            return;
        }
        if (this.context.clientDetails.type === summarizerClientType) {
            // Make sure that the summarizer client does not load another summarizer.
            this.state = SummaryManagerState.Disabled;
            return;
        }
        this.state = SummaryManagerState.Starting;
        // throttle creation of new summarizer containers to prevent spamming the server with websocket connections
        const delayMs = this.startThrottler.getDelay();
        if (delayMs >= defaultThrottleMaxDelayMs) {
            // we can't create a summarizer for some reason; raise error on container
            this.raiseContainerWarning((0,_summarizer__WEBPACK_IMPORTED_MODULE_4__.createSummarizingWarning)("SummaryManager: CreateSummarizer Max Throttle Delay", false));
        }
        this.createSummarizer(delayMs).then((summarizer) => {
            this.setNextSummarizer(summarizer.setSummarizer());
            summarizer.on("summarizingError", (warning) => this.raiseContainerWarning(warning));
            this.run(summarizer);
        }, (error) => {
            this.logger.sendErrorEvent({
                eventName: "CreateSummarizerError",
                attempt: this.startThrottler.attempts,
            }, error);
            this.tryRestart();
        });
    }
    run(summarizer) {
        this.state = SummaryManagerState.Running;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const clientId = this.latestClientId;
        this.runningSummarizer = summarizer;
        _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, { eventName: "RunningSummarizer", attempt: this.startThrottler.attempts }, async () => summarizer.run(clientId)).finally(() => {
            this.runningSummarizer = undefined;
            this.nextSummarizerP = undefined;
            this.tryRestart();
        });
        const shouldSummarizeState = this.getShouldSummarizeState();
        if (shouldSummarizeState.shouldSummarize === false) {
            this.stop(shouldSummarizeState.stopReason);
        }
    }
    tryRestart() {
        const shouldSummarizeState = this.getShouldSummarizeState();
        if (shouldSummarizeState.shouldSummarize && shouldSummarizeState.shouldStart) {
            this.start();
        }
        else {
            this.state = SummaryManagerState.Off;
        }
    }
    stop(reason) {
        this.state = SummaryManagerState.Stopping;
        if (this.runningSummarizer) {
            // Stopping the running summarizer client should trigger a change
            // in states when the running summarizer closes
            this.runningSummarizer.stop(reason);
        }
        else {
            // Should not be possible to hit this case
            this.logger.sendErrorEvent({ eventName: "StopCalledWithoutRunningSummarizer", reason });
            this.state = SummaryManagerState.Off;
        }
    }
    async createSummarizer(delayMs) {
        // We have been elected the summarizer. Some day we may be able to summarize with a live document but for
        // now we play it safe and launch a second copy.
        this.logger.sendTelemetryEvent({
            eventName: "CreatingSummarizer",
            delayMs,
            opsUntilFirstConnect: this.opsUntilFirstConnect,
        });
        const shouldDelay = delayMs > 0;
        const shouldInitialDelay = this.opsUntilFirstConnect < opsToBypassInitialDelay;
        if (shouldDelay || shouldInitialDelay) {
            await Promise.all([
                shouldInitialDelay ? this.initialDelayP : Promise.resolve(),
                shouldDelay ? new Promise((resolve) => setTimeout(resolve, delayMs)) : Promise.resolve(),
            ]);
        }
        if (this.nextSummarizerP) {
            return this.nextSummarizerP;
        }
        const loader = this.context.loader;
        // TODO eventually we may wish to spawn an execution context from which to run this
        const request = {
            headers: {
                [_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.LoaderHeader.cache]: false,
                [_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.LoaderHeader.clientDetails]: {
                    capabilities: { interactive: false },
                    type: summarizerClientType,
                },
                [_fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_6__.DriverHeader.summarizingClient]: true,
                [_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.LoaderHeader.reconnect]: false,
                [_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.LoaderHeader.sequenceNumber]: this.context.deltaManager.lastSequenceNumber,
            },
            url: "/_summarizer",
        };
        const response = await loader.request(request);
        if (response.status !== 200
            || (response.mimeType !== "fluid/object" && response.mimeType !== "fluid/component")) {
            return Promise.reject(new Error("Invalid summarizer route"));
        }
        const rawFluidObject = response.value;
        const summarizer = rawFluidObject.ISummarizer;
        if (!summarizer) {
            return Promise.reject(new Error("Fluid object does not implement ISummarizer"));
        }
        return summarizer;
    }
    dispose() {
        var _a;
        (_a = this.initialDelayTimer) === null || _a === void 0 ? void 0 : _a.clear();
        this._disposed = true;
    }
}
//# sourceMappingURL=summaryManager.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/container-utils/lib/error.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@fluidframework/container-utils/lib/error.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataCorruptionError": () => (/* binding */ DataCorruptionError),
/* harmony export */   "extractSafePropertiesFromMessage": () => (/* binding */ extractSafePropertiesFromMessage),
/* harmony export */   "CreateProcessingError": () => (/* binding */ CreateProcessingError),
/* harmony export */   "CreateContainerError": () => (/* binding */ CreateContainerError)
/* harmony export */ });
/* unused harmony exports GenericError, DataProcessingError */
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/container-definitions */ "../../node_modules/@fluidframework/container-definitions/lib/error.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */



function messageFromError(error) {
    if (typeof (error === null || error === void 0 ? void 0 : error.message) === "string") {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return error.message;
    }
    return `${error}`;
}
const isValidLoggingError = (error) => {
    return typeof (error === null || error === void 0 ? void 0 : error.errorType) === "string" && error instanceof _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError;
};
const isRegularObject = (value) => {
    return value !== null && !Array.isArray(value) && typeof value === "object";
};
// TODO: move this elsewhere and use in TelemetryLogger.prepareErrorObject
function extractLogSafeErrorProperties(error) {
    // Only get properties we know about.
    // Grabbing all properties will expose PII in telemetry!
    const message = messageFromError(error);
    const safeProps = {
        message,
    };
    if (isRegularObject(error)) {
        const { errorType, stack } = error;
        if (typeof errorType === "string") {
            safeProps.errorType = errorType;
        }
        if (typeof stack === "string") {
            safeProps.stack = stack;
        }
    }
    return safeProps;
}
/**
 * Generic error
 */
class GenericError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(errorMessage, error, props) {
        super(errorMessage, props);
        this.error = error;
        this.errorType = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType.genericError;
    }
}
class DataCorruptionError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(errorMessage, props) {
        super(errorMessage, props);
        this.errorType = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType.dataCorruptionError;
        this.canRetry = false;
    }
}
class DataProcessingError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(errorMessage, props) {
        super(errorMessage, props);
        this.errorType = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType.dataProcessingError;
        this.canRetry = false;
    }
}
const extractSafePropertiesFromMessage = (message) => ({
    messageClientId: message.clientId,
    messageSequenceNumber: message.sequenceNumber,
    messageClientSequenceNumber: message.clientSequenceNumber,
    messageReferenceSequenceNumber: message.referenceSequenceNumber,
    messageMinimumSequenceNumber: message.minimumSequenceNumber,
    messageTimestamp: message.timestamp,
});
/**
 * Conditionally coerce the throwable input into a DataProcessingError.
 * @param error - Throwable input to be converted.
 */
function CreateProcessingError(error, message) {
    const info = message !== undefined
        ? extractSafePropertiesFromMessage(message)
        : undefined;
    if (typeof error === "string") {
        return new DataProcessingError(error, info);
    }
    else if (!isRegularObject(error)) {
        return new DataProcessingError("DataProcessingError without explicit message (needs review)", Object.assign(Object.assign({}, info), { typeof: typeof error }));
    }
    else if (isValidLoggingError(error)) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return error;
    }
    else {
        const safeProps = extractLogSafeErrorProperties(error);
        return new DataProcessingError(safeProps.message, Object.assign(Object.assign(Object.assign({}, info), safeProps), { errorType: _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType.dataProcessingError }));
    }
}
/**
 * Convert the error into one of the error types.
 * @param error - Error to be converted.
 */
function CreateContainerError(error) {
    var _a;
    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(error !== undefined, 0x0f5 /* "Missing error input" */);
    if (typeof error === "object" && error !== null) {
        const err = error;
        if (isValidLoggingError(error)) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return err;
        }
        const { message, stack, errorType = `${(_a = error.errorType) !== null && _a !== void 0 ? _a : _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType.genericError}`, } = extractLogSafeErrorProperties(error);
        return new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError(message, {
            errorType,
            stack,
        });
    }
    else if (typeof error === "string") {
        return new GenericError(error, new Error(error));
    }
    else {
        return new GenericError(messageFromError(error), error);
    }
}
//# sourceMappingURL=error.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/core-interfaces/lib/fluidPackage.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/core-interfaces/lib/fluidPackage.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isFluidCodeDetails": () => (/* binding */ isFluidCodeDetails)
/* harmony export */ });
/* unused harmony exports isFluidPackage, IFluidCodeDetailsComparer */
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Check if the package.json defines a Fluid package
 * @param pkg - the package json data to check if it is a Fluid package.
 */
const isFluidPackage = (pkg) => typeof pkg === "object"
    && typeof (pkg === null || pkg === void 0 ? void 0 : pkg.name) === "string"
    && typeof (pkg === null || pkg === void 0 ? void 0 : pkg.fluid) === "object";
const isFluidCodeDetails = (details) => {
    const maybeCodeDetails = details;
    return typeof maybeCodeDetails === "object"
        && (typeof (maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.package) === "string" || isFluidPackage(maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.package))
        && ((maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.config) === undefined || typeof (maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.config) === "object");
};
const IFluidCodeDetailsComparer = "IFluidCodeDetailsComparer";
//# sourceMappingURL=fluidPackage.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/datastore/lib/channelContext.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@fluidframework/datastore/lib/channelContext.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "attributesBlobKey": () => (/* binding */ attributesBlobKey),
/* harmony export */   "createServiceEndpoints": () => (/* binding */ createServiceEndpoints),
/* harmony export */   "summarizeChannel": () => (/* binding */ summarizeChannel)
/* harmony export */ });
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/summaryUtils.js");
/* harmony import */ var _channelDeltaConnection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./channelDeltaConnection */ "../../node_modules/@fluidframework/datastore/lib/channelDeltaConnection.js");
/* harmony import */ var _channelStorageService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./channelStorageService */ "../../node_modules/@fluidframework/datastore/lib/channelStorageService.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */



const attributesBlobKey = ".attributes";
function createServiceEndpoints(id, connected, submitFn, dirtyFn, storageService, tree, extraBlobs) {
    const deltaConnection = new _channelDeltaConnection__WEBPACK_IMPORTED_MODULE_0__.ChannelDeltaConnection(id, connected, (message, localOpMetadata) => submitFn(message, localOpMetadata), dirtyFn);
    const objectStorage = new _channelStorageService__WEBPACK_IMPORTED_MODULE_1__.ChannelStorageService(tree, storageService, extraBlobs);
    return {
        deltaConnection,
        objectStorage,
    };
}
function summarizeChannel(channel, fullTree = false, trackState = false) {
    const summarizeResult = channel.summarize(fullTree, trackState);
    // Add the channel attributes to the returned result.
    (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.addBlobToSummary)(summarizeResult, attributesBlobKey, JSON.stringify(channel.attributes));
    return summarizeResult;
}
//# sourceMappingURL=channelContext.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/datastore/lib/channelDeltaConnection.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/datastore/lib/channelDeltaConnection.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChannelDeltaConnection": () => (/* binding */ ChannelDeltaConnection)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/container-utils */ "../../node_modules/@fluidframework/container-utils/lib/error.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


class ChannelDeltaConnection {
    constructor(objectId, _connected, submitFn, dirtyFn) {
        this.objectId = objectId;
        this._connected = _connected;
        this.submitFn = submitFn;
        this.dirtyFn = dirtyFn;
    }
    get handler() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!this._handler, 0x177 /* "Missing delta handler" */);
        return this._handler;
    }
    get connected() {
        return this._connected;
    }
    attach(handler) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this._handler === undefined, 0x178 /* "Missing delta handler on attach" */);
        this._handler = handler;
    }
    setConnectionState(connected) {
        this._connected = connected;
        this.handler.setConnectionState(connected);
    }
    process(message, local, localOpMetadata) {
        try {
            // catches as data processing error whether or not they come from async pending queues
            this.handler.process(message, local, localOpMetadata);
        }
        catch (error) {
            // eslint-disable-next-line @typescript-eslint/no-throw-literal
            throw (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.CreateProcessingError)(error, message);
        }
    }
    reSubmit(content, localOpMetadata) {
        this.handler.reSubmit(content, localOpMetadata);
    }
    applyStashedOp(message) {
        return this.handler.applyStashedOp(message);
    }
    /**
     * Send new messages to the server
     */
    submit(message, localOpMetadata) {
        this.submitFn(message, localOpMetadata);
    }
    /**
     * Indicates that the channel is dirty and needs to be part of the summary. It is called by a SharedSummaryBlock
     * that needs to be part of the summary but does not generate ops.
     */
    dirty() {
        this.dirtyFn();
    }
}
//# sourceMappingURL=channelDeltaConnection.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/datastore/lib/channelStorageService.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/datastore/lib/channelStorageService.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChannelStorageService": () => (/* binding */ ChannelStorageService)
/* harmony export */ });
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/objectstorageutils.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

class ChannelStorageService {
    constructor(tree, storage, extraBlobs) {
        this.tree = tree;
        this.storage = storage;
        this.extraBlobs = extraBlobs;
        this.flattenedTree = {};
        // Create a map from paths to blobs
        if (tree !== undefined) {
            ChannelStorageService.flattenTree("", tree, this.flattenedTree);
        }
    }
    static flattenTree(base, tree, results) {
        // eslint-disable-next-line guard-for-in, no-restricted-syntax
        for (const path in tree.trees) {
            ChannelStorageService.flattenTree(`${base}${path}/`, tree.trees[path], results);
        }
        // eslint-disable-next-line guard-for-in, no-restricted-syntax
        for (const blob in tree.blobs) {
            results[`${base}${blob}`] = tree.blobs[blob];
        }
    }
    async contains(path) {
        return this.flattenedTree[path] !== undefined;
    }
    async readBlob(path) {
        const id = await this.getIdForPath(path);
        const blob = this.extraBlobs !== undefined
            ? this.extraBlobs.get(id)
            : undefined;
        if (blob !== undefined) {
            return blob;
        }
        return this.storage.readBlob(id);
    }
    async list(path) {
        var _a;
        let tree = this.tree;
        const pathParts = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.getNormalizedObjectStoragePathParts)(path);
        while (tree !== undefined && pathParts.length > 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const part = pathParts.shift();
            tree = tree.trees[part];
        }
        if (tree === undefined || pathParts.length !== 0) {
            throw new Error("path does not exist");
        }
        return Object.keys((_a = tree === null || tree === void 0 ? void 0 : tree.blobs) !== null && _a !== void 0 ? _a : {});
    }
    async getIdForPath(path) {
        return this.flattenedTree[path];
    }
}
//# sourceMappingURL=channelStorageService.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/datastore/lib/dataStoreRuntime.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@fluidframework/datastore/lib/dataStoreRuntime.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FluidDataStoreRuntime": () => (/* binding */ FluidDataStoreRuntime),
/* harmony export */   "mixinRequestHandler": () => (/* binding */ mixinRequestHandler)
/* harmony export */ });
/* unused harmony exports DataStoreMessageType, mixinSummaryHandler */
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/container-definitions */ "../../node_modules/@fluidframework/container-definitions/lib/runtime.js");
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @fluidframework/container-utils */ "../../node_modules/@fluidframework/container-utils/lib/error.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/typedEventEmitter.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/promises.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/unreachable.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/events.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/readAndParse.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/buildSnapshotTree.js");
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @fluidframework/runtime-definitions */ "../../node_modules/@fluidframework/runtime-definitions/dist/index.js");
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/serializer.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHandleContextUtils.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/requestParser.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHelpers.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/summaryUtils.js");
/* harmony import */ var _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @fluidframework/garbage-collector */ "../../node_modules/@fluidframework/garbage-collector/lib/utils.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _channelContext__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./channelContext */ "../../node_modules/@fluidframework/datastore/lib/channelContext.js");
/* harmony import */ var _localChannelContext__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./localChannelContext */ "../../node_modules/@fluidframework/datastore/lib/localChannelContext.js");
/* harmony import */ var _remoteChannelContext__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./remoteChannelContext */ "../../node_modules/@fluidframework/datastore/lib/remoteChannelContext.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */












var DataStoreMessageType;
(function (DataStoreMessageType) {
    // Creates a new channel
    DataStoreMessageType["Attach"] = "attach";
    DataStoreMessageType["ChannelOp"] = "op";
})(DataStoreMessageType || (DataStoreMessageType = {}));
/**
 * Base data store class
 */
class FluidDataStoreRuntime extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {
    constructor(dataStoreContext, sharedObjectRegistry) {
        super();
        this.dataStoreContext = dataStoreContext;
        this.sharedObjectRegistry = sharedObjectRegistry;
        this.serializer = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__.FluidSerializer(this.IFluidHandleContext);
        this._disposed = false;
        this.contexts = new Map();
        this.contextsDeferred = new Map();
        this.pendingAttach = new Map();
        // This is used to break the recursion while attaching the graph. Also tells the attach state of the graph.
        this.graphAttachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.AttachState.Detached;
        this.deferredAttached = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Deferred();
        this.localChannelContextQueue = new Map();
        this.notBoundedChannelContextSet = new Set();
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__.ChildLogger.create(dataStoreContext.containerRuntime.logger, undefined, { all: { dataStoreId: (0,uuid__WEBPACK_IMPORTED_MODULE_5__.default)() } });
        this.documentId = dataStoreContext.documentId;
        this.id = dataStoreContext.id;
        this.existing = dataStoreContext.existing;
        this.options = dataStoreContext.options;
        this.deltaManager = dataStoreContext.deltaManager;
        this.quorum = dataStoreContext.getQuorum();
        this.audience = dataStoreContext.getAudience();
        const tree = dataStoreContext.baseSnapshot;
        this.initialChannelUsedRoutesP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.LazyPromise(async () => {
            var _a, _b;
            // back-compat: 0.35.0. getInitialGCSummaryDetails is added to IFluidDataStoreContext in 0.35.0. Remove
            // undefined check when N > 0.36.0.
            const gcDetailsInInitialSummary = await ((_b = (_a = this.dataStoreContext).getInitialGCSummaryDetails) === null || _b === void 0 ? void 0 : _b.call(_a));
            if ((gcDetailsInInitialSummary === null || gcDetailsInInitialSummary === void 0 ? void 0 : gcDetailsInInitialSummary.usedRoutes) !== undefined) {
                // Remove the route to this data store, if it exists.
                const usedRoutes = gcDetailsInInitialSummary.usedRoutes.filter((id) => { return id !== "/" && id !== ""; });
                return (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_6__.getChildNodesUsedRoutes)(usedRoutes);
            }
            return new Map();
        });
        this.initialChannelGCDataP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.LazyPromise(async () => {
            var _a, _b;
            // back-compat: 0.35.0. getInitialGCSummaryDetails is added to IFluidDataStoreContext in 0.35.0. Remove
            // undefined check when N > 0.36.0.
            const gcDetailsInInitialSummary = await ((_b = (_a = this.dataStoreContext).getInitialGCSummaryDetails) === null || _b === void 0 ? void 0 : _b.call(_a));
            if ((gcDetailsInInitialSummary === null || gcDetailsInInitialSummary === void 0 ? void 0 : gcDetailsInInitialSummary.gcData) !== undefined) {
                const gcData = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_6__.cloneGCData)(gcDetailsInInitialSummary.gcData);
                // Remove GC node for this data store, if any.
                delete gcData.gcNodes["/"];
                // Remove the back route to this data store that was added when generating each child's GC nodes.
                (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_6__.removeRouteFromAllNodes)(gcData.gcNodes, this.absolutePath);
                return (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_6__.getChildNodesGCData)(gcData);
            }
            return new Map();
        });
        // Must always receive the data store type inside of the attributes
        if ((tree === null || tree === void 0 ? void 0 : tree.trees) !== undefined) {
            Object.keys(tree.trees).forEach((path) => {
                // Issue #4414
                if (path === "_search") {
                    return;
                }
                let channelContext;
                // If already exists on storage, then create a remote channel. However, if it is case of rehydrating a
                // container from snapshot where we load detached container from a snapshot, isLocalDataStore would be
                // true. In this case create a LocalChannelContext.
                if (dataStoreContext.isLocalDataStore) {
                    const channelAttributes = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_7__.readAndParseFromBlobs)(tree.trees[path].blobs, tree.trees[path].blobs[".attributes"]);
                    channelContext = new _localChannelContext__WEBPACK_IMPORTED_MODULE_8__.LocalChannelContext(path, this.sharedObjectRegistry, channelAttributes.type, this, this.dataStoreContext, this.dataStoreContext.storage, (content, localOpMetadata) => this.submitChannelOp(path, content, localOpMetadata), (address) => this.setChannelDirty(address), tree.trees[path]);
                    // This is the case of rehydrating a detached container from snapshot. Now due to delay loading of
                    // data store, if the data store is loaded after the container is attached, then we missed marking
                    // the channel as attached. So mark it now. Otherwise add it to local channel context queue, so
                    // that it can be mark attached later with the data store.
                    if (dataStoreContext.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.AttachState.Detached) {
                        channelContext.markAttached();
                    }
                    else {
                        this.localChannelContextQueue.set(path, channelContext);
                    }
                }
                else {
                    channelContext = new _remoteChannelContext__WEBPACK_IMPORTED_MODULE_9__.RemoteChannelContext(this, dataStoreContext, dataStoreContext.storage, (content, localOpMetadata) => this.submitChannelOp(path, content, localOpMetadata), (address) => this.setChannelDirty(address), path, tree.trees[path], this.sharedObjectRegistry, undefined /* extraBlobs */, this.dataStoreContext.getCreateChildSummarizerNodeFn(path, { type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.CreateSummarizerNodeSource.FromSummary }), async () => this.getChannelInitialGCDetails(path));
                }
                const deferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Deferred();
                deferred.resolve(channelContext);
                this.contexts.set(path, channelContext);
                this.contextsDeferred.set(path, deferred);
            });
        }
        this.attachListener();
        // If exists on storage or loaded from a snapshot, it should already be binded.
        this.bindState = this.existing ? _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.BindState.Bound : _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.BindState.NotBound;
        this._attachState = dataStoreContext.attachState;
        // If it's existing we know it has been attached.
        if (this.existing) {
            this.deferredAttached.resolve();
        }
    }
    /**
     * Loads the data store runtime
     * @param context - The data store context
     * @param sharedObjectRegistry - The registry of shared objects used by this data store
     * @param activeCallback - The callback called when the data store runtime in active
     * @param dataStoreRegistry - The registry of data store created and used by this data store
     */
    static load(context, sharedObjectRegistry) {
        return new FluidDataStoreRuntime(context, sharedObjectRegistry);
    }
    get IFluidRouter() { return this; }
    get connected() {
        return this.dataStoreContext.connected;
    }
    get leader() {
        return this.dataStoreContext.leader;
    }
    get clientId() {
        return this.dataStoreContext.clientId;
    }
    get clientDetails() {
        return this.dataStoreContext.containerRuntime.clientDetails;
    }
    get loader() {
        return this.dataStoreContext.loader;
    }
    get isAttached() {
        return this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.AttachState.Detached;
    }
    get attachState() {
        return this._attachState;
    }
    get absolutePath() {
        return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__.generateHandleContextPath)(this.id, this.routeContext);
    }
    get routeContext() {
        return this.dataStoreContext.containerRuntime.IFluidHandleContext;
    }
    get IFluidSerializer() { return this.serializer; }
    get IFluidHandleContext() { return this; }
    get rootRoutingContext() { return this; }
    get channelsRoutingContext() { return this; }
    get objectsRoutingContext() { return this; }
    get disposed() { return this._disposed; }
    dispose() {
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        this.emit("dispose");
        this.removeAllListeners();
    }
    async resolveHandle(request) {
        return this.request(request);
    }
    async request(request) {
        try {
            const parser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_12__.RequestParser.create(request);
            const id = parser.pathParts[0];
            if (id === "_channels" || id === "_custom") {
                return this.request(parser.createSubRequest(1));
            }
            // Check for a data type reference first
            if (this.contextsDeferred.has(id) && parser.isLeaf(1)) {
                try {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const value = await this.contextsDeferred.get(id).promise;
                    const channel = await value.getChannel();
                    return { mimeType: "fluid/object", status: 200, value: channel };
                }
                catch (error) {
                    this.logger.sendErrorEvent({ eventName: "GetChannelFailedInRequest" }, error);
                    return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_13__.createResponseError)(500, `Failed to get Channel: ${error}`, request);
                }
            }
            // Otherwise defer to an attached request handler
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_13__.create404Response)(request);
        }
        catch (error) {
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_13__.exceptionToResponse)(error);
        }
    }
    async getChannel(id) {
        this.verifyNotClosed();
        // TODO we don't assume any channels (even root) in the runtime. If you request a channel that doesn't exist
        // we will never resolve the promise. May want a flag to getChannel that doesn't wait for the promise if
        // it doesn't exist
        if (!this.contextsDeferred.has(id)) {
            this.contextsDeferred.set(id, new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Deferred());
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const context = await this.contextsDeferred.get(id).promise;
        const channel = await context.getChannel();
        return channel;
    }
    createChannel(id = (0,uuid__WEBPACK_IMPORTED_MODULE_5__.default)(), type) {
        this.verifyNotClosed();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__.assert)(!this.contexts.has(id), 0x179 /* "createChannel() with existing ID" */);
        this.notBoundedChannelContextSet.add(id);
        const context = new _localChannelContext__WEBPACK_IMPORTED_MODULE_8__.LocalChannelContext(id, this.sharedObjectRegistry, type, this, this.dataStoreContext, this.dataStoreContext.storage, (content, localOpMetadata) => this.submitChannelOp(id, content, localOpMetadata), (address) => this.setChannelDirty(address), undefined);
        this.contexts.set(id, context);
        if (this.contextsDeferred.has(id)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.contextsDeferred.get(id).resolve(context);
        }
        else {
            const deferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Deferred();
            deferred.resolve(context);
            this.contextsDeferred.set(id, deferred);
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__.assert)(!!context.channel, 0x17a /* "Channel should be loaded when created!!" */);
        return context.channel;
    }
    /**
     * Binds a channel with the runtime. If the runtime is attached we will attach the channel right away.
     * If the runtime is not attached we will defer the attach until the runtime attaches.
     * @param channel - channel to be registered.
     */
    bindChannel(channel) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__.assert)(this.notBoundedChannelContextSet.has(channel.id), 0x17b /* "Channel to be binded should be in not bounded set" */);
        this.notBoundedChannelContextSet.delete(channel.id);
        // If our data store is attached, then attach the channel.
        if (this.isAttached) {
            this.attachChannel(channel);
            return;
        }
        else {
            this.bind(channel.handle);
            // If our data store is local then add the channel to the queue
            if (!this.localChannelContextQueue.has(channel.id)) {
                this.localChannelContextQueue.set(channel.id, this.contexts.get(channel.id));
            }
        }
    }
    attachGraph() {
        if (this.graphAttachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.AttachState.Detached) {
            return;
        }
        this.graphAttachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.AttachState.Attaching;
        if (this.boundhandles !== undefined) {
            this.boundhandles.forEach((handle) => {
                handle.attachGraph();
            });
            this.boundhandles = undefined;
        }
        // Flush the queue to set any pre-existing channels to local
        this.localChannelContextQueue.forEach((channel) => {
            // When we are attaching the data store we don't need to send attach for the registered services.
            // This is because they will be captured as part of the Attach data store snapshot
            channel.markAttached();
        });
        this.localChannelContextQueue.clear();
        this.bindToContext();
        this.graphAttachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.AttachState.Attached;
    }
    /**
     * Binds this runtime to the container
     * This includes the following:
     * 1. Sending an Attach op that includes all existing state
     * 2. Attaching the graph if the data store becomes attached.
     */
    bindToContext() {
        if (this.bindState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.BindState.NotBound) {
            return;
        }
        this.bindState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.BindState.Binding;
        this.dataStoreContext.bindToContext();
        this.bindState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.BindState.Bound;
    }
    bind(handle) {
        // If the data store is already attached or its graph is already in attaching or attached state,
        // then attach the incoming handle too.
        if (this.isAttached || this.graphAttachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.AttachState.Detached) {
            handle.attachGraph();
            return;
        }
        if (this.boundhandles === undefined) {
            this.boundhandles = new Set();
        }
        this.boundhandles.add(handle);
    }
    setConnectionState(connected, clientId) {
        this.verifyNotClosed();
        for (const [, object] of this.contexts) {
            object.setConnectionState(connected, clientId);
        }
        (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_15__.raiseConnectedEvent)(this.logger, this, connected, clientId);
    }
    getQuorum() {
        return this.quorum;
    }
    getAudience() {
        return this.audience;
    }
    async uploadBlob(blob) {
        this.verifyNotClosed();
        return this.dataStoreContext.uploadBlob(blob);
    }
    process(message, local, localOpMetadata) {
        this.verifyNotClosed();
        try {
            // catches as data processing error whether or not they come from async pending queues
            switch (message.type) {
                case DataStoreMessageType.Attach: {
                    const attachMessage = message.contents;
                    const id = attachMessage.id;
                    // If a non-local operation then go and create the object
                    // Otherwise mark it as officially attached.
                    if (local) {
                        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__.assert)(this.pendingAttach.has(id), 0x17c /* "Unexpected attach (local) channel OP" */);
                        this.pendingAttach.delete(id);
                    }
                    else {
                        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__.assert)(!this.contexts.has(id), 0x17d);
                        const flatBlobs = new Map();
                        const snapshotTree = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_16__.buildSnapshotTree)(attachMessage.snapshot.entries, flatBlobs);
                        const remoteChannelContext = new _remoteChannelContext__WEBPACK_IMPORTED_MODULE_9__.RemoteChannelContext(this, this.dataStoreContext, this.dataStoreContext.storage, (content, localContentMetadata) => this.submitChannelOp(id, content, localContentMetadata), (address) => this.setChannelDirty(address), id, snapshotTree, this.sharedObjectRegistry, flatBlobs, this.dataStoreContext.getCreateChildSummarizerNodeFn(id, {
                            type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.CreateSummarizerNodeSource.FromAttach,
                            sequenceNumber: message.sequenceNumber,
                            snapshot: attachMessage.snapshot,
                        }), async () => this.getChannelInitialGCDetails(id), attachMessage.type);
                        this.contexts.set(id, remoteChannelContext);
                        if (this.contextsDeferred.has(id)) {
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            this.contextsDeferred.get(id).resolve(remoteChannelContext);
                        }
                        else {
                            const deferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Deferred();
                            deferred.resolve(remoteChannelContext);
                            this.contextsDeferred.set(id, deferred);
                        }
                    }
                    break;
                }
                case DataStoreMessageType.ChannelOp:
                    this.processChannelOp(message, local, localOpMetadata);
                    break;
                default:
            }
            this.emit("op", message);
        }
        catch (error) {
            // eslint-disable-next-line @typescript-eslint/no-throw-literal
            throw (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_17__.CreateProcessingError)(error, message);
        }
    }
    processSignal(message, local) {
        this.emit("signal", message, local);
    }
    isChannelAttached(id) {
        return (
        // Added in createChannel
        // Removed when bindChannel is called
        !this.notBoundedChannelContextSet.has(id)
            // Added in bindChannel only if this is not attached yet
            // Removed when this is attached by calling attachGraph
            && !this.localChannelContextQueue.has(id)
            // Added in attachChannel called by bindChannel
            // Removed when attach op is broadcast
            && !this.pendingAttach.has(id));
    }
    /**
     * Returns the outbound routes of this channel. Currently, all contexts in this channel are considered
     * referenced and are hence outbound. This will change when we have root and non-root channel contexts.
     * The only root contexts will be considered as referenced.
     */
    getOutboundRoutes() {
        const outboundRoutes = [];
        for (const [contextId] of this.contexts) {
            outboundRoutes.push(`${this.absolutePath}/${contextId}`);
        }
        return outboundRoutes;
    }
    /**
     * Updates the GC nodes of this channel. It does the following:
     * - Adds a back route to self to all its child GC nodes.
     * - Adds a node for this channel.
     * @param builder - The builder that contains the GC nodes for this channel's children.
     */
    updateGCNodes(builder) {
        // Add a back route to self in each child's GC nodes. If any child is referenced, then its parent should
        // be considered referenced as well.
        builder.addRouteToAllNodes(this.absolutePath);
        // Get the outbound routes and add a GC node for this channel.
        builder.addNode("/", this.getOutboundRoutes());
    }
    /**
     * Generates data used for garbage collection. This includes a list of GC nodes that represent this channel
     * including any of its child channel contexts. Each node has a set of outbound routes to other GC nodes in the
     * document. It does the following:
     * 1. Calls into each child context to get its GC data.
     * 2. Prefixs the child context's id to the GC nodes in the child's GC data. This makes sure that the node can be
     *    idenfied as belonging to the child.
     * 3. Adds a GC node for this channel to the nodes received from the children. All these nodes together represent
     *    the GC data of this channel.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        const builder = new _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_6__.GCDataBuilder();
        // Iterate over each channel context and get their GC data.
        await Promise.all(Array.from(this.contexts)
            .filter(([contextId, _]) => {
            // Get GC data only for attached contexts. Detached contexts are not connected in the GC reference
            // graph so any references they might have won't be connected as well.
            return this.isChannelAttached(contextId);
        }).map(async ([contextId, context]) => {
            const contextGCData = await context.getGCData(fullGC);
            // Prefix the child's id to the ids of its GC nodes so they can be identified as belonging to the child.
            // This also gradually builds the id of each node to be a path from the root.
            builder.prefixAndAddNodes(contextId, contextGCData.gcNodes);
        }));
        this.updateGCNodes(builder);
        return builder.getGCData();
    }
    /**
     * After GC has run, called to notify this channel of routes that are used in it. It calls the child contexts to
     * update their used routes.
     * @param usedRoutes - The routes that are used in all contexts in this channel.
     */
    updateUsedRoutes(usedRoutes) {
        var _a;
        // Get a map of channel ids to routes used in it.
        const usedContextRoutes = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_6__.getChildNodesUsedRoutes)(usedRoutes);
        // Verify that the used routes are correct.
        for (const [id] of usedContextRoutes) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__.assert)(this.contexts.has(id), 0x17e /* "Used route does not belong to any known context" */);
        }
        // Update the used routes in each context. Used routes is empty for unused context.
        for (const [contextId, context] of this.contexts) {
            context.updateUsedRoutes((_a = usedContextRoutes.get(contextId)) !== null && _a !== void 0 ? _a : []);
        }
    }
    /**
     * Returns the GC details in initial summary for the channel with the given id. The initial summary of the data
     * store contains the GC details of all the child channel contexts that were created before the summary was taken.
     * We find the GC details belonging to the given channel context and return it.
     * @param channelId - The id of the channel context that is asked for the initial GC details.
     * @returns the requested channel's GC details in the initial summary.
     */
    async getChannelInitialGCDetails(channelId) {
        const channelInitialUsedRoutes = await this.initialChannelUsedRoutesP;
        const channelInitialGCData = await this.initialChannelGCDataP;
        let channelUsedRoutes = channelInitialUsedRoutes.get(channelId);
        // Currently, channel context's are always considered used. So, it there is no used route for it, we still
        // need to mark it as used. Add self-route (empty string) to the channel context's used routes.
        if (channelUsedRoutes === undefined || channelUsedRoutes.length === 0) {
            channelUsedRoutes = [""];
        }
        return {
            usedRoutes: channelUsedRoutes,
            gcData: channelInitialGCData.get(channelId),
        };
    }
    /**
     * Returns a summary at the current sequence number.
     * @param fullTree - true to bypass optimizations and force a full summary tree
     * @param trackState - This tells whether we should track state from this summary.
     */
    async summarize(fullTree = false, trackState = true) {
        const gcDataBuilder = new _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_6__.GCDataBuilder();
        const summaryBuilder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_18__.SummaryTreeBuilder();
        // Iterate over each data store and ask it to summarize
        await Promise.all(Array.from(this.contexts)
            .filter(([contextId, _]) => {
            const isAttached = this.isChannelAttached(contextId);
            // We are not expecting local dds! Summary may not capture local state.
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__.assert)(isAttached, 0x17f /* "Not expecting detached channels during summarize" */);
            // If the object is registered - and we have received the sequenced op creating the object
            // (i.e. it has a base mapping) - then we go ahead and summarize
            return isAttached;
        }).map(async ([contextId, context]) => {
            // If BlobAggregationStorage is engaged, we have to write full summary for data stores
            // BlobAggregationStorage relies on this behavior, as it aggregates blobs across DDSs.
            // Not generating full summary will mean data loss, as we will overwrite aggregate blob in new summary,
            // and any virtual blobs that stayed (for unchanged DDSs) will need aggregate blob in previous summary
            // that is no longer present in this summary.
            // This is temporal limitation that can be lifted in future once BlobAggregationStorage becomes smarter.
            const contextSummary = await context.summarize(true /* fullTree */, trackState);
            summaryBuilder.addWithStats(contextId, contextSummary);
            // Prefix the child's id to the ids of its GC nodes. This gradually builds the id of each node
            // to be a path from the root.
            gcDataBuilder.prefixAndAddNodes(contextId, contextSummary.gcData.gcNodes);
        }));
        this.updateGCNodes(gcDataBuilder);
        return Object.assign(Object.assign({}, summaryBuilder.getSummaryTree()), { gcData: gcDataBuilder.getGCData() });
    }
    getAttachSummary() {
        this.attachGraph();
        const gcDataBuilder = new _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_6__.GCDataBuilder();
        const summaryBuilder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_18__.SummaryTreeBuilder();
        // Craft the .attributes file for each shared object
        for (const [contextId, context] of this.contexts) {
            if (!(context instanceof _localChannelContext__WEBPACK_IMPORTED_MODULE_8__.LocalChannelContext)) {
                throw new Error("Should only be called with local channel handles");
            }
            if (!this.notBoundedChannelContextSet.has(contextId)) {
                let summaryTree;
                if (context.isLoaded) {
                    const contextSummary = context.getAttachSummary();
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__.assert)(contextSummary.summary.type === 1 /* Tree */, 0x180 /* "getAttachSummary should always return a tree" */);
                    summaryTree = { stats: contextSummary.stats, summary: contextSummary.summary };
                    // Prefix the child's id to the ids of its GC nodest. This gradually builds the id of each node
                    // to be a path from the root.
                    gcDataBuilder.prefixAndAddNodes(contextId, contextSummary.gcData.gcNodes);
                }
                else {
                    // If this channel is not yet loaded, then there should be no changes in the snapshot from which
                    // it was created as it is detached container. So just use the previous snapshot.
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__.assert)(!!this.dataStoreContext.baseSnapshot, 0x181 /* "BaseSnapshot should be there as detached container loaded from snapshot" */);
                    summaryTree = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_18__.convertSnapshotTreeToSummaryTree)(this.dataStoreContext.baseSnapshot.trees[contextId]);
                }
                summaryBuilder.addWithStats(contextId, summaryTree);
            }
        }
        this.updateGCNodes(gcDataBuilder);
        return Object.assign(Object.assign({}, summaryBuilder.getSummaryTree()), { gcData: gcDataBuilder.getGCData() });
    }
    submitMessage(type, content, localOpMetadata) {
        this.submit(type, content, localOpMetadata);
    }
    submitSignal(type, content) {
        this.verifyNotClosed();
        return this.dataStoreContext.submitSignal(type, content);
    }
    /**
     * Will return when the data store is attached.
     */
    async waitAttached() {
        return this.deferredAttached.promise;
    }
    raiseContainerWarning(warning) {
        this.dataStoreContext.raiseContainerWarning(warning);
    }
    /**
     * Attach channel should only be called after the data store has been attached
     */
    attachChannel(channel) {
        this.verifyNotClosed();
        // If this handle is already attached no need to attach again.
        if (channel.handle.isAttached) {
            return;
        }
        channel.handle.attachGraph();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__.assert)(this.isAttached, 0x182 /* "Data store should be attached to attach the channel." */);
        // Get the object snapshot only if the data store is Bound and its graph is attached too,
        // because if the graph is attaching, then it would get included in the data store snapshot.
        if (this.bindState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.BindState.Bound && this.graphAttachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.AttachState.Attached) {
            const summarizeResult = (0,_channelContext__WEBPACK_IMPORTED_MODULE_19__.summarizeChannel)(channel, true /* fullTree */, false /* trackState */);
            // Attach message needs the summary in ITree format. Convert the ISummaryTree into an ITree.
            const snapshot = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_18__.convertSummaryTreeToITree)(summarizeResult.summary);
            const message = {
                id: channel.id,
                snapshot,
                type: channel.attributes.type,
            };
            this.pendingAttach.set(channel.id, message);
            this.submit(DataStoreMessageType.Attach, message);
        }
        const context = this.contexts.get(channel.id);
        context.markAttached();
    }
    submitChannelOp(address, contents, localOpMetadata) {
        const envelope = { address, contents };
        this.submit(DataStoreMessageType.ChannelOp, envelope, localOpMetadata);
    }
    submit(type, content, localOpMetadata = undefined) {
        this.verifyNotClosed();
        this.dataStoreContext.submitMessage(type, content, localOpMetadata);
    }
    /**
     * For messages of type MessageType.Operation, finds the right channel and asks it to resubmit the message.
     * For all other messages, just submit it again.
     * This typically happens when we reconnect and there are unacked messages.
     * @param content - The content of the original message.
     * @param localOpMetadata - The local metadata associated with the original message.
     */
    reSubmit(type, content, localOpMetadata) {
        this.verifyNotClosed();
        switch (type) {
            case DataStoreMessageType.ChannelOp:
                {
                    // For Operations, find the right channel and trigger resubmission on it.
                    const envelope = content;
                    const channelContext = this.contexts.get(envelope.address);
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__.assert)(!!channelContext, 0x183 /* "There should be a channel context for the op" */);
                    channelContext.reSubmit(envelope.contents, localOpMetadata);
                    break;
                }
            case DataStoreMessageType.Attach:
                // For Attach messages, just submit them again.
                this.submit(type, content, localOpMetadata);
                break;
            default:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_20__.unreachableCase)(type);
        }
    }
    async applyStashedOp(content) {
        const envelope = content;
        const channelContext = this.contexts.get(envelope.address);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__.assert)(!!channelContext, 0x184 /* "There should be a channel context for the op" */);
        await channelContext.getChannel();
        return channelContext.applyStashedOp(envelope.contents);
    }
    setChannelDirty(address) {
        this.verifyNotClosed();
        this.dataStoreContext.setChannelDirty(address);
    }
    processChannelOp(message, local, localOpMetadata) {
        this.verifyNotClosed();
        const envelope = message.contents;
        const transformed = Object.assign(Object.assign({}, message), { contents: envelope.contents });
        const channelContext = this.contexts.get(envelope.address);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__.assert)(!!channelContext, 0x185 /* "Channel not found" */);
        channelContext.processOp(transformed, local, localOpMetadata);
        return channelContext;
    }
    attachListener() {
        this.setMaxListeners(Number.MAX_SAFE_INTEGER);
        this.dataStoreContext.on("leader", () => {
            this.emit("leader");
        });
        this.dataStoreContext.on("notleader", () => {
            this.emit("notleader");
        });
        this.dataStoreContext.once("attaching", () => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__.assert)(this.bindState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.BindState.NotBound, 0x186 /* "Data store attaching should not occur if it is not bound" */);
            this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.AttachState.Attaching;
            // This promise resolution will be moved to attached event once we fix the scheduler.
            this.deferredAttached.resolve();
            this.emit("attaching");
        });
        this.dataStoreContext.once("attached", () => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__.assert)(this.bindState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.BindState.Bound, 0x187 /* "Data store should only be attached after it is bound" */);
            this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_2__.AttachState.Attached;
            this.emit("attached");
        });
    }
    verifyNotClosed() {
        if (this._disposed) {
            throw new Error("Runtime is closed");
        }
    }
}
/**
 * Mixin class that adds request handler to FluidDataStoreRuntime
 * Request handler is only called when data store can't resolve request, i.e. for custom requests.
 * @param Base - base class, inherits from FluidDataStoreRuntime
 * @param requestHandler - request handler to mix in
 */
const mixinRequestHandler = (requestHandler, Base = FluidDataStoreRuntime) => class RuntimeWithRequestHandler extends Base {
    async request(request) {
        const response = await super.request(request);
        if (response.status === 404) {
            return requestHandler(request, this);
        }
        return response;
    }
};
/**
 * Mixin class that adds await for DataObject to finish initialization before we proceed to summary.
 * @param Base - base class, inherits from FluidDataStoreRuntime
 */
const mixinSummaryHandler = (handler, Base = FluidDataStoreRuntime) => class RuntimeWithSummarizerHandler extends Base {
    addBlob(summary, path, content) {
        const firstName = path.shift();
        if (firstName === undefined) {
            throw new Error("Path can't be empty");
        }
        let blob = {
            type: 2 /* Blob */,
            content,
        };
        summary.stats.blobNodeCount++;
        summary.stats.totalBlobSize += content.length;
        for (const name of path.reverse()) {
            blob = {
                type: 1 /* Tree */,
                tree: { [name]: blob },
            };
            summary.stats.treeNodeCount++;
        }
        summary.summary.tree[firstName] = blob;
    }
    async summarize(...args) {
        const summary = await super.summarize(...args);
        const content = await handler(this);
        this.addBlob(summary, content.path, content.content);
        return summary;
    }
};
//# sourceMappingURL=dataStoreRuntime.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/datastore/lib/debug.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@fluidframework/datastore/lib/debug.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debug": () => (/* binding */ debug)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "../../node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packageVersion */ "../../node_modules/@fluidframework/datastore/lib/packageVersion.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


const debug = debug__WEBPACK_IMPORTED_MODULE_0___default()("fluid:process-loader");
debug(`Package: ${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgName} - Version: ${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgVersion}`);
//# sourceMappingURL=debug.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/datastore/lib/fluidHandle.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@fluidframework/datastore/lib/fluidHandle.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FluidObjectHandle": () => (/* binding */ FluidObjectHandle)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/container-definitions */ "../../node_modules/@fluidframework/container-definitions/lib/runtime.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHandleContextUtils.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


class FluidObjectHandle {
    /**
     * Creates a new FluidObjectHandle.
     * @param value - The IFluidObject object this handle is for.
     * @param path - The path to this handle relative to the routeContext.
     * @param routeContext - The parent IFluidHandleContext that has a route to this handle.
     */
    constructor(value, path, routeContext) {
        this.value = value;
        this.path = path;
        this.routeContext = routeContext;
        // This is used to break the recursion while attaching the graph. Also tells the attach state of the graph.
        this.graphAttachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.AttachState.Detached;
        this.absolutePath = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__.generateHandleContextPath)(path, this.routeContext);
    }
    get IFluidHandle() { return this; }
    get isAttached() {
        return this.routeContext.isAttached;
    }
    async get() {
        return this.value;
    }
    attachGraph() {
        // If this handle is already in attaching state in the graph or attached, no need to attach again.
        if (this.graphAttachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.AttachState.Detached) {
            return;
        }
        this.graphAttachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.AttachState.Attaching;
        if (this.bound !== undefined) {
            for (const handle of this.bound) {
                handle.attachGraph();
            }
            this.bound = undefined;
        }
        this.routeContext.attachGraph();
        this.graphAttachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.AttachState.Attached;
    }
    bind(handle) {
        // If the dds is already attached or its graph is already in attaching or attached state,
        // then attach the incoming handle too.
        if (this.isAttached || this.graphAttachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.AttachState.Detached) {
            handle.attachGraph();
            return;
        }
        if (this.bound === undefined) {
            this.bound = new Set();
        }
        this.bound.add(handle);
    }
}
//# sourceMappingURL=fluidHandle.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/datastore/lib/localChannelContext.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/datastore/lib/localChannelContext.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LocalChannelContext": () => (/* binding */ LocalChannelContext)
/* harmony export */ });
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/cloneDeep */ "../../node_modules/lodash/cloneDeep.js");
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/readAndParse.js");
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/container-utils */ "../../node_modules/@fluidframework/container-utils/lib/error.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/lazy.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/bufferBrowser.js");
/* harmony import */ var _channelContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./channelContext */ "../../node_modules/@fluidframework/datastore/lib/channelContext.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
// eslint-disable-next-line import/no-internal-modules





/**
 * Channel context for a locally created channel
 */
class LocalChannelContext {
    constructor(id, registry, type, runtime, dataStoreContext, storageService, submitFn, dirtyFn, snapshotTree) {
        this.id = id;
        this.runtime = runtime;
        this.dataStoreContext = dataStoreContext;
        this.storageService = storageService;
        this.submitFn = submitFn;
        this.snapshotTree = snapshotTree;
        this.attached = false;
        this.pending = [];
        let blobMap;
        const clonedSnapshotTree = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default()(this.snapshotTree);
        if (clonedSnapshotTree !== undefined) {
            blobMap = new Map();
            this.collectExtraBlobsAndSanitizeSnapshot(clonedSnapshotTree, blobMap);
        }
        this.services = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Lazy(() => {
            return (0,_channelContext__WEBPACK_IMPORTED_MODULE_2__.createServiceEndpoints)(this.id, this.dataStoreContext.connected, this.submitFn, this.dirtyFn, this.storageService, clonedSnapshotTree, blobMap);
        });
        this.factory = registry.get(type);
        if (this.factory === undefined) {
            throw new Error(`Channel Factory ${type} not registered`);
        }
        if (snapshotTree === undefined) {
            this.channel = this.factory.create(runtime, id);
        }
        this.dirtyFn = () => { dirtyFn(id); };
    }
    async getChannel() {
        if (this.channel === undefined) {
            this.channel = await this.loadChannel();
        }
        return this.channel;
    }
    get isLoaded() {
        return this.channel !== undefined;
    }
    setConnectionState(connected, clientId) {
        // Connection events are ignored if the data store is not yet attached or loaded
        if (this.attached && this.isLoaded) {
            this.services.value.deltaConnection.setConnectionState(connected);
        }
    }
    processOp(message, local, localOpMetadata) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.attached, 0x188 /* "Local channel must be attached when processing op" */);
        // A local channel may not be loaded in case where we rehydrate the container from a snapshot because of
        // delay loading. So after the container is attached and some other client joins which start generating
        // ops for this channel. So not loaded local channel can still receive ops and we store them to process later.
        if (this.isLoaded) {
            this.services.value.deltaConnection.process(message, local, localOpMetadata);
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(local === false, 0x189 /* "Should always be remote because a local dds shouldn't generate ops before loading" */);
            this.pending.push(message);
        }
    }
    reSubmit(content, localOpMetadata) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.isLoaded, 0x18a /* "Channel should be loaded to resubmit ops" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.attached, 0x18b /* "Local channel must be attached when resubmitting op" */);
        this.services.value.deltaConnection.reSubmit(content, localOpMetadata);
    }
    applyStashedOp() {
        throw new Error("no stashed ops on local channel");
    }
    /**
     * Returns a summary at the current sequence number.
     * @param fullTree - true to bypass optimizations and force a full summary tree
     * @param trackState - This tells whether we should track state from this summary.
     */
    async summarize(fullTree = false, trackState = false) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.isLoaded && this.channel !== undefined, 0x18c /* "Channel should be loaded to summarize" */);
        return (0,_channelContext__WEBPACK_IMPORTED_MODULE_2__.summarizeChannel)(this.channel, fullTree, trackState);
    }
    getAttachSummary() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.isLoaded && this.channel !== undefined, 0x18d /* "Channel should be loaded to take snapshot" */);
        return (0,_channelContext__WEBPACK_IMPORTED_MODULE_2__.summarizeChannel)(this.channel, true /* fullTree */, false /* trackState */);
    }
    async loadChannel() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.isLoaded, 0x18e /* "Channel must not already be loaded when loading" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.snapshotTree, 0x18f /* "Snapshot should be provided to load from!!" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(await this.services.value.objectStorage.contains(".attributes"), 0x190 /* ".attributes blob should be present" */);
        const attributes = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.readAndParse)(this.services.value.objectStorage, ".attributes");
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.factory, 0x191 /* "Factory should be there for local channel" */);
        // Services will be assigned during this load.
        const channel = await this.factory.load(this.runtime, this.id, this.services.value, attributes);
        // Commit changes.
        this.channel = channel;
        // Send all pending messages to the channel
        for (const message of this.pending) {
            try {
                this.services.value.deltaConnection.process(message, false, undefined /* localOpMetadata */);
            }
            catch (err) {
                // record sequence number for easier debugging
                const error = (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_5__.CreateContainerError)(err);
                error.sequenceNumber = message.sequenceNumber;
                // eslint-disable-next-line @typescript-eslint/no-throw-literal
                throw error;
            }
        }
        return this.channel;
    }
    markAttached() {
        if (this.attached) {
            throw new Error("Channel is already attached");
        }
        if (this.isLoaded) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.channel, 0x192 /* "Channel should be there if loaded!!" */);
            this.channel.connect(this.services.value);
        }
        this.attached = true;
    }
    collectExtraBlobsAndSanitizeSnapshot(snapshotTree, blobMap) {
        const blobMapInitial = new Map(Object.entries(snapshotTree.blobs));
        for (const [blobName, blobId] of blobMapInitial.entries()) {
            const blobValue = blobMapInitial.get(blobId);
            if (blobValue !== undefined) {
                blobMap.set(blobId, (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.stringToBuffer)(blobValue, "base64"));
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete snapshotTree.blobs[blobName];
            }
        }
        for (const value of Object.values(snapshotTree.trees)) {
            this.collectExtraBlobsAndSanitizeSnapshot(value, blobMap);
        }
    }
    /**
     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this context.
     * Each node has a set of outbound routes to other GC nodes in the document. This should be called only after
     * the context has loaded.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.isLoaded && this.channel !== undefined, 0x193 /* "Channel should be loaded to run GC" */);
        return this.channel.getGCData(fullGC);
    }
    updateUsedRoutes(usedRoutes) {
        /**
         * Currently, DDSs are always considered referenced and are not garbage collected.
         * Once we have GC at DDS level, this channel context's used routes will be updated as per the passed
         * value. See - https://github.com/microsoft/FluidFramework/issues/4611
         */
    }
}
//# sourceMappingURL=localChannelContext.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/datastore/lib/packageVersion.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@fluidframework/datastore/lib/packageVersion.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pkgName": () => (/* binding */ pkgName),
/* harmony export */   "pkgVersion": () => (/* binding */ pkgVersion)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
const pkgName = "@fluidframework/datastore";
const pkgVersion = "0.37.4";
//# sourceMappingURL=packageVersion.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/datastore/lib/remoteChannelContext.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/datastore/lib/remoteChannelContext.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RemoteChannelContext": () => (/* binding */ RemoteChannelContext)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/container-utils */ "../../node_modules/@fluidframework/container-utils/lib/error.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/readAndParse.js");
/* harmony import */ var _channelContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./channelContext */ "../../node_modules/@fluidframework/datastore/lib/channelContext.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./debug */ "../../node_modules/@fluidframework/datastore/lib/debug.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */





class RemoteChannelContext {
    constructor(runtime, dataStoreContext, storageService, submitFn, dirtyFn, id, baseSnapshot, registry, extraBlobs, createSummarizerNode, gcDetailsInInitialSummary, attachMessageType) {
        this.runtime = runtime;
        this.dataStoreContext = dataStoreContext;
        this.id = id;
        this.registry = registry;
        this.attachMessageType = attachMessageType;
        this.isLoaded = false;
        this.pending = [];
        this.services = (0,_channelContext__WEBPACK_IMPORTED_MODULE_0__.createServiceEndpoints)(this.id, this.dataStoreContext.connected, submitFn, () => dirtyFn(this.id), storageService, baseSnapshot, extraBlobs);
        const thisSummarizeInternal = async (fullTree, trackState) => this.summarizeInternal(fullTree, trackState);
        this.summarizerNode = createSummarizerNode(thisSummarizeInternal, async (fullGC) => this.getGCDataInternal(fullGC), async () => gcDetailsInInitialSummary());
    }
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    getChannel() {
        if (this.channelP === undefined) {
            this.channelP = this.loadChannel();
        }
        return this.channelP;
    }
    setConnectionState(connected, clientId) {
        // Connection events are ignored if the data store is not yet loaded
        if (!this.isLoaded) {
            return;
        }
        this.services.deltaConnection.setConnectionState(connected);
    }
    applyStashedOp(message) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.isLoaded, 0x194 /* "Remote channel must be loaded when rebasing op" */);
        return this.services.deltaConnection.applyStashedOp(message);
    }
    processOp(message, local, localOpMetadata) {
        this.summarizerNode.invalidate(message.sequenceNumber);
        if (this.isLoaded) {
            this.services.deltaConnection.process(message, local, localOpMetadata);
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!local, 0x195 /* "Remote channel must not be local when processing op" */);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.pending.push(message);
        }
    }
    reSubmit(content, localOpMetadata) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.isLoaded, 0x196 /* "Remote channel must be loaded when resubmitting op" */);
        this.services.deltaConnection.reSubmit(content, localOpMetadata);
    }
    /**
     * Returns a summary at the current sequence number.
     * @param fullTree - true to bypass optimizations and force a full summary tree
     * @param trackState - This tells whether we should track state from this summary.
     */
    async summarize(fullTree = false, trackState = true) {
        return this.summarizerNode.summarize(fullTree, trackState);
    }
    async summarizeInternal(fullTree, trackState) {
        const channel = await this.getChannel();
        const summarizeResult = (0,_channelContext__WEBPACK_IMPORTED_MODULE_0__.summarizeChannel)(channel, fullTree, trackState);
        return Object.assign(Object.assign({}, summarizeResult), { id: this.id });
    }
    async loadChannel() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.isLoaded, 0x197 /* "Remote channel must not already be loaded when loading" */);
        let attributes;
        if (await this.services.objectStorage.contains(_channelContext__WEBPACK_IMPORTED_MODULE_0__.attributesBlobKey)) {
            attributes = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_2__.readAndParse)(this.services.objectStorage, _channelContext__WEBPACK_IMPORTED_MODULE_0__.attributesBlobKey);
        }
        let factory;
        // this is a backward compatibility case where
        // the attach message doesn't include
        // the attributes. Since old attach messages
        // will not have attributes we need to keep
        // this as long as we support old attach messages
        if (attributes === undefined) {
            if (this.attachMessageType === undefined) {
                // TODO: Strip out potential PII content #1920
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.DataCorruptionError("Channel type not available", {
                    channelId: this.id,
                    dataStoreId: this.dataStoreContext.id,
                    dataStorePackagePath: this.dataStoreContext.packagePath.join("/"),
                });
            }
            factory = this.registry.get(this.attachMessageType);
            if (factory === undefined) {
                // TODO: Strip out potential PII content #1920
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.DataCorruptionError(`Channel Factory ${this.attachMessageType} for attach not registered`, {
                    channelId: this.id,
                    dataStoreId: this.dataStoreContext.id,
                    dataStorePackagePath: this.dataStoreContext.packagePath.join("/"),
                    channelFactoryType: this.attachMessageType,
                });
            }
            attributes = factory.attributes;
        }
        else {
            factory = this.registry.get(attributes.type);
            if (factory === undefined) {
                // TODO: Strip out potential PII content #1920
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.DataCorruptionError(`Channel Factory ${attributes.type} not registered`, {
                    channelId: this.id,
                    dataStoreId: this.dataStoreContext.id,
                    dataStorePackagePath: this.dataStoreContext.packagePath.join("/"),
                    channelFactoryType: attributes.type,
                });
            }
        }
        // Compare snapshot version to collaborative object version
        if (attributes.snapshotFormatVersion !== undefined
            && attributes.snapshotFormatVersion !== factory.attributes.snapshotFormatVersion) {
            (0,_debug__WEBPACK_IMPORTED_MODULE_4__.debug)(`Snapshot version mismatch. Type: ${attributes.type}, ` +
                `Snapshot format@pkg version: ${attributes.snapshotFormatVersion}@${attributes.packageVersion}, ` +
                // eslint-disable-next-line max-len
                `client format@pkg version: ${factory.attributes.snapshotFormatVersion}@${factory.attributes.packageVersion}`);
        }
        const channel = await factory.load(this.runtime, this.id, this.services, attributes);
        // Send all pending messages to the channel
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        for (const message of this.pending) {
            try {
                this.services.deltaConnection.process(message, false, undefined /* localOpMetadata */);
            }
            catch (err) {
                // record sequence number for easier debugging
                const error = (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.CreateContainerError)(err);
                error.sequenceNumber = message.sequenceNumber;
                // eslint-disable-next-line @typescript-eslint/no-throw-literal
                throw error;
            }
        }
        // Commit changes.
        this.channel = channel;
        this.pending = undefined;
        this.isLoaded = true;
        // Because have some await between we created the service and here, the connection state might have changed
        // and we don't propagate the connection state when we are not loaded.  So we have to set it again here.
        this.services.deltaConnection.setConnectionState(this.dataStoreContext.connected);
        return this.channel;
    }
    /**
     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this context.
     * Each node has a set of outbound routes to other GC nodes in the document.
     * If there is no new data in this context since the last summary, previous GC data is used.
     * If there is new data, the GC data is generated again (by calling getGCDataInternal).
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        return this.summarizerNode.getGCData(fullGC);
    }
    /**
     * Generates the data used for garbage collection. This is called when there is new data since last summary. It
     * loads the context and calls into the channel to get its GC data.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCDataInternal(fullGC = false) {
        const channel = await this.getChannel();
        return channel.getGCData(fullGC);
    }
    /**
     * After GC has run, called to notify the context of routes used in it. These are used for the following:
     * 1. To identify if this context is being referenced in the document or not.
     * 2. To determine if it needs to re-summarize in case used routes changed since last summary.
     * 3. These are added to the summary generated by the context.
     * @param usedRoutes - The routes that are used in this context.
     */
    updateUsedRoutes(usedRoutes) {
        /**
         * Currently, DDSs are always considered referenced and are not garbage collected. Update the summarizer node's
         * used routes to contain a route to this channel context.
         * Once we have GC at DDS level, this will be updated to use the passed usedRoutes. See -
         * https://github.com/microsoft/FluidFramework/issues/4611
         */
        this.summarizerNode.updateUsedRoutes([""]);
    }
}
//# sourceMappingURL=remoteChannelContext.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/driver-definitions/lib/driverError.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/driver-definitions/lib/driverError.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DriverErrorType": () => (/* binding */ DriverErrorType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Driver Error types
 * Lists types that are likely to be used by all drivers
 */
var DriverErrorType;
(function (DriverErrorType) {
    /**
     * Some error, most likely an exception caught by runtime and propagated to container as critical error
     */
    DriverErrorType["genericError"] = "genericError";
    /**
     * Some non-categorized (below) networking error
     * Include errors like  fatal server error (usually 500).
     */
    DriverErrorType["genericNetworkError"] = "genericNetworkError";
    /**
     * Access denied - user does not have enough privileges to open a file, or continue to operate on a file
     */
    DriverErrorType["authorizationError"] = "authorizationError";
    /**
     * File not found, or file deleted during session
     */
    DriverErrorType["fileNotFoundOrAccessDeniedError"] = "fileNotFoundOrAccessDeniedError";
    /**
     * Throttling error from server. Server is busy and is asking not to reconnect for some time
     */
    DriverErrorType["throttlingError"] = "throttlingError";
    /**
     * We can not reach server due to computer being offline.
     */
    DriverErrorType["offlineError"] = "offlineError";
    /*
     * Unsupported client protocol
     */
    DriverErrorType["unsupportedClientProtocolVersion"] = "unsupportedClientProtocolVersion";
    /**
     * User does not have write permissions to a file, but is changing content of a file.
     * That might be indication of some data store error - data stores should not generate ops in readonly mode.
     */
    DriverErrorType["writeError"] = "writeError";
    /**
     * Generic fetch failure.
     * Most of such failures are due to client being offline, or DNS is not reachable, such errors map to
     * DriverErrorType.offlineError. Anything else that can't be diagnose as likely offline maps to this error.
     * This can also indicate no response from server.
     */
    DriverErrorType["fetchFailure"] = "fetchFailure";
    /**
     * Unexpected response from server. Either JSON is malformed, or some required properties are missing
     */
    DriverErrorType["incorrectServerResponse"] = "incorrectServerResponse";
})(DriverErrorType || (DriverErrorType = {}));
//# sourceMappingURL=driverError.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/driver-definitions/lib/storage.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@fluidframework/driver-definitions/lib/storage.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoaderCachingPolicy": () => (/* binding */ LoaderCachingPolicy)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var LoaderCachingPolicy;
(function (LoaderCachingPolicy) {
    /**
     * The loader should not implement any prefetching or caching policy.
     */
    LoaderCachingPolicy[LoaderCachingPolicy["NoCaching"] = 0] = "NoCaching";
    /**
     * The loader should implement prefetching policy, i.e. it should prefetch resources from the latest snapshot.
     */
    LoaderCachingPolicy[LoaderCachingPolicy["Prefetch"] = 1] = "Prefetch";
})(LoaderCachingPolicy || (LoaderCachingPolicy = {}));
//# sourceMappingURL=storage.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/driver-definitions/lib/urlResolver.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/driver-definitions/lib/urlResolver.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DriverHeader": () => (/* binding */ DriverHeader)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Additional key in the loader request header
 */
var DriverHeader;
(function (DriverHeader) {
    // Key to indicate whether the request for summarizer
    DriverHeader["summarizingClient"] = "fluid-client-summarizer";
    // createNew information, specific to each driver
    DriverHeader["createNew"] = "createNew";
})(DriverHeader || (DriverHeader = {}));
//# sourceMappingURL=urlResolver.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/driver-utils/lib/blobAggregationStorage.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/driver-utils/lib/blobAggregationStorage.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlobAggregationStorage": () => (/* binding */ BlobAggregationStorage)
/* harmony export */ });
/* unused harmony export SnapshotExtractor */
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/bufferBrowser.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/base64Encoding.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/unreachable.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

// Gate that when flipped, instructs to compress small blobs.
// We have to first ship with this gate off, such that we can get to saturation bits
// that can understand compressed format. And only after that flip it.
function gatesAllowPacking() {
    try {
        // Leave override for testing purposes
        // eslint-disable-next-line no-null/no-null
        if (typeof localStorage === "object" && localStorage !== null) {
            if (localStorage.FluidAggregateBlobs === "1") {
                return true;
            }
            if (localStorage.FluidAggregateBlobs === "0") {
                return false;
            }
        }
    }
    catch (e) { }
    // We are starting disabled.
    return false;
}
/*
 * Work around for bufferToString having a bug - it can't consume IsoBuffer!
 * To be removed once bufferToString is fixed!
*/
function bufferToString2(blob, encoding) {
    if (blob instanceof Uint8Array) { // IsoBuffer does not have ctor, so it's not in proto chain :(
        return (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Uint8ArrayToString)(blob, encoding);
    }
    return (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.bufferToString)(blob, encoding);
}
/**
 * Class responsible for aggregating smaller blobs into one and unpacking it later on.
 */
class BlobAggregator {
    constructor() {
        this.content = [];
    }
    addBlob(key, content) {
        this.content.push([key, content]);
    }
    getAggregatedBlobContent() {
        if (this.content.length === 0) {
            return undefined;
        }
        return JSON.stringify(this.content);
    }
    static load(input) {
        const data = bufferToString2(input, "utf-8");
        return JSON.parse(data);
    }
}
/*
 * Base class that deals with unpacking snapshots (in place) containing aggregated blobs
 * It relies on abstract methods for reads and storing unpacked blobs.
 */
class SnapshotExtractor {
    constructor() {
        this.aggregatedBlobName = "__big";
        this.virtualIdPrefix = "__";
        // counter for generation of virtual storage IDs
        this.virtualIdCounter = 0;
    }
    getNextVirtualId() {
        return `${this.virtualIdPrefix}${++this.virtualIdCounter}`;
    }
    async unpackSnapshotCore(snapshot, level = 0) {
        // for now only working at data store level, i.e.
        // .app/DataStore/...
        if (level >= 2) {
            return;
        }
        for (const key of Object.keys(snapshot.trees)) {
            const obj = snapshot.trees[key];
            await this.unpackSnapshotCore(obj, level + 1);
        }
        // For future proof, we will support multiple aggregated blobs with any name
        // that starts with this.aggregatedBlobName
        for (const key of Object.keys(snapshot.blobs)) {
            if (!key.startsWith(this.aggregatedBlobName)) {
                continue;
            }
            const blobId = snapshot.blobs[key];
            if (blobId !== undefined) {
                const blob = await this.getBlob(blobId, snapshot);
                for (const [path, value] of BlobAggregator.load(blob)) {
                    const id = this.getNextVirtualId();
                    this.setBlob(id, snapshot, value);
                    const pathSplit = path.split("/");
                    let subTree = snapshot;
                    for (const subPath of pathSplit.slice(0, pathSplit.length - 1)) {
                        if (subTree.trees[subPath] === undefined) {
                            subTree.trees[subPath] = { blobs: {}, commits: {}, trees: {} };
                        }
                        subTree = subTree.trees[subPath];
                    }
                    const blobName = pathSplit[pathSplit.length - 1];
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(subTree.blobs[blobName] === undefined, 0x0f6 /* "real blob ID exists" */);
                    subTree.blobs[blobName] = id;
                }
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete snapshot.blobs[this.aggregatedBlobName];
            }
        }
    }
}
/*
 * Snapshot extractor class that works in place, i.e. patches snapshot that has
 * blob content in ISnapshotTree.blobs itself, not in storage.
 * As result, it implements reading and writing of blobs to/from snapshot itself.
 * It follows existing pattern that mixes concerns - ISnapshotTree.blobs is used for two
 * purposes:
 * 1. map path name to blob ID
 * 2. map blob ID to blob content
 * #2 is what storage (IDocumentStorageService) is for, but in places where we do not have it
 * (like loading serialized earlier draft content), blob content is put directly into snapshot.
 * Ideally this should be fixed by using BlobCacheStorageService or something similar and
 * fixing existing flows to allow switching of storage.
 */
class SnapshotExtractorInPlace extends SnapshotExtractor {
    async getBlob(id, tree) {
        const blob = tree.blobs[id];
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(blob !== undefined, 0x0f7 /* "aggregate blob missing" */);
        return (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.stringToBuffer)(blob, "base64");
    }
    setBlob(id, tree, content) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(tree.blobs[id] === undefined, 0x0f8 /* "blob from aggregate blob exists on its own" */);
        tree.blobs[id] = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.fromUtf8ToBase64)(content);
    }
}
/*
 * Snapshot packer and extractor.
 * When summary is written it will find and aggregate small blobs into bigger blobs
 * When snapshot is read, it will unpack aggregated blobs and provide them transparently to caller.
 */
class BlobAggregationStorage extends SnapshotExtractor {
    constructor(storage, logger, allowPacking, blobCutOffSize) {
        super();
        this.storage = storage;
        this.logger = logger;
        this.allowPacking = allowPacking;
        this.blobCutOffSize = blobCutOffSize;
        this.loadedFromSummary = false;
        this.virtualBlobs = new Map();
    }
    static wrap(storage, logger, allowPacking = gatesAllowPacking()) {
        var _a;
        if (storage instanceof BlobAggregationStorage) {
            return storage;
        }
        // Always create BlobAggregationStorage even if storage is not asking for packing.
        // This is mostly to avoid cases where future changes in policy would result in inability to
        // load old files that were created with aggregation on.
        const minBlobSize = (_a = storage.policies) === null || _a === void 0 ? void 0 : _a.minBlobSize;
        return new BlobAggregationStorage(storage, logger, allowPacking, minBlobSize);
    }
    static async unpackSnapshot(snapshot) {
        const converter = new SnapshotExtractorInPlace();
        await converter.unpackSnapshotCore(snapshot);
    }
    get policies() {
        const policies = this.storage.policies;
        if (policies) {
            return Object.assign(Object.assign({}, policies), { minBlobSize: undefined });
        }
    }
    async unpackSnapshot(snapshot) {
        // SummarizerNodeWithGC.refreshLatestSummary can call it when this.loadedFromSummary === false
        // (I assumed after file was created)
        // assert(!this.loadedFromSummary, "unpack without summary");
        this.loadedFromSummary = true;
        await this.unpackSnapshotCore(snapshot);
    }
    setBlob(id, tree, content) {
        this.virtualBlobs.set(id, (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.stringToBuffer)(content, "utf-8"));
    }
    async getBlob(id, tree) {
        return this.readBlob(id).catch((error) => {
            this.logger.sendErrorEvent({ eventName: "BlobDedupNoAggregateBlob" }, error);
            throw error;
        });
    }
    get repositoryUrl() { return this.storage.repositoryUrl; }
    async getVersions(versionId, count) {
        return this.storage.getVersions(versionId, count);
    }
    async downloadSummary(handle) {
        throw new Error("NYI");
    }
    // This is only used through Container.snapshot() for testing purposes
    async write(root, parents, message, ref) {
        return this.storage.write(root, parents, message, ref);
    }
    // for now we are not optimizing these blobs, with assumption that this API is used only
    // for big blobs (images)
    async createBlob(file) {
        return this.storage.createBlob(file);
    }
    async getSnapshotTree(version) {
        const tree = await this.storage.getSnapshotTree(version);
        if (tree) {
            await this.unpackSnapshot(tree);
        }
        return tree;
    }
    async read(id) {
        // optimize it a bit to avoid unneeded conversions while we transition to using readBlob everywhere.
        if (this.isRealStorageId(id)) {
            return bufferToString2(await this.storage.readBlob(id), "base64");
        }
        const blob = await this.readBlob(id);
        return bufferToString2(blob, "base64");
    }
    async readBlob(id) {
        if (this.isRealStorageId(id)) {
            return this.storage.readBlob(id);
        }
        // We support only reading blobs from the summary we loaded from.
        // This may need to be extended to any general summary in the future as runtime usage pattern
        // of storage changes (for example, data stores start to load from recent summary, not from original
        // summary whole container loaded from)
        // are there other ways we can get here? createFile is one flow, but we should not be reading blobs
        // in such flow
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.loadedFromSummary, 0x0f9 /* "never read summary" */);
        const blob = this.virtualBlobs.get(id);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(blob !== undefined, 0x0fa /* "virtual blob not found" */);
        return blob;
    }
    async uploadSummaryWithContext(summary, context) {
        const summaryNew = this.allowPacking ? await this.compressSmallBlobs(summary) : summary;
        return this.storage.uploadSummaryWithContext(summaryNew, context);
    }
    // For simplification, we assume that
    // - blob aggregation is done at data store level only for now
    // - data store either reuses previous summary, or generates full summary, i.e. there is no partial (some DDS)
    // summary produced by data stores.
    // These simplifications allow us not to touch handles, as they are self-contained (either do not use aggregated
    // blob Or contain aggregated blob that stays relevant for that sub-tree)
    // Note:
    // From perf perspective, it makes sense to place aggregated blobs one level up in the tree not to create extra
    // tree nodes (i.e. have shallow tree with less edges). But that creates problems with reusability of trees at
    // incremental summary time - we would need to understand handles and parse them. In current design we can skip
    // that step because if data store is reused, the hole sub-tree is reused included aggregated blob embedded into it
    // and that means we can do nothing and be correct!
    async compressSmallBlobs(summary, path = "", level = 0, aggregatorArg) {
        if (this.blobCutOffSize === undefined || this.blobCutOffSize < 0) {
            return summary;
        }
        // Only pack at data store level.
        const startingLevel = level === 1;
        let aggregator = aggregatorArg;
        if (startingLevel) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(aggregator === undefined, 0x0fb /* "logic err with aggregator" */);
            aggregator = new BlobAggregator();
        }
        const newSummary = Object.assign({}, summary);
        newSummary.tree = Object.assign({}, newSummary.tree);
        for (const key of Object.keys(summary.tree)) {
            const obj = summary.tree[key];
            // Get path relative to root of data store (where we do aggregation)
            const newPath = startingLevel ? key : `${path}/${key}`;
            switch (obj.type) {
                case 1 /* Tree */:
                    // If client created empty tree, keep it as is
                    // Also do not package search blobs - they are part of storage contract
                    if (obj.tree !== {} && key !== "__search") {
                        const tree = await this.compressSmallBlobs(obj, newPath, level + 1, aggregator);
                        newSummary.tree[key] = tree;
                        if (tree.tree === {}) {
                            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                            delete newSummary.tree[key];
                        }
                    }
                    break;
                case 2 /* Blob */:
                    if (aggregator && typeof obj.content == "string" && obj.content.length < this.blobCutOffSize) {
                        aggregator.addBlob(newPath, obj.content);
                        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                        delete newSummary.tree[key];
                    }
                    break;
                case 3 /* Handle */: {
                    // Would be nice to:
                    // Trees: expand the tree
                    // Blobs: parse handle and ensure it points to real blob, not virtual blob.
                    // We can avoid it for now given data store is the granularity of incremental summaries.
                    let handlePath = obj.handle;
                    if (handlePath.startsWith("/")) {
                        handlePath = handlePath.substr(1);
                    }
                    // Ensure only whole data stores can be reused, no reusing at deeper level!
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(level === 0, 0x0fc /* "tree reuse at lower level" */);
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(handlePath.indexOf("/") === -1, 0x0fd /* "data stores are writing incremental summaries!" */);
                    break;
                }
                case 4 /* Attachment */:
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.isRealStorageId(obj.id), 0x0fe /* "attachment is aggregate blob" */);
                    break;
                default:
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.unreachableCase)(obj, `Unknown type: ${obj.type}`);
            }
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(newSummary.tree[this.aggregatedBlobName] === undefined, 0x0ff /* "duplicate aggregate blob" */);
        if (startingLevel) {
            // Note: It would be great to add code here to unpack aggregate blob back to normal blobs
            // If only one blob made it into aggregate. Currently that does not happen as we always have
            // at least one .component blob and at least one DDS that has .attributes blob, so it's not an issue.
            // But it's possible that in future that would be great addition!
            // Good news - it's backward compatible change.
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(aggregator !== undefined, 0x100 /* "logic error" */);
            const content = aggregator.getAggregatedBlobContent();
            if (content !== undefined) {
                newSummary.tree[this.aggregatedBlobName] = {
                    type: 2 /* Blob */,
                    content,
                };
            }
        }
        return newSummary;
    }
    isRealStorageId(id) {
        return !id.startsWith(this.virtualIdPrefix);
    }
}
// Tells data store if it can use incremental summary (i.e. reuse DDSs from previous summary
// when only one DDS changed).
// The answer has to be know long before we enable actual packing. The reason for the is the following:
// A the moment when we enable packing, we should assume that all clients out there wil already have bits
// that can unpack properly (i.e. enough time passed since we deployed bits that can unpack)
// But we can still have clients where some of them already pack, and some do not. If one summary was
// using packing, then it relies on non-incremental summaries going forward, even if next client who
// produced summary is not packing!
// This can have slight improvement by enabling it per file (based on "did summary we loaded from contain
// aggregated blobs"), but that's harder to make reliable, so going for simplicity.
BlobAggregationStorage.fullDataStoreSummaries = true;
//# sourceMappingURL=blobAggregationStorage.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/driver-utils/lib/blobCacheStorageService.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/driver-utils/lib/blobCacheStorageService.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlobCacheStorageService": () => (/* binding */ BlobCacheStorageService)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/bufferBrowser.js");
/* harmony import */ var _documentStorageServiceProxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./documentStorageServiceProxy */ "../../node_modules/@fluidframework/driver-utils/lib/documentStorageServiceProxy.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * IDocumentStorageService adapter with pre-cached blobs.
 */
class BlobCacheStorageService extends _documentStorageServiceProxy__WEBPACK_IMPORTED_MODULE_0__.DocumentStorageServiceProxy {
    constructor(internalStorageService, blobs) {
        super(internalStorageService);
        this.blobs = blobs;
    }
    get policies() {
        return this.internalStorageService.policies;
    }
    async read(id) {
        const blob = this.blobs.get(id);
        if (blob !== undefined) {
            return (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.bufferToString)(blob, "base64");
        }
        return (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.bufferToString)(await this.internalStorageService.readBlob(id), "base64");
    }
    async readBlob(id) {
        const blob = this.blobs.get(id);
        if (blob !== undefined) {
            return blob;
        }
        return this.internalStorageService.readBlob(id);
    }
}
//# sourceMappingURL=blobCacheStorageService.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/driver-utils/lib/buildSnapshotTree.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/driver-utils/lib/buildSnapshotTree.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildSnapshotTree": () => (/* binding */ buildSnapshotTree)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/bufferBrowser.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/storage.js");
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/protocol-base */ "../../node_modules/@fluidframework/protocol-base/lib/blobs.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-browser/v4.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */




function flattenCore(path, treeEntries, blobMap) {
    const entries = [];
    for (const treeEntry of treeEntries) {
        const subPath = `${path}${treeEntry.path}`;
        if (treeEntry.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.TreeEntry.Blob) {
            const blob = treeEntry.value;
            const buffer = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.stringToBuffer)(blob.contents, blob.encoding);
            const id = (0,uuid__WEBPACK_IMPORTED_MODULE_2__.default)();
            blobMap.set(id, buffer);
            const entry = {
                mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.FileMode[treeEntry.mode],
                path: subPath,
                sha: id,
                size: 0,
                type: "blob",
                url: "",
            };
            entries.push(entry);
        }
        else if (treeEntry.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.TreeEntry.Commit) {
            const entry = {
                mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.FileMode[treeEntry.mode],
                path: subPath,
                sha: treeEntry.value,
                size: -1,
                type: "commit",
                url: "",
            };
            entries.push(entry);
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(treeEntry.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.TreeEntry.Tree, 0x101 /* "Unexpected tree entry type on flatten!" */);
            const t = treeEntry.value;
            const entry = {
                mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.FileMode[treeEntry.mode],
                path: subPath,
                sha: "",
                size: -1,
                type: "tree",
                url: "",
            };
            entries.push(entry);
            const subTreeEntries = flattenCore(`${subPath}/`, t.entries, blobMap);
            entries.push(...subTreeEntries);
        }
    }
    return entries;
}
/**
 * Create a flatten view of an array of ITreeEntry
 *
 * @param tree - an array of ITreeEntry to flatten
 * @param blobMap - a map of blob's sha1 to content
 * @returns A flatten with of the ITreeEntry
 */
function flatten(tree, blobMap) {
    const entries = flattenCore("", tree, blobMap);
    return {
        sha: "",
        tree: entries,
        url: "",
    };
}
/**
 * Build a tree hierarchy base on an array of ITreeEntry
 *
 * @param entries - an array of ITreeEntry to flatten
 * @param blobMap - a map of blob's sha1 to content that gets filled with content from entries
 * NOTE: blobMap's validity is contingent on the returned promise's resolution
 * @returns the hierarchical tree
 */
function buildSnapshotTree(entries, blobMap) {
    const flattened = flatten(entries, blobMap);
    return (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__.buildHierarchy)(flattened);
}
//# sourceMappingURL=buildSnapshotTree.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/driver-utils/lib/documentStorageServiceProxy.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/driver-utils/lib/documentStorageServiceProxy.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DocumentStorageServiceProxy": () => (/* binding */ DocumentStorageServiceProxy)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class DocumentStorageServiceProxy {
    constructor(internalStorageService) {
        this.internalStorageService = internalStorageService;
    }
    get repositoryUrl() {
        return this.internalStorageService.repositoryUrl;
    }
    async getSnapshotTree(version) {
        return this.internalStorageService.getSnapshotTree(version);
    }
    async getVersions(versionId, count) {
        return this.internalStorageService.getVersions(versionId, count);
    }
    async write(tree, parents, message, ref) {
        return this.internalStorageService.write(tree, parents, message, ref);
    }
    async uploadSummaryWithContext(summary, context) {
        return this.internalStorageService.uploadSummaryWithContext(summary, context);
    }
    async downloadSummary(handle) {
        return this.internalStorageService.downloadSummary(handle);
    }
    async createBlob(file) {
        return this.internalStorageService.createBlob(file);
    }
    async readBlob(blobId) {
        return this.internalStorageService.readBlob(blobId);
    }
}
//# sourceMappingURL=documentStorageServiceProxy.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/driver-utils/lib/fluidResolvedUrl.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/driver-utils/lib/fluidResolvedUrl.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ensureFluidResolvedUrl": () => (/* binding */ ensureFluidResolvedUrl)
/* harmony export */ });
/* unused harmony export isFluidResolvedUrl */
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const isFluidResolvedUrl = (resolved) => (resolved === null || resolved === void 0 ? void 0 : resolved.type) === "fluid";
function ensureFluidResolvedUrl(resolved) {
    if (!isFluidResolvedUrl(resolved)) {
        throw new Error(`resolved is not a Fluid url. Type: ${resolved === null || resolved === void 0 ? void 0 : resolved.type}`);
    }
}
//# sourceMappingURL=fluidResolvedUrl.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/driver-utils/lib/multiDocumentServiceFactory.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/driver-utils/lib/multiDocumentServiceFactory.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MultiDocumentServiceFactory": () => (/* binding */ MultiDocumentServiceFactory)
/* harmony export */ });
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url */ "../../node_modules/url/url.js");
/* harmony import */ var _fluidResolvedUrl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fluidResolvedUrl */ "../../node_modules/@fluidframework/driver-utils/lib/fluidResolvedUrl.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


class MultiDocumentServiceFactory {
    constructor(documentServiceFactories) {
        this.protocolName = "none:";
        this.protocolToDocumentFactoryMap = new Map();
        documentServiceFactories.forEach((factory) => {
            this.protocolToDocumentFactoryMap.set(factory.protocolName, factory);
        });
    }
    static create(documentServiceFactory) {
        if (Array.isArray(documentServiceFactory)) {
            const factories = [];
            documentServiceFactory.forEach((factory) => {
                const maybeMulti = factory;
                if (maybeMulti.protocolToDocumentFactoryMap !== undefined) {
                    factories.push(...maybeMulti.protocolToDocumentFactoryMap.values());
                }
                else {
                    factories.push(factory);
                }
            });
            if (factories.length === 1) {
                return factories[0];
            }
            return new MultiDocumentServiceFactory(factories);
        }
        return documentServiceFactory;
    }
    async createDocumentService(resolvedUrl, logger) {
        (0,_fluidResolvedUrl__WEBPACK_IMPORTED_MODULE_1__.ensureFluidResolvedUrl)(resolvedUrl);
        const urlObj = (0,url__WEBPACK_IMPORTED_MODULE_0__.parse)(resolvedUrl.url);
        if (urlObj.protocol === undefined) {
            throw new Error("No protocol provided");
        }
        const factory = this.protocolToDocumentFactoryMap.get(urlObj.protocol);
        if (factory === undefined) {
            throw new Error("Unknown Fluid protocol");
        }
        return factory.createDocumentService(resolvedUrl, logger);
    }
    async createContainer(createNewSummary, createNewResolvedUrl, logger) {
        (0,_fluidResolvedUrl__WEBPACK_IMPORTED_MODULE_1__.ensureFluidResolvedUrl)(createNewResolvedUrl);
        const urlObj = (0,url__WEBPACK_IMPORTED_MODULE_0__.parse)(createNewResolvedUrl.url);
        if (urlObj.protocol === undefined) {
            throw new Error("No protocol provided");
        }
        const factory = this.protocolToDocumentFactoryMap.get(urlObj.protocol);
        if (factory === undefined) {
            throw new Error("Unknown Fluid protocol");
        }
        return factory.createContainer(createNewSummary, createNewResolvedUrl, logger);
    }
}
//# sourceMappingURL=multiDocumentServiceFactory.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/driver-utils/lib/multiUrlResolver.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/driver-utils/lib/multiUrlResolver.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MultiUrlResolver": () => (/* binding */ MultiUrlResolver)
/* harmony export */ });
/* unused harmony export configurableUrlResolver */
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Resolver that takes a list of url resolvers and then try each of them to resolve the url.
 * @param resolversList - List of url resolvers to be used to resolve the request.
 * @param request - Request to be resolved.
 */
async function configurableUrlResolver(resolversList, request) {
    const url = request.url;
    let resolved;
    for (const resolver of resolversList) {
        resolved = await resolver.resolve({ url });
        if (resolved !== undefined) {
            return resolved;
        }
    }
    return undefined;
}
class MultiUrlResolver {
    constructor(urlResolvers) {
        this.urlResolvers = urlResolvers;
    }
    static create(urlResolver) {
        if (Array.isArray(urlResolver)) {
            if (urlResolver.length === 1) {
                return urlResolver[0];
            }
            return new MultiUrlResolver(urlResolver);
        }
        return urlResolver;
    }
    async resolve(request) {
        return configurableUrlResolver(this.urlResolvers, request);
    }
    async getAbsoluteUrl(resolvedUrl, relativeUrl) {
        throw new Error("Not implmented");
    }
}
//# sourceMappingURL=multiUrlResolver.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/driver-utils/lib/network.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@fluidframework/driver-utils/lib/network.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OnlineStatus": () => (/* binding */ OnlineStatus),
/* harmony export */   "isOnline": () => (/* binding */ isOnline),
/* harmony export */   "createWriteError": () => (/* binding */ createWriteError),
/* harmony export */   "createGenericNetworkError": () => (/* binding */ createGenericNetworkError),
/* harmony export */   "canRetryOnError": () => (/* binding */ canRetryOnError),
/* harmony export */   "getRetryDelayFromError": () => (/* binding */ getRetryDelayFromError)
/* harmony export */ });
/* unused harmony exports GenericNetworkError, AuthorizationError, NetworkErrorBasic, NonRetryableError, ThrottlingError */
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/driver-definitions */ "../../node_modules/@fluidframework/driver-definitions/lib/driverError.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


var OnlineStatus;
(function (OnlineStatus) {
    OnlineStatus[OnlineStatus["Offline"] = 0] = "Offline";
    OnlineStatus[OnlineStatus["Online"] = 1] = "Online";
    OnlineStatus[OnlineStatus["Unknown"] = 2] = "Unknown";
})(OnlineStatus || (OnlineStatus = {}));
// It tells if we have local connection only - we might not have connection to web.
// No solution for node.js (other than resolve dns names / ping specific sites)
// Can also use window.addEventListener("online" / "offline")
function isOnline() {
    // eslint-disable-next-line no-null/no-null
    if (typeof navigator === "object" && navigator !== null && typeof navigator.onLine === "boolean") {
        return navigator.onLine ? OnlineStatus.Online : OnlineStatus.Offline;
    }
    return OnlineStatus.Unknown;
}
/**
 * Generic network error class.
 */
class GenericNetworkError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(errorMessage, canRetry, statusCode) {
        super(errorMessage, { statusCode });
        this.canRetry = canRetry;
        this.errorType = _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.DriverErrorType.genericNetworkError;
    }
}
class AuthorizationError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(errorMessage, claims, tenantId, statusCode) {
        super(errorMessage, { statusCode });
        this.claims = claims;
        this.tenantId = tenantId;
        this.errorType = _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.DriverErrorType.authorizationError;
        this.canRetry = false;
    }
}
class NetworkErrorBasic extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(errorMessage, errorType, canRetry, statusCode) {
        super(errorMessage, { statusCode });
        this.errorType = errorType;
        this.canRetry = canRetry;
    }
}
class NonRetryableError extends NetworkErrorBasic {
    constructor(errorMessage, errorType, statusCode) {
        super(errorMessage, errorType, false, statusCode);
        this.errorType = errorType;
    }
}
/**
 * Throttling error class - used to communicate all throttling errors
 */
class ThrottlingError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(errorMessage, retryAfterSeconds, statusCode) {
        super(errorMessage, { statusCode });
        this.retryAfterSeconds = retryAfterSeconds;
        this.errorType = _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.DriverErrorType.throttlingError;
        this.canRetry = true;
    }
}
const createWriteError = (errorMessage) => new NonRetryableError(errorMessage, _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.DriverErrorType.writeError, undefined /* statusCodes */);
function createGenericNetworkError(errorMessage, canRetry, retryAfterSeconds, statusCode) {
    if (retryAfterSeconds !== undefined && canRetry) {
        return new ThrottlingError(errorMessage, retryAfterSeconds, statusCode);
    }
    return new GenericNetworkError(errorMessage, canRetry, statusCode);
}
/**
 * Check if a connection error can be retried.  Unless explicitly allowed, retry is disallowed.
 * I.e. asserts or unexpected exceptions in our code result in container failure.
 * @param error - The error to inspect for ability to retry
 */
const canRetryOnError = (error) => (error === null || error === void 0 ? void 0 : error.canRetry) === true;
// eslint-disable-next-line @typescript-eslint/no-unsafe-return
const getRetryDelayFromError = (error) => error === null || error === void 0 ? void 0 : error.retryAfterSeconds;
//# sourceMappingURL=network.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/driver-utils/lib/parallelRequests.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/driver-utils/lib/parallelRequests.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParallelRequests": () => (/* binding */ ParallelRequests)
/* harmony export */ });
/* unused harmony exports Queue, parallel */
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/promises.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Helper class to organize parallel fetching of data
 * It can be used to concurrently do many requests, while consuming
 * data in the right order. Take a look at UT for examples.
 * @param concurrency - level of concurrency
 * @param from - starting point of fetching data (inclusive)
 * @param to  - ending point of fetching data. exclusive, or undefined if unknown
 * @param payloadSize - batch size
 * @param logger - logger to use
 * @param requestCallback - callback to request batches
 * @returns - Queue that can be used to retrieve data
 */
class ParallelRequests {
    constructor(from, to, payloadSize, logger, requestCallback, responseCallback) {
        this.to = to;
        this.payloadSize = payloadSize;
        this.logger = logger;
        this.requestCallback = requestCallback;
        this.responseCallback = responseCallback;
        this.results = new Map();
        this.working = true;
        this.requestsInFlight = 0;
        this.endEvent = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        this.requests = 0;
        this.latestRequested = from;
        this.nextToDeliver = from;
        this.knewTo = (to !== undefined);
    }
    cancel() {
        this.working = false;
        this.endEvent.resolve();
    }
    async run(concurrency) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(concurrency > 0, 0x102 /* "invalid level of concurrency" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.working, 0x103 /* "trying to parallel run while not working" */);
        let c = concurrency;
        while (c > 0) {
            c--;
            this.addRequest();
        }
        this.dispatch(); // will recalculate and trigger this.endEvent if needed
        return this.endEvent.promise;
    }
    done() {
        // We should satisfy request fully.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.to !== undefined, 0x104 /* "undefined end point for parallel fetch" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.nextToDeliver >= this.to, 0x105 /* "unexpected end point for parallel fetch" */);
        this.working = false;
        this.endEvent.resolve();
    }
    fail(error) {
        this.working = false;
        this.endEvent.reject(error);
    }
    dispatch() {
        while (this.working) {
            const value = this.results.get(this.nextToDeliver);
            if (value === undefined) {
                break;
            }
            this.results.delete(this.nextToDeliver);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(value.length <= this.payloadSize, 0x1d9 /* "addRequestCore() should break into smaller chunks" */);
            this.nextToDeliver += value.length;
            this.responseCallback(value);
        }
        // Account for cancellation - state might be not in consistent state on cancelling operation
        if (this.working) {
            if (this.requestsInFlight === 0) {
                // we should have dispatched everything, no matter whether we knew about the end or not.
                // see comment in addRequestCore() around throwing away chunk if it's above this.to
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.results.size === 0, 0x107 /* "ending dispatch with remaining results to be sent" */);
                this.done();
            }
            else if (this.to !== undefined && this.nextToDeliver >= this.to) {
                // Learned about the end and dispatched all the ops up to it.
                // Ignore all the in-flight requests above boundary - unblock caller sooner.
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.knewTo, 0x108 /* "ending results dispatch but knew in advance about more requests" */);
                this.done();
            }
        }
    }
    getNextChunk() {
        if (!this.working) {
            return undefined;
        }
        const from = this.latestRequested;
        if (this.to !== undefined) {
            if (this.to <= from) {
                return undefined;
            }
        }
        // this.latestRequested
        // inclusive on the right side! Exclusive on the left.
        this.latestRequested += this.payloadSize;
        if (this.to !== undefined) {
            this.latestRequested = Math.min(this.to, this.latestRequested);
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(from < this.latestRequested, 0x109 /* "unexpected next chunk position" */);
        return { from, to: this.latestRequested };
    }
    addRequest() {
        const chunk = this.getNextChunk();
        if (chunk === undefined) {
            return;
        }
        this.addRequestCore(chunk.from, chunk.to).catch(this.fail.bind(this));
    }
    async addRequestCore(fromArg, toArg) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.working, 0x10a /* "cannot add parallel request while not working" */);
        let from = fromArg;
        let to = toArg;
        // to & from are exclusive
        this.requestsInFlight++;
        while (this.working) {
            const requestedLength = to - from;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(requestedLength > 0, 0x10b /* "invalid parallel request range" */);
            // We should not be wasting time asking for something useless.
            if (this.to !== undefined) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(from < this.to, 0x10c /* "invalid parallel request start point" */);
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(to <= this.to, 0x10d /* "invalid parallel request end point" */);
            }
            this.requests++;
            const promise = this.requestCallback(this.requests, from, to, this.to !== undefined);
            // dispatch any prior received data
            this.dispatch();
            const { payload, cancel, partial } = await promise;
            if (cancel) {
                this.cancel();
            }
            if (this.to !== undefined && from >= this.to) {
                // while we were waiting for response, we learned on what is the boundary
                // We can get here (with actual result!) if situation changed while this request was in
                // flight, i.e. the end was extended over what we learn in some other request
                // While it's useful not to throw this result, this is very corner cases and makes logic
                // (including consistency checks) much harder to write correctly.
                // So for now, we are throwing this result out the window.
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.knewTo, 0x10e /* "should not throw result if we knew about boundary in advance" */);
                // Learn how often it happens and if it's too wasteful to throw these chunks.
                // If it pops into our view a lot, we would need to reconsider how we approach it.
                // Note that this is not visible to user other than potentially not hitting 100% of
                // what we can in perf domain.
                if (payload.length !== 0) {
                    this.logger.sendErrorEvent({
                        eventName: "ParallelRequests_GotExtra",
                        from,
                        to,
                        end: this.to,
                        length: payload.length,
                    });
                }
                break;
            }
            if (this.working) {
                const fromOrig = from;
                const length = payload.length;
                let fullChunk = (requestedLength <= length); // we can possible get more than we asked.
                if (length !== 0) {
                    // We can get more than we asked for!
                    // This can screw up logic in dispatch!
                    // So push only batch size, and keep the rest for later - if conditions are favorable, we
                    // will be able to use it. If not (parallel request overlapping these ops), it's easier to
                    // discard them and wait for another (overlapping) request to come in later.
                    if (requestedLength < length) {
                        // This is error in a sense that it's not expected and likely points bug in other layer.
                        // This layer copes with this situation just fine.
                        this.logger.sendTelemetryEvent({
                            eventName: "ParallelRequests_Over",
                            from,
                            to,
                            length,
                        });
                    }
                    const data = payload.splice(0, requestedLength);
                    this.results.set(from, data);
                    from += data.length;
                }
                else {
                    // 1. empty (partial) chunks should not be returned by various caching / adapter layers -
                    //    they should fall back to next layer. This might be important invariant to hold to ensure
                    //    that we are less likely have bugs where such layer would keep returning empty partial
                    //    result on each call.
                    // 2. Current invariant is that callback does retries until it gets something,
                    //    with the goal of failing if zero data is retrieved in given amount of time.
                    //    This is very specific property of storage / ops, so this logic is not here, but given only
                    //    one user of this class, we assert that to catch issues earlier.
                    // These invariant can be relaxed if needed.
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!partial, 0x10f /* "empty/partial chunks should not be returned by caching" */);
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.knewTo, 0x110 /* "callback should retry until valid fetch before it learns new boundary" */);
                }
                if (!partial && !fullChunk) {
                    if (!this.knewTo) {
                        if (this.to === undefined || this.to > from) {
                            // The END
                            this.to = from;
                        }
                        break;
                    }
                    // We know that there are more items to be retrieved
                    // Can we get partial chunk? Ideally storage indicates that's not a full chunk
                    // Note that it's possible that not all ops hit storage yet.
                    // We will come back to request more, and if we can't get any more ops soon, it's
                    // catastrophic failure (see comment above on responsibility of callback to return something)
                    // This layer will just keep trying until it gets full set.
                    this.logger.sendPerformanceEvent({
                        eventName: "ParallelRequests_Partial",
                        from: fromOrig,
                        to,
                        length,
                    });
                }
                if (to === this.latestRequested) {
                    // we can go after full chunk at the end if we received partial chunk, or more than asked
                    // Also if we got more than we asked to, we can actually use those ops!
                    if (payload.length !== 0) {
                        this.results.set(from, payload);
                        from += payload.length;
                    }
                    this.latestRequested = from;
                    fullChunk = true;
                }
                if (fullChunk) {
                    const chunk = this.getNextChunk();
                    if (chunk === undefined) {
                        break;
                    }
                    from = chunk.from;
                    to = chunk.to;
                }
            }
        }
        this.requestsInFlight--;
        this.dispatch();
    }
}
/**
 * Helper queue class to allow async push / pull
 * It's essentially a pipe allowing multiple writers, and single reader
 */
class Queue {
    constructor() {
        this.queue = [];
        this.done = false;
    }
    pushValue(value) {
        this.pushCore(Promise.resolve(value));
    }
    pushError(error) {
        this.pushCore(Promise.reject(error));
        this.done = true;
    }
    pushDone() {
        this.pushCore(Promise.resolve(undefined));
        this.done = true;
    }
    pushCore(value) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.done, 0x112 /* "cannot push onto queue if done" */);
        if (this.deferred) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.queue.length === 0, 0x113 /* "deferred queue should be empty" */);
            this.deferred.resolve(value);
            this.deferred = undefined;
        }
        else {
            this.queue.push(value);
        }
    }
    async pop() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.deferred === undefined, 0x114 /* "cannot pop if deferred" */);
        const el = this.queue.shift();
        if (el !== undefined) {
            return el;
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.done, 0x115 /* "queue should not be done during pop" */);
        this.deferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        return this.deferred.promise;
    }
}
/**
 * Helper function to expose ParallelRequests through IReadPipe interface
 * @param concurrency - level of concurrency
 * @param from - starting point of fetching data (inclusive)
 * @param to  - ending point of fetching data. exclusive, or undefined if unknown
 * @param payloadSize - batch size
 * @param logger - logger to use
 * @param requestCallback - callback to request batches
 * @returns - Queue that can be used to retrieve data
 */
function parallel(concurrency, from, to, payloadSize, logger, requestCallback) {
    const queue = new Queue();
    const manager = new ParallelRequests(from, to, payloadSize, logger, requestCallback, (messages) => queue.pushValue(messages));
    manager.run(concurrency)
        .then(() => queue.pushDone())
        .catch((error) => queue.pushError(error));
    return queue;
}
//# sourceMappingURL=parallelRequests.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/driver-utils/lib/readAndParse.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@fluidframework/driver-utils/lib/readAndParse.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "readAndParse": () => (/* binding */ readAndParse),
/* harmony export */   "readAndParseFromBlobs": () => (/* binding */ readAndParseFromBlobs)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/bufferBrowser.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/base64Encoding.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Read a blob from IDocumentStorageService and JSON.parse it into object of type T
 *
 * @param storage - the IDocumentStorageService to read from
 * @param id - the id of the blob to read and parse
 * @returns the object that we decoded and JSON.parse
 */
async function readAndParse(storage, id) {
    const blob = await storage.readBlob(id);
    const decoded = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.bufferToString)(blob, "utf8");
    return JSON.parse(decoded);
}
/**
 * Read a blob from map, decode it (from "base64") and JSON.parse it into object of type T
 *
 * @param blobs - the blob map to read from
 * @param id - the id of the blob to read and parse
 * @returns the object that we decoded and JSON.parse
 */
function readAndParseFromBlobs(blobs, id) {
    const encoded = blobs[id];
    const decoded = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.fromBase64ToUtf8)(encoded);
    return JSON.parse(decoded);
}
//# sourceMappingURL=readAndParse.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/driver-utils/lib/summaryForCreateNew.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/driver-utils/lib/summaryForCreateNew.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "combineAppAndProtocolSummary": () => (/* binding */ combineAppAndProtocolSummary)
/* harmony export */ });
/* unused harmony exports getDocAttributesFromProtocolSummary, getQuorumValuesFromProtocolSummary */
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Combine the app summary and protocol summary in 1 tree.
 * @param appSummary - Summary of the app.
 * @param protocolSummary - Summary of the protocol.
 */
function combineAppAndProtocolSummary(appSummary, protocolSummary) {
    const createNewSummary = {
        type: 1 /* Tree */,
        tree: {
            ".protocol": protocolSummary,
            ".app": appSummary,
        },
    };
    return createNewSummary;
}
/**
 * Extract the attributes from the protocol summary.
 * @param protocolSummary - protocol summary from which the values are to be extracted.
 */
function getDocAttributesFromProtocolSummary(protocolSummary) {
    var _a;
    const attributesBlob = protocolSummary.tree.attributes;
    const documentAttributes = JSON.parse(attributesBlob.content);
    documentAttributes.term = (_a = documentAttributes.term) !== null && _a !== void 0 ? _a : 1;
    return documentAttributes;
}
/**
 * Extract quorum values from the protocol summary.
 * @param protocolSummary - protocol summary from which the values are to be extracted.
 */
function getQuorumValuesFromProtocolSummary(protocolSummary) {
    const quorumValuesBlob = protocolSummary.tree.quorumValues;
    const quorumValues = JSON.parse(quorumValuesBlob.content);
    return quorumValues;
}
//# sourceMappingURL=summaryForCreateNew.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/garbage-collector/lib/garbageCollector.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/garbage-collector/lib/garbageCollector.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "runGarbageCollection": () => (/* binding */ runGarbageCollection)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Runs garbage collection on the given reference graph.
 * @param referenceGraph - The reference graph to run GC on. It's a list of nodes where each node has an id and set of
 * routes to other nodes in the graph.
 * @param rootIds - The ids of root nodes that are considered referenced.
 * @param logger - Used to log telelmetry.
 * @returns the ids of referenced nodes and the ids of deleted nodes in the referenced graph.
 */
function runGarbageCollection(referenceGraph, rootIds, logger) {
    // This set keeps track of nodes that we have visited. It is used to detect cycles in the graph.
    const visited = new Set();
    // This tracks the ids of referenced nodes. The nodes corresponding to rootIds are always considered
    // referenced so we start with those.
    const referencedIds = [...rootIds];
    for (const id of referencedIds) {
        // If we have already seen this node, ignore and continue. Else, add it to visited list.
        if (visited.has(id)) {
            continue;
        }
        visited.add(id);
        // Get the node for the referenced id and add its outbound routes to referencedIds since they are
        // also referenced.
        const routes = referenceGraph[id];
        if (routes !== undefined) {
            referencedIds.push(...routes);
        }
        else {
            // Log a telemetry event if there is a node missing for a referenced id. This should not happen but for now
            // we don't assert. We can monitor telemetry for a while to figure out next steps.
            /**
             * This telemetry is currently too noisy. Start sending it GC is enabled end-to-end. See here for details -
             * https://github.com/microsoft/FluidFramework/issues/4939
             *
             * logger.sendTelemetryEvent({
             *    eventName: "MissingGCNode",
             *    missingNodeId: id,
             * });
            */
        }
    }
    const referencedNodeIds = [];
    const deletedNodeIds = [];
    for (const id of Object.keys(referenceGraph)) {
        // The nodes from the reference graph whose ids are in the visited list are referenced.
        // The rest of the nodes are deleted.
        if (visited.has(id)) {
            referencedNodeIds.push(id);
        }
        else {
            deletedNodeIds.push(id);
        }
    }
    return { referencedNodeIds, deletedNodeIds };
}
//# sourceMappingURL=garbageCollector.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/garbage-collector/lib/utils.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@fluidframework/garbage-collector/lib/utils.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cloneGCData": () => (/* binding */ cloneGCData),
/* harmony export */   "getChildNodesUsedRoutes": () => (/* binding */ getChildNodesUsedRoutes),
/* harmony export */   "getChildNodesGCData": () => (/* binding */ getChildNodesGCData),
/* harmony export */   "removeRouteFromAllNodes": () => (/* binding */ removeRouteFromAllNodes),
/* harmony export */   "GCDataBuilder": () => (/* binding */ GCDataBuilder)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Helper function that clones the GC data.
 * @param gcData - The GC data to clone.
 * @returns a clone of the given GC data.
 */
function cloneGCData(gcData) {
    const clonedGCNodes = {};
    for (const [id, outboundRoutes] of Object.entries(gcData.gcNodes)) {
        clonedGCNodes[id] = Array.from(outboundRoutes);
    }
    return {
        gcNodes: clonedGCNodes,
    };
}
/**
 * Helper function that generates the used routes of children from a given node's used routes.
 * @param usedRoutes - The used routes of a node.
 * @returns A map of used routes of each children of the the given node.
 */
function getChildNodesUsedRoutes(usedRoutes) {
    const childUsedRoutesMap = new Map();
    for (const route of usedRoutes) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(route.startsWith("/"), 0x198 /* "Used route should always be an absolute route" */);
        const childId = route.split("/")[1];
        const childUsedRoute = route.slice(childId.length + 1);
        const childUsedRoutes = childUsedRoutesMap.get(childId);
        if (childUsedRoutes !== undefined) {
            childUsedRoutes.push(childUsedRoute);
        }
        else {
            childUsedRoutesMap.set(childId, [childUsedRoute]);
        }
    }
    return childUsedRoutesMap;
}
/**
 * Helper function that generates the GC data of children from a given node's GC data.
 * @param gcData - The GC data of a node.
 * @returns A map of GC data of each children of the the given node.
 */
function getChildNodesGCData(gcData) {
    const childGCDataMap = new Map();
    for (const [id, outboundRoutes] of Object.entries(gcData.gcNodes)) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(id.startsWith("/"), 0x199 /* "id should always be an absolute route" */);
        const childId = id.split("/")[1];
        let childGCNodeId = id.slice(childId.length + 1);
        // GC node id always begins with "/". Handle the special case where the id in parent's GC nodes is of the
        // for `/root`. This would make `childId=root` and `childGCNodeId=""`.
        if (childGCNodeId === "") {
            childGCNodeId = "/";
        }
        // Create a copy of the outbound routes array in the parents GC data.
        const childOutboundRoutes = Array.from(outboundRoutes);
        let childGCData = childGCDataMap.get(childId);
        if (childGCData === undefined) {
            childGCData = { gcNodes: {} };
        }
        childGCData.gcNodes[childGCNodeId] = childOutboundRoutes;
        childGCDataMap.set(childId, childGCData);
    }
    return childGCDataMap;
}
/**
 * Removes the given route from the outbound routes of all the given GC nodes.
 * @param gcNodes - The nodes from which the route is to be removed.
 * @param outboundRoute - The route to be removed.
 */
function removeRouteFromAllNodes(gcNodes, outboundRoute) {
    for (const outboundRoutes of Object.values(gcNodes)) {
        const index = outboundRoutes.indexOf(outboundRoute);
        if (index > -1) {
            outboundRoutes.splice(index, 1);
        }
    }
}
class GCDataBuilder {
    constructor() {
        this.gcNodes = {};
    }
    addNode(id, outboundRoutes) {
        this.gcNodes[id] = outboundRoutes;
    }
    /**
     * Adds the given GC nodes. It does the following:
     * - Normalizes the ids of the given nodes.
     * - Prefixes the given `prefixId` to the given nodes' ids.
     * - Adds the outbound routes of the nodes against the normalized and prefixed id.
     */
    prefixAndAddNodes(prefixId, gcNodes) {
        for (const [id, outboundRoutes] of Object.entries(gcNodes)) {
            let normalizedId = id;
            // Remove any starting slashes from the id.
            while (normalizedId.startsWith("/")) {
                normalizedId = normalizedId.substr(1);
            }
            // Prefix the given id to the normalized id.
            normalizedId = `/${prefixId}/${normalizedId}`;
            // Remove any trailing slashes from the normalized id.
            while (normalizedId.endsWith("/")) {
                normalizedId = normalizedId.substr(0, normalizedId.length - 1);
            }
            // Add the outbound routes against the normalized and prefixed id.
            this.gcNodes[normalizedId] = outboundRoutes;
        }
    }
    /**
     * Adds the given outbound route to the outbound routes of all GC nodes.
     */
    addRouteToAllNodes(outboundRoute) {
        for (const outboundRoutes of Object.values(this.gcNodes)) {
            outboundRoutes.push(outboundRoute);
        }
    }
    getGCData() {
        return {
            gcNodes: this.gcNodes,
        };
    }
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/map/lib/debug.js":
/*!***********************************************************!*\
  !*** ../../node_modules/@fluidframework/map/lib/debug.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debug": () => (/* binding */ debug)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "../../node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packageVersion */ "../../node_modules/@fluidframework/map/lib/packageVersion.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


const debug = debug__WEBPACK_IMPORTED_MODULE_0___default()("fluid:map");
debug(`Package: ${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgName} - Version: ${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgVersion}`);
//# sourceMappingURL=debug.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/map/lib/directory.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@fluidframework/map/lib/directory.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DirectoryFactory": () => (/* binding */ DirectoryFactory),
/* harmony export */   "SharedDirectory": () => (/* binding */ SharedDirectory)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/typedEventEmitter.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/readAndParse.js");
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/protocol-base */ "../../node_modules/@fluidframework/protocol-base/lib/blobs.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/protocol.js");
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/shared-object-base */ "../../node_modules/@fluidframework/shared-object-base/lib/sharedObject.js");
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @fluidframework/shared-object-base */ "../../node_modules/@fluidframework/shared-object-base/lib/valueType.js");
/* harmony import */ var path_browserify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path-browserify */ "../../node_modules/path-browserify/index.js");
/* harmony import */ var path_browserify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path_browserify__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./debug */ "../../node_modules/@fluidframework/map/lib/debug.js");
/* harmony import */ var _localValues__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./localValues */ "../../node_modules/@fluidframework/map/lib/localValues.js");
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./packageVersion */ "../../node_modules/@fluidframework/map/lib/packageVersion.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */









// We use path-browserify since this code can run safely on the server or the browser.
// We standardize on using posix slashes everywhere.
const posix = path_browserify__WEBPACK_IMPORTED_MODULE_0__.posix;
const snapshotFileName = "header";
function serializeDirectory(absolutePath, root, serializer) {
    const MinValueSizeSeparateSnapshotBlob = 8 * 1024;
    const tree = { entries: [] };
    let counter = 0;
    const blobs = [];
    const stack = [];
    const content = {};
    stack.push([root, content]);
    while (stack.length > 0) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const [currentSubDir, currentSubDirObject] = stack.pop();
        for (const [key, value] of currentSubDir.getSerializedStorage(serializer)) {
            if (!currentSubDirObject.storage) {
                currentSubDirObject.storage = {};
            }
            const result = {
                type: value.type,
                // eslint-disable-next-line @typescript-eslint/ban-types
                value: value.value && JSON.parse(value.value),
            };
            if (value.value && value.value.length >= MinValueSizeSeparateSnapshotBlob) {
                const extraContent = {};
                let largeContent = extraContent;
                if (currentSubDir.absolutePath !== posix.sep) {
                    for (const dir of currentSubDir.absolutePath.substr(1).split(posix.sep)) {
                        const subDataObject = {};
                        largeContent.subdirectories = { [dir]: subDataObject };
                        largeContent = subDataObject;
                    }
                }
                largeContent.storage = { [key]: result };
                const blobName = `blob${counter}`;
                counter++;
                blobs.push(blobName);
                (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_1__.addBlobToTree)(tree, blobName, extraContent);
            }
            else {
                currentSubDirObject.storage[key] = result;
            }
        }
        for (const [subdirName, subdir] of currentSubDir.subdirectories()) {
            if (!currentSubDirObject.subdirectories) {
                currentSubDirObject.subdirectories = {};
            }
            const subDataObject = {};
            currentSubDirObject.subdirectories[subdirName] = subDataObject;
            stack.push([subdir, subDataObject]);
        }
    }
    const newFormat = {
        absolutePath,
        blobs,
        content,
    };
    (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_1__.addBlobToTree)(tree, snapshotFileName, newFormat);
    return tree;
}
/**
 * The factory that defines the directory.
 * @sealed
 */
class DirectoryFactory {
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory."type"}
     */
    get type() {
        return DirectoryFactory.Type;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}
     */
    get attributes() {
        return DirectoryFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     */
    async load(runtime, id, services, attributes) {
        const directory = new SharedDirectory(id, runtime, attributes);
        await directory.load(services);
        return directory;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.create}
     */
    create(runtime, id) {
        const directory = new SharedDirectory(id, runtime, DirectoryFactory.Attributes);
        directory.initializeLocal();
        return directory;
    }
}
/**
 * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory."type"}
 */
DirectoryFactory.Type = "https://graph.microsoft.com/types/directory";
/**
 * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}
 */
DirectoryFactory.Attributes = {
    type: DirectoryFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_2__.pkgVersion,
};
/**
 * SharedDirectory provides a hierarchical organization of map-like data structures as SubDirectories.
 * The values stored within can be accessed like a map, and the hierarchy can be navigated using path syntax.
 * SubDirectories can be retrieved for use as working directories.
 *
 * @example
 * ```ts
 * mySharedDirectory.createSubDirectory("a").createSubDirectory("b").createSubDirectory("c").set("foo", val1);
 * const mySubDir = mySharedDirectory.getWorkingDirectory("/a/b/c");
 * mySubDir.get("foo"); // returns val1
 * ```
 *
 * @sealed
 */
class SharedDirectory extends _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_3__.SharedObject {
    /**
     * Constructs a new shared directory. If the object is non-local an id and service interfaces will
     * be provided.
     * @param id - String identifier for the SharedDirectory
     * @param runtime - Data store runtime
     * @param type - Type identifier
     */
    constructor(id, runtime, attributes) {
        super(id, runtime, attributes);
        /**
         * String representation for the class.
         */
        this[Symbol.toStringTag] = "SharedDirectory";
        /**
         * Root of the SharedDirectory, most operations on the SharedDirectory itself act on the root.
         */
        this.root = new SubDirectory(this, this.runtime, this.serializer, posix.sep);
        /**
         * Mapping of op types to message handlers.
         */
        this.messageHandlers = new Map();
        this.localValueMaker = new _localValues__WEBPACK_IMPORTED_MODULE_4__.LocalValueMaker(this.serializer);
        this.setMessageHandlers();
        // Mirror the containedValueChanged op on the SharedDirectory
        this.root.on("containedValueChanged", (changed, local) => {
            this.emit("containedValueChanged", changed, local, this);
        });
    }
    /**
     * Create a new shared directory
     *
     * @param runtime - Data store runtime the new shared directory belongs to
     * @param id - Optional name of the shared directory
     * @returns Newly create shared directory (but not attached yet)
     */
    static create(runtime, id) {
        return runtime.createChannel(id, DirectoryFactory.Type);
    }
    /**
     * Get a factory for SharedDirectory to register with the data store.
     *
     * @returns A factory that creates and load SharedDirectory
     */
    static getFactory() {
        return new DirectoryFactory();
    }
    /**
     * {@inheritDoc IDirectory.absolutePath}
     */
    get absolutePath() {
        return this.root.absolutePath;
    }
    /**
     * {@inheritDoc IDirectory.get}
     */
    get(key) {
        return this.root.get(key);
    }
    /**
     * {@inheritDoc IDirectory.wait}
     */
    async wait(key) {
        return this.root.wait(key);
    }
    /**
     * {@inheritDoc IDirectory.set}
     */
    set(key, value) {
        this.root.set(key, value);
        return this;
    }
    /**
     * Deletes the given key from within this IDirectory.
     * @param key - The key to delete
     * @returns True if the key existed and was deleted, false if it did not exist
     */
    delete(key) {
        return this.root.delete(key);
    }
    /**
     * Deletes all keys from within this IDirectory.
     */
    clear() {
        this.root.clear();
    }
    /**
     * Checks whether the given key exists in this IDirectory.
     * @param key - The key to check
     * @returns True if the key exists, false otherwise
     */
    has(key) {
        return this.root.has(key);
    }
    /**
     * The number of entries under this IDirectory.
     */
    get size() {
        return this.root.size;
    }
    /**
     * Issue a callback on each entry under this IDirectory.
     * @param callback - Callback to issue
     */
    forEach(callback) {
        this.root.forEach(callback);
    }
    /**
     * Get an iterator over the entries under this IDirectory.
     * @returns The iterator
     */
    [Symbol.iterator]() {
        return this.root[Symbol.iterator]();
    }
    /**
     * Get an iterator over the entries under this IDirectory.
     * @returns The iterator
     */
    entries() {
        return this.root.entries();
    }
    /**
     * Get an iterator over the keys under this IDirectory.
     * @returns The iterator
     */
    keys() {
        return this.root.keys();
    }
    /**
     * Get an iterator over the values under this IDirectory.
     * @returns The iterator
     */
    values() {
        return this.root.values();
    }
    /**
     * {@inheritDoc IDirectory.createSubDirectory}
     */
    createSubDirectory(subdirName) {
        return this.root.createSubDirectory(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.getSubDirectory}
     */
    getSubDirectory(subdirName) {
        return this.root.getSubDirectory(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.hasSubDirectory}
     */
    hasSubDirectory(subdirName) {
        return this.root.hasSubDirectory(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.deleteSubDirectory}
     */
    deleteSubDirectory(subdirName) {
        return this.root.deleteSubDirectory(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.subdirectories}
     */
    subdirectories() {
        return this.root.subdirectories();
    }
    /**
     * {@inheritDoc IDirectory.getWorkingDirectory}
     */
    getWorkingDirectory(relativePath) {
        const absolutePath = this.makeAbsolute(relativePath);
        if (absolutePath === posix.sep) {
            return this.root;
        }
        let currentSubDir = this.root;
        const subdirs = absolutePath.substr(1).split(posix.sep);
        for (const subdir of subdirs) {
            currentSubDir = currentSubDir.getSubDirectory(subdir);
            if (!currentSubDir) {
                return undefined;
            }
        }
        return currentSubDir;
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.snapshotCore}
     */
    snapshotCore(serializer) {
        return serializeDirectory(this.handle.absolutePath, this.root, serializer);
    }
    /**
     * Submits an operation
     * @param op - Op to submit
     * @param localOpMetadata - The local metadata associated with the op. We send a unique id that is used to track
     * this op while it has not been ack'd. This will be sent when we receive this op back from the server.
     * @internal
     */
    submitDirectoryMessage(op, localOpMetadata) {
        this.submitLocalMessage(op, localOpMetadata);
    }
    /**
     * Create an emitter for a value type to emit ops from the given key and path.
     * @param key - The key of the directory that the value type will be stored on
     * @param absolutePath - The absolute path of the subdirectory storing the value type
     * @returns A value op emitter for the given key and path
     * @internal
     */
    makeDirectoryValueOpEmitter(key, absolutePath) {
        const emit = (opName, previousValue, params) => {
            const op = {
                key,
                path: absolutePath,
                type: "act",
                value: {
                    opName,
                    value: params,
                },
            };
            // Send the localOpMetadata as undefined because we don't care about the ack.
            this.submitDirectoryMessage(op, undefined /* localOpMetadata */);
            const event = { key, path: absolutePath, previousValue };
            this.emit("valueChanged", event, true, null, this);
        };
        return { emit };
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.onDisconnect}
     */
    onDisconnect() {
        (0,_debug__WEBPACK_IMPORTED_MODULE_5__.debug)(`Directory ${this.id} is now disconnected`);
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.reSubmitCore}
     */
    reSubmitCore(content, localOpMetadata) {
        const message = content;
        const handler = this.messageHandlers.get(message.type);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(handler !== undefined, 0x00d /* `Missing message handler for message type: ${message.type}` */);
        handler.submit(message, localOpMetadata);
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}
     */
    async loadCore(storage) {
        const data = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_7__.readAndParse)(storage, snapshotFileName);
        const newFormat = data;
        if (Array.isArray(newFormat.blobs)) {
            // New storage format
            this.populate(newFormat.content);
            await Promise.all(newFormat.blobs.map(async (value) => {
                const dataExtra = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_7__.readAndParse)(storage, value);
                this.populate(dataExtra);
            }));
        }
        else {
            // Old storage format
            this.populate(data);
        }
    }
    /**
     * Populate the directory with the given directory data.
     * @param data - A JSON string containing serialized directory data
     * @internal
     */
    populate(data) {
        const stack = [];
        stack.push([this.root, data]);
        while (stack.length > 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const [currentSubDir, currentSubDirObject] = stack.pop();
            if (currentSubDirObject.subdirectories) {
                for (const [subdirName, subdirObject] of Object.entries(currentSubDirObject.subdirectories)) {
                    let newSubDir = currentSubDir.getSubDirectory(subdirName);
                    if (!newSubDir) {
                        newSubDir = new SubDirectory(this, this.runtime, this.serializer, posix.join(currentSubDir.absolutePath, subdirName));
                        currentSubDir.populateSubDirectory(subdirName, newSubDir);
                    }
                    stack.push([newSubDir, subdirObject]);
                }
            }
            if (currentSubDirObject.storage) {
                for (const [key, serializable] of Object.entries(currentSubDirObject.storage)) {
                    const localValue = this.makeLocal(key, currentSubDir.absolutePath, serializable);
                    currentSubDir.populateStorage(key, localValue);
                }
            }
        }
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.registerCore}
     */
    registerCore() {
        const subdirsToRegisterFrom = new Array();
        subdirsToRegisterFrom.push(this.root);
        for (const currentSubDir of subdirsToRegisterFrom) {
            for (const value of currentSubDir.values()) {
                if (_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_3__.SharedObject.is(value)) {
                    value.bindToContext();
                }
            }
            for (const [, subdir] of currentSubDir.subdirectories()) {
                subdirsToRegisterFrom.push(subdir);
            }
        }
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.processCore}
     */
    processCore(message, local, localOpMetadata) {
        if (message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_8__.MessageType.Operation) {
            const op = message.contents;
            const handler = this.messageHandlers.get(op.type);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(handler !== undefined, 0x00e /* `Missing message handler for message type: ${message.type}` */);
            handler.process(op, local, message, localOpMetadata);
        }
    }
    /**
     * Converts the given relative path to absolute against the root.
     * @param relativePath - The path to convert
     */
    makeAbsolute(relativePath) {
        return posix.resolve(posix.sep, relativePath);
    }
    /**
     * The remote ISerializableValue we're receiving (either as a result of a snapshot load or an incoming set op)
     * will have the information we need to create a real object, but will not be the real object yet.  For example,
     * we might know it's a map and the ID but not have the actual map or its data yet.  makeLocal's job
     * is to convert that information into a real object for local usage.
     * @param key - Key of element being converted
     * @param absolutePath - Path of element being converted
     * @param serializable - The remote information that we can convert into a real object
     * @returns The local value that was produced
     */
    makeLocal(key, absolutePath, serializable) {
        if (serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_9__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_9__.ValueType.Plain] || serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_9__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_9__.ValueType.Shared]) {
            return this.localValueMaker.fromSerializable(serializable);
        }
        else {
            return this.localValueMaker.fromSerializableValueType(serializable, this.makeDirectoryValueOpEmitter(key, absolutePath));
        }
    }
    /**
     * Set the message handlers for the directory.
     */
    setMessageHandlers() {
        this.messageHandlers.set("clear", {
            process: (op, local, message, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    subdir.processClearMessage(op, local, message, localOpMetadata);
                }
            },
            submit: (op, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    // We don't reuse the metadata but send a new one on each submit.
                    subdir.submitClearMessage(op);
                }
            },
        });
        this.messageHandlers.set("delete", {
            process: (op, local, message, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    subdir.processDeleteMessage(op, local, message, localOpMetadata);
                }
            },
            submit: (op, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    // We don't reuse the metadata but send a new one on each submit.
                    subdir.submitKeyMessage(op);
                }
            },
        });
        this.messageHandlers.set("set", {
            process: (op, local, message, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    const context = local ? undefined : this.makeLocal(op.key, op.path, op.value);
                    subdir.processSetMessage(op, context, local, message, localOpMetadata);
                }
            },
            submit: (op, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    // We don't reuse the metadata but send a new one on each submit.
                    subdir.submitKeyMessage(op);
                }
            },
        });
        this.messageHandlers.set("createSubDirectory", {
            process: (op, local, message, localOpMetadata) => {
                const parentSubdir = this.getWorkingDirectory(op.path);
                if (parentSubdir) {
                    parentSubdir.processCreateSubDirectoryMessage(op, local, message, localOpMetadata);
                }
            },
            submit: (op, localOpMetadata) => {
                const parentSubdir = this.getWorkingDirectory(op.path);
                if (parentSubdir) {
                    // We don't reuse the metadata but send a new one on each submit.
                    parentSubdir.submitSubDirectoryMessage(op);
                }
            },
        });
        this.messageHandlers.set("deleteSubDirectory", {
            process: (op, local, message, localOpMetadata) => {
                const parentSubdir = this.getWorkingDirectory(op.path);
                if (parentSubdir) {
                    parentSubdir.processDeleteSubDirectoryMessage(op, local, message, localOpMetadata);
                }
            },
            submit: (op, localOpMetadata) => {
                const parentSubdir = this.getWorkingDirectory(op.path);
                if (parentSubdir) {
                    // We don't reuse the metadata but send a new one on each submit.
                    parentSubdir.submitSubDirectoryMessage(op);
                }
            },
        });
        // Ops with type "act" describe actions taken by custom value type handlers of whatever item is
        // being addressed.  These custom handlers can be retrieved from the ValueTypeLocalValue which has
        // stashed its valueType (and therefore its handlers).  We also emit a valueChanged for anyone
        // watching for manipulations of that item.
        this.messageHandlers.set("act", {
            process: (op, local, message, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                // Subdir might not exist if we deleted it
                if (!subdir) {
                    return;
                }
                const localValue = subdir.getLocalValue(op.key);
                // Local value might not exist if we deleted it
                if (!localValue) {
                    return;
                }
                const handler = localValue.getOpHandler(op.value.opName);
                const previousValue = localValue.value;
                const translatedValue = this.serializer.parse(JSON.stringify(op.value.value));
                handler.process(previousValue, translatedValue, local, message);
                const event = { key: op.key, path: op.path, previousValue };
                this.emit("valueChanged", event, local, message, this);
            },
            submit: (op, localOpMetadata) => {
                this.submitDirectoryMessage(op, localOpMetadata);
            },
        });
    }
    applyStashedOp() {
        throw new Error("not implemented");
    }
}
/**
 * Node of the directory tree.
 * @sealed
 */
class SubDirectory extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_10__.TypedEventEmitter {
    /**
     * Constructor.
     * @param directory - Reference back to the SharedDirectory to perform operations
     * @param runtime - The data store runtime this directory is associated with
     * @param serializer - The serializer to serialize / parse handles
     * @param absolutePath - The absolute path of this IDirectory
     */
    constructor(directory, runtime, serializer, absolutePath) {
        super();
        this.directory = directory;
        this.runtime = runtime;
        this.serializer = serializer;
        this.absolutePath = absolutePath;
        /**
         * String representation for the class.
         */
        this[Symbol.toStringTag] = "SubDirectory";
        /**
         * The in-memory data the directory is storing.
         */
        this._storage = new Map();
        /**
         * The subdirectories the directory is holding.
         */
        this._subdirectories = new Map();
        /**
         * Keys that have been modified locally but not yet ack'd from the server.
         */
        this.pendingKeys = new Map();
        /**
         * Subdirectories that have been modified locally but not yet ack'd from the server.
         */
        this.pendingSubDirectories = new Map();
        /**
         * This is used to assign a unique id to every outgoing operation and helps in tracking unack'd ops.
         */
        this.pendingMessageId = -1;
        /**
         * If a clear has been performed locally but not yet ack'd from the server, then this stores the pending id
         * of that clear operation. Otherwise, is -1.
         */
        this.pendingClearMessageId = -1;
    }
    /**
     * Checks whether the given key exists in this IDirectory.
     * @param key - The key to check
     * @returns True if the key exists, false otherwise
     */
    has(key) {
        return this._storage.has(key);
    }
    /**
     * {@inheritDoc IDirectory.get}
     */
    get(key) {
        var _a;
        return (_a = this._storage.get(key)) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * {@inheritDoc IDirectory.wait}
     */
    async wait(key) {
        // Return immediately if the value already exists
        if (this._storage.has(key)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this._storage.get(key).value;
        }
        // Otherwise subscribe to changes
        return new Promise((resolve, reject) => {
            const callback = (changed) => {
                if (this.absolutePath === changed.path && key === changed.key) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    resolve(this._storage.get(key).value);
                    this.directory.removeListener("valueChanged", callback);
                }
            };
            this.directory.on("valueChanged", callback);
        });
    }
    /**
     * {@inheritDoc IDirectory.set}
     */
    set(key, value) {
        // Undefined/null keys can't be serialized to JSON in the manner we currently snapshot.
        if (key === undefined || key === null) {
            throw new Error("Undefined and null keys are not supported");
        }
        // Create a local value and serialize it.
        const localValue = this.directory.localValueMaker.fromInMemory(value);
        const serializableValue = (0,_localValues__WEBPACK_IMPORTED_MODULE_4__.makeSerializable)(localValue, this.serializer, this.directory.handle);
        // Set the value locally.
        this.setCore(key, localValue, true, null);
        // If we are not attached, don't submit the op.
        if (!this.directory.isAttached()) {
            return this;
        }
        const op = {
            key,
            path: this.absolutePath,
            type: "set",
            value: serializableValue,
        };
        this.submitKeyMessage(op);
        return this;
    }
    /**
     * {@inheritDoc IDirectory.createSubDirectory}
     */
    createSubDirectory(subdirName) {
        // Undefined/null subdirectory names can't be serialized to JSON in the manner we currently snapshot.
        if (subdirName === undefined || subdirName === null) {
            throw new Error("SubDirectory name may not be undefined or null");
        }
        if (subdirName.includes(posix.sep)) {
            throw new Error(`SubDirectory name may not contain ${posix.sep}`);
        }
        // Create the sub directory locally first.
        this.createSubDirectoryCore(subdirName, true, null);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const subDir = this._subdirectories.get(subdirName);
        // If we are not attached, don't submit the op.
        if (!this.directory.isAttached()) {
            return subDir;
        }
        const op = {
            path: this.absolutePath,
            subdirName,
            type: "createSubDirectory",
        };
        this.submitSubDirectoryMessage(op);
        return subDir;
    }
    /**
     * {@inheritDoc IDirectory.getSubDirectory}
     */
    getSubDirectory(subdirName) {
        return this._subdirectories.get(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.hasSubDirectory}
     */
    hasSubDirectory(subdirName) {
        return this._subdirectories.has(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.deleteSubDirectory}
     */
    deleteSubDirectory(subdirName) {
        // Delete the sub directory locally first.
        const successfullyRemoved = this.deleteSubDirectoryCore(subdirName, true, null);
        // If we are not attached, don't submit the op.
        if (!this.directory.isAttached()) {
            return successfullyRemoved;
        }
        const op = {
            path: this.absolutePath,
            subdirName,
            type: "deleteSubDirectory",
        };
        this.submitSubDirectoryMessage(op);
        return successfullyRemoved;
    }
    /**
     * {@inheritDoc IDirectory.subdirectories}
     */
    subdirectories() {
        return this._subdirectories.entries();
    }
    /**
     * {@inheritDoc IDirectory.getWorkingDirectory}
     */
    getWorkingDirectory(relativePath) {
        return this.directory.getWorkingDirectory(this.makeAbsolute(relativePath));
    }
    /**
     * Deletes the given key from within this IDirectory.
     * @param key - The key to delete
     * @returns True if the key existed and was deleted, false if it did not exist
     */
    delete(key) {
        // Delete the key locally first.
        const successfullyRemoved = this.deleteCore(key, true, null);
        // If we are not attached, don't submit the op.
        if (!this.directory.isAttached()) {
            return successfullyRemoved;
        }
        const op = {
            key,
            path: this.absolutePath,
            type: "delete",
        };
        this.submitKeyMessage(op);
        return successfullyRemoved;
    }
    /**
     * Deletes all keys from within this IDirectory.
     */
    clear() {
        // Clear the data locally first.
        this.clearCore(true, null);
        // If we are not attached, don't submit the op.
        if (!this.directory.isAttached()) {
            return;
        }
        const op = {
            path: this.absolutePath,
            type: "clear",
        };
        this.submitClearMessage(op);
    }
    /**
     * Issue a callback on each entry under this IDirectory.
     * @param callback - Callback to issue
     */
    forEach(callback) {
        this._storage.forEach((localValue, key, map) => {
            callback(localValue.value, key, map);
        });
    }
    /**
     * The number of entries under this IDirectory.
     */
    get size() {
        return this._storage.size;
    }
    /**
     * Get an iterator over the entries under this IDirectory.
     * @returns The iterator
     */
    entries() {
        const localEntriesIterator = this._storage.entries();
        const iterator = {
            next() {
                const nextVal = localEntriesIterator.next();
                if (nextVal.done) {
                    return { value: undefined, done: true };
                }
                else {
                    // Unpack the stored value
                    return { value: [nextVal.value[0], nextVal.value[1].value], done: false };
                }
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     * Get an iterator over the keys under this IDirectory.
     * @returns The iterator
     */
    keys() {
        return this._storage.keys();
    }
    /**
     * Get an iterator over the values under this IDirectory.
     * @returns The iterator
     */
    values() {
        const localValuesIterator = this._storage.values();
        const iterator = {
            next() {
                const nextVal = localValuesIterator.next();
                if (nextVal.done) {
                    return { value: undefined, done: true };
                }
                else {
                    // Unpack the stored value
                    return { value: nextVal.value.value, done: false };
                }
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     * Get an iterator over the entries under this IDirectory.
     * @returns The iterator
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * Process a clear operation.
     * @param op - The op to process
     * @param local - Whether the message originated from the local client
     * @param message - The message
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @internal
     */
    processClearMessage(op, local, message, localOpMetadata) {
        if (local) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(localOpMetadata !== undefined, 0x00f /* `pendingMessageId is missing from the local client's ${op.type} operation` */);
            const pendingMessageId = localOpMetadata;
            if (this.pendingClearMessageId === pendingMessageId) {
                this.pendingClearMessageId = -1;
            }
            return;
        }
        this.clearExceptPendingKeys();
        this.directory.emit("clear", local, op, this.directory);
    }
    /**
     * Process a delete operation.
     * @param op - The op to process
     * @param local - Whether the message originated from the local client
     * @param message - The message
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @internal
     */
    processDeleteMessage(op, local, message, localOpMetadata) {
        if (!this.needProcessStorageOperation(op, local, message, localOpMetadata)) {
            return;
        }
        this.deleteCore(op.key, local, message);
    }
    /**
     * Process a set operation.
     * @param op - The op to process
     * @param local - Whether the message originated from the local client
     * @param message - The message
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @internal
     */
    processSetMessage(op, context, local, message, localOpMetadata) {
        if (!this.needProcessStorageOperation(op, local, message, localOpMetadata)) {
            return;
        }
        // needProcessStorageOperation should have returned false if local is true
        // so we can assume context is not undefined
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.setCore(op.key, context, local, message);
    }
    /**
     * Process a create subdirectory operation.
     * @param op - The op to process
     * @param local - Whether the message originated from the local client
     * @param message - The message
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @internal
     */
    processCreateSubDirectoryMessage(op, local, message, localOpMetadata) {
        if (!this.needProcessSubDirectoryOperations(op, local, message, localOpMetadata)) {
            return;
        }
        this.createSubDirectoryCore(op.subdirName, local, message);
    }
    /**
     * Process a delete subdirectory operation.
     * @param op - The op to process
     * @param local - Whether the message originated from the local client
     * @param message - The message
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @internal
     */
    processDeleteSubDirectoryMessage(op, local, message, localOpMetadata) {
        if (!this.needProcessSubDirectoryOperations(op, local, message, localOpMetadata)) {
            return;
        }
        this.deleteSubDirectoryCore(op.subdirName, local, message);
    }
    /**
     * Submit a clear operation.
     * @param op - The operation
     * @internal
     */
    submitClearMessage(op) {
        const pendingMessageId = ++this.pendingMessageId;
        this.directory.submitDirectoryMessage(op, pendingMessageId);
        this.pendingClearMessageId = pendingMessageId;
    }
    /**
     * Submit a key operation.
     * @param op - The operation
     * @internal
     */
    submitKeyMessage(op) {
        const pendingMessageId = ++this.pendingMessageId;
        this.directory.submitDirectoryMessage(op, pendingMessageId);
        this.pendingKeys.set(op.key, pendingMessageId);
    }
    /**
     * Submit a subdirectory operation.
     * @param op - The operation
     * @internal
     */
    submitSubDirectoryMessage(op) {
        const pendingMessageId = ++this.pendingMessageId;
        this.directory.submitDirectoryMessage(op, pendingMessageId);
        this.pendingSubDirectories.set(op.subdirName, pendingMessageId);
    }
    /**
     * Get the storage of this subdirectory in a serializable format, to be used in snapshotting.
     * @param serializer - The serializer to use to serialize handles in its values.
     * @returns The JSONable string representing the storage of this subdirectory
     * @internal
     */
    *getSerializedStorage(serializer) {
        for (const [key, localValue] of this._storage) {
            const value = localValue.makeSerialized(serializer, this.directory.handle);
            const res = [key, value];
            yield res;
        }
    }
    /**
     * Populate a key value in this subdirectory's storage, to be used when loading from snapshot.
     * @param key - The key to populate
     * @param localValue - The local value to populate into it
     * @internal
     */
    populateStorage(key, localValue) {
        this._storage.set(key, localValue);
    }
    /**
     * Populate a subdirectory into this subdirectory, to be used when loading from snapshot.
     * @param subdirName - The name of the subdirectory to add
     * @param newSubDir - The new subdirectory to add
     * @internal
     */
    populateSubDirectory(subdirName, newSubDir) {
        this._subdirectories.set(subdirName, newSubDir);
    }
    /**
     * Retrieve the local value at the given key.  This is used to get value type information stashed on the local
     * value so op handlers can be retrieved
     * @param key - The key to retrieve from
     * @returns The local value
     * @internal
     */
    getLocalValue(key) {
        return this._storage.get(key);
    }
    /**
     * Converts the given relative path into an absolute path.
     * @param path - Relative path to convert
     * @returns The equivalent absolute path
     */
    makeAbsolute(relativePath) {
        return posix.resolve(this.absolutePath, relativePath);
    }
    /**
     * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should
     * not process the incoming operation.
     * @param op - Operation to check
     * @param local - Whether the message originated from the local client
     * @param message - The message
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @returns True if the operation should be processed, false otherwise
     */
    needProcessStorageOperation(op, local, message, localOpMetadata) {
        if (this.pendingClearMessageId !== -1) {
            if (local) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(localOpMetadata !== undefined && localOpMetadata < this.pendingClearMessageId, 0x010 /* "Received out of order storage op when there is an unackd clear message" */);
            }
            // If I have a NACK clear, we can ignore all ops.
            return false;
        }
        if (this.pendingKeys.has(op.key)) {
            // Found an NACK op, clear it from the directory if the latest sequence number in the directory
            // match the message's and don't process the op.
            if (local) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(localOpMetadata !== undefined, 0x011 /* `pendingMessageId is missing from the local client's ${op.type} operation` */);
                const pendingMessageId = localOpMetadata;
                const pendingKeyMessageId = this.pendingKeys.get(op.key);
                if (pendingKeyMessageId === pendingMessageId) {
                    this.pendingKeys.delete(op.key);
                }
            }
            return false;
        }
        // If we don't have a NACK op on the key, we need to process the remote ops.
        return !local;
    }
    /**
     * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should
     * not process the incoming operation.
     * @param op - Operation to check
     * @param local - Whether the message originated from the local client
     * @param message - The message
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @returns True if the operation should be processed, false otherwise
     */
    needProcessSubDirectoryOperations(op, local, message, localOpMetadata) {
        if (this.pendingSubDirectories.has(op.subdirName)) {
            if (local) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(localOpMetadata !== undefined, 0x012 /* `pendingMessageId is missing from the local client's ${op.type} operation` */);
                const pendingMessageId = localOpMetadata;
                const pendingSubDirectoryMessageId = this.pendingSubDirectories.get(op.subdirName);
                if (pendingSubDirectoryMessageId === pendingMessageId) {
                    this.pendingSubDirectories.delete(op.subdirName);
                }
            }
            return false;
        }
        return !local;
    }
    /**
     * Clear all keys in memory in response to a remote clear, but retain keys we have modified but not yet been ack'd.
     */
    clearExceptPendingKeys() {
        // Assuming the pendingKeys is small and the map is large
        // we will get the value for the pendingKeys and clear the map
        const temp = new Map();
        this.pendingKeys.forEach((value, key, map) => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            temp.set(key, this._storage.get(key));
        });
        this._storage.clear();
        temp.forEach((value, key, map) => {
            this._storage.set(key, value);
        });
    }
    /**
     * Clear implementation used for both locally sourced clears as well as incoming remote clears.
     * @param local - Whether the message originated from the local client
     * @param op - The message if from a remote clear, or null if from a local clear
     */
    clearCore(local, op) {
        this._storage.clear();
        this.directory.emit("clear", local, op, this.directory);
    }
    /**
     * Delete implementation used for both locally sourced deletes as well as incoming remote deletes.
     * @param key - The key being deleted
     * @param local - Whether the message originated from the local client
     * @param op - The message if from a remote delete, or null if from a local delete
     * @returns True if the key existed and was deleted, false if it did not exist
     */
    deleteCore(key, local, op) {
        const previousValue = this.get(key);
        const successfullyRemoved = this._storage.delete(key);
        if (successfullyRemoved) {
            const event = { key, path: this.absolutePath, previousValue };
            this.directory.emit("valueChanged", event, local, op, this.directory);
            const containedEvent = { key, previousValue };
            this.emit("containedValueChanged", containedEvent, local, this);
        }
        return successfullyRemoved;
    }
    /**
     * Set implementation used for both locally sourced sets as well as incoming remote sets.
     * @param key - The key being set
     * @param value - The value being set
     * @param local - Whether the message originated from the local client
     * @param op - The message if from a remote set, or null if from a local set
     */
    setCore(key, value, local, op) {
        const previousValue = this.get(key);
        this._storage.set(key, value);
        const event = { key, path: this.absolutePath, previousValue };
        this.directory.emit("valueChanged", event, local, op, this.directory);
        const containedEvent = { key, previousValue };
        this.emit("containedValueChanged", containedEvent, local, this);
    }
    /**
     * Create subdirectory implementation used for both locally sourced creation as well as incoming remote creation.
     * @param subdirName - The name of the subdirectory being created
     * @param local - Whether the message originated from the local client
     * @param op - The message if from a remote create, or null if from a local create
     */
    createSubDirectoryCore(subdirName, local, op) {
        if (!this._subdirectories.has(subdirName)) {
            this._subdirectories.set(subdirName, new SubDirectory(this.directory, this.runtime, this.serializer, posix.join(this.absolutePath, subdirName)));
        }
    }
    /**
     * Delete subdirectory implementation used for both locally sourced creation as well as incoming remote creation.
     * @param subdirName - The name of the subdirectory being deleted
     * @param local - Whether the message originated from the local client
     * @param op - The message if from a remote delete, or null if from a local delete
     */
    deleteSubDirectoryCore(subdirName, local, op) {
        // This should make the subdirectory structure unreachable so it can be GC'd and won't appear in snapshots
        // Might want to consider cleaning out the structure more exhaustively though?
        return this._subdirectories.delete(subdirName);
    }
}
//# sourceMappingURL=directory.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/map/lib/localValues.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@fluidframework/map/lib/localValues.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeSerializable": () => (/* binding */ makeSerializable),
/* harmony export */   "LocalValueMaker": () => (/* binding */ LocalValueMaker)
/* harmony export */ });
/* unused harmony exports PlainLocalValue, ValueTypeLocalValue */
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/shared-object-base */ "../../node_modules/@fluidframework/shared-object-base/lib/valueType.js");
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/shared-object-base */ "../../node_modules/@fluidframework/shared-object-base/lib/utils.js");
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/shared-object-base */ "../../node_modules/@fluidframework/shared-object-base/lib/sharedObject.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

function makeSerializable(localValue, serializer, bind) {
    const value = localValue.makeSerialized(serializer, bind);
    return {
        type: value.type,
        value: value.value && JSON.parse(value.value),
    };
}
/**
 * Manages a contained plain value.  May also contain shared object handles.
 */
class PlainLocalValue {
    /**
     * Create a new PlainLocalValue.
     * @param value - The value to store, which may contain shared object handles
     */
    constructor(value) {
        this.value = value;
    }
    /**
     * {@inheritDoc ILocalValue."type"}
     */
    get type() {
        return _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType.Plain];
    }
    /**
     * {@inheritDoc ILocalValue.makeSerialized}
     */
    makeSerialized(serializer, bind) {
        // Stringify to convert to the serialized handle values - and then parse in order to create
        // a POJO for the op
        const value = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.serializeHandles)(this.value, serializer, bind);
        return {
            type: this.type,
            value,
        };
    }
}
/**
 * Manages a contained value type.
 *
 * @privateRemarks
 * TODO: Should maybe be a generic
 *
 * @alpha
 */
class ValueTypeLocalValue {
    /**
     * Create a new ValueTypeLocalValue.
     * @param value - The instance of the value type stored within
     * @param valueType - The type object of the value type stored within
     */
    constructor(value, valueType) {
        this.value = value;
        this.valueType = valueType;
    }
    /**
     * {@inheritDoc ILocalValue."type"}
     */
    get type() {
        return this.valueType.name;
    }
    /**
     * {@inheritDoc ILocalValue.makeSerialized}
     */
    makeSerialized(serializer, bind) {
        const storedValueType = this.valueType.factory.store(this.value);
        const value = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.serializeHandles)(storedValueType, serializer, bind);
        return {
            type: this.type,
            value,
        };
    }
    /**
     * Get the handler for a given op of this value type.
     * @param opName - The name of the operation that needs processing
     * @returns The object which can process the given op
     */
    getOpHandler(opName) {
        const handler = this.valueType.ops.get(opName);
        if (!handler) {
            throw new Error("Unknown type message");
        }
        return handler;
    }
}
/**
 * A LocalValueMaker enables a container type DDS to produce and store local values with minimal awareness of how
 * those objects are stored, serialized, and deserialized.
 */
class LocalValueMaker {
    /**
     * Create a new LocalValueMaker.
     * @param serializer - The serializer to serialize / parse handles.
     */
    constructor(serializer) {
        this.serializer = serializer;
        /**
         * The value types this maker is able to produce.
         */
        this.valueTypes = new Map();
    }
    /**
     * Register a value type this maker will be able to produce.
     * @param type - The value type to register
     * @alpha
     */
    registerValueType(type) {
        this.valueTypes.set(type.name, type);
    }
    /**
     * Create a new local value from an incoming serialized value.
     * @param serializable - The serializable value to make local
     */
    fromSerializable(serializable) {
        // Migrate from old shared value to handles
        if (serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType.Shared]) {
            serializable.type = _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType.Plain];
            const handle = {
                type: "__fluid_handle__",
                url: serializable.value,
            };
            serializable.value = handle;
        }
        const translatedValue = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.parseHandles)(serializable.value, this.serializer);
        return new PlainLocalValue(translatedValue);
    }
    /**
     * Create a new local value from an incoming serialized value for value type
     * @param serializable - The serializable value to make local
     * @param emitter - The value op emitter, if the serializable is a value type
     */
    fromSerializableValueType(serializable, emitter) {
        if (this.valueTypes.has(serializable.type)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const valueType = this.valueTypes.get(serializable.type);
            serializable.value = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.parseHandles)(serializable.value, this.serializer);
            const localValue = valueType.factory.load(emitter, serializable.value);
            return new ValueTypeLocalValue(localValue, valueType);
        }
        else {
            throw new Error(`Unknown value type "${serializable.type}"`);
        }
    }
    /**
     * Create a new local value containing a given plain object.
     * @param value - The value to store
     * @returns An ILocalValue containing the value
     */
    fromInMemory(value) {
        if (_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.SharedObject.is(value)) {
            throw new Error("SharedObject sets are no longer supported. Instead set the SharedObject handle.");
        }
        return new PlainLocalValue(value);
    }
    /**
     * Create a new local value containing a value type.
     * @param type - The type of the value type to create
     * @param emitter - The IValueOpEmitter object that the new value type will use to emit ops
     * @param params - The initialization arguments for the value type
     * @returns An ILocalValue containing the new value type
     * @alpha
     */
    makeValueType(type, emitter, params) {
        const valueType = this.loadValueType(params, type, emitter);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return new ValueTypeLocalValue(valueType, this.valueTypes.get(type));
    }
    /**
     * Create a new value type.
     * @param params - The initialization arguments for the value type
     * @param type - The type of value type to create
     * @param emitter - The IValueOpEmitter object that the new value type will use to emit ops
     * @returns The new value type
     * @alpha
     */
    loadValueType(params, type, emitter) {
        const valueType = this.valueTypes.get(type);
        if (!valueType) {
            throw new Error(`Unknown type '${type}' specified`);
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return valueType.factory.load(emitter, params);
    }
}
//# sourceMappingURL=localValues.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/map/lib/map.js":
/*!*********************************************************!*\
  !*** ../../node_modules/@fluidframework/map/lib/map.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MapFactory": () => (/* binding */ MapFactory),
/* harmony export */   "SharedMap": () => (/* binding */ SharedMap)
/* harmony export */ });
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/protocol-base */ "../../node_modules/@fluidframework/protocol-base/lib/blobs.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/protocol.js");
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/driver-utils */ "../../node_modules/@fluidframework/driver-utils/lib/readAndParse.js");
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/shared-object-base */ "../../node_modules/@fluidframework/shared-object-base/lib/sharedObject.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./debug */ "../../node_modules/@fluidframework/map/lib/debug.js");
/* harmony import */ var _mapKernel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mapKernel */ "../../node_modules/@fluidframework/map/lib/mapKernel.js");
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./packageVersion */ "../../node_modules/@fluidframework/map/lib/packageVersion.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */







const snapshotFileName = "header";
/**
 * The factory that defines the map.
 * @sealed
 */
class MapFactory {
    /**
    * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory."type"}
    */
    get type() {
        return MapFactory.Type;
    }
    /**
    * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}
    */
    get attributes() {
        return MapFactory.Attributes;
    }
    /**
    * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
    */
    async load(runtime, id, services, attributes) {
        const map = new SharedMap(id, runtime, attributes);
        await map.load(services);
        return map;
    }
    /**
    * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.create}
    */
    create(runtime, id) {
        const map = new SharedMap(id, runtime, MapFactory.Attributes);
        map.initializeLocal();
        return map;
    }
}
/**
* {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory."type"}
*/
MapFactory.Type = "https://graph.microsoft.com/types/map";
/**
* {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}
*/
MapFactory.Attributes = {
    type: MapFactory.Type,
    snapshotFormatVersion: "0.2",
    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_0__.pkgVersion,
};
/**
 * The SharedMap distributed data structure can be used to store key-value pairs. It provides the same API for setting
 * and retrieving values that JavaScript developers are accustomed to with the
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map | Map} built-in object.
 * However, the keys of a SharedMap must be strings.
 */
class SharedMap extends _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.SharedObject {
    /**
    * Do not call the constructor. Instead, you should use the {@link SharedMap.create | create method}.
    *
    * @param id - String identifier.
    * @param runtime - Data store runtime.
    * @param attributes - The attributes for the map.
    */
    constructor(id, runtime, attributes) {
        super(id, runtime, attributes);
        /**
        * String representation for the class.
        */
        this[Symbol.toStringTag] = "SharedMap";
        this.kernel = new _mapKernel__WEBPACK_IMPORTED_MODULE_2__.MapKernel(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), () => this.isAttached(), [], this);
    }
    /**
     * Create a new shared map.
     * @param runtime - The data store runtime that the new shared map belongs to.
     * @param id - Optional name of the shared map.
     * @returns Newly created shared map.
     *
     * @example
     * To create a `SharedMap`, call the static create method:
     *
     * ```typescript
     * const myMap = SharedMap.create(this.runtime, id);
     * ```
     *
     */
    static create(runtime, id) {
        return runtime.createChannel(id, MapFactory.Type);
    }
    /**
     * Get a factory for SharedMap to register with the data store.
     * @returns A factory that creates SharedMaps and loads them from storage.
     */
    static getFactory() {
        return new MapFactory();
    }
    /**
    * {@inheritDoc MapKernel.keys}
    */
    keys() {
        return this.kernel.keys();
    }
    /**
    * {@inheritDoc MapKernel.entries}
    */
    entries() {
        return this.kernel.entries();
    }
    /**
    * {@inheritDoc MapKernel.values}
    */
    values() {
        return this.kernel.values();
    }
    /**
    * Get an iterator over the entries in this map.
    * @returns The iterator
    */
    [Symbol.iterator]() {
        return this.kernel.entries();
    }
    /**
    * {@inheritDoc MapKernel.size}
    */
    get size() {
        return this.kernel.size;
    }
    /**
    * {@inheritDoc MapKernel.forEach}
    */
    forEach(callbackFn) {
        this.kernel.forEach(callbackFn);
    }
    /**
    * {@inheritDoc ISharedMap.get}
    */
    get(key) {
        return this.kernel.get(key);
    }
    /**
    * {@inheritDoc ISharedMap.wait}
    */
    async wait(key) {
        return this.kernel.wait(key);
    }
    /**
    * {@inheritDoc MapKernel.has}
    */
    has(key) {
        return this.kernel.has(key);
    }
    /**
    * {@inheritDoc ISharedMap.set}
    */
    set(key, value) {
        this.kernel.set(key, value);
        return this;
    }
    /**
    * {@inheritDoc MapKernel.delete}
    */
    delete(key) {
        return this.kernel.delete(key);
    }
    /**
    * {@inheritDoc MapKernel.clear}
    */
    clear() {
        this.kernel.clear();
    }
    /**
    * {@inheritDoc @fluidframework/shared-object-base#SharedObject.snapshotCore}
    */
    snapshotCore(serializer) {
        let currentSize = 0;
        let counter = 0;
        let headerBlob = {};
        const blobs = [];
        const tree = {
            entries: [],
        };
        const data = this.kernel.getSerializedStorage(serializer);
        // If single property exceeds this size, it goes into its own blob
        const MinValueSizeSeparateSnapshotBlob = 8 * 1024;
        // Maximum blob size for multiple map properties
        // Should be bigger than MinValueSizeSeparateSnapshotBlob
        const MaxSnapshotBlobSize = 16 * 1024;
        // Partitioning algorithm:
        // 1) Split large (over MinValueSizeSeparateSnapshotBlob = 8K) properties into their own blobs.
        //    Naming (across snapshots) of such blob does not have to be stable across snapshots,
        //    As de-duping process (in driver) should not care about paths, only content.
        // 2) Split remaining properties into blobs of MaxSnapshotBlobSize (16K) size.
        //    This process does not produce stable partitioning. This means
        //    modification (including addition / deletion) of property can shift properties across blobs
        //    and result in non-incremental snapshot.
        //    This can be improved in the future, without being format breaking change, as loading sequence
        //    loads all blobs at once and partitioning schema has no impact on that process.
        for (const key of Object.keys(data)) {
            const value = data[key];
            if (value.value && value.value.length >= MinValueSizeSeparateSnapshotBlob) {
                const blobName = `blob${counter}`;
                counter++;
                blobs.push(blobName);
                const content = {
                    [key]: {
                        type: value.type,
                        value: JSON.parse(value.value),
                    },
                };
                (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_3__.addBlobToTree)(tree, blobName, content);
            }
            else {
                currentSize += value.type.length + 21; // Approximation cost of property header
                if (value.value) {
                    currentSize += value.value.length;
                }
                if (currentSize > MaxSnapshotBlobSize) {
                    const blobName = `blob${counter}`;
                    counter++;
                    blobs.push(blobName);
                    (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_3__.addBlobToTree)(tree, blobName, headerBlob);
                    headerBlob = {};
                    currentSize = 0;
                }
                headerBlob[key] = {
                    type: value.type,
                    value: value.value === undefined ? undefined : JSON.parse(value.value),
                };
            }
        }
        const header = {
            absolutePath: this.handle.absolutePath,
            blobs,
            content: headerBlob,
        };
        (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_3__.addBlobToTree)(tree, snapshotFileName, header);
        return tree;
    }
    getSerializableStorage() {
        return this.kernel.getSerializableStorage(this.serializer);
    }
    /**
    * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}
    */
    async loadCore(storage) {
        // eslint-disable-next-line @typescript-eslint/ban-types
        const json = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.readAndParse)(storage, snapshotFileName);
        const newFormat = json;
        if (Array.isArray(newFormat.blobs)) {
            this.kernel.populateFromSerializable(newFormat.content);
            await Promise.all(newFormat.blobs.map(async (value) => {
                const content = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.readAndParse)(storage, value);
                this.kernel.populateFromSerializable(content);
            }));
        }
        else {
            this.kernel.populateFromSerializable(json);
        }
    }
    /**
    * {@inheritDoc @fluidframework/shared-object-base#SharedObject.onDisconnect}
    */
    onDisconnect() {
        (0,_debug__WEBPACK_IMPORTED_MODULE_5__.debug)(`Map ${this.id} is now disconnected`);
    }
    /**
      * {@inheritDoc @fluidframework/shared-object-base#SharedObject.reSubmitCore}
      */
    reSubmitCore(content, localOpMetadata) {
        this.kernel.trySubmitMessage(content, localOpMetadata);
    }
    applyStashedOp(content) {
        this.kernel.tryProcessMessage(content, false, undefined, undefined);
        return this.kernel.tryGetStashedOpLocalMetadata(content);
    }
    /**
    * {@inheritDoc @fluidframework/shared-object-base#SharedObject.processCore}
    */
    processCore(message, local, localOpMetadata) {
        if (message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__.MessageType.Operation) {
            this.kernel.tryProcessMessage(message.contents, local, message, localOpMetadata);
        }
    }
    /**
    * {@inheritDoc @fluidframework/shared-object-base#SharedObject.registerCore}
    */
    registerCore() {
        for (const value of this.values()) {
            if (_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.SharedObject.is(value)) {
                value.bindToContext();
            }
        }
    }
}
//# sourceMappingURL=map.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/map/lib/mapKernel.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@fluidframework/map/lib/mapKernel.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MapKernel": () => (/* binding */ MapKernel)
/* harmony export */ });
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/shared-object-base */ "../../node_modules/@fluidframework/shared-object-base/lib/utils.js");
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/shared-object-base */ "../../node_modules/@fluidframework/shared-object-base/lib/valueType.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/typedEventEmitter.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _localValues__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./localValues */ "../../node_modules/@fluidframework/map/lib/localValues.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * A SharedMap is a map-like distributed data structure.
 */
class MapKernel {
    /**
     * Create a new shared map kernel.
     * @param serializer - The serializer to serialize / parse handles
     * @param handle - The handle of the shared object using the kernel
     * @param submitMessage - A callback to submit a message through the shared object
     * @param isAttached - To query whether the shared object should generate ops
     * @param valueTypes - The value types to register
     * @param eventEmitter - The object that will emit map events
     */
    constructor(serializer, handle, submitMessage, isAttached, valueTypes, eventEmitter = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter()) {
        this.serializer = serializer;
        this.handle = handle;
        this.submitMessage = submitMessage;
        this.isAttached = isAttached;
        this.eventEmitter = eventEmitter;
        /**
         * Mapping of op types to message handlers.
         */
        this.messageHandlers = new Map();
        /**
         * The in-memory data the map is storing.
         */
        this.data = new Map();
        /**
         * Keys that have been modified locally but not yet ack'd from the server.
         */
        this.pendingKeys = new Map();
        /**
         * This is used to assign a unique id to every outgoing operation and helps in tracking unack'd ops.
         */
        this.pendingMessageId = -1;
        /**
         * If a clear has been performed locally but not yet ack'd from the server, then this stores the pending id
         * of that clear operation. Otherwise, is -1.
         */
        this.pendingClearMessageId = -1;
        this.localValueMaker = new _localValues__WEBPACK_IMPORTED_MODULE_1__.LocalValueMaker(serializer);
        this.messageHandlers = this.getMessageHandlers();
        for (const type of valueTypes) {
            this.localValueMaker.registerValueType(type);
        }
    }
    /**
     * The number of key/value pairs stored in the map.
     */
    get size() {
        return this.data.size;
    }
    /**
     * Get an iterator over the keys in this map.
     * @returns The iterator
     */
    keys() {
        return this.data.keys();
    }
    /**
     * Get an iterator over the entries in this map.
     * @returns The iterator
     */
    entries() {
        const localEntriesIterator = this.data.entries();
        const iterator = {
            next() {
                const nextVal = localEntriesIterator.next();
                if (nextVal.done) {
                    return { value: undefined, done: true };
                }
                else {
                    // Unpack the stored value
                    return { value: [nextVal.value[0], nextVal.value[1].value], done: false };
                }
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     * Get an iterator over the values in this map.
     * @returns The iterator
     */
    values() {
        const localValuesIterator = this.data.values();
        const iterator = {
            next() {
                const nextVal = localValuesIterator.next();
                if (nextVal.done) {
                    return { value: undefined, done: true };
                }
                else {
                    // Unpack the stored value
                    return { value: nextVal.value.value, done: false };
                }
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     * Get an iterator over the entries in this map.
     * @returns The iterator
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * Executes the given callback on each entry in the map.
     * @param callbackFn - Callback function
     */
    forEach(callbackFn) {
        this.data.forEach((localValue, key, m) => {
            callbackFn(localValue.value, key, m);
        });
    }
    /**
     * {@inheritDoc ISharedMap.get}
     */
    get(key) {
        if (!this.data.has(key)) {
            return undefined;
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const localValue = this.data.get(key);
        return localValue.value;
    }
    /**
     * {@inheritDoc ISharedMap.wait}
     */
    async wait(key) {
        // Return immediately if the value already exists
        if (this.has(key)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.get(key);
        }
        // Otherwise subscribe to changes
        return new Promise((resolve) => {
            const callback = (changed) => {
                if (key === changed.key) {
                    // eslint-disable-next-line max-len
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-unnecessary-type-assertion
                    resolve(this.get(changed.key));
                    this.eventEmitter.removeListener("valueChanged", callback);
                }
            };
            this.eventEmitter.on("valueChanged", callback);
        });
    }
    /**
     * Check if a key exists in the map.
     * @param key - The key to check
     * @returns True if the key exists, false otherwise
     */
    has(key) {
        return this.data.has(key);
    }
    /**
     * {@inheritDoc ISharedMap.set}
     */
    set(key, value) {
        // Undefined/null keys can't be serialized to JSON in the manner we currently snapshot.
        if (key === undefined || key === null) {
            throw new Error("Undefined and null keys are not supported");
        }
        // Create a local value and serialize it.
        const localValue = this.localValueMaker.fromInMemory(value);
        const serializableValue = (0,_localValues__WEBPACK_IMPORTED_MODULE_1__.makeSerializable)(localValue, this.serializer, this.handle);
        // Set the value locally.
        this.setCore(key, localValue, true, undefined);
        // If we are not attached, don't submit the op.
        if (!this.isAttached()) {
            return;
        }
        const op = {
            key,
            type: "set",
            value: serializableValue,
        };
        this.submitMapKeyMessage(op);
    }
    /**
     * {@inheritDoc IValueTypeCreator.createValueType}
     */
    createValueType(key, type, params) {
        // Create a local value and serialize it.
        const localValue = this.localValueMaker.makeValueType(type, this.makeMapValueOpEmitter(key), params);
        // TODO ideally we could use makeSerialized in this case as well. But the interval
        // collection has assumptions of attach being called prior. Given the IFluidSerializer it
        // may be possible to remove custom value type serialization entirely.
        const transformedValue = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.makeHandlesSerializable)(params, this.serializer, this.handle);
        // Set the value locally.
        this.setCore(key, localValue, true, undefined);
        // If we are not attached, don't submit the op.
        if (!this.isAttached()) {
            return this;
        }
        // This is a special form of serialized valuetype only used for set, containing info for initialization.
        // After initialization, the serialized form will need to come from the .store of the value type's factory.
        const serializableValue = { type, value: transformedValue };
        const op = {
            key,
            type: "set",
            value: serializableValue,
        };
        this.submitMapKeyMessage(op);
        return this;
    }
    /**
     * Delete a key from the map.
     * @param key - Key to delete
     * @returns True if the key existed and was deleted, false if it did not exist
     */
    delete(key) {
        // Delete the key locally first.
        const successfullyRemoved = this.deleteCore(key, true, undefined);
        // If we are not attached, don't submit the op.
        if (!this.isAttached()) {
            return successfullyRemoved;
        }
        const op = {
            key,
            type: "delete",
        };
        this.submitMapKeyMessage(op);
        return successfullyRemoved;
    }
    /**
     * Clear all data from the map.
     */
    clear() {
        // Clear the data locally first.
        this.clearCore(true, undefined);
        // If we are not attached, don't submit the op.
        if (!this.isAttached()) {
            return;
        }
        const op = {
            type: "clear",
        };
        this.submitMapClearMessage(op);
    }
    /**
     * Serializes the data stored in the shared map to a JSON string
     * @param serializer - The serializer to use to serialize handles in its values.
     * @returns A JSON string containing serialized map data
     */
    getSerializedStorage(serializer) {
        const serializableMapData = {};
        this.data.forEach((localValue, key) => {
            serializableMapData[key] = localValue.makeSerialized(serializer, this.handle);
        });
        return serializableMapData;
    }
    getSerializableStorage(serializer) {
        const serializableMapData = {};
        this.data.forEach((localValue, key) => {
            serializableMapData[key] = (0,_localValues__WEBPACK_IMPORTED_MODULE_1__.makeSerializable)(localValue, serializer, this.handle);
        });
        return serializableMapData;
    }
    serialize(serializer) {
        return JSON.stringify(this.getSerializableStorage(serializer));
    }
    /**
     * Populate the kernel with the given map data.
     * @param data - A JSON string containing serialized map data
     */
    populateFromSerializable(json) {
        for (const [key, serializable] of Object.entries(json)) {
            const localValue = {
                key,
                value: this.makeLocal(key, serializable),
            };
            this.data.set(localValue.key, localValue.value);
        }
    }
    populate(json) {
        this.populateFromSerializable(JSON.parse(json));
    }
    /**
     * Submit the given op if a handler is registered.
     * @param op - The operation to attempt to submit
     * @param localOpMetadata - The local metadata associated with the op. This is kept locally by the runtime
     * and not sent to the server. This will be sent back when this message is received back from the server. This is
     * also sent if we are asked to resubmit the message.
     * @returns True if the operation was submitted, false otherwise.
     */
    trySubmitMessage(op, localOpMetadata) {
        const type = op.type;
        if (this.messageHandlers.has(type)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.messageHandlers.get(type).submit(op, localOpMetadata);
            return true;
        }
        return false;
    }
    tryGetStashedOpLocalMetadata(op) {
        const type = op.type;
        if (this.messageHandlers.has(type)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.messageHandlers.get(type).getStashedOpLocalMetadata(op);
        }
        throw new Error("no apply stashed op handler");
    }
    /**
     * Process the given op if a handler is registered.
     * @param message - The message to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @returns True if the operation was processed, false otherwise.
     */
    tryProcessMessage(op, local, message, localOpMetadata) {
        if (this.messageHandlers.has(op.type)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.messageHandlers
                .get(op.type)
                .process(op, local, message, localOpMetadata);
            return true;
        }
        return false;
    }
    /**
     * Set implementation used for both locally sourced sets as well as incoming remote sets.
     * @param key - The key being set
     * @param value - The value being set
     * @param local - Whether the message originated from the local client
     * @param op - The message if from a remote set, or null if from a local set
     */
    setCore(key, value, local, op) {
        const previousValue = this.get(key);
        this.data.set(key, value);
        const event = { key, previousValue };
        this.eventEmitter.emit("valueChanged", event, local, op, this.eventEmitter);
    }
    /**
     * Clear implementation used for both locally sourced clears as well as incoming remote clears.
     * @param local - Whether the message originated from the local client
     * @param op - The message if from a remote clear, or null if from a local clear
     */
    clearCore(local, op) {
        this.data.clear();
        this.eventEmitter.emit("clear", local, op, this.eventEmitter);
    }
    /**
     * Delete implementation used for both locally sourced deletes as well as incoming remote deletes.
     * @param key - The key being deleted
     * @param local - Whether the message originated from the local client
     * @param op - The message if from a remote delete, or null if from a local delete
     * @returns True if the key existed and was deleted, false if it did not exist
     */
    deleteCore(key, local, op) {
        const previousValue = this.get(key);
        const successfullyRemoved = this.data.delete(key);
        if (successfullyRemoved) {
            const event = { key, previousValue };
            this.eventEmitter.emit("valueChanged", event, local, op, this.eventEmitter);
        }
        return successfullyRemoved;
    }
    /**
     * Clear all keys in memory in response to a remote clear, but retain keys we have modified but not yet been ack'd.
     */
    clearExceptPendingKeys() {
        // Assuming the pendingKeys is small and the map is large
        // we will get the value for the pendingKeys and clear the map
        const temp = new Map();
        this.pendingKeys.forEach((value, key) => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            temp.set(key, this.data.get(key));
        });
        this.data.clear();
        temp.forEach((value, key) => {
            this.data.set(key, value);
        });
    }
    /**
     * The remote ISerializableValue we're receiving (either as a result of a load or an incoming set op) will
     * have the information we need to create a real object, but will not be the real object yet.  For example,
     * we might know it's a map and the map's ID but not have the actual map or its data yet.  makeLocal's
     * job is to convert that information into a real object for local usage.
     * @param key - The key that the caller intends to store the local value into (used for ops later).  But
     * doesn't actually store the local value into that key.  So better not lie!
     * @param serializable - The remote information that we can convert into a real object
     * @returns The local value that was produced
     */
    makeLocal(key, serializable) {
        if (serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_3__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_3__.ValueType.Plain] || serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_3__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_3__.ValueType.Shared]) {
            return this.localValueMaker.fromSerializable(serializable);
        }
        else {
            return this.localValueMaker.fromSerializableValueType(serializable, this.makeMapValueOpEmitter(key));
        }
    }
    /**
     * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should
     * not process the incoming operation.
     * @param op - Operation to check
     * @param local - Whether the message originated from the local client
     * @param message - The message
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @returns True if the operation should be processed, false otherwise
     */
    needProcessKeyOperation(op, local, localOpMetadata) {
        if (this.pendingClearMessageId !== -1) {
            if (local) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(localOpMetadata !== undefined && localOpMetadata < this.pendingClearMessageId, 0x013 /* "Received out of order op when there is an unackd clear message" */);
            }
            // If we have an unack'd clear, we can ignore all ops.
            return false;
        }
        if (this.pendingKeys.has(op.key)) {
            // Found an unack'd op. Clear it from the map if the pendingMessageId in the map matches this message's
            // and don't process the op.
            if (local) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(localOpMetadata !== undefined, 0x014 /* `pendingMessageId is missing from the local client's ${op.type} operation` */);
                const pendingMessageId = localOpMetadata;
                const pendingKeyMessageId = this.pendingKeys.get(op.key);
                if (pendingKeyMessageId === pendingMessageId) {
                    this.pendingKeys.delete(op.key);
                }
            }
            return false;
        }
        // If we don't have a NACK op on the key, we need to process the remote ops.
        return !local;
    }
    /**
     * Get the message handlers for the map.
     * @returns A map of string op names to IMapMessageHandlers for those ops
     */
    getMessageHandlers() {
        const messageHandlers = new Map();
        messageHandlers.set("clear", {
            process: (op, local, message, localOpMetadata) => {
                if (local) {
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(localOpMetadata !== undefined, 0x015 /* "pendingMessageId is missing from the local client's clear operation" */);
                    const pendingMessageId = localOpMetadata;
                    if (this.pendingClearMessageId === pendingMessageId) {
                        this.pendingClearMessageId = -1;
                    }
                    return;
                }
                if (this.pendingKeys.size !== 0) {
                    this.clearExceptPendingKeys();
                    return;
                }
                this.clearCore(local, message);
            },
            submit: (op, localOpMetadata) => {
                // We don't reuse the metadata but send a new one on each submit.
                this.submitMapClearMessage(op);
            },
            getStashedOpLocalMetadata: (op) => {
                // We don't reuse the metadata but send a new one on each submit.
                return this.getMapClearMessageLocalMetadata(op);
            },
        });
        messageHandlers.set("delete", {
            process: (op, local, message, localOpMetadata) => {
                if (!this.needProcessKeyOperation(op, local, localOpMetadata)) {
                    return;
                }
                this.deleteCore(op.key, local, message);
            },
            submit: (op, localOpMetadata) => {
                // We don't reuse the metadata but send a new one on each submit.
                this.submitMapKeyMessage(op);
            },
            getStashedOpLocalMetadata: (op) => {
                // We don't reuse the metadata but send a new one on each submit.
                return this.getMapKeyMessageLocalMetadata(op);
            },
        });
        messageHandlers.set("set", {
            process: (op, local, message, localOpMetadata) => {
                if (!this.needProcessKeyOperation(op, local, localOpMetadata)) {
                    return;
                }
                // needProcessKeyOperation should have returned false if local is true
                const context = this.makeLocal(op.key, op.value);
                this.setCore(op.key, context, local, message);
            },
            submit: (op, localOpMetadata) => {
                // We don't reuse the metadata but send a new one on each submit.
                this.submitMapKeyMessage(op);
            },
            getStashedOpLocalMetadata: (op) => {
                // We don't reuse the metadata but send a new one on each submit.
                return this.getMapKeyMessageLocalMetadata(op);
            },
        });
        // Ops with type "act" describe actions taken by custom value type handlers of whatever item is
        // being addressed.  These custom handlers can be retrieved from the ValueTypeLocalValue which has
        // stashed its valueType (and therefore its handlers).  We also emit a valueChanged for anyone
        // watching for manipulations of that item.
        messageHandlers.set("act", {
            process: (op, local, message, localOpMetadata) => {
                // Local value might not exist if we deleted it
                const localValue = this.data.get(op.key);
                if (!localValue) {
                    return;
                }
                const handler = localValue.getOpHandler(op.value.opName);
                const previousValue = localValue.value;
                const translatedValue = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.parseHandles)(op.value.value, this.serializer);
                handler.process(previousValue, translatedValue, local, message);
                const event = { key: op.key, previousValue };
                this.eventEmitter.emit("valueChanged", event, local, message, this.eventEmitter);
            },
            submit: (op, localOpMetadata) => {
                this.submitMessage(op, localOpMetadata);
            },
            getStashedOpLocalMetadata: (op) => {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(false, 0x016 /* "apply stashed op not implemented for custom value type ops" */);
            },
        });
        return messageHandlers;
    }
    getMapClearMessageLocalMetadata(op) {
        const pendingMessageId = ++this.pendingMessageId;
        this.pendingClearMessageId = pendingMessageId;
        return pendingMessageId;
    }
    /**
     * Submit a clear message to remote clients.
     * @param op - The clear message
     */
    submitMapClearMessage(op) {
        const pendingMessageId = this.getMapClearMessageLocalMetadata(op);
        this.submitMessage(op, pendingMessageId);
    }
    getMapKeyMessageLocalMetadata(op) {
        const pendingMessageId = ++this.pendingMessageId;
        this.pendingKeys.set(op.key, pendingMessageId);
        return pendingMessageId;
    }
    /**
     * Submit a map key message to remote clients.
     * @param op - The map key message
     */
    submitMapKeyMessage(op) {
        const pendingMessageId = this.getMapKeyMessageLocalMetadata(op);
        this.submitMessage(op, pendingMessageId);
    }
    /**
     * Create an emitter for a value type to emit ops from the given key.
     * @alpha
     * @param key - The key of the map that the value type will be stored on
     * @returns A value op emitter for the given key
     */
    makeMapValueOpEmitter(key) {
        const emit = (opName, previousValue, params) => {
            const translatedParams = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.makeHandlesSerializable)(params, this.serializer, this.handle);
            const op = {
                key,
                type: "act",
                value: {
                    opName,
                    value: translatedParams,
                },
            };
            // Send the localOpMetadata as undefined because we don't care about the ack.
            this.submitMessage(op, undefined /* localOpMetadata */);
            const event = { key, previousValue };
            this.eventEmitter.emit("valueChanged", event, true, null, this.eventEmitter);
        };
        return { emit };
    }
}
//# sourceMappingURL=mapKernel.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/map/lib/packageVersion.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@fluidframework/map/lib/packageVersion.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pkgName": () => (/* binding */ pkgName),
/* harmony export */   "pkgVersion": () => (/* binding */ pkgVersion)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
const pkgName = "@fluidframework/map";
const pkgVersion = "0.37.4";
//# sourceMappingURL=packageVersion.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/client.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/client.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Client": () => (/* binding */ Client)
/* harmony export */ });
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/protocol.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/trace.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./collections */ "../../node_modules/@fluidframework/merge-tree/lib/collections.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants */ "../../node_modules/@fluidframework/merge-tree/lib/constants.js");
/* harmony import */ var _localReference__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./localReference */ "../../node_modules/@fluidframework/merge-tree/lib/localReference.js");
/* harmony import */ var _mergeTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mergeTree */ "../../node_modules/@fluidframework/merge-tree/lib/mergeTree.js");
/* harmony import */ var _opBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./opBuilder */ "../../node_modules/@fluidframework/merge-tree/lib/opBuilder.js");
/* harmony import */ var _snapshotlegacy__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./snapshotlegacy */ "../../node_modules/@fluidframework/merge-tree/lib/snapshotlegacy.js");
/* harmony import */ var _snapshotLoader__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./snapshotLoader */ "../../node_modules/@fluidframework/merge-tree/lib/snapshotLoader.js");
/* harmony import */ var _textSegment__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./textSegment */ "../../node_modules/@fluidframework/merge-tree/lib/textSegment.js");
/* harmony import */ var _snapshotV1__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./snapshotV1 */ "../../node_modules/@fluidframework/merge-tree/lib/snapshotV1.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */












class Client {
    constructor(
    // Passing this callback would be unnecessary if Client were merged with SharedSegmentSequence
    specToSegment, logger, options) {
        this.specToSegment = specToSegment;
        this.logger = logger;
        this.verboseOps = false;
        this.noVerboseRemoteAnnotate = false;
        this.measureOps = false;
        this.registerCollection = new _mergeTree__WEBPACK_IMPORTED_MODULE_0__.RegisterCollection();
        this.accumTime = 0;
        this.localTime = 0;
        this.localOps = 0;
        this.accumWindowTime = 0;
        this.accumWindow = 0;
        this.accumOps = 0;
        this.maxWindowTime = 0;
        this.clientNameToIds = new _collections__WEBPACK_IMPORTED_MODULE_1__.RedBlackTree(_mergeTree__WEBPACK_IMPORTED_MODULE_0__.compareStrings);
        this.shortClientIdMap = [];
        this.pendingConsensus = new Map();
        this.mergeTree = new _mergeTree__WEBPACK_IMPORTED_MODULE_0__.MergeTree(options);
        this.mergeTree.getLongClientId = (id) => this.getLongClientId(id);
    }
    get mergeTreeDeltaCallback() { return this.mergeTree.mergeTreeDeltaCallback; }
    set mergeTreeDeltaCallback(callback) {
        this.mergeTree.mergeTreeDeltaCallback = callback;
    }
    get mergeTreeMaintenanceCallback() {
        return this.mergeTree.mergeTreeMaintenanceCallback;
    }
    set mergeTreeMaintenanceCallback(callback) {
        this.mergeTree.mergeTreeMaintenanceCallback = callback;
    }
    /**
     * The merge tree maintains a queue of segment groups for each local operation.
     * These segment groups track segments modified by an operation.
     * This method peeks the tail of that queue, and returns the segments groups there.
     * It is used to get the segment group(s) for the previous operations.
     * @param count - The number segment groups to get peek from the tail of the queue. Default 1.
     */
    peekPendingSegmentGroups(count = 1) {
        var _a, _b;
        if (count === 1) {
            return (_a = this.mergeTree.pendingSegments) === null || _a === void 0 ? void 0 : _a.last();
        }
        let taken = 0;
        return (_b = this.mergeTree.pendingSegments) === null || _b === void 0 ? void 0 : _b.some(() => {
            if (taken < count) {
                taken++;
                return true;
            }
            return false;
        }, true);
    }
    /**
     * Annotate a maker and call the callback on concensus.
     * @param marker - The marker to annotate
     * @param props - The properties to annotate the marker with
     * @param consensusCallback - The callback called when consensus is reached
     * @returns The annotate op if valid, otherwise undefined
     */
    annotateMarkerNotifyConsensus(marker, props, consensusCallback) {
        const combiningOp = {
            name: "consensus",
        };
        const annotateOp = this.annotateMarker(marker, props, combiningOp);
        if (annotateOp) {
            const consensusInfo = {
                callback: consensusCallback,
                marker,
            };
            this.pendingConsensus.set(marker.getId(), consensusInfo);
            return annotateOp;
        }
        else {
            return undefined;
        }
    }
    /**
     * Annotates the markers with the provided properties
     * @param marker - The marker to annotate
     * @param props - The properties to annotate the marker with
     * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
     * @returns The annotate op if valid, otherwise undefined
     */
    annotateMarker(marker, props, combiningOp) {
        const annotateOp = _opBuilder__WEBPACK_IMPORTED_MODULE_2__.createAnnotateMarkerOp(marker, props, combiningOp);
        if (this.applyAnnotateRangeOp({ op: annotateOp })) {
            return annotateOp;
        }
        else {
            return undefined;
        }
    }
    /**
     * Annotates the range with the provided properties
     * @param start - The inclusive start postition of the range to annotate
     * @param end - The exclusive end position of the range to annotate
     * @param props - The properties to annotate the range with
     * @param combiningOp - Specifies how to combine values for the property, such as "incr" for increment.
     * @returns The annotate op if valid, otherwise undefined
     */
    annotateRangeLocal(start, end, props, combiningOp) {
        const annotateOp = _opBuilder__WEBPACK_IMPORTED_MODULE_2__.createAnnotateRangeOp(start, end, props, combiningOp);
        if (this.applyAnnotateRangeOp({ op: annotateOp })) {
            return annotateOp;
        }
        return undefined;
    }
    /**
     * Removes the range and puts the content of the removed range in a register
     * if a register name is provided
     *
     * @param start - The inclusive start of the range to remove
     * @param end - The exclusive end of the range to remove
     * @param register - Optional. The name of the register to store the removed range in
     */
    removeRangeLocal(start, end, register) {
        const removeOp = _opBuilder__WEBPACK_IMPORTED_MODULE_2__.createRemoveRangeOp(start, end, register);
        if (this.applyRemoveRangeOp({ op: removeOp })) {
            return removeOp;
        }
        return undefined;
    }
    /**
     * @param pos - The position to insert the segment at
     * @param segment - The segment to insert
     */
    insertSegmentLocal(pos, segment) {
        if (segment.cachedLength <= 0) {
            return undefined;
        }
        const insertOp = _opBuilder__WEBPACK_IMPORTED_MODULE_2__.createInsertSegmentOp(pos, segment);
        if (this.applyInsertOp({ op: insertOp })) {
            return insertOp;
        }
        return undefined;
    }
    /**
     * @param refPos - The reference position to insert the segment at
     * @param segment - The segment to insert
     */
    insertAtReferencePositionLocal(refPos, segment) {
        const pos = this.mergeTree.referencePositionToLocalPosition(refPos, this.getCurrentSeq(), this.getClientId());
        if (pos === _localReference__WEBPACK_IMPORTED_MODULE_3__.LocalReference.DetachedPosition) {
            return undefined;
        }
        const op = _opBuilder__WEBPACK_IMPORTED_MODULE_2__.createInsertSegmentOp(pos, segment);
        const opArgs = { op };
        let traceStart;
        if (this.measureOps) {
            traceStart = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();
        }
        this.mergeTree.insertAtReferencePosition(refPos, segment, opArgs);
        this.completeAndLogOp(opArgs, this.getClientSequenceArgs(opArgs), { start: op.pos1 }, traceStart);
        return op;
    }
    /**
     * @param pos - The position to insert the register contents at
     * @param register - The name of the register to insert the value of
     */
    pasteLocal(pos, register) {
        const insertOp = _opBuilder__WEBPACK_IMPORTED_MODULE_2__.createInsertFromRegisterOp(pos, register);
        if (this.applyInsertOp({ op: insertOp })) {
            return insertOp;
        }
        return undefined;
    }
    /**
     *
     * @param start - he inclusive start of the range to copy into the register
     * @param end - The exclusive end of the range to copy into the register
     * @param register - The name of the register to insert the range contents into
     */
    copyLocal(start, end, register) {
        const insertOp = _opBuilder__WEBPACK_IMPORTED_MODULE_2__.createInsertToRegisterOp(start, end, register);
        if (this.applyInsertOp({ op: insertOp })) {
            return insertOp;
        }
        return undefined;
    }
    walkSegments(handler, start, end, accum, splitRange = false) {
        this.mergeTree.mapRange({
            leaf: handler,
        }, this.getCurrentSeq(), this.getClientId(), accum, start, end, splitRange);
    }
    getCollabWindow() {
        return this.mergeTree.getCollabWindow();
    }
    /**
     * Returns the current position of a segment, and -1 if the segment
     * does not exist in this merge tree
     * @param segment - The segment to get the position of
     */
    getPosition(segment) {
        if ((segment === null || segment === void 0 ? void 0 : segment.parent) === undefined) {
            return -1;
        }
        return this.mergeTree.getPosition(segment, this.getCurrentSeq(), this.getClientId());
    }
    addLocalReference(lref) {
        return this.mergeTree.addLocalReference(lref);
    }
    removeLocalReference(lref) {
        return this.mergeTree.removeLocalReference(lref.segment, lref);
    }
    /**
     * Given a position specified relative to a marker id, lookup the marker
     * and convert the position to a character position.
     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.
     */
    posFromRelativePos(relativePos) {
        return this.mergeTree.posFromRelativePos(relativePos);
    }
    getMarkerFromId(id) {
        return this.mergeTree.getMarkerFromId(id);
    }
    /**
     * Performs the remove based on the provided op
     * @param opArgs - The ops args for the op
     * @returns True if the remove was applied. False if it could not be.
     */
    applyRemoveRangeOp(opArgs) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(opArgs.op.type === 1 /* REMOVE */, 0x02d /* "Unexpected op type on range remove!" */);
        const op = opArgs.op;
        const clientArgs = this.getClientSequenceArgs(opArgs);
        const range = this.getValidOpRange(op, clientArgs);
        if (!range) {
            return false;
        }
        if (op.register) {
            // Cut
            this.copy(range, op.register, clientArgs);
        }
        let traceStart;
        if (this.measureOps) {
            traceStart = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();
        }
        this.mergeTree.markRangeRemoved(range.start, range.end, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, false, opArgs);
        this.completeAndLogOp(opArgs, clientArgs, range, traceStart);
        return true;
    }
    /**
     * Performs the annotate based on the provided op
     * @param opArgs - The ops args for the op
     * @returns True if the annotate was applied. False if it could not be.
     */
    applyAnnotateRangeOp(opArgs) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(opArgs.op.type === 2 /* ANNOTATE */, 0x02e /* "Unexpected op type on range annotate!" */);
        const op = opArgs.op;
        const clientArgs = this.getClientSequenceArgs(opArgs);
        const range = this.getValidOpRange(op, clientArgs);
        if (!range) {
            return false;
        }
        let traceStart;
        if (this.measureOps) {
            traceStart = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();
        }
        this.mergeTree.annotateRange(range.start, range.end, op.props, op.combiningOp, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, opArgs);
        this.completeAndLogOp(opArgs, clientArgs, range, traceStart);
        return true;
    }
    /**
     * Performs the insert based on the provided op
     * @param opArgs - The ops args for the op
     * @returns True if the insert was applied. False if it could not be.
     */
    applyInsertOp(opArgs) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(opArgs.op.type === 0 /* INSERT */, 0x02f /* "Unexpected op type on range insert!" */);
        const op = opArgs.op;
        const clientArgs = this.getClientSequenceArgs(opArgs);
        const range = this.getValidOpRange(op, clientArgs);
        if (!range) {
            return false;
        }
        let segments;
        if (op.seg) {
            segments = [this.specToSegment(op.seg)];
        }
        else if (op.register) {
            if (range.end) {
                this.copy(range, op.register, clientArgs);
                // Enqueue an empty segment group to be dequeued on ack
                //
                if (clientArgs.sequenceNumber === _constants__WEBPACK_IMPORTED_MODULE_6__.UnassignedSequenceNumber) {
                    this.mergeTree.pendingSegments.enqueue({ segments: [], localSeq: this.getCollabWindow().localSeq });
                }
                return true;
            }
            segments = this.registerCollection.get(this.getLongClientId(clientArgs.clientId), op.register);
        }
        if (!segments || segments.length === 0) {
            return false;
        }
        let traceStart;
        if (this.measureOps) {
            traceStart = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();
        }
        this.mergeTree.insertSegments(range.start, segments, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, opArgs);
        this.completeAndLogOp(opArgs, clientArgs, range, traceStart);
        return true;
    }
    /**
     *
     * @param opArgs - The op args of the op to complete
     * @param clientArgs - The client args for the op
     * @param range - The range the op applied to
     * @param clockStart - Optional. The clock start if timing data should be updated.
     */
    completeAndLogOp(opArgs, clientArgs, range, traceStart) {
        if (!opArgs.sequencedMessage) {
            if (traceStart) {
                this.localTime += (0,_mergeTree__WEBPACK_IMPORTED_MODULE_0__.elapsedMicroseconds)(traceStart);
                this.localOps++;
            }
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(this.mergeTree.getCollabWindow().currentSeq < clientArgs.sequenceNumber, 0x030 /* "Incoming remote op sequence# <= local collabWindow's currentSequence#" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(this.mergeTree.getCollabWindow().minSeq <= opArgs.sequencedMessage.minimumSequenceNumber, 0x031 /* "Incoming remote op minSequence# < local collabWindow's minSequence#" */);
            if (traceStart) {
                this.accumTime += (0,_mergeTree__WEBPACK_IMPORTED_MODULE_0__.elapsedMicroseconds)(traceStart);
                this.accumOps++;
                this.accumWindow += (this.getCurrentSeq() - this.getCollabWindow().minSeq);
            }
        }
        if (this.verboseOps && (!opArgs.sequencedMessage || !this.noVerboseRemoteAnnotate)) {
            console.log(`@cli ${this.getLongClientId(this.getCollabWindow().clientId)} ` +
                `seq ${clientArgs.sequenceNumber} ${opArgs.op.type} local ${!opArgs.sequencedMessage} ` +
                `start ${range.start} end ${range.end} refseq ${clientArgs.referenceSequenceNumber} ` +
                `cli ${clientArgs.clientId}`);
        }
    }
    /**
     * Returns a valid range for the op, or undefined
     * @param op - The op to generate the range for
     * @param clientArgs - The client args for the op
     */
    getValidOpRange(op, clientArgs) {
        let start = op.pos1;
        if (start === undefined && op.relativePos1) {
            start = this.mergeTree.posFromRelativePos(op.relativePos1, clientArgs.referenceSequenceNumber, clientArgs.clientId);
        }
        let end = op.pos2;
        if (end === undefined && op.relativePos2) {
            end = this.mergeTree.posFromRelativePos(op.relativePos2, clientArgs.referenceSequenceNumber, clientArgs.clientId);
        }
        // Validate if local op
        if (clientArgs.clientId === this.getClientId()) {
            const length = this.getLength();
            const invalidPositions = [];
            // Validate start position
            //
            if (start === undefined
                || start < 0
                || start > length
                || start === length && op.type !== 0 /* INSERT */) {
                invalidPositions.push("start");
            }
            // Validate end if not insert, or insert has end
            //
            if (op.type !== 0 /* INSERT */ || end !== undefined) {
                if (end === undefined || end <= start) {
                    invalidPositions.push("end");
                }
            }
            if (invalidPositions.length > 0) {
                throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.LoggingError("RangeOutOfBounds", {
                    UsageError: true,
                    end,
                    invalidPositions: invalidPositions.toString(),
                    length,
                    opPos1: op.pos1,
                    opPos1Relative: op.relativePos1 !== undefined,
                    opPos2: op.pos2,
                    opPos2Relative: op.relativePos2 !== undefined,
                    opType: op.type,
                    start,
                });
            }
        }
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return { start, end };
    }
    /**
     * Gets the client args from the op if remote, otherwise uses the local clients info
     * @param opArgs - The op arg to get the client sequence args for
     */
    getClientSequenceArgs(opArgs) {
        // If there this no sequenced message, then the op is local
        // and unacked, so use this clients sequenced args
        //
        if (!opArgs.sequencedMessage) {
            const segWindow = this.getCollabWindow();
            return {
                clientId: segWindow.clientId,
                referenceSequenceNumber: segWindow.currentSeq,
                sequenceNumber: this.getLocalSequenceNumber(),
            };
        }
        else {
            return {
                clientId: this.getShortClientId(opArgs.sequencedMessage.clientId),
                referenceSequenceNumber: opArgs.sequencedMessage.referenceSequenceNumber,
                sequenceNumber: opArgs.sequencedMessage.sequenceNumber,
            };
        }
    }
    /**
     * @param range - The range to copy into the register
     * @param register - The name of the register to copy to range into
     * @param clientArgs - The client args to use when evaluating the range for copying
     */
    copy(range, register, clientArgs) {
        const segs = this.mergeTree.cloneSegments(clientArgs.referenceSequenceNumber, clientArgs.clientId, range.start, range.end);
        this.registerCollection.set(this.getLongClientId(clientArgs.clientId), register, segs);
    }
    ackPendingSegment(opArgs) {
        const ackOp = (deltaOpArgs) => {
            var _a;
            let trace;
            if (this.measureOps) {
                trace = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();
            }
            this.mergeTree.ackPendingSegment(deltaOpArgs, this.verboseOps);
            if (deltaOpArgs.op.type === 2 /* ANNOTATE */) {
                if (deltaOpArgs.op.combiningOp && (deltaOpArgs.op.combiningOp.name === "consensus")) {
                    this.updateConsensusProperty(deltaOpArgs.op, deltaOpArgs.sequencedMessage);
                }
            }
            if (trace) {
                this.accumTime += (0,_mergeTree__WEBPACK_IMPORTED_MODULE_0__.elapsedMicroseconds)(trace);
                this.accumOps++;
                this.accumWindow += (this.getCurrentSeq() - this.getCollabWindow().minSeq);
            }
            if (this.verboseOps) {
                console.log(`@cli ${this.getLongClientId(this.getCollabWindow().clientId)} ` +
                    `ack seq # ${(_a = deltaOpArgs.sequencedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber}`);
            }
        };
        if (opArgs.op.type === 3 /* GROUP */) {
            for (const memberOp of opArgs.op.ops) {
                ackOp({
                    groupOp: opArgs.op,
                    op: memberOp,
                    sequencedMessage: opArgs.sequencedMessage,
                });
            }
        }
        else {
            ackOp(opArgs);
        }
    }
    // as functions are modified move them above the eslint-disabled waterline and lint them
    cloneFromSegments() {
        const clone = new Client(this.specToSegment, this.logger, this.mergeTree.options);
        const segments = [];
        const newRoot = this.mergeTree.blockClone(this.mergeTree.root, segments);
        clone.mergeTree.root = newRoot;
        return clone;
    }
    getOrAddShortClientId(longClientId) {
        if (!this.clientNameToIds.get(longClientId)) {
            this.addLongClientId(longClientId);
        }
        return this.getShortClientId(longClientId);
    }
    getShortClientId(longClientId) {
        return this.clientNameToIds.get(longClientId).data;
    }
    getLongClientId(shortClientId) {
        if (shortClientId >= 0) {
            return this.shortClientIdMap[shortClientId];
        }
        else {
            return "original";
        }
    }
    addLongClientId(longClientId) {
        this.clientNameToIds.put(longClientId, this.shortClientIdMap.length);
        this.shortClientIdMap.push(longClientId);
    }
    /**
     * During reconnect, we must find the positions to pending segments
     * relative to other pending segments. This methods computes that
     * position relative to a localSeq. Pending segments above the localSeq
     * will be ignored.
     *
     * @param segment - The segment to find the position for
     * @param localSeq - The localSeq to find the position of the segment at
     */
    findReconnectionPostition(segment, localSeq) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(localSeq <= this.mergeTree.collabWindow.localSeq, 0x032 /* "localSeq greater than collab window" */);
        let segmentPosition = 0;
        /*
            Walk the segments up to the current segment, and calculate it's
            position taking into account local segments that were modified,
            after the current segment.

            TODO: Consider embedding this information into the tree for
            more efficient look up of pending segment positions.
        */
        this.mergeTree.walkAllSegments(this.mergeTree.root, (seg) => {
            // If we've found the desired segment, terminate the walk and return 'segmentPosition'.
            if (seg === segment) {
                return false;
            }
            // Otherwise, advance segmentPosition if the segment has been inserted and not removed
            // with respect to the given 'localSeq'.
            //
            // Note that all ACKed / remote ops are applied and we only need concern ourself with
            // determining if locally pending ops fall before/after the given 'localSeq'.
            if ((seg.localSeq === undefined || seg.localSeq <= localSeq) // Is inserted
                && (seg.removedSeq === undefined || seg.localRemovedSeq > localSeq) // Not removed
            ) {
                segmentPosition += seg.cachedLength;
            }
            return true;
        });
        return segmentPosition;
    }
    resetPendingDeltaToOps(resetOp, segmentGroup) {
        var _a, _b;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!!segmentGroup, 0x033 /* "Segment group undefined" */);
        const NACKedSegmentGroup = (_a = this.mergeTree.pendingSegments) === null || _a === void 0 ? void 0 : _a.dequeue();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(segmentGroup === NACKedSegmentGroup, 0x034 /* "Segment group not at head of merge tree pending queue" */);
        const opList = [];
        // We need to sort the segments by ordinal, as the segments are not sorted in the segment group.
        // The reason they need them sorted, as they have the same local sequence number and which means
        // farther segments will  take into account nearer segments when calculating their position.
        // By sorting we ensure the nearer segment will be applied and sequenced before the father segments
        // so their recalulated positions will be correct.
        for (const segment of segmentGroup.segments.sort((a, b) => a.ordinal < b.ordinal ? -1 : 1)) {
            const segmentSegGroup = segment.segmentGroups.dequeue();
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(segmentGroup === segmentSegGroup, 0x035 /* "Segment group not at head of segment pending queue" */);
            const segmentPosition = this.findReconnectionPostition(segment, segmentGroup.localSeq);
            let newOp;
            switch (resetOp.type) {
                case 2 /* ANNOTATE */:
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(((_b = segment.propertyManager) === null || _b === void 0 ? void 0 : _b.hasPendingProperties()) === true, 0x036 /* "Segment has no pending properties" */);
                    newOp = _opBuilder__WEBPACK_IMPORTED_MODULE_2__.createAnnotateRangeOp(segmentPosition, segmentPosition + segment.cachedLength, resetOp.props, resetOp.combiningOp);
                    break;
                case 0 /* INSERT */:
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(segment.seq === _constants__WEBPACK_IMPORTED_MODULE_6__.UnassignedSequenceNumber, 0x037 /* "Segment already has assigned sequence number" */);
                    newOp = _opBuilder__WEBPACK_IMPORTED_MODULE_2__.createInsertSegmentOp(segmentPosition, segment);
                    break;
                case 1 /* REMOVE */:
                    if (segment.localRemovedSeq !== undefined) {
                        newOp = _opBuilder__WEBPACK_IMPORTED_MODULE_2__.createRemoveRangeOp(segmentPosition, segmentPosition + segment.cachedLength);
                    }
                    break;
                default:
                    throw new Error(`Invalid op type`);
            }
            if (newOp) {
                const newSegmentGroup = { segments: [], localSeq: segmentGroup.localSeq };
                segment.segmentGroups.enqueue(newSegmentGroup);
                this.mergeTree.pendingSegments.enqueue(newSegmentGroup);
                opList.push(newOp);
            }
        }
        return opList;
    }
    applyRemoteOp(opArgs) {
        const op = opArgs.op;
        const msg = opArgs.sequencedMessage;
        this.getOrAddShortClientId(msg.clientId);
        switch (op.type) {
            case 0 /* INSERT */:
                this.applyInsertOp(opArgs);
                break;
            case 1 /* REMOVE */:
                this.applyRemoveRangeOp(opArgs);
                break;
            case 2 /* ANNOTATE */:
                this.applyAnnotateRangeOp(opArgs);
                break;
            case 3 /* GROUP */: {
                for (const memberOp of op.ops) {
                    this.applyRemoteOp({
                        op: memberOp,
                        groupOp: op,
                        sequencedMessage: msg,
                    });
                }
                break;
            }
            default:
                break;
        }
    }
    applyMsg(msg) {
        var _a;
        // Ensure client ID is registered
        this.getOrAddShortClientId(msg.clientId);
        // Apply if an operation message
        if (msg.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_8__.MessageType.Operation) {
            const opArgs = {
                op: msg.contents,
                sequencedMessage: msg,
            };
            if (((_a = opArgs.sequencedMessage) === null || _a === void 0 ? void 0 : _a.clientId) === this.longClientId) {
                this.ackPendingSegment(opArgs);
            }
            else {
                this.applyRemoteOp(opArgs);
            }
        }
        this.updateSeqNumbers(msg.minimumSequenceNumber, msg.sequenceNumber);
    }
    updateSeqNumbers(min, seq) {
        const collabWindow = this.mergeTree.getCollabWindow();
        // Equal is fine here due to SharedSegmentSequence<>.snapshotContent() potentially updating with same #
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(collabWindow.currentSeq <= seq, 0x038 /* "Incoming op sequence# < local collabWindow's currentSequence#" */);
        collabWindow.currentSeq = seq;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(min <= seq, 0x039 /* "Incoming op sequence# < minSequence#" */);
        this.updateMinSeq(min);
    }
    /**
     * Resolves a remote client's position against the local sequence
     * and returns the remote client's position relative to the local
     * sequence
     * @param remoteClientPosition - The remote client's position to resolve
     * @param remoteClientRefSeq - The reference sequence number of the remote client
     * @param remoteClientId - The client id of the remote client
     */
    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {
        const shortRemoteClientId = this.getOrAddShortClientId(remoteClientId);
        return this.mergeTree.resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, shortRemoteClientId);
    }
    /**
     *  Given an pending operation and segment group, regenerate the op, so it
     *  can be resubmitted
     * @param resetOp - The op to reset
     * @param segmentGroup - The segment group associated with the op
     */
    regeneratePendingOp(resetOp, segmentGroup) {
        const trace = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();
        try {
            const opList = [];
            if (resetOp.type === 3 /* GROUP */) {
                if (Array.isArray(segmentGroup)) {
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(resetOp.ops.length === segmentGroup.length, 0x03a /* "Number of ops in 'resetOp' must match the number of segment groups provided." */);
                    for (let i = 0; i < resetOp.ops.length; i++) {
                        opList.push(...this.resetPendingDeltaToOps(resetOp.ops[i], segmentGroup[i]));
                    }
                }
                else {
                    // A group op containing a single op will pass a direct reference to 'segmentGroup'
                    // rather than an array of segment groups.  (See 'peekPendingSegmentGroups()')
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(resetOp.ops.length === 1, 0x03b /* "Number of ops in 'resetOp' must match the number of segment groups provided." */);
                    opList.push(...this.resetPendingDeltaToOps(resetOp.ops[0], segmentGroup));
                }
            }
            else {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(resetOp.type !== 3 /* GROUP */, 0x03c /* "Reset op has 'group' delta type!" */);
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!Array.isArray(segmentGroup), 0x03d /* "segmentGroup is array rather than singleton!" */);
                opList.push(...this.resetPendingDeltaToOps(resetOp, segmentGroup));
            }
            return opList.length === 1 ? opList[0] : _opBuilder__WEBPACK_IMPORTED_MODULE_2__.createGroupOp(...opList);
        }
        finally {
            this.logger.sendPerformanceEvent({
                eventName: "MergeTree:RegeneratePendingOp",
                category: "performance",
                duration: (0,_mergeTree__WEBPACK_IMPORTED_MODULE_0__.elapsedMicroseconds)(trace),
            });
        }
    }
    createTextHelper() {
        return new _textSegment__WEBPACK_IMPORTED_MODULE_9__.MergeTreeTextHelper(this.mergeTree);
    }
    // TODO: Remove `catchUpMsgs` once new snapshot format is adopted as default.
    //       (See https://github.com/microsoft/FluidFramework/issues/84)
    snapshot(runtime, handle, serializer, catchUpMsgs) {
        var _a;
        const deltaManager = runtime.deltaManager;
        const minSeq = deltaManager.minimumSequenceNumber;
        // Catch up to latest MSN, if we have not had a chance to do it.
        // Required for case where FluidDataStoreRuntime.attachChannel()
        // generates snapshot right after loading data store.
        this.updateSeqNumbers(minSeq, deltaManager.lastSequenceNumber);
        // One of the snapshots (from SPO) I observed to have chunk.chunkSequenceNumber > minSeq!
        // Not sure why - need to catch it sooner
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(this.getCollabWindow().minSeq === minSeq, 0x03e /* "minSeq mismatch between collab window and delta manager!" */);
        // TODO: Remove options flag once new snapshot format is adopted as default.
        //       (See https://github.com/microsoft/FluidFramework/issues/84)
        if (((_a = this.mergeTree.options) === null || _a === void 0 ? void 0 : _a.newMergeTreeSnapshotFormat) === true) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(catchUpMsgs === undefined || catchUpMsgs.length === 0, 0x03f /* "New format should not emit catchup ops" */);
            const snap = new _snapshotV1__WEBPACK_IMPORTED_MODULE_10__.SnapshotV1(this.mergeTree, this.logger);
            snap.extractSync();
            return snap.emit(serializer, handle);
        }
        else {
            const snap = new _snapshotlegacy__WEBPACK_IMPORTED_MODULE_11__.SnapshotLegacy(this.mergeTree, this.logger);
            snap.extractSync();
            return snap.emit(catchUpMsgs, serializer, handle);
        }
    }
    async load(runtime, storage, serializer) {
        const loader = new _snapshotLoader__WEBPACK_IMPORTED_MODULE_12__.SnapshotLoader(runtime, this, this.mergeTree, this.logger, serializer);
        return loader.initialize(storage);
    }
    getStackContext(startPos, rangeLabels) {
        return this.mergeTree.getStackContext(startPos, this.getCollabWindow().clientId, rangeLabels);
    }
    getLocalSequenceNumber() {
        const segWindow = this.getCollabWindow();
        if (segWindow.collaborating) {
            return _constants__WEBPACK_IMPORTED_MODULE_6__.UnassignedSequenceNumber;
        }
        else {
            return _constants__WEBPACK_IMPORTED_MODULE_6__.UniversalSequenceNumber;
        }
    }
    localTransaction(groupOp) {
        for (const op of groupOp.ops) {
            const opArgs = {
                op,
                groupOp,
            };
            switch (op.type) {
                case 0 /* INSERT */:
                    this.applyInsertOp(opArgs);
                    break;
                case 2 /* ANNOTATE */:
                    this.applyAnnotateRangeOp(opArgs);
                    break;
                case 1 /* REMOVE */:
                    this.applyRemoveRangeOp(opArgs);
                    break;
                default:
                    break;
            }
        }
    }
    updateConsensusProperty(op, msg) {
        const markerId = op.relativePos1.id;
        const consensusInfo = this.pendingConsensus.get(markerId);
        if (consensusInfo) {
            consensusInfo.marker.addProperties(op.props, op.combiningOp, msg.sequenceNumber);
        }
        this.mergeTree.addMinSeqListener(msg.sequenceNumber, () => consensusInfo.callback(consensusInfo.marker));
    }
    updateMinSeq(minSeq) {
        let trace;
        if (this.measureOps) {
            trace = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();
        }
        this.mergeTree.setMinSeq(minSeq);
        if (trace) {
            const elapsed = (0,_mergeTree__WEBPACK_IMPORTED_MODULE_0__.elapsedMicroseconds)(trace);
            this.accumWindowTime += elapsed;
            if (elapsed > this.maxWindowTime) {
                this.maxWindowTime = elapsed;
            }
        }
    }
    getContainingSegment(pos) {
        const segWindow = this.mergeTree.getCollabWindow();
        return this.mergeTree.getContainingSegment(pos, segWindow.currentSeq, segWindow.clientId);
    }
    getPropertiesAtPosition(pos) {
        const segWindow = this.getCollabWindow();
        if (this.verboseOps) {
            // eslint-disable-next-line max-len
            console.log(`getPropertiesAtPosition cli ${this.getLongClientId(segWindow.clientId)} ref seq ${segWindow.currentSeq}`);
        }
        let propertiesAtPosition;
        const segoff = this.getContainingSegment(pos);
        const seg = segoff.segment;
        if (seg) {
            propertiesAtPosition = seg.properties;
        }
        return propertiesAtPosition;
    }
    getRangeExtentsOfPosition(pos) {
        const segWindow = this.getCollabWindow();
        if (this.verboseOps) {
            // eslint-disable-next-line max-len
            console.log(`getRangeExtentsOfPosition cli ${this.getLongClientId(segWindow.clientId)} ref seq ${segWindow.currentSeq}`);
        }
        let posStart;
        let posAfterEnd;
        const segoff = this.getContainingSegment(pos);
        const seg = segoff.segment;
        if (seg) {
            posStart = this.getPosition(seg);
            posAfterEnd = posStart + seg.cachedLength;
        }
        return { posStart, posAfterEnd };
    }
    getCurrentSeq() {
        return this.getCollabWindow().currentSeq;
    }
    getClientId() {
        return this.getCollabWindow().clientId;
    }
    getLength() { return this.mergeTree.length; }
    startOrUpdateCollaboration(longClientId, minSeq = 0, currentSeq = 0) {
        // we should always have a client id if we are collaborating
        // if the client id is undefined we are likely bound to a detached
        // container, so we should keep going in local mode. once
        // the container attaches this will be called again on connect with the
        // client id
        if (longClientId !== undefined) {
            if (this.longClientId === undefined) {
                this.longClientId = longClientId;
                this.addLongClientId(this.longClientId);
                this.mergeTree.startCollaboration(this.getShortClientId(this.longClientId), minSeq, currentSeq);
            }
            else {
                const oldClientId = this.longClientId;
                const oldData = this.clientNameToIds.get(oldClientId).data;
                this.longClientId = longClientId;
                this.clientNameToIds.put(longClientId, oldData);
                this.shortClientIdMap[oldData] = longClientId;
            }
        }
    }
    findTile(startPos, tileLabel, preceding = true) {
        const clientId = this.getClientId();
        return this.mergeTree.findTile(startPos, clientId, tileLabel, preceding);
    }
}
//# sourceMappingURL=client.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/collections.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/collections.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Stack": () => (/* binding */ Stack),
/* harmony export */   "ListMakeHead": () => (/* binding */ ListMakeHead),
/* harmony export */   "Heap": () => (/* binding */ Heap),
/* harmony export */   "RedBlackTree": () => (/* binding */ RedBlackTree),
/* harmony export */   "IntervalTree": () => (/* binding */ IntervalTree)
/* harmony export */ });
/* unused harmony exports ListRemoveEntry, ListMakeEntry, List, numberComparer, LinearDictionary, RBColor, integerRangeUnion, integerRangeOverlaps, integerRangeComparer, integerRangeCopy, integerRangeToString, IntegerRangeTree, intervalComparer, TST */
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/trace.js");
/* harmony import */ var _mergeTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mergeTree */ "../../node_modules/@fluidframework/merge-tree/lib/mergeTree.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/* eslint-disable @typescript-eslint/consistent-type-assertions, eqeqeq, object-shorthand */
/* eslint-disable no-bitwise */
/* Remove once strictNullCheck is enabled */


class Stack {
    constructor() {
        this.items = [];
    }
    push(val) {
        this.items.push(val);
    }
    empty() {
        return this.items.length === 0;
    }
    top() {
        return this.items[this.items.length - 1];
    }
    pop() {
        return this.items.pop();
    }
}
function ListRemoveEntry(entry) {
    if (entry === undefined) {
        return undefined;
    }
    else if (entry.isHead) {
        return undefined;
    }
    else {
        entry.next.prev = entry.prev;
        entry.prev.next = entry.next;
    }
    return (entry);
}
function ListMakeEntry(data) {
    return new List(false, data);
}
function ListMakeHead() {
    return new List(true, undefined);
}
class List {
    constructor(isHead, data) {
        this.isHead = isHead;
        this.data = data;
        this.prev = this;
        this.next = this;
    }
    clear() {
        if (this.isHead) {
            this.prev = this;
            this.next = this;
        }
    }
    add(data) {
        const entry = ListMakeEntry(data);
        this.prev.next = entry;
        entry.next = this;
        entry.prev = this.prev;
        this.prev = entry;
        return (entry);
    }
    dequeue() {
        if (!this.empty()) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const removedEntry = ListRemoveEntry(this.next);
            return removedEntry.data;
        }
    }
    enqueue(data) {
        return this.add(data);
    }
    walk(fn) {
        for (let entry = this.next; !(entry.isHead); entry = entry.next) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            fn(entry.data, entry);
        }
    }
    some(fn, rev) {
        const rtn = [];
        const start = rev ? this.prev : this.next;
        for (let entry = start; !(entry.isHead); entry = rev ? entry.prev : entry.next) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const data = entry.data;
            if (fn(data, entry)) {
                if (rev) {
                    // preserve list order when in reverse
                    rtn.unshift(data);
                }
                else {
                    rtn.push(data);
                }
            }
        }
        return rtn;
    }
    count() {
        let entry;
        let i;
        entry = this.next;
        for (i = 0; !(entry.isHead); i++) {
            entry = entry.next;
        }
        return (i);
    }
    first() {
        if (!this.empty()) {
            return (this.next.data);
        }
    }
    last() {
        if (!this.empty()) {
            return (this.prev.data);
        }
    }
    empty() {
        return (this.next === this);
    }
    pushEntry(entry) {
        entry.isHead = false;
        entry.next = this.next;
        entry.prev = this;
        this.next = entry;
        entry.next.prev = entry;
    }
    push(data) {
        const entry = ListMakeEntry(data);
        entry.data = data;
        entry.isHead = false;
        entry.next = this.next;
        entry.prev = this;
        this.next = entry;
        entry.next.prev = entry;
    }
    popEntry(head) {
        if (this.next.isHead) {
            return undefined;
        }
        else {
            return ListRemoveEntry(this.next);
        }
    }
    insertEntry(entry) {
        entry.isHead = false;
        this.prev.next = entry;
        entry.next = this;
        entry.prev = this.prev;
        this.prev = entry;
        return entry;
    }
    insertAfter(data) {
        const entry = ListMakeEntry(data);
        entry.next = this.next;
        entry.prev = this;
        this.next = entry;
        entry.next.prev = entry;
        return (entry);
    }
    insertBefore(data) {
        const entry = ListMakeEntry(data);
        return this.insertEntryBefore(entry);
    }
    insertEntryBefore(entry) {
        this.prev.next = entry;
        entry.next = this;
        entry.prev = this.prev;
        this.prev = entry;
        return (entry);
    }
}
const numberComparer = {
    min: Number.MIN_VALUE,
    compare: (a, b) => a - b,
};
class Heap {
    constructor(a, comp) {
        this.comp = comp;
        this.L = [comp.min];
        for (let i = 0, len = a.length; i < len; i++) {
            this.add(a[i]);
        }
    }
    count() {
        return this.L.length - 1;
    }
    peek() {
        return this.L[1];
    }
    get() {
        const x = this.L[1];
        this.L[1] = this.L[this.count()];
        this.L.pop();
        this.fixdown(1);
        return x;
    }
    add(x) {
        this.L.push(x);
        this.fixup(this.count());
    }
    fixup(k) {
        let _k = k;
        while (_k > 1 && (this.comp.compare(this.L[_k >> 1], this.L[_k]) > 0)) {
            const tmp = this.L[_k >> 1];
            this.L[_k >> 1] = this.L[_k];
            this.L[_k] = tmp;
            _k = _k >> 1;
        }
    }
    fixdown(k) {
        let _k = k;
        while ((_k << 1) <= (this.count())) {
            let j = _k << 1;
            if ((j < this.count()) && (this.comp.compare(this.L[j], this.L[j + 1]) > 0)) {
                j++;
            }
            if (this.comp.compare(this.L[_k], this.L[j]) <= 0) {
                break;
            }
            const tmp = this.L[_k];
            this.L[_k] = this.L[j];
            this.L[j] = tmp;
            _k = j;
        }
    }
}
// For testing
function LinearDictionary(compareKeys) {
    const props = [];
    const compareProps = (a, b) => compareKeys(a.key, b.key);
    function diag() {
        console.log(`size is ${props.length}`);
    }
    function mapRange(action, accum, start, end) {
        let _start = start;
        let _end = end;
        if (props.length !== 0) {
            return;
        }
        if (_start === undefined) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            _start = min().key;
        }
        if (_end === undefined) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            _end = max().key;
        }
        for (let i = 0, len = props.length; i < len; i++) {
            if (compareKeys(_start, props[i].key) <= 0) {
                const ecmp = compareKeys(_end, props[i].key);
                if (ecmp < 0) {
                    break;
                }
                if (!action(props[i], accum)) {
                    break;
                }
            }
        }
    }
    function map(action, accum) {
        mapRange(action, accum);
    }
    function min() {
        if (props.length > 0) {
            return props[0];
        }
    }
    function max() {
        if (props.length > 0) {
            return props[props.length - 1];
        }
    }
    function get(key) {
        for (let i = 0, len = props.length; i < len; i++) {
            if (props[i].key == key) {
                return props[i];
            }
        }
    }
    function put(key, data) {
        if (key !== undefined) {
            if (data === undefined) {
                remove(key);
            }
            else {
                props.push({ key, data });
                props.sort(compareProps); // Go to insertion sort if too slow
            }
        }
    }
    function remove(key) {
        if (key !== undefined) {
            for (let i = 0, len = props.length; i < len; i++) {
                if (props[i].key == key) {
                    props[i] = props[len - 1];
                    props.length--;
                    props.sort(compareProps);
                    break;
                }
            }
        }
    }
    return {
        min: min,
        max: max,
        map: map,
        mapRange: mapRange,
        remove: remove,
        get: get,
        put: put,
        diag: diag,
    };
}
var RBColor;
(function (RBColor) {
    RBColor[RBColor["RED"] = 0] = "RED";
    RBColor[RBColor["BLACK"] = 1] = "BLACK";
})(RBColor || (RBColor = {}));
class RedBlackTree {
    constructor(compareKeys, aug) {
        this.compareKeys = compareKeys;
        this.aug = aug;
    }
    makeNode(key, data, color, size) {
        const node = { key, data, color, size };
        if (this.aug && this.aug.init) {
            this.aug.init(node);
        }
        return node;
    }
    isRed(node) {
        return !!node && (node.color == 0 /* RED */);
    }
    nodeSize(node) {
        return node ? node.size : 0;
    }
    size() {
        return this.nodeSize(this.root);
    }
    isEmpty() {
        return !this.root;
    }
    get(key) {
        if (key !== undefined) {
            return this.nodeGet(this.root, key);
        }
    }
    nodeGet(node, key) {
        let _node = node;
        while (_node) {
            const cmp = this.compareKeys(key, _node.key);
            if (cmp < 0) {
                _node = _node.left;
            }
            else if (cmp > 0) {
                _node = _node.right;
            }
            else {
                return _node;
            }
        }
    }
    contains(key) {
        return this.get(key);
    }
    gather(key, matcher) {
        const results = [];
        if (key !== undefined) {
            this.nodeGather(this.root, results, key, matcher);
        }
        return results;
    }
    nodeGather(node, results, key, matcher) {
        if (node) {
            if (matcher.continueSubtree(node.left, key)) {
                this.nodeGather(node.left, results, key, matcher);
            }
            if (matcher.matchNode(node, key)) {
                results.push(node);
            }
            if (matcher.continueSubtree(node.right, key)) {
                this.nodeGather(node.right, results, key, matcher);
            }
        }
    }
    put(key, data, conflict) {
        if (key !== undefined) {
            if (data === undefined) {
                this.remove(key);
            }
            else {
                this.root = this.nodePut(this.root, key, data, conflict);
                this.root.color = 1 /* BLACK */;
            }
        }
    }
    nodePut(node, key, data, conflict) {
        let _node = node;
        if (!_node) {
            return this.makeNode(key, data, 0 /* RED */, 1);
        }
        else {
            const cmp = this.compareKeys(key, _node.key);
            if (cmp < 0) {
                _node.left = this.nodePut(_node.left, key, data, conflict);
            }
            else if (cmp > 0) {
                _node.right = this.nodePut(_node.right, key, data, conflict);
            }
            else {
                if (conflict) {
                    const kd = conflict(key, _node.key, data, _node.data);
                    if (kd.key) {
                        _node.key = kd.key;
                    }
                    if (kd.data) {
                        _node.data = kd.data;
                    }
                    else {
                        _node.data = data;
                    }
                }
                else {
                    _node.data = data;
                }
            }
            if (this.isRed(_node.right) && (!this.isRed(_node.left))) {
                _node = this.rotateLeft(_node);
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (this.isRed(_node.left) && this.isRed(_node.left.left)) {
                _node = this.rotateRight(_node);
            }
            if (this.isRed(_node.left) && this.isRed(_node.right)) {
                this.flipColors(_node);
            }
            _node.size = this.nodeSize(_node.left) + this.nodeSize(_node.right) + 1;
            if (this.aug) {
                this.updateLocal(_node);
            }
            return _node;
        }
    }
    updateLocal(node) {
        if (this.aug) {
            if (this.isRed(node.left)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.aug.update(node.left);
            }
            if (this.isRed(node.right)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.aug.update(node.right);
            }
            this.aug.update(node);
        }
    }
    removeMin() {
        if (this.root) {
            if ((!this.isRed(this.root.left)) && (!this.isRed(this.root.right))) {
                this.root.color = 0 /* RED */;
            }
            this.root = this.nodeRemoveMin(this.root);
            if (this.root) {
                this.root.color = 1 /* BLACK */;
            }
        }
        // TODO: error on empty
    }
    nodeRemoveMin(node) {
        let _node = node;
        if (_node.left) {
            if ((!this.isRed(_node.left)) && (!this.isRed(_node.left.left))) {
                _node = this.moveRedLeft(_node);
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            _node.left = this.nodeRemoveMin(_node.left);
            return this.balance(_node);
        }
    }
    removeMax() {
        if (this.root) {
            if ((!this.isRed(this.root.left)) && (!this.isRed(this.root.right))) {
                this.root.color = 0 /* RED */;
            }
            this.root = this.nodeRemoveMax(this.root);
            if (this.root) {
                this.root.color = 1 /* BLACK */;
            }
        }
        // TODO: error on empty
    }
    nodeRemoveMax(node) {
        let _node = node;
        if (this.isRed(_node.left)) {
            _node = this.rotateRight(_node);
        }
        if (!_node.right) {
            return undefined;
        }
        if ((!this.isRed(_node.right)) && (!this.isRed(_node.right.left))) {
            _node = this.moveRedRight(_node);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        _node.right = this.nodeRemoveMax(_node.right);
        return this.balance(_node);
    }
    remove(key) {
        if (key !== undefined) {
            if (!this.contains(key)) {
                return;
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if ((!this.isRed(this.root.left)) && (!this.isRed(this.root.right))) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.root.color = 0 /* RED */;
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.root = this.nodeRemove(this.root, key);
        }
        // TODO: error on undefined key
    }
    nodeRemove(node, key) {
        let _node = node;
        if (this.compareKeys(key, _node.key) < 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if ((!this.isRed(_node.left)) && (!this.isRed(_node.left.left))) {
                _node = this.moveRedLeft(_node);
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            _node.left = this.nodeRemove(_node.left, key);
        }
        else {
            if (this.isRed(_node.left)) {
                _node = this.rotateRight(_node);
            }
            if ((this.compareKeys(key, _node.key) == 0) && (!_node.right)) {
                return undefined;
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if ((!this.isRed(_node.right)) && (!this.isRed(_node.right.left))) {
                _node = this.moveRedRight(_node);
            }
            if (this.compareKeys(key, _node.key) == 0) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const subtreeMin = this.nodeMin(_node.right);
                _node.key = subtreeMin.key;
                _node.data = subtreeMin.data;
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                _node.right = this.nodeRemoveMin(_node.right);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                _node.right = this.nodeRemove(_node.right, key);
            }
        }
        return this.balance(_node);
    }
    height() {
        return this.nodeHeight(this.root);
    }
    nodeHeight(node) {
        if (node === undefined) {
            return -1;
        }
        else {
            return 1 + Math.max(this.nodeHeight(node.left), this.nodeHeight(node.right));
        }
    }
    floor(key) {
        if (!this.isEmpty()) {
            return this.nodeFloor(this.root, key);
        }
    }
    nodeFloor(node, key) {
        if (node) {
            const cmp = this.compareKeys(key, node.key);
            if (cmp == 0) {
                return node;
            }
            else if (cmp < 0) {
                return this.nodeFloor(node.left, key);
            }
            else {
                const rightFloor = this.nodeFloor(node.right, key);
                if (rightFloor) {
                    return rightFloor;
                }
                else {
                    return node;
                }
            }
        }
    }
    ceil(key) {
        if (!this.isEmpty()) {
            return this.nodeCeil(this.root, key);
        }
    }
    nodeCeil(node, key) {
        if (node) {
            const cmp = this.compareKeys(key, node.key);
            if (cmp == 0) {
                return node;
            }
            else if (cmp > 0) {
                return this.nodeCeil(node.right, key);
            }
            else {
                const leftCeil = this.nodeCeil(node.left, key);
                if (leftCeil) {
                    return leftCeil;
                }
                else {
                    return node;
                }
            }
        }
    }
    min() {
        if (this.root) {
            return this.nodeMin(this.root);
        }
    }
    nodeMin(node) {
        if (!node.left) {
            return node;
        }
        else {
            return this.nodeMin(node.left);
        }
    }
    max() {
        if (this.root) {
            return this.nodeMax(this.root);
        }
    }
    nodeMax(node) {
        if (!node.right) {
            return node;
        }
        else {
            return this.nodeMax(node.right);
        }
    }
    rotateRight(node) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const leftChild = node.left;
        node.left = leftChild.right;
        leftChild.right = node;
        leftChild.color = leftChild.right.color;
        leftChild.right.color = 0 /* RED */;
        leftChild.size = node.size;
        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;
        if (this.aug) {
            this.updateLocal(node);
            this.updateLocal(leftChild);
        }
        return leftChild;
    }
    rotateLeft(node) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const rightChild = node.right;
        node.right = rightChild.left;
        rightChild.left = node;
        rightChild.color = rightChild.left.color;
        rightChild.left.color = 0 /* RED */;
        rightChild.size = node.size;
        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;
        if (this.aug) {
            this.updateLocal(node);
            this.updateLocal(rightChild);
        }
        return rightChild;
    }
    oppositeColor(c) {
        return (c == 1 /* BLACK */) ? 0 /* RED */ : 1 /* BLACK */;
    }
    flipColors(node) {
        node.color = this.oppositeColor(node.color);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        node.left.color = this.oppositeColor(node.left.color);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        node.right.color = this.oppositeColor(node.right.color);
    }
    moveRedLeft(node) {
        let _node = node;
        this.flipColors(_node);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (this.isRed(_node.right.left)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            _node.right = this.rotateRight(_node.right);
            _node = this.rotateLeft(_node);
            this.flipColors(_node);
        }
        return _node;
    }
    moveRedRight(node) {
        let _node = node;
        this.flipColors(_node);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (this.isRed(_node.left.left)) {
            _node = this.rotateRight(_node);
            this.flipColors(_node);
        }
        return _node;
    }
    balance(input) {
        let node = input;
        if (this.isRed(node.right)) {
            node = this.rotateLeft(node);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (this.isRed(node.left) && this.isRed(node.left.left)) {
            node = this.rotateRight(node);
        }
        if (this.isRed(node.left) && (this.isRed(node.right))) {
            this.flipColors(node);
        }
        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;
        if (this.aug) {
            this.aug.update(node);
        }
        return node;
    }
    mapRange(action, accum, start, end) {
        this.nodeMap(this.root, action, start, end);
    }
    map(action, accum) {
        // TODO: optimize to avoid comparisons
        this.nodeMap(this.root, action, accum);
    }
    keys() {
        const keyList = [];
        const actions = {
            showStructure: true,
            infix: (node) => {
                keyList.push(node.key);
                return true;
            },
        };
        this.walk(actions);
        return keyList;
    }
    /**
     * Depth-first traversal with custom action; if action returns
     * false, traversal is halted.
     * @param action - action to apply to each node
     */
    walk(actions) {
        this.nodeWalk(this.root, actions);
    }
    nodeWalk(node, actions) {
        let go = true;
        if (node) {
            if (actions.pre) {
                if (actions.showStructure || (node.color === 1 /* BLACK */)) {
                    go = actions.pre(node);
                }
            }
            if (node.left) {
                go = this.nodeWalk(node.left, actions);
            }
            if (go && actions.infix) {
                if (actions.showStructure || (node.color === 1 /* BLACK */)) {
                    go = actions.infix(node);
                }
            }
            if (go) {
                go = this.nodeWalk(node.right, actions);
            }
            if (go && actions.post) {
                if (actions.showStructure || (node.color === 1 /* BLACK */)) {
                    go = actions.post(node);
                }
            }
        }
        return go;
    }
    nodeMap(node, action, accum, start, end) {
        let _start = start;
        let _end = end;
        if (!node) {
            return true;
        }
        if (_start === undefined) {
            _start = this.nodeMin(node).key;
        }
        if (_end === undefined) {
            _end = this.nodeMax(node).key;
        }
        const cmpStart = this.compareKeys(_start, node.key);
        const cmpEnd = this.compareKeys(_end, node.key);
        let go = true;
        if (cmpStart < 0) {
            go = this.nodeMap(node.left, action, accum, _start, _end);
        }
        if (go && (cmpStart <= 0) && (cmpEnd >= 0)) {
            // REVIEW: test for black node here
            go = action(node, accum);
        }
        if (go && (cmpEnd > 0)) {
            go = this.nodeMap(node.right, action, accum, _start, _end);
        }
        return go;
    }
    diag() {
        console.log(`Height is ${this.height()}`);
    }
}
/**
 * Union of two ranges; assumes for both ranges start \<= end.
 * @param a - A range
 * @param b - A range
 */
function integerRangeUnion(a, b) {
    return {
        start: Math.min(a.start, b.start),
        end: Math.max(a.end, b.end),
    };
}
function integerRangeOverlaps(a, b) {
    return (a.start < b.end) && (a.end > b.start);
}
function integerRangeComparer(a, b) {
    if (a.start === b.start) {
        return a.end - b.end;
    }
    else {
        return a.start - b.start;
    }
}
const integerRangeCopy = (r) => ({ start: r.start, end: r.end });
const integerRangeToString = (range) => `[${range.start},${range.end})`;
// TODO: handle duplicate keys
class IntegerRangeTree {
    constructor() {
        this.ranges = new RedBlackTree(integerRangeComparer, this);
        this.diag = false;
    }
    remove(r) {
        this.ranges.remove(r);
    }
    put(r) {
        this.ranges.put(r, { minmax: integerRangeCopy(r) });
    }
    toString() {
        return this.nodeToString(this.ranges.root);
    }
    nodeToString(node) {
        let buf = "";
        let indentAmt = 0;
        const actions = {
            pre: (n) => {
                let red = "";
                if (n.color === 0 /* RED */) {
                    red = "R ";
                }
                buf += _mergeTree__WEBPACK_IMPORTED_MODULE_0__.internedSpaces(indentAmt);
                buf += `${red}key: ${integerRangeToString(n.key)} minmax: ${integerRangeToString(n.data.minmax)}\n`;
                indentAmt += 2;
                return true;
            },
            post: (n) => {
                indentAmt -= 2;
                return true;
            },
            showStructure: true,
        };
        this.ranges.nodeWalk(node, actions);
        return buf;
    }
    matchPos(pos) {
        return this.match({ start: pos, end: pos + 1 });
    }
    match(r) {
        return this.ranges.gather(r, this);
    }
    matchNode(node, key) {
        return !!node && integerRangeOverlaps(node.key, key);
    }
    continueSubtree(node, key) {
        const cont = !!node && integerRangeOverlaps(node.data.minmax, key);
        if (this.diag && (!cont)) {
            if (node) {
                console.log(`skipping subtree of size ${node.size} key ${integerRangeToString(key)}`);
                console.log(this.nodeToString(node));
            }
        }
        return cont;
    }
    update(node) {
        if (node.left && node.right) {
            node.data.minmax = integerRangeUnion(node.key, integerRangeUnion(node.left.data.minmax, node.right.data.minmax));
        }
        else {
            if (node.left) {
                node.data.minmax = integerRangeUnion(node.key, node.left.data.minmax);
            }
            else if (node.right) {
                node.data.minmax = integerRangeUnion(node.key, node.right.data.minmax);
            }
            else {
                node.data.minmax = integerRangeCopy(node.key);
            }
        }
    }
}
const intervalComparer = (a, b) => a.compare(b);
class IntervalTree {
    constructor() {
        this.intervals = new RedBlackTree(intervalComparer, this);
        this.diag = false;
        this.timePut = false;
        this.putTime = 0;
        this.putCount = 0;
    }
    printTiming() {
        console.log(`put total = ${this.putTime} avg=${(this.putTime / this.putCount).toFixed(2)}`);
    }
    remove(x) {
        this.intervals.remove(x);
    }
    put(x, conflict) {
        let rbConflict;
        if (conflict) {
            rbConflict = (key, currentKey) => {
                const ival = conflict(key, currentKey);
                return {
                    key: ival,
                };
            };
        }
        if (this.timePut) {
            const trace = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Trace.start();
            this.intervals.put(x, { minmax: x.clone() }, rbConflict);
            this.putTime += trace.trace().duration * 1000;
            this.putCount++;
        }
        else {
            this.intervals.put(x, { minmax: x.clone() }, rbConflict);
        }
    }
    map(fn) {
        const actions = {
            infix: (node) => {
                fn(node.key);
                return true;
            },
            showStructure: true,
        };
        this.intervals.walk(actions);
    }
    // TODO: toString()
    match(x) {
        return this.intervals.gather(x, this);
    }
    matchNode(node, key) {
        return !!node && node.key.overlaps(key);
    }
    continueSubtree(node, key) {
        const cont = !!node && node.data.minmax.overlaps(key);
        if (this.diag && (!cont)) {
            if (node) {
                console.log(`skipping subtree of size ${node.size} key ${key.toString()}`);
                // console.log(this.nodeToString(node));
            }
        }
        return cont;
    }
    update(node) {
        if (node.left && node.right) {
            node.data.minmax = node.key.union(node.left.data.minmax.union(node.right.data.minmax));
        }
        else {
            if (node.left) {
                node.data.minmax = node.key.union(node.left.data.minmax);
            }
            else if (node.right) {
                node.data.minmax = node.key.union(node.right.data.minmax);
            }
            else {
                node.data.minmax = node.key.clone();
            }
        }
    }
}
class TST {
    constructor() {
        this.n = 0;
    }
    size() {
        return this.n;
    }
    contains(key) {
        return this.get(key);
    }
    get(key) {
        const x = this.nodeGet(this.root, key, 0);
        if (x === undefined) {
            return undefined;
        }
        return x.val;
    }
    nodeGet(x, key, d) {
        if (x === undefined) {
            return undefined;
        }
        const c = key.charAt(d);
        if (c < x.c) {
            return this.nodeGet(x.left, key, d);
        }
        else if (c > x.c) {
            return this.nodeGet(x.right, key, d);
        }
        else if (d < (key.length - 1)) {
            return this.nodeGet(x.mid, key, d + 1);
        }
        else {
            return x;
        }
    }
    put(key, val) {
        if (!this.contains(key)) {
            this.n++;
        }
        this.root = this.nodePut(this.root, key, val, 0);
        // console.log(`put ${key}`);
    }
    nodePut(x, key, val, d) {
        let _x = x;
        const c = key.charAt(d);
        if (_x === undefined) {
            _x = { c };
        }
        if (c < _x.c) {
            _x.left = this.nodePut(_x.left, key, val, d);
        }
        else if (c > _x.c) {
            _x.right = this.nodePut(_x.right, key, val, d);
        }
        else if (d < (key.length - 1)) {
            _x.mid = this.nodePut(_x.mid, key, val, d + 1);
        }
        else {
            _x.val = val;
        }
        return _x;
    }
    neighbors(text, distance = 2) {
        let q = [];
        this.nodeProximity(this.root, { text: "" }, 0, text, distance, q);
        q = q.filter((value) => (value.text.length > 0));
        return q;
    }
    keysWithPrefix(text) {
        const q = [];
        const x = this.nodeGet(this.root, text, 0);
        if (x === undefined) {
            return q;
        }
        if (x.val !== undefined) {
            q.push(text);
        }
        this.collect(x.mid, { text }, q);
        return q;
    }
    collect(x, prefix, q) {
        if (x === undefined) {
            return;
        }
        this.collect(x.left, prefix, q);
        if (x.val !== undefined) {
            q.push(prefix.text + x.c);
        }
        this.collect(x.mid, { text: prefix.text + x.c }, q);
        this.collect(x.right, prefix, q);
    }
    mapNode(x, prefix, fn) {
        if (x === undefined) {
            return;
        }
        const key = prefix.text + x.c;
        this.mapNode(x.left, prefix, fn);
        if (x.val) {
            fn(key, x.val);
        }
        this.mapNode(x.mid, { text: key }, fn);
        this.mapNode(x.right, prefix, fn);
    }
    map(fn) {
        this.mapNode(this.root, { text: "" }, fn);
    }
    pairsWithPrefix(text) {
        const q = [];
        const x = this.nodeGet(this.root, text, 0);
        if (x === undefined) {
            return q;
        }
        if (x.val !== undefined) {
            q.push({ key: text, val: x.val });
        }
        this.collectPairs(x.mid, { text }, q);
        return q;
    }
    collectPairs(x, prefix, q) {
        if (x === undefined) {
            return;
        }
        this.collectPairs(x.left, prefix, q);
        if (x.val !== undefined) {
            q.push({ key: prefix.text + x.c, val: x.val });
        }
        this.collectPairs(x.mid, { text: prefix.text + x.c }, q);
        this.collectPairs(x.right, prefix, q);
    }
    patternCollect(x, prefix, d, pattern, q) {
        if (x === undefined) {
            return;
        }
        const c = pattern.charAt(d);
        if ((c === ".") || (c < x.c)) {
            this.patternCollect(x.left, prefix, d, pattern, q);
        }
        else if ((c === ".") || (c === x.c)) {
            if ((d === (pattern.length - 1)) && (x.val !== undefined)) {
                q.push(prefix.text + x.c);
            }
            else if (d < (pattern.length - 1)) {
                this.patternCollect(x.mid, { text: prefix.text + x.c }, d + 1, pattern, q);
            }
        }
        if ((c === ".") || (c > x.c)) {
            this.patternCollect(x.right, prefix, d, pattern, q);
        }
    }
    nodeProximity(x, prefix, d, pattern, distance, q) {
        if ((x === undefined) || (distance < 0)) {
            return;
        }
        const c = pattern.charAt(d);
        if ((distance > 0) || (c < x.c)) {
            this.nodeProximity(x.left, prefix, d, pattern, distance, q);
        }
        if (x.val !== undefined) {
            const remD = distance - (pattern.length - d);
            if (remD >= 0) {
                let invD = distance;
                if (c !== x.c) {
                    invD--;
                }
                q.push({ text: prefix.text + x.c, val: x.val, invDistance: invD });
            }
        }
        const recurD = (d < (pattern.length - 1)) ? d + 1 : d;
        if (c === x.c) {
            this.nodeProximity(x.mid, { text: prefix.text + x.c }, recurD, pattern, distance, q);
        }
        else {
            this.nodeProximity(x.mid, { text: prefix.text + x.c }, recurD, pattern, distance - 1, q);
        }
        if ((distance > 0) || (c > x.c)) {
            this.nodeProximity(x.right, prefix, d, pattern, distance, q);
        }
    }
    match(pattern) {
        const q = [];
        this.patternCollect(this.root, { text: "" }, 0, pattern, q);
        return q;
    }
}
//# sourceMappingURL=collections.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/constants.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/constants.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UniversalSequenceNumber": () => (/* binding */ UniversalSequenceNumber),
/* harmony export */   "UnassignedSequenceNumber": () => (/* binding */ UnassignedSequenceNumber),
/* harmony export */   "TreeMaintenanceSequenceNumber": () => (/* binding */ TreeMaintenanceSequenceNumber),
/* harmony export */   "LocalClientId": () => (/* binding */ LocalClientId),
/* harmony export */   "NonCollabClient": () => (/* binding */ NonCollabClient)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Sequence numbers for shared segments start at 1 or greater.  Every segment marked
 * with sequence number zero will be counted as part of the requested string.
 */
const UniversalSequenceNumber = 0;
const UnassignedSequenceNumber = -1;
const TreeMaintenanceSequenceNumber = -2;
const LocalClientId = -1;
const NonCollabClient = -2;
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/localReference.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/localReference.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LocalReference": () => (/* binding */ LocalReference),
/* harmony export */   "LocalReferenceCollection": () => (/* binding */ LocalReferenceCollection)
/* harmony export */ });
/* harmony import */ var _mergeTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergeTree */ "../../node_modules/@fluidframework/merge-tree/lib/mergeTree.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ops */ "../../node_modules/@fluidframework/merge-tree/lib/ops.js");
/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./properties */ "../../node_modules/@fluidframework/merge-tree/lib/properties.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */



class LocalReference {
    constructor(client, initSegment, offset = 0, refType = _ops__WEBPACK_IMPORTED_MODULE_0__.ReferenceType.Simple) {
        this.client = client;
        this.offset = offset;
        this.refType = refType;
        this.segment = initSegment;
    }
    min(b) {
        if (this.compare(b) < 0) {
            return this;
        }
        else {
            return b;
        }
    }
    max(b) {
        if (this.compare(b) > 0) {
            return this;
        }
        else {
            return b;
        }
    }
    compare(b) {
        if (this.segment === b.segment) {
            return this.offset - b.offset;
        }
        else {
            if (this.segment === undefined
                || (b.segment !== undefined &&
                    this.segment.ordinal < b.segment.ordinal)) {
                return -1;
            }
            else {
                return 1;
            }
        }
    }
    toPosition() {
        if (this.segment && this.segment.parent) {
            return this.getOffset() + this.client.getPosition(this.segment);
        }
        else {
            return LocalReference.DetachedPosition;
        }
    }
    hasTileLabels() {
        return !!this.getTileLabels();
    }
    hasRangeLabels() {
        return !!this.getRangeLabels();
    }
    hasTileLabel(label) {
        return (0,_mergeTree__WEBPACK_IMPORTED_MODULE_1__.refHasTileLabel)(this, label);
    }
    hasRangeLabel(label) {
        return (0,_mergeTree__WEBPACK_IMPORTED_MODULE_1__.refHasRangeLabel)(this, label);
    }
    getTileLabels() {
        return (0,_mergeTree__WEBPACK_IMPORTED_MODULE_1__.refGetTileLabels)(this);
    }
    getRangeLabels() {
        return (0,_mergeTree__WEBPACK_IMPORTED_MODULE_1__.refGetRangeLabels)(this);
    }
    isLeaf() {
        return false;
    }
    addProperties(newProps, op) {
        this.properties = (0,_properties__WEBPACK_IMPORTED_MODULE_2__.addProperties)(this.properties, newProps, op);
    }
    getSegment() {
        return this.segment;
    }
    getOffset() {
        var _a;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if ((_a = this.segment) === null || _a === void 0 ? void 0 : _a.removedSeq) {
            return 0;
        }
        return this.offset;
    }
    getProperties() {
        return this.properties;
    }
}
LocalReference.DetachedPosition = -1;
class LocalReferenceCollection {
    constructor(segment, initialRefsByfOffset = new Array(segment.cachedLength)) {
        this.segment = segment;
        this.hierRefCount = 0;
        this.refCount = 0;
        // Since javascript arrays are sparse the above won't populate any of the
        // indicies, but it will ensure the length property of the array matches
        // the length of the segment.
        this.refsByOffset = initialRefsByfOffset;
    }
    static append(seg1, seg2) {
        if (seg2.localRefs && !seg2.localRefs.empty) {
            if (!seg1.localRefs) {
                seg1.localRefs = new LocalReferenceCollection(seg1);
            }
            seg1.localRefs.append(seg2.localRefs);
        }
    }
    [Symbol.iterator]() {
        const subiterators = [];
        for (const refs of this.refsByOffset) {
            if (refs) {
                if (refs.before) {
                    subiterators.push(refs.before[Symbol.iterator]());
                }
                if (refs.at) {
                    subiterators.push(refs.at[Symbol.iterator]());
                }
                if (refs.after) {
                    subiterators.push(refs.after[Symbol.iterator]());
                }
            }
        }
        const iterator = {
            next() {
                while (subiterators.length > 0) {
                    const next = subiterators[0].next();
                    if (next.done === true) {
                        subiterators.shift();
                    }
                    else {
                        return next;
                    }
                }
                return { value: undefined, done: true };
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    clear() {
        this.refCount = 0;
        this.hierRefCount = 0;
        const detachSegments = (refs) => {
            if (refs) {
                refs.forEach((r) => {
                    if (r.segment === this.segment) {
                        r.segment = undefined;
                    }
                });
            }
        };
        for (let i = 0; i < this.refsByOffset.length; i++) {
            const refsAtOffset = this.refsByOffset[i];
            if (refsAtOffset) {
                detachSegments(refsAtOffset.before);
                detachSegments(refsAtOffset.at);
                detachSegments(refsAtOffset.before);
                this.refsByOffset[i] = undefined;
            }
        }
    }
    get empty() {
        return this.refCount === 0;
    }
    addLocalRef(lref) {
        const refsAtOffset = this.refsByOffset[lref.offset];
        if (refsAtOffset === undefined) {
            this.refsByOffset[lref.offset] = {
                at: [lref],
            };
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            refsAtOffset.at.push(lref);
        }
        if (lref.hasRangeLabels() || lref.hasTileLabels()) {
            this.hierRefCount++;
        }
        this.refCount++;
    }
    removeLocalRef(lref) {
        const tryRemoveRef = (refs) => {
            if (refs) {
                const index = refs.indexOf(lref);
                if (index >= 0) {
                    refs.splice(index, 1);
                    if (lref.hasRangeLabels() || lref.hasTileLabels()) {
                        this.hierRefCount--;
                    }
                    this.refCount--;
                    return lref;
                }
            }
        };
        const refAtOffset = this.refsByOffset[lref.offset];
        if (refAtOffset !== undefined) {
            let ref = tryRemoveRef(refAtOffset.before);
            if (ref) {
                return ref;
            }
            ref = tryRemoveRef(refAtOffset.at);
            if (ref) {
                return ref;
            }
            ref = tryRemoveRef(refAtOffset.after);
            if (ref) {
                return ref;
            }
        }
    }
    /**
     * Called by 'append()' implementations to append local refs from the given 'other' segment to the
     * end of 'this' segment.
     *
     * Note: This method should be invoked after the caller has ensured that segments can be merged,
     *       but before 'this' segment's cachedLength has changed, or the adjustment to the local refs
     *       will be incorrect.
     */
    append(other) {
        if (!other || other.empty) {
            return;
        }
        this.hierRefCount += other.hierRefCount;
        this.refCount += other.refCount;
        other.hierRefCount = 0;
        for (const lref of other) {
            lref.segment = this.segment;
            lref.offset += this.refsByOffset.length;
        }
        this.refsByOffset.push(...other.refsByOffset);
    }
    split(offset, splitSeg) {
        if (!this.empty) {
            const localRefs = new LocalReferenceCollection(splitSeg, this.refsByOffset.splice(offset, this.refsByOffset.length - offset));
            splitSeg.localRefs = localRefs;
            for (const lref of localRefs) {
                lref.segment = splitSeg;
                lref.offset -= offset;
                if (lref.hasRangeLabels() || lref.hasTileLabels()) {
                    this.hierRefCount--;
                    localRefs.hierRefCount++;
                }
                this.refCount--;
                localRefs.refCount++;
            }
        }
    }
    addBeforeTombstones(...refs) {
        const beforeRefs = [];
        for (const iterable of refs) {
            for (const lref of iterable) {
                // eslint-disable-next-line no-bitwise
                if (lref.refType & _ops__WEBPACK_IMPORTED_MODULE_0__.ReferenceType.SlideOnRemove) {
                    beforeRefs.push(lref);
                    lref.segment = this.segment;
                    lref.offset = 0;
                    if (lref.hasRangeLabels() || lref.hasTileLabels()) {
                        this.hierRefCount++;
                    }
                    this.refCount++;
                }
                else {
                    lref.segment = undefined;
                }
            }
        }
        if (beforeRefs.length > 0) {
            if (this.refsByOffset[0] === undefined) {
                this.refsByOffset[0] = { before: beforeRefs };
            }
            else if (this.refsByOffset[0].before === undefined) {
                this.refsByOffset[0].before = beforeRefs;
            }
            else {
                this.refsByOffset[0].before.unshift(...beforeRefs);
            }
        }
    }
    addAfterTombstones(...refs) {
        const afterRefs = [];
        for (const iterable of refs) {
            for (const lref of iterable) {
                // eslint-disable-next-line no-bitwise
                if (lref.refType & _ops__WEBPACK_IMPORTED_MODULE_0__.ReferenceType.SlideOnRemove) {
                    afterRefs.push(lref);
                    lref.segment = this.segment;
                    lref.offset = this.segment.cachedLength - 1;
                    if (lref.hasRangeLabels() || lref.hasTileLabels()) {
                        this.hierRefCount++;
                    }
                    this.refCount++;
                }
                else {
                    lref.segment = undefined;
                }
            }
        }
        if (afterRefs.length > 0) {
            const refsAtOffset = this.refsByOffset[this.segment.cachedLength - 1];
            if (refsAtOffset === undefined) {
                this.refsByOffset[this.segment.cachedLength - 1] = { after: afterRefs };
            }
            else if (refsAtOffset.after === undefined) {
                refsAtOffset.after = afterRefs;
            }
            else {
                refsAtOffset.after.push(...afterRefs);
            }
        }
    }
}
//# sourceMappingURL=localReference.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/mergeTree.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/mergeTree.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ordinalToArray": () => (/* binding */ ordinalToArray),
/* harmony export */   "BaseSegment": () => (/* binding */ BaseSegment),
/* harmony export */   "reservedRangeLabelsKey": () => (/* binding */ reservedRangeLabelsKey),
/* harmony export */   "refGetTileLabels": () => (/* binding */ refGetTileLabels),
/* harmony export */   "refGetRangeLabels": () => (/* binding */ refGetRangeLabels),
/* harmony export */   "refHasTileLabel": () => (/* binding */ refHasTileLabel),
/* harmony export */   "refHasRangeLabel": () => (/* binding */ refHasRangeLabel),
/* harmony export */   "Marker": () => (/* binding */ Marker),
/* harmony export */   "compareNumbers": () => (/* binding */ compareNumbers),
/* harmony export */   "compareStrings": () => (/* binding */ compareStrings),
/* harmony export */   "elapsedMicroseconds": () => (/* binding */ elapsedMicroseconds),
/* harmony export */   "internedSpaces": () => (/* binding */ internedSpaces),
/* harmony export */   "RegisterCollection": () => (/* binding */ RegisterCollection),
/* harmony export */   "glc": () => (/* binding */ glc),
/* harmony export */   "MergeTree": () => (/* binding */ MergeTree)
/* harmony export */ });
/* unused harmony exports MergeNode, MaxNodesInBlock, MergeBlock, reservedTileLabelsKey, reservedMarkerIdKey, reservedMarkerSimpleTypeKey, IncrementalExecOp, IncrementalMapState, CollaborationWindow, clock, clientSeqComparer */
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/trace.js");
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./collections */ "../../node_modules/@fluidframework/merge-tree/lib/collections.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ "../../node_modules/@fluidframework/merge-tree/lib/constants.js");
/* harmony import */ var _localReference__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./localReference */ "../../node_modules/@fluidframework/merge-tree/lib/localReference.js");
/* harmony import */ var _mergeTreeTracking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mergeTreeTracking */ "../../node_modules/@fluidframework/merge-tree/lib/mergeTreeTracking.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ops */ "../../node_modules/@fluidframework/merge-tree/lib/ops.js");
/* harmony import */ var _partialLengths__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./partialLengths */ "../../node_modules/@fluidframework/merge-tree/lib/partialLengths.js");
/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./properties */ "../../node_modules/@fluidframework/merge-tree/lib/properties.js");
/* harmony import */ var _segmentGroupCollection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./segmentGroupCollection */ "../../node_modules/@fluidframework/merge-tree/lib/segmentGroupCollection.js");
/* harmony import */ var _segmentPropertiesManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./segmentPropertiesManager */ "../../node_modules/@fluidframework/merge-tree/lib/segmentPropertiesManager.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-shadow, max-len, no-bitwise */










class MergeNode {
    constructor() {
        this.index = 0;
        this.ordinal = "";
        this.cachedLength = 0;
    }
    isLeaf() {
        return false;
    }
}
// eslint-disable-next-line @typescript-eslint/ban-types
function addTile(tile, tiles) {
    const tileLabels = tile.getTileLabels();
    if (tileLabels) {
        for (const tileLabel of tileLabels) {
            tiles[tileLabel] = tile;
        }
    }
}
// eslint-disable-next-line @typescript-eslint/ban-types
function addTileIfNotPresent(tile, tiles) {
    const tileLabels = tile.getTileLabels();
    if (tileLabels) {
        for (const tileLabel of tileLabels) {
            if (tiles[tileLabel] === undefined) {
                tiles[tileLabel] = tile;
            }
        }
    }
}
function applyStackDelta(currentStackMap, deltaStackMap) {
    // eslint-disable-next-line guard-for-in, no-restricted-syntax
    for (const label in deltaStackMap) {
        const deltaStack = deltaStackMap[label];
        if (!deltaStack.empty()) {
            let currentStack = currentStackMap[label];
            if (currentStack === undefined) {
                currentStack = new _collections__WEBPACK_IMPORTED_MODULE_0__.Stack();
                currentStackMap[label] = currentStack;
            }
            for (const delta of deltaStack.items) {
                applyRangeReference(currentStack, delta);
            }
        }
    }
}
function applyRangeReference(stack, delta) {
    if (delta.refType & _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.NestBegin) {
        stack.push(delta);
        return true;
    }
    else {
        // Assume delta is end reference
        const top = stack.top();
        // TODO: match end with begin
        if (top && (top.refType & _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.NestBegin)) {
            stack.pop();
        }
        else {
            stack.push(delta);
        }
        return false;
    }
}
function addNodeReferences(mergeTree, node, rightmostTiles, leftmostTiles, rangeStacks) {
    function updateRangeInfo(label, refPos) {
        let stack = rangeStacks[label];
        if (stack === undefined) {
            stack = new _collections__WEBPACK_IMPORTED_MODULE_0__.Stack();
            rangeStacks[label] = stack;
        }
        applyRangeReference(stack, refPos);
    }
    if (node.isLeaf()) {
        const segment = node;
        if (mergeTree.localNetLength(segment) > 0) {
            if (Marker.is(segment)) {
                const markerId = segment.getId();
                // Also in insertMarker but need for reload segs case
                // can add option for this only from reload segs
                if (markerId) {
                    mergeTree.mapIdToSegment(markerId, segment);
                }
                if (segment.refType & _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.Tile) {
                    addTile(segment, rightmostTiles);
                    addTileIfNotPresent(segment, leftmostTiles);
                }
                if (segment.refType & (_ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.NestBegin | _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.NestEnd)) {
                    const rangeLabels = segment.getRangeLabels();
                    if (rangeLabels) {
                        for (const label of segment.getRangeLabels()) {
                            updateRangeInfo(label, segment);
                        }
                    }
                }
            }
            else {
                const baseSegment = node;
                if (baseSegment.localRefs && (baseSegment.localRefs.hierRefCount !== undefined) &&
                    (baseSegment.localRefs.hierRefCount > 0)) {
                    for (const lref of baseSegment.localRefs) {
                        if (lref.refType & _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.Tile) {
                            addTile(lref, rightmostTiles);
                            addTileIfNotPresent(lref, leftmostTiles);
                        }
                        if (lref.refType & (_ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.NestBegin | _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.NestEnd)) {
                            for (const label of lref.getRangeLabels()) {
                                updateRangeInfo(label, lref);
                            }
                        }
                    }
                }
            }
        }
    }
    else {
        const block = node;
        applyStackDelta(rangeStacks, block.rangeStacks);
        _properties__WEBPACK_IMPORTED_MODULE_2__.extend(rightmostTiles, block.rightmostTiles);
        _properties__WEBPACK_IMPORTED_MODULE_2__.extendIfUndefined(leftmostTiles, block.leftmostTiles);
    }
}
function ordinalToArray(ord) {
    const a = [];
    if (ord) {
        for (let i = 0, len = ord.length; i < len; i++) {
            a.push(ord.charCodeAt(i));
        }
    }
    return a;
}
// Note that the actual branching factor of the MergeTree is `MaxNodesInBlock - 1`.  This is because
// the MergeTree always inserts first, then checks for overflow and splits if the child count equals
// `MaxNodesInBlock`.  (i.e., `MaxNodesInBlock` contains 1 extra slot for temporary storage to
// facilitate splits.)
const MaxNodesInBlock = 8;
class MergeBlock extends MergeNode {
    constructor(childCount) {
        super();
        this.childCount = childCount;
        this.children = new Array(MaxNodesInBlock);
    }
    hierBlock() {
        return undefined;
    }
    setOrdinal(child, index) {
        let childCount = this.childCount;
        if (childCount === 8) {
            childCount = 7;
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)((childCount >= 1) && (childCount <= 7), 0x040 /* "Child count is not within [1,7] range!" */);
        let localOrdinal;
        const ordinalWidth = 1 << (MaxNodesInBlock - (childCount + 1));
        if (index === 0) {
            localOrdinal = ordinalWidth - 1;
        }
        else {
            const prevOrd = this.children[index - 1].ordinal;
            const prevOrdCode = prevOrd.charCodeAt(prevOrd.length - 1);
            localOrdinal = prevOrdCode + ordinalWidth;
        }
        child.ordinal = this.ordinal + String.fromCharCode(localOrdinal);
        if (MergeBlock.traceOrdinals) {
            console.log(`so: prnt chld prev ${ordinalToArray(this.ordinal)} ${ordinalToArray(child.ordinal)} ${(index > 0) ? ordinalToArray(this.children[index - 1].ordinal) : "NA"}`);
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(child.ordinal.length === (this.ordinal.length + 1), 0x041 /* "Unexpected child ordinal length!" */);
        if (index > 0) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(child.ordinal > this.children[index - 1].ordinal, 0x042 /* "Child ordinal <= previous sibling ordinal!" */);
            // console.log(`${ordinalToArray(this.ordinal)} ${ordinalToArray(child.ordinal)} ${ordinalToArray(this.children[index - 1].ordinal)}`);
            // console.log(`ord width ${ordinalWidth}`);
        }
    }
    assignChild(child, index, updateOrdinal = true) {
        child.parent = this;
        child.index = index;
        if (updateOrdinal) {
            this.setOrdinal(child, index);
        }
        this.children[index] = child;
    }
}
MergeBlock.traceOrdinals = false;
class HierMergeBlock extends MergeBlock {
    constructor(childCount) {
        super(childCount);
        this.rightmostTiles = _properties__WEBPACK_IMPORTED_MODULE_2__.createMap();
        this.leftmostTiles = _properties__WEBPACK_IMPORTED_MODULE_2__.createMap();
        this.rangeStacks = _properties__WEBPACK_IMPORTED_MODULE_2__.createMap();
    }
    addNodeReferences(mergeTree, node) {
        addNodeReferences(mergeTree, node, this.rightmostTiles, this.leftmostTiles, this.rangeStacks);
    }
    hierBlock() {
        return this;
    }
    hierToString(indentCount) {
        let strbuf = "";
        // eslint-disable-next-line guard-for-in, no-restricted-syntax
        for (const key in this.rangeStacks) {
            const stack = this.rangeStacks[key];
            strbuf += internedSpaces(indentCount);
            strbuf += `${key}: `;
            for (const item of stack.items) {
                strbuf += `${item.toString()} `;
            }
            strbuf += "\n";
        }
        return strbuf;
    }
}
function nodeTotalLength(mergeTree, node) {
    if (!node.isLeaf()) {
        return node.cachedLength;
    }
    return mergeTree.localNetLength(node);
}
class BaseSegment extends MergeNode {
    constructor() {
        super();
        this.clientId = _constants__WEBPACK_IMPORTED_MODULE_4__.LocalClientId;
        this.seq = _constants__WEBPACK_IMPORTED_MODULE_4__.UniversalSequenceNumber;
        this.segmentGroups = new _segmentGroupCollection__WEBPACK_IMPORTED_MODULE_5__.SegmentGroupCollection(this);
        this.trackingCollection = new _mergeTreeTracking__WEBPACK_IMPORTED_MODULE_6__.TrackingGroupCollection(this);
    }
    addProperties(newProps, op, seq, collabWindow) {
        if (!this.propertyManager) {
            this.propertyManager = new _segmentPropertiesManager__WEBPACK_IMPORTED_MODULE_7__.SegmentPropertiesManager(this);
        }
        return this.propertyManager.addProperties(newProps, op, seq, collabWindow);
    }
    hasProperty(key) {
        return !!this.properties && (this.properties[key] !== undefined);
    }
    isLeaf() {
        return true;
    }
    cloneInto(b) {
        b.clientId = this.clientId;
        // TODO: deep clone properties
        b.properties = _properties__WEBPACK_IMPORTED_MODULE_2__.clone(this.properties);
        b.removedClientId = this.removedClientId;
        // TODO: copy removed client overlap and branch removal info
        b.removedSeq = this.removedSeq;
        b.seq = this.seq;
    }
    canAppend(segment) {
        return false;
    }
    addSerializedProps(jseg) {
        if (this.properties) {
            jseg.props = this.properties;
        }
    }
    ack(segmentGroup, opArgs, mergeTree) {
        const currentSegmentGroup = this.segmentGroups.dequeue();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(currentSegmentGroup === segmentGroup, 0x043 /* "On ack, unexpected segmentGroup!" */);
        switch (opArgs.op.type) {
            case 2 /* ANNOTATE */:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.propertyManager, 0x044 /* "On annotate ack, missing segment property manager!" */);
                this.propertyManager.ackPendingProperties(opArgs.op);
                return true;
            case 0 /* INSERT */:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.seq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber, 0x045 /* "On insert, seq number already assigned!" */);
                this.seq = opArgs.sequencedMessage.sequenceNumber;
                this.localSeq = undefined;
                return true;
            case 1 /* REMOVE */:
                const removalInfo = mergeTree.getRemovalInfo(this);
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!removalInfo, 0x046 /* "On remove ack, missing removal info!" */);
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!removalInfo.removedSeq, 0x047 /* "On remove ack, missing removed sequence number!" */);
                this.localRemovedSeq = undefined;
                if (removalInfo.removedSeq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) {
                    removalInfo.removedSeq = opArgs.sequencedMessage.sequenceNumber;
                    return true;
                }
                if (MergeTree.diagOverlappingRemove) {
                    console.log(`grump @seq ${opArgs.sequencedMessage.sequenceNumber} ` +
                        `cli ${glc(mergeTree, mergeTree.collabWindow.clientId)} ` +
                        `from ${removalInfo.removedSeq} text ${mergeTree.toString()}`);
                }
                return false;
            default:
                throw new Error(`${opArgs.op.type} is in unrecognized operation type`);
        }
    }
    splitAt(pos) {
        if (pos > 0) {
            const leafSegment = this.createSplitSegmentAt(pos);
            if (leafSegment) {
                if (this.propertyManager) {
                    this.propertyManager.copyTo(leafSegment);
                }
                leafSegment.parent = this.parent;
                // Give the leaf a temporary yet valid ordinal.
                // when this segment is put in the tree, it will get it's real ordinal,
                // but this ordinal meets all the necessary invariants for now.
                leafSegment.ordinal = this.ordinal + String.fromCharCode(0);
                leafSegment.removedClientId = this.removedClientId;
                leafSegment.removedSeq = this.removedSeq;
                leafSegment.localRemovedSeq = this.localRemovedSeq;
                leafSegment.seq = this.seq;
                leafSegment.localSeq = this.localSeq;
                leafSegment.clientId = this.clientId;
                if (this.removedClientOverlap) {
                    leafSegment.removedClientOverlap = [...this.removedClientOverlap];
                }
                this.segmentGroups.copyTo(leafSegment);
                this.trackingCollection.copyTo(leafSegment);
                if (this.localRefs) {
                    this.localRefs.split(pos, leafSegment);
                }
            }
            return leafSegment;
        }
    }
}
const reservedTileLabelsKey = "referenceTileLabels";
const reservedRangeLabelsKey = "referenceRangeLabels";
const reservedMarkerIdKey = "markerId";
const reservedMarkerSimpleTypeKey = "markerSimpleType";
const refGetTileLabels = (refPos) => (refPos.refType & _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.Tile) &&
    refPos.properties ? refPos.properties[reservedTileLabelsKey] : undefined;
const refGetRangeLabels = (refPos) => (refPos.refType & (_ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.NestBegin | _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.NestEnd)) &&
    refPos.properties ? refPos.properties[reservedRangeLabelsKey] : undefined;
function refHasTileLabel(refPos, label) {
    const tileLabels = refPos.getTileLabels();
    if (tileLabels) {
        for (const refLabel of tileLabels) {
            if (label === refLabel) {
                return true;
            }
        }
    }
    return false;
}
function refHasRangeLabel(refPos, label) {
    const rangeLabels = refPos.getRangeLabels();
    if (rangeLabels) {
        for (const refLabel of rangeLabels) {
            if (label === refLabel) {
                return true;
            }
        }
    }
    return false;
}
class Marker extends BaseSegment {
    constructor(refType) {
        super();
        this.refType = refType;
        this.type = Marker.type;
        this.cachedLength = 1;
    }
    static is(segment) {
        return segment.type === Marker.type;
    }
    static make(refType, props) {
        const marker = new Marker(refType);
        if (props) {
            marker.addProperties(props);
        }
        return marker;
    }
    toJSONObject() {
        const obj = { marker: { refType: this.refType } };
        super.addSerializedProps(obj);
        return obj;
    }
    static fromJSONObject(spec) {
        if (spec && typeof spec === "object" && "marker" in spec) {
            return Marker.make(spec.marker.refType, spec.props);
        }
        return undefined;
    }
    clone() {
        const b = Marker.make(this.refType, this.properties);
        this.cloneInto(b);
        return b;
    }
    getSegment() {
        return this;
    }
    getOffset() {
        return 0;
    }
    hasSimpleType(simpleTypeName) {
        return !!this.properties &&
            this.properties[reservedMarkerSimpleTypeKey] === simpleTypeName;
    }
    getProperties() {
        return this.properties;
    }
    getId() {
        if (this.properties && this.properties[reservedMarkerIdKey]) {
            return this.properties[reservedMarkerIdKey];
        }
    }
    hasTileLabels() {
        return !!this.getTileLabels();
    }
    hasRangeLabels() {
        return !!this.getRangeLabels();
    }
    hasTileLabel(label) {
        return refHasTileLabel(this, label);
    }
    hasRangeLabel(label) {
        return refHasRangeLabel(this, label);
    }
    getTileLabels() {
        return refGetTileLabels(this);
    }
    getRangeLabels() {
        return refGetRangeLabels(this);
    }
    toString() {
        let bbuf = "";
        if (this.refType & _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.Tile) {
            bbuf += "Tile";
        }
        if (this.refType & _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.NestBegin) {
            if (bbuf.length > 0) {
                bbuf += "; ";
            }
            bbuf += "RangeBegin";
        }
        if (this.refType & _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.NestEnd) {
            if (bbuf.length > 0) {
                bbuf += "; ";
            }
            bbuf += "RangeEnd";
        }
        let lbuf = "";
        const id = this.getId();
        if (id) {
            bbuf += ` (${id}) `;
        }
        const tileLabels = this.getTileLabels();
        if (tileLabels) {
            lbuf += "tile -- ";
            for (let i = 0, len = tileLabels.length; i < len; i++) {
                const tileLabel = tileLabels[i];
                if (i > 0) {
                    lbuf += "; ";
                }
                lbuf += tileLabel;
            }
        }
        const rangeLabels = this.getRangeLabels();
        if (rangeLabels) {
            let rangeKind = "begin";
            if (this.refType & _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.NestEnd) {
                rangeKind = "end";
            }
            if (tileLabels) {
                lbuf += " ";
            }
            lbuf += `range ${rangeKind} -- `;
            const labels = rangeLabels;
            for (let i = 0, len = labels.length; i < len; i++) {
                const rangeLabel = labels[i];
                if (i > 0) {
                    lbuf += "; ";
                }
                lbuf += rangeLabel;
            }
        }
        let pbuf = "";
        if (this.properties) {
            pbuf += JSON.stringify(this.properties, (key, value) => {
                // Avoid circular reference when stringifying makers containing handles.
                // (Substitute a debug string instead.)
                const handle = !!value && value.IFluidHandle;
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return handle
                    ? `#Handle(${handle.routeContext.path}/${handle.path})`
                    : value;
            });
        }
        return `M ${bbuf}: ${lbuf} ${pbuf}`;
    }
    createSplitSegmentAt(pos) {
        return undefined;
    }
    canAppend(segment) {
        return false;
    }
    append() { throw new Error("Can not append to marker"); }
}
Marker.type = "Marker";
var IncrementalExecOp;
(function (IncrementalExecOp) {
    IncrementalExecOp[IncrementalExecOp["Go"] = 0] = "Go";
    IncrementalExecOp[IncrementalExecOp["Stop"] = 1] = "Stop";
    IncrementalExecOp[IncrementalExecOp["Yield"] = 2] = "Yield";
})(IncrementalExecOp || (IncrementalExecOp = {}));
class IncrementalMapState {
    constructor(block, actions, pos, refSeq, clientId, context, start, end, childIndex = 0) {
        this.block = block;
        this.actions = actions;
        this.pos = pos;
        this.refSeq = refSeq;
        this.clientId = clientId;
        this.context = context;
        this.start = start;
        this.end = end;
        this.childIndex = childIndex;
        this.op = IncrementalExecOp.Go;
    }
}
class CollaborationWindow {
    constructor() {
        this.clientId = _constants__WEBPACK_IMPORTED_MODULE_4__.LocalClientId;
        this.collaborating = false;
        // Lowest-numbered segment in window; no client can reference a state before this one
        this.minSeq = 0;
        // Highest-numbered segment in window and current
        // reference segment for this client
        this.currentSeq = 0;
        this.localSeq = 0;
    }
    loadFrom(a) {
        this.clientId = a.clientId;
        this.collaborating = a.collaborating;
        this.minSeq = a.minSeq;
        this.currentSeq = a.currentSeq;
    }
}
const compareNumbers = (a, b) => a - b;
const compareStrings = (a, b) => a.localeCompare(b);
function clock() {
    return _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.Trace.start();
}
function elapsedMicroseconds(trace) {
    return trace.trace().duration * 1000;
}
const indentStrings = ["", " ", "  "];
function internedSpaces(n) {
    if (indentStrings[n] === undefined) {
        indentStrings[n] = "";
        for (let i = 0; i < n; i++) {
            indentStrings[n] += " ";
        }
    }
    return indentStrings[n];
}
class RegisterCollection {
    constructor() {
        this.clientCollections = _properties__WEBPACK_IMPORTED_MODULE_2__.createMap();
        // TODO: snapshot
    }
    set(clientId, id, segments) {
        let clientCollection = this.clientCollections[clientId];
        if (!clientCollection) {
            clientCollection = _properties__WEBPACK_IMPORTED_MODULE_2__.createMap();
            this.clientCollections[clientId] = clientCollection;
        }
        clientCollection[id] = segments;
    }
    get(clientId, id) {
        const clientCollection = this.clientCollections[clientId];
        if (clientCollection) {
            return clientCollection[id];
        }
    }
    getLength(clientId, id) {
        const segs = this.get(clientId, id);
        let len = 0;
        if (segs) {
            for (const seg of segs) {
                len += seg.cachedLength;
            }
        }
        return len;
    }
    removeClient(clientId) {
        this.clientCollections[clientId] = undefined;
    }
}
const clientSeqComparer = {
    min: { refSeq: -1, clientId: "" },
    compare: (a, b) => a.refSeq - b.refSeq,
};
const LRUSegmentComparer = {
    min: { maxSeq: -2 },
    compare: (a, b) => a.maxSeq - b.maxSeq,
};
function glc(mergeTree, id) {
    if (mergeTree.getLongClientId) {
        return mergeTree.getLongClientId(id);
    }
    else {
        return id.toString();
    }
}
function applyLeafRangeMarker(marker, searchInfo) {
    for (const rangeLabel of searchInfo.rangeLabels) {
        if (marker.hasRangeLabel(rangeLabel)) {
            let currentStack = searchInfo.stacks[rangeLabel];
            if (currentStack === undefined) {
                currentStack = new _collections__WEBPACK_IMPORTED_MODULE_0__.Stack();
                searchInfo.stacks[rangeLabel] = currentStack;
            }
            applyRangeReference(currentStack, marker);
        }
    }
}
function recordRangeLeaf(segment, segpos, refSeq, clientId, start, end, searchInfo) {
    if (Marker.is(segment)) {
        if (segment.refType &
            (_ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.NestBegin | _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.NestEnd)) {
            applyLeafRangeMarker(segment, searchInfo);
        }
    }
    return false;
}
function rangeShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {
    if (node.isLeaf()) {
        const seg = node;
        if ((searchInfo.mergeTree.localNetLength(seg) > 0) && Marker.is(seg)) {
            if (seg.refType &
                (_ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.NestBegin | _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.NestEnd)) {
                applyLeafRangeMarker(seg, searchInfo);
            }
        }
    }
    else {
        const block = node;
        applyStackDelta(searchInfo.stacks, block.rangeStacks);
    }
    return true;
}
function recordTileStart(segment, segpos, refSeq, clientId, start, end, searchInfo) {
    if (Marker.is(segment)) {
        if (segment.hasTileLabel(searchInfo.tileLabel)) {
            searchInfo.tile = segment;
        }
    }
    return false;
}
function tileShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {
    if (node.isLeaf()) {
        const seg = node;
        if ((searchInfo.mergeTree.localNetLength(seg) > 0) && Marker.is(seg)) {
            if (seg.hasTileLabel(searchInfo.tileLabel)) {
                searchInfo.tile = seg;
            }
        }
    }
    else {
        const block = node;
        let marker;
        if (searchInfo.posPrecedesTile) {
            marker = block.rightmostTiles[searchInfo.tileLabel];
        }
        else {
            marker = block.leftmostTiles[searchInfo.tileLabel];
        }
        if (marker !== undefined) {
            searchInfo.tile = marker;
        }
    }
    return true;
}
const minListenerComparer = {
    min: { minRequired: Number.MIN_VALUE, onMinGE: () => { (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(false, 0x048 /* "onMinGE()" */); } },
    compare: (a, b) => a.minRequired - b.minRequired,
};
// Represents a sequence of text segments
class MergeTree {
    // TODO: make and use interface describing options
    constructor(options) {
        this.options = options;
        this.windowTime = 0;
        this.packTime = 0;
        this.ordTime = 0;
        this.maxOrdTime = 0;
        this.collabWindow = new CollaborationWindow();
        // TODO: change this to ES6 map; add remove on segment remove
        // for now assume only markers have ids and so point directly at the Segment
        // if we need to have pointers to non-markers, we can change to point at local refs
        this.idToSegment = _properties__WEBPACK_IMPORTED_MODULE_2__.createMap();
        this.splitLeafSegment = (segment, pos) => {
            if (!(pos > 0 && segment)) {
                return {};
            }
            const next = segment.splitAt(pos);
            if (this.mergeTreeMaintenanceCallback) {
                this.mergeTreeMaintenanceCallback({
                    operation: -2 /* SPLIT */,
                    deltaSegments: [{ segment }, { segment: next }],
                }, undefined);
            }
            return { next };
        };
        this.blockUpdateActions = MergeTree.initBlockUpdateActions;
        this.root = this.makeBlock(0);
    }
    makeBlock(childCount) {
        let block;
        if (MergeTree.blockUpdateMarkers) {
            block = new HierMergeBlock(childCount);
        }
        else {
            block = new MergeBlock(childCount);
        }
        block.ordinal = "";
        return block;
    }
    clone() {
        const b = new MergeTree(this.options);
        // For now assume that b will not collaborate
        b.root = b.blockClone(this.root);
    }
    blockClone(block, segments) {
        const bBlock = this.makeBlock(block.childCount);
        for (let i = 0; i < block.childCount; i++) {
            const child = block.children[i];
            if (child.isLeaf()) {
                const segment = this.segmentClone(child);
                bBlock.assignChild(segment, i);
                if (segments) {
                    segments.push(segment);
                }
            }
            else {
                bBlock.assignChild(this.blockClone(child, segments), i);
            }
        }
        this.nodeUpdateLengthNewStructure(bBlock);
        this.nodeUpdateOrdinals(bBlock);
        return bBlock;
    }
    segmentClone(segment) {
        const b = segment.clone();
        return b;
    }
    localNetLength(segment) {
        const removalInfo = this.getRemovalInfo(segment);
        if (removalInfo.removedSeq !== undefined) {
            return 0;
        }
        else {
            return segment.cachedLength;
        }
    }
    // TODO: remove id when segment removed
    mapIdToSegment(id, segment) {
        this.idToSegment[id] = segment;
    }
    addNode(block, node) {
        const index = block.childCount++;
        block.assignChild(node, index, false);
        return index;
    }
    reloadFromSegments(segments) {
        // This code assumes that a later call to `startCollaboration()` will initialize partial lengths.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.collabWindow.collaborating, 0x049 /* "Trying to reload from segments while collaborating!" */);
        const maxChildren = MaxNodesInBlock - 1;
        const measureReloadTime = false;
        // Starting with the leaf segments, recursively builds the B-Tree layer by layer from the bottom up.
        const buildMergeBlock = (nodes) => {
            const blockCount = Math.ceil(nodes.length / maxChildren); // Compute # blocks require for this level of B-Tree
            const blocks = new Array(blockCount); // Pre-alloc array to collect nodes
            // For each block in this level of the B-Tree...
            for (let nodeIndex = 0, blockIndex = 0; // Start with the first block and first node
             blockIndex < blockCount; // If we have more blocks, we also have more nodes to insert
             blockIndex++ // Advance to next block in this layer.
            ) {
                const block = blocks[blockIndex] = this.makeBlock(0);
                // For each child of the current block, insert a node (while we have nodes left)
                // and update the block's info.
                for (let childIndex = 0; childIndex < maxChildren && nodeIndex < nodes.length; // While we still have children & nodes left
                 childIndex++, nodeIndex++ // Advance to next child & node
                ) {
                    // Insert the next node into the current block
                    this.addNode(block, nodes[nodeIndex]);
                }
                // Calculate this block's info.  Previously this was inlined into the above loop as a micro-optimization,
                // but it turns out to be negligible in practice since `reloadFromSegments()` is only invoked for the
                // snapshot header.  The bulk of the segments in long documents are inserted via `insertSegments()`.
                this.blockUpdate(block);
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return blocks.length === 1 // If there is only one block at this layer...
                ? blocks[0] // ...then we're done.  Return the root.
                : buildMergeBlock(blocks); // ...otherwise recursively build the next layer above blocks.
        };
        let clockStart;
        if (measureReloadTime) {
            clockStart = clock();
        }
        if (segments.length > 0) {
            this.root = buildMergeBlock(segments);
            this.nodeUpdateOrdinals(this.root);
        }
        else {
            this.root = this.makeBlock(0);
        }
        if (clockStart) {
            console.log(`reload time ${elapsedMicroseconds(clockStart)}`);
        }
    }
    // For now assume min starts at zero
    startCollaboration(localClientId, minSeq, currentSeq) {
        this.collabWindow.clientId = localClientId;
        this.collabWindow.minSeq = minSeq;
        this.collabWindow.collaborating = true;
        this.collabWindow.currentSeq = currentSeq;
        this.segmentsToScour = new _collections__WEBPACK_IMPORTED_MODULE_0__.Heap([], LRUSegmentComparer);
        this.pendingSegments = _collections__WEBPACK_IMPORTED_MODULE_0__.ListMakeHead();
        const measureFullCollab = false;
        let clockStart;
        if (measureFullCollab) {
            clockStart = clock();
        }
        this.nodeUpdateLengthNewStructure(this.root, true);
        if (clockStart) {
            console.log(`update partial lengths at start ${elapsedMicroseconds(clockStart)}`);
        }
    }
    addToLRUSet(segment, seq) {
        // If the parent node has not yet been marked for scour (i.e., needsScour is not false or undefined),
        // add the segment and mark the mark the node now.
        // TODO: 'seq' may be less than the current sequence number when inserting pre-ACKed
        //       segments from a snapshot.  We currently skip these for now.
        if (segment.parent.needsScour !== true && seq > this.collabWindow.currentSeq) {
            segment.parent.needsScour = true;
            this.segmentsToScour.add({ segment, maxSeq: seq });
        }
    }
    underflow(node) {
        return node.childCount < (MaxNodesInBlock / 2);
    }
    scourNode(node, holdNodes) {
        let prevSegment;
        for (let k = 0; k < node.childCount; k++) {
            const childNode = node.children[k];
            if (childNode.isLeaf()) {
                const segment = childNode;
                if (segment.segmentGroups.empty) {
                    if (segment.removedSeq !== undefined) {
                        if (segment.removedSeq > this.collabWindow.minSeq) {
                            holdNodes.push(segment);
                        }
                        else if (!segment.trackingCollection.empty) {
                            holdNodes.push(segment);
                        }
                        else {
                            if (MergeTree.traceZRemove) {
                                // eslint-disable-next-line @typescript-eslint/dot-notation
                                console.log(`${this.getLongClientId(this.collabWindow.clientId)}: Zremove ${segment["text"]}; cli ${this.getLongClientId(segment.clientId)}`);
                            }
                            // Notify maintenance event observers that the segment is being unlinked from the MergeTree.
                            if (this.mergeTreeMaintenanceCallback) {
                                this.mergeTreeMaintenanceCallback({
                                    operation: -3 /* UNLINK */,
                                    deltaSegments: [{ segment }],
                                }, undefined);
                            }
                            segment.parent = undefined;
                        }
                        prevSegment = undefined;
                    }
                    else {
                        if (segment.seq <= this.collabWindow.minSeq) {
                            const canAppend = prevSegment
                                && prevSegment.canAppend(segment)
                                && _properties__WEBPACK_IMPORTED_MODULE_2__.matchProperties(prevSegment.properties, segment.properties)
                                && prevSegment.trackingCollection.matches(segment.trackingCollection)
                                && this.localNetLength(segment) > 0;
                            if (canAppend) {
                                if (MergeTree.traceAppend) {
                                    // eslint-disable-next-line @typescript-eslint/dot-notation
                                    console.log(`${this.getLongClientId(this.collabWindow.clientId)}: append ${prevSegment["text"]} + ${segment["text"]}; cli ${this.getLongClientId(prevSegment.clientId)} + cli ${this.getLongClientId(segment.clientId)}`);
                                }
                                prevSegment.append(segment);
                                if (this.mergeTreeMaintenanceCallback) {
                                    this.mergeTreeMaintenanceCallback({
                                        operation: -1 /* APPEND */,
                                        deltaSegments: [{ segment: prevSegment }, { segment }],
                                    }, undefined);
                                }
                                segment.parent = undefined;
                                segment.trackingCollection.trackingGroups.forEach((tg) => tg.unlink(segment));
                            }
                            else {
                                holdNodes.push(segment);
                                if (this.localNetLength(segment) > 0) {
                                    prevSegment = segment;
                                }
                                else {
                                    prevSegment = undefined;
                                }
                            }
                        }
                        else {
                            holdNodes.push(segment);
                            prevSegment = undefined;
                        }
                    }
                }
                else {
                    holdNodes.push(segment);
                    prevSegment = undefined;
                }
            }
            else {
                holdNodes.push(childNode);
                prevSegment = undefined;
            }
        }
    }
    // Interior node with all node children
    packParent(parent) {
        const children = parent.children;
        let childIndex;
        let childBlock;
        const holdNodes = [];
        for (childIndex = 0; childIndex < parent.childCount; childIndex++) {
            // Debug assert not isLeaf()
            childBlock = children[childIndex];
            this.scourNode(childBlock, holdNodes);
            // Will replace this block with a packed block
            childBlock.parent = undefined;
        }
        const totalNodeCount = holdNodes.length;
        const halfCount = MaxNodesInBlock / 2;
        let childCount = Math.min(MaxNodesInBlock - 1, Math.floor(totalNodeCount / halfCount));
        if (childCount < 1) {
            childCount = 1;
        }
        const baseCount = Math.floor(totalNodeCount / childCount);
        let extraCount = totalNodeCount % childCount;
        const packedBlocks = new Array(MaxNodesInBlock);
        let readCount = 0;
        for (let nodeIndex = 0; nodeIndex < childCount; nodeIndex++) {
            let nodeCount = baseCount;
            if (extraCount > 0) {
                nodeCount++;
                extraCount--;
            }
            const packedBlock = this.makeBlock(nodeCount);
            for (let packedNodeIndex = 0; packedNodeIndex < nodeCount; packedNodeIndex++) {
                const nodeToPack = holdNodes[readCount++];
                packedBlock.assignChild(nodeToPack, packedNodeIndex, false);
            }
            packedBlock.parent = parent;
            packedBlocks[nodeIndex] = packedBlock;
            this.nodeUpdateLengthNewStructure(packedBlock);
        }
        if (readCount !== totalNodeCount) {
            console.log(`total count ${totalNodeCount} readCount ${readCount}`);
        }
        parent.children = packedBlocks;
        for (let j = 0; j < childCount; j++) {
            parent.assignChild(packedBlocks[j], j, false);
        }
        parent.childCount = childCount;
        if (this.underflow(parent) && (parent.parent)) {
            this.packParent(parent.parent);
        }
        else {
            this.nodeUpdateOrdinals(parent);
            this.blockUpdatePathLengths(parent, _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber, -1, true);
        }
    }
    zamboniSegments(zamboniSegmentsMaxCount = MergeTree.zamboniSegmentsMaxCount) {
        if (!this.collabWindow.collaborating) {
            return;
        }
        let clockStart;
        if (MergeTree.options.measureWindowTime) {
            clockStart = clock();
        }
        for (let i = 0; i < zamboniSegmentsMaxCount; i++) {
            let segmentToScour = this.segmentsToScour.peek();
            if (!segmentToScour || segmentToScour.maxSeq > this.collabWindow.minSeq) {
                break;
            }
            segmentToScour = this.segmentsToScour.get();
            // Only skip scouring if needs scour is explicitly false, not true or undefined
            if (segmentToScour.segment.parent && segmentToScour.segment.parent.needsScour !== false) {
                const block = segmentToScour.segment.parent;
                const childrenCopy = [];
                // console.log(`scouring from ${segmentToScour.segment.seq}`);
                this.scourNode(block, childrenCopy);
                // This will avoid the cost of re-scouring nodes
                // that have recently been scoured
                block.needsScour = false;
                const newChildCount = childrenCopy.length;
                if (newChildCount < block.childCount) {
                    block.childCount = newChildCount;
                    block.children = childrenCopy;
                    for (let j = 0; j < newChildCount; j++) {
                        block.assignChild(childrenCopy[j], j, false);
                    }
                    if (this.underflow(block) && block.parent) {
                        // nodeUpdatePathLengths(node, UnassignedSequenceNumber, -1, true);
                        let packClockStart;
                        if (MergeTree.options.measureWindowTime) {
                            packClockStart = clock();
                        }
                        this.packParent(block.parent);
                        if (MergeTree.options.measureWindowTime) {
                            this.packTime += elapsedMicroseconds(packClockStart);
                        }
                    }
                    else {
                        this.nodeUpdateOrdinals(block);
                        this.blockUpdatePathLengths(block, _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber, -1, true);
                    }
                }
            }
        }
        if (MergeTree.options.measureWindowTime) {
            this.windowTime += elapsedMicroseconds(clockStart);
        }
    }
    getCollabWindow() {
        return this.collabWindow;
    }
    getStats() {
        const nodeGetStats = (block) => {
            const stats = { maxHeight: 0, nodeCount: 0, leafCount: 0, removedLeafCount: 0, liveCount: 0, histo: [] };
            for (let k = 0; k < MaxNodesInBlock; k++) {
                stats.histo[k] = 0;
            }
            for (let i = 0; i < block.childCount; i++) {
                const child = block.children[i];
                let height = 1;
                if (!child.isLeaf()) {
                    const childStats = nodeGetStats(child);
                    height = 1 + childStats.maxHeight;
                    stats.nodeCount += childStats.nodeCount;
                    stats.leafCount += childStats.leafCount;
                    stats.removedLeafCount += childStats.removedLeafCount;
                    stats.liveCount += childStats.liveCount;
                    for (let i = 0; i < MaxNodesInBlock; i++) {
                        stats.histo[i] += childStats.histo[i];
                    }
                }
                else {
                    stats.leafCount++;
                    const segment = child;
                    if (segment.removedSeq !== undefined) {
                        stats.removedLeafCount++;
                    }
                }
                if (height > stats.maxHeight) {
                    stats.maxHeight = height;
                }
            }
            stats.histo[block.childCount]++;
            stats.nodeCount++;
            stats.liveCount += block.childCount;
            return stats;
        };
        const rootStats = nodeGetStats(this.root);
        if (MergeTree.options.measureWindowTime) {
            rootStats.windowTime = this.windowTime;
            rootStats.packTime = this.packTime;
            rootStats.ordTime = this.ordTime;
            rootStats.maxOrdTime = this.maxOrdTime;
        }
        return rootStats;
    }
    findHistorialPosition(pos, fromSeq, toSeq, clientId) {
        return this.findHistorialPositionFromClient(pos, fromSeq, toSeq, clientId);
    }
    findHistorialPositionFromClient(pos, fromSeq, toSeq, clientId) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(fromSeq < toSeq, 0x04a /* "Invalid range for historical position search!" */);
        if (pos < this.getLength(fromSeq, clientId)) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(toSeq <= this.collabWindow.currentSeq, 0x04b /* "Out-of-bounds end sequence number for historical position search!" */);
            const segoff = this.getContainingSegment(pos, fromSeq, clientId);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(segoff.segment !== undefined, 0x04c /* "Containing segment for historical position search is undefined!" */);
            const toPos = this.getPosition(segoff.segment, toSeq, clientId);
            const ret = toPos + segoff.offset;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(ret !== undefined, 0x04d /* "Return value for historical position search is undefined!" */);
            return ret;
        }
        else {
            return pos;
        }
    }
    findHistorialRangeFromClient(rangeStart, rangeEnd, fromSeq, toSeq, clientId) {
        const ranges = [];
        const recordRange = (segment, pos, refSeq, clientId, segStart, segEnd) => {
            let _segStart = segStart;
            let _segEnd = segEnd;
            if (this.nodeLength(segment, toSeq, clientId) > 0) {
                const position = this.getPosition(segment, toSeq, clientId);
                if (_segStart < 0) {
                    _segStart = 0;
                }
                if (_segEnd > segment.cachedLength) {
                    _segEnd = segment.cachedLength;
                }
                ranges.push({ start: position + _segStart, end: position + _segEnd });
            }
            return true;
        };
        this.mapRange({ leaf: recordRange }, fromSeq, clientId, undefined, rangeStart, rangeEnd);
        return ranges;
    }
    findHistorialRange(rangeStart, rangeEnd, fromSeq, toSeq, clientId) {
        return this.findHistorialRangeFromClient(rangeStart, rangeEnd, fromSeq, toSeq, clientId);
    }
    getLength(refSeq, clientId) {
        return this.blockLength(this.root, refSeq, clientId);
    }
    /**
     * Returns the current length of the MergeTree for the local client.
     */
    get length() { return this.root.cachedLength; }
    getPosition(node, refSeq, clientId) {
        let totalOffset = 0;
        let parent = node.parent;
        let prevParent;
        while (parent) {
            const children = parent.children;
            for (let childIndex = 0; childIndex < parent.childCount; childIndex++) {
                const child = children[childIndex];
                if ((prevParent && (child === prevParent)) || (child === node)) {
                    break;
                }
                totalOffset += this.nodeLength(child, refSeq, clientId);
            }
            prevParent = parent;
            parent = parent.parent;
        }
        return totalOffset;
    }
    cloneSegments(refSeq, clientId, start = 0, end) {
        let _end = end;
        const gatherSegment = (segment, pos, refSeq, clientId, start, end, accumSegments) => {
            accumSegments.segments.push(segment.clone());
            return true;
        };
        if (_end === undefined) {
            _end = this.blockLength(this.root, refSeq, clientId);
        }
        const accum = {
            segments: [],
        };
        this.mapRange({ leaf: gatherSegment }, refSeq, clientId, accum, start, _end);
        return accum.segments;
    }
    getContainingSegment(pos, refSeq, clientId) {
        let segment;
        let offset;
        const leaf = (leafSeg, segpos, refSeq, clientId, start) => {
            segment = leafSeg;
            offset = start;
            return false;
        };
        this.searchBlock(this.root, pos, 0, refSeq, clientId, { leaf }, undefined);
        return { segment, offset };
    }
    blockLength(node, refSeq, clientId) {
        if ((this.collabWindow.collaborating) && (clientId !== this.collabWindow.clientId)) {
            return node.partialLengths.getPartialLength(refSeq, clientId);
        }
        else {
            return node.cachedLength;
        }
    }
    getRemovalInfo(segment) {
        return segment;
    }
    nodeLength(node, refSeq, clientId) {
        if ((!this.collabWindow.collaborating) || (this.collabWindow.clientId === clientId)) {
            // Local client sees all segments, even when collaborating
            if (!node.isLeaf()) {
                return node.cachedLength;
            }
            else {
                return this.localNetLength(node);
            }
        }
        else {
            // Sequence number within window
            if (!node.isLeaf()) {
                return node.partialLengths.getPartialLength(refSeq, clientId);
            }
            else {
                const segment = node;
                if (((segment.clientId === clientId) ||
                    ((segment.seq !== _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) && (segment.seq <= refSeq)))) {
                    const removalInfo = this.getRemovalInfo(segment);
                    // Segment happened by reference sequence number or segment from requesting client
                    if (removalInfo.removedSeq !== undefined) {
                        if ((removalInfo.removedClientId === clientId) ||
                            (removalInfo.removedClientOverlap && (removalInfo.removedClientOverlap.includes(clientId))) ||
                            ((removalInfo.removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) && (removalInfo.removedSeq <= refSeq))) {
                            return 0;
                        }
                        else {
                            return segment.cachedLength;
                        }
                    }
                    else {
                        return segment.cachedLength;
                    }
                }
                else {
                    // Segment invisible to client at reference sequence number/branch id/client id of op
                    return 0;
                }
            }
        }
    }
    addMinSeqListener(minRequired, onMinGE) {
        if (!this.minSeqListeners) {
            this.minSeqListeners = new _collections__WEBPACK_IMPORTED_MODULE_0__.Heap([], minListenerComparer);
        }
        this.minSeqListeners.add({ minRequired, onMinGE });
    }
    notifyMinSeqListeners() {
        if (this.minSeqListeners) {
            while ((this.minSeqListeners.count() > 0) &&
                (this.minSeqListeners.peek().minRequired <= this.collabWindow.minSeq)) {
                const minListener = this.minSeqListeners.get();
                minListener.onMinGE(this.collabWindow.minSeq);
            }
        }
    }
    setMinSeq(minSeq) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(minSeq <= this.collabWindow.currentSeq, 0x04e /* "Trying to set minSeq above currentSeq of collab window!" */);
        // Only move forward
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.collabWindow.minSeq <= minSeq, 0x04f /* "minSeq of collab window > target minSeq!" */);
        if (minSeq > this.collabWindow.minSeq) {
            this.collabWindow.minSeq = minSeq;
            if (MergeTree.options.zamboniSegments) {
                this.zamboniSegments();
            }
            this.notifyMinSeqListeners();
        }
    }
    referencePositionToLocalPosition(refPos, refSeq = this.collabWindow.currentSeq, clientId = this.collabWindow.clientId) {
        const seg = refPos.getSegment();
        if (seg && seg.parent) {
            const offset = !seg.removedSeq ? refPos.getOffset() : 0;
            return offset + this.getPosition(seg, refSeq, clientId);
        }
        return _localReference__WEBPACK_IMPORTED_MODULE_9__.LocalReference.DetachedPosition;
    }
    getStackContext(startPos, clientId, rangeLabels) {
        const searchInfo = {
            mergeTree: this,
            stacks: _properties__WEBPACK_IMPORTED_MODULE_2__.createMap(),
            rangeLabels,
        };
        this.search(startPos, _constants__WEBPACK_IMPORTED_MODULE_4__.UniversalSequenceNumber, clientId, { leaf: recordRangeLeaf, shift: rangeShift }, searchInfo);
        return searchInfo.stacks;
    }
    // TODO: filter function
    findTile(startPos, clientId, tileLabel, posPrecedesTile = true) {
        const searchInfo = {
            mergeTree: this,
            posPrecedesTile,
            tileLabel,
        };
        if (posPrecedesTile) {
            this.search(startPos, _constants__WEBPACK_IMPORTED_MODULE_4__.UniversalSequenceNumber, clientId, { leaf: recordTileStart, shift: tileShift }, searchInfo);
        }
        else {
            this.backwardSearch(startPos, _constants__WEBPACK_IMPORTED_MODULE_4__.UniversalSequenceNumber, clientId, { leaf: recordTileStart, shift: tileShift }, searchInfo);
        }
        if (searchInfo.tile) {
            let pos;
            if (searchInfo.tile.isLeaf()) {
                const marker = searchInfo.tile;
                pos = this.getPosition(marker, _constants__WEBPACK_IMPORTED_MODULE_4__.UniversalSequenceNumber, clientId);
            }
            else {
                const localRef = searchInfo.tile;
                pos = localRef.toPosition();
            }
            return { tile: searchInfo.tile, pos };
        }
    }
    search(pos, refSeq, clientId, actions, clientData) {
        return this.searchBlock(this.root, pos, 0, refSeq, clientId, actions, clientData);
    }
    searchBlock(block, pos, segpos, refSeq, clientId, actions, clientData) {
        let _pos = pos;
        let _segpos = segpos;
        const children = block.children;
        if (actions && actions.pre) {
            actions.pre(block, _segpos, refSeq, clientId, undefined, undefined, clientData);
        }
        const contains = actions && actions.contains;
        for (let childIndex = 0; childIndex < block.childCount; childIndex++) {
            const child = children[childIndex];
            const len = this.nodeLength(child, refSeq, clientId);
            if (((!contains) && (_pos < len)) || (contains && contains(child, _pos, refSeq, clientId, undefined, undefined, clientData))) {
                // Found entry containing pos
                if (!child.isLeaf()) {
                    return this.searchBlock(child, _pos, _segpos, refSeq, clientId, actions, clientData);
                }
                else {
                    if (actions && actions.leaf) {
                        actions.leaf(child, _segpos, refSeq, clientId, _pos, -1, clientData);
                    }
                    return child;
                }
            }
            else {
                if (actions && actions.shift) {
                    actions.shift(child, _segpos, refSeq, clientId, _pos, undefined, clientData);
                }
                _pos -= len;
                _segpos += len;
            }
        }
        if (actions && actions.post) {
            actions.post(block, _segpos, refSeq, clientId, undefined, undefined, clientData);
        }
    }
    backwardSearch(pos, refSeq, clientId, actions, clientData) {
        const len = this.getLength(refSeq, clientId);
        if (pos > len) {
            return undefined;
        }
        return this.backwardSearchBlock(this.root, pos, len, refSeq, clientId, actions, clientData);
    }
    backwardSearchBlock(block, pos, segEnd, refSeq, clientId, actions, clientData) {
        let _segEnd = segEnd;
        const children = block.children;
        if (actions && actions.pre) {
            actions.pre(block, _segEnd, refSeq, clientId, undefined, undefined, clientData);
        }
        const contains = actions && actions.contains;
        for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {
            const child = children[childIndex];
            const len = this.nodeLength(child, refSeq, clientId);
            const segpos = _segEnd - len;
            if (((!contains) && (pos >= segpos)) ||
                (contains && contains(child, pos, refSeq, clientId, undefined, undefined, clientData))) {
                // Found entry containing pos
                if (!child.isLeaf()) {
                    return this.backwardSearchBlock(child, pos, _segEnd, refSeq, clientId, actions, clientData);
                }
                else {
                    if (actions && actions.leaf) {
                        actions.leaf(child, segpos, refSeq, clientId, pos, -1, clientData);
                    }
                    return child;
                }
            }
            else {
                if (actions && actions.shift) {
                    actions.shift(child, segpos, refSeq, clientId, pos, undefined, clientData);
                }
                _segEnd = segpos;
            }
        }
        if (actions && actions.post) {
            actions.post(block, _segEnd, refSeq, clientId, undefined, undefined, clientData);
        }
    }
    updateRoot(splitNode) {
        if (splitNode !== undefined) {
            const newRoot = this.makeBlock(2);
            newRoot.assignChild(this.root, 0, false);
            newRoot.assignChild(splitNode, 1, false);
            this.root = newRoot;
            this.nodeUpdateOrdinals(this.root);
            this.nodeUpdateLengthNewStructure(this.root);
        }
    }
    /**
     * Assign sequence number to existing segment; update partial lengths to reflect the change
     * @param seq - sequence number given by server to pending segment
     */
    ackPendingSegment(opArgs, verboseOps = false) {
        const seq = opArgs.sequencedMessage.sequenceNumber;
        const pendingSegmentGroup = this.pendingSegments.dequeue();
        const nodesToUpdate = [];
        let overwrite = false;
        if (pendingSegmentGroup !== undefined) {
            if (verboseOps) {
                console.log(`segment group has ${pendingSegmentGroup.segments.length} segments`);
            }
            const deltaSegments = [];
            pendingSegmentGroup.segments.map((pendingSegment) => {
                overwrite = !pendingSegment.ack(pendingSegmentGroup, opArgs, this) || overwrite;
                if (MergeTree.options.zamboniSegments) {
                    this.addToLRUSet(pendingSegment, seq);
                }
                if (!nodesToUpdate.includes(pendingSegment.parent)) {
                    nodesToUpdate.push(pendingSegment.parent);
                }
                deltaSegments.push({
                    segment: pendingSegment,
                });
            });
            if (this.mergeTreeMaintenanceCallback) {
                this.mergeTreeMaintenanceCallback({
                    deltaSegments,
                    operation: -4 /* ACKNOWLEDGED */,
                }, opArgs);
            }
            const clientId = this.collabWindow.clientId;
            for (const node of nodesToUpdate) {
                this.blockUpdatePathLengths(node, seq, clientId, overwrite);
                // NodeUpdatePathLengths(node, seq, clientId, true);
            }
        }
        if (MergeTree.options.zamboniSegments) {
            this.zamboniSegments();
        }
    }
    addToPendingList(segment, segmentGroup, localSeq) {
        let _segmentGroup = segmentGroup;
        if (_segmentGroup === undefined) {
            // TODO: review the cast
            _segmentGroup = { segments: [], localSeq };
            this.pendingSegments.enqueue(_segmentGroup);
        }
        segment.segmentGroups.enqueue(_segmentGroup);
        return _segmentGroup;
    }
    // TODO: error checking
    getMarkerFromId(id) {
        return this.idToSegment[id];
    }
    /**
     * Given a position specified relative to a marker id, lookup the marker
     * and convert the position to a character position.
     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.
     * @param refseq - The reference sequence number at which to compute the position.
     * @param clientId - The client id with which to compute the position.
     */
    posFromRelativePos(relativePos, refseq = this.collabWindow.currentSeq, clientId = this.collabWindow.clientId) {
        let pos = -1;
        let marker;
        if (relativePos.id) {
            marker = this.getMarkerFromId(relativePos.id);
        }
        if (marker) {
            pos = this.getPosition(marker, refseq, clientId);
            if (!relativePos.before) {
                pos += marker.cachedLength;
                if (relativePos.offset !== undefined) {
                    pos += relativePos.offset;
                }
            }
            else {
                if (relativePos.offset !== undefined) {
                    pos -= relativePos.offset;
                }
            }
        }
        return pos;
    }
    insertSegments(pos, segments, refSeq, clientId, seq, opArgs) {
        // const tt = MergeTree.traceTraversal;
        // MergeTree.traceTraversal = true;
        this.ensureIntervalBoundary(pos, refSeq, clientId);
        if (MergeTree.traceOrdinals) {
            this.ordinalIntegrity();
        }
        const localSeq = seq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;
        this.blockInsert(pos, refSeq, clientId, seq, localSeq, segments);
        // opArgs == undefined => loading snapshot or test code
        if (this.mergeTreeDeltaCallback && opArgs !== undefined) {
            this.mergeTreeDeltaCallback(opArgs, {
                operation: 0 /* INSERT */,
                deltaSegments: segments.map((segment) => ({ segment })),
            });
        }
        // MergeTree.traceTraversal = tt;
        if (MergeTree.traceOrdinals) {
            this.ordinalIntegrity();
        }
        if (this.collabWindow.collaborating && MergeTree.options.zamboniSegments &&
            (seq !== _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber)) {
            this.zamboniSegments();
        }
    }
    insertAtReferencePosition(referencePosition, insertSegment, opArgs) {
        if (insertSegment.cachedLength === 0) {
            return;
        }
        if (insertSegment.parent
            || insertSegment.removedSeq
            || insertSegment.seq !== _constants__WEBPACK_IMPORTED_MODULE_4__.UniversalSequenceNumber) {
            throw new Error("Cannot insert segment that has already been inserted.");
        }
        const rebalanceTree = (segment) => {
            // Blocks should never be left full
            // if the inserts makes the block full
            // then we need to walk up the chain of parents
            // and split the blocks until we find a block with
            // room
            let block = segment.parent;
            let ordinalUpdateNode = block;
            while (block !== undefined) {
                if (block.childCount >= MaxNodesInBlock) {
                    const splitNode = this.split(block);
                    if (block === this.root) {
                        this.updateRoot(splitNode);
                        // Update root already updates all it's children ordinals
                        ordinalUpdateNode = undefined;
                    }
                    else {
                        this.insertChildNode(block.parent, splitNode, block.index + 1);
                        ordinalUpdateNode = splitNode.parent;
                        this.blockUpdateLength(block.parent, _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber, clientId);
                    }
                }
                else {
                    this.blockUpdateLength(block, _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber, clientId);
                }
                block = block.parent;
            }
            // Only update ordinals once, for all children,
            // on the path
            if (ordinalUpdateNode) {
                this.nodeUpdateOrdinals(ordinalUpdateNode);
            }
        };
        const clientId = this.collabWindow.clientId;
        const refSegment = referencePosition.getSegment();
        const refOffset = referencePosition.getOffset();
        const refSegLen = this.nodeLength(refSegment, this.collabWindow.currentSeq, clientId);
        let startSeg = refSegment;
        if (refOffset !== 0 && refSegLen !== 0) {
            const splitSeg = this.splitLeafSegment(refSegment, refOffset);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!splitSeg.next, 0x050 /* "Next segment changes are undefined!" */);
            this.insertChildNode(refSegment.parent, splitSeg.next, refSegment.index + 1);
            rebalanceTree(splitSeg.next);
            startSeg = splitSeg.next;
        }
        this.leftExcursion(startSeg, (backSeg) => {
            if (!backSeg.isLeaf()) {
                return true;
            }
            const backLen = this.nodeLength(backSeg, this.collabWindow.currentSeq, clientId);
            // Find the nearest 0 length seg we can insert over, as all other inserts
            // go near to far
            if (backLen === 0) {
                if (this.breakTie(0, 0, backSeg, this.collabWindow.currentSeq, clientId)) {
                    startSeg = backSeg;
                }
                return true;
            }
            return false;
        });
        if (this.collabWindow.collaborating) {
            insertSegment.localSeq = ++this.collabWindow.localSeq;
            insertSegment.seq = _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber;
        }
        else {
            insertSegment.seq = _constants__WEBPACK_IMPORTED_MODULE_4__.UniversalSequenceNumber;
        }
        insertSegment.clientId = clientId;
        if (Marker.is(insertSegment)) {
            const markerId = insertSegment.getId();
            if (markerId) {
                this.mapIdToSegment(markerId, insertSegment);
            }
        }
        this.insertChildNode(startSeg.parent, insertSegment, startSeg.index);
        rebalanceTree(insertSegment);
        if (this.mergeTreeDeltaCallback) {
            this.mergeTreeDeltaCallback(opArgs, {
                deltaSegments: [{ segment: insertSegment }],
                operation: 0 /* INSERT */,
            });
        }
        if (this.collabWindow.collaborating) {
            this.addToPendingList(insertSegment, undefined, insertSegment.localSeq);
        }
    }
    /**
     * Resolves a remote client's position against the local sequence
     * and returns the remote client's position relative to the local
     * sequence
     * @param remoteClientPosition - The remote client's position to resolve
     * @param remoteClientRefSeq - The reference sequence number of the remote client
     * @param remoteClientId - The client id of the remote client
     */
    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {
        const segmentInfo = this.getContainingSegment(remoteClientPosition, remoteClientRefSeq, remoteClientId);
        const segwindow = this.getCollabWindow();
        if (segmentInfo && segmentInfo.segment) {
            const segmentPosition = this.getPosition(segmentInfo.segment, segwindow.currentSeq, segwindow.clientId);
            return segmentPosition + segmentInfo.offset;
        }
        else {
            if (remoteClientPosition === this.getLength(remoteClientRefSeq, remoteClientId)) {
                return this.getLength(segwindow.currentSeq, segwindow.clientId);
            }
        }
    }
    insertChildNode(block, child, childIndex) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(block.childCount < MaxNodesInBlock, 0x051 /* "Too many children on merge block!" */);
        for (let i = block.childCount; i > childIndex; i--) {
            block.children[i] = block.children[i - 1];
            block.children[i].index = i;
        }
        block.childCount++;
        block.assignChild(child, childIndex, false);
    }
    blockInsert(pos, refSeq, clientId, seq, localSeq, newSegments) {
        let segIsLocal = false;
        const checkSegmentIsLocal = (segment, pos, refSeq, clientId) => {
            if (segment.seq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) {
                if (MergeTree.diagInsertTie) {
                    console.log(`@cli ${glc(this, this.collabWindow.clientId)}: promoting continue due to seq ${segment.seq} text ${segment.toString()} ref ${refSeq}`);
                }
                segIsLocal = true;
            }
            // Only need to look at first segment that follows finished node
            return false;
        };
        const continueFrom = (node) => {
            segIsLocal = false;
            this.rightExcursion(node, checkSegmentIsLocal);
            if (MergeTree.diagInsertTie && segIsLocal) {
                console.log(`@cli ${glc(this, this.collabWindow.clientId)}: attempting continue with seq ${seq}  ref ${refSeq} `);
            }
            return segIsLocal;
        };
        let segmentGroup;
        const saveIfLocal = (locSegment) => {
            // Save segment so can assign sequence number when acked by server
            if (this.collabWindow.collaborating) {
                if ((locSegment.seq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) &&
                    (clientId === this.collabWindow.clientId)) {
                    segmentGroup = this.addToPendingList(locSegment, segmentGroup, localSeq);
                }
                // LocSegment.seq === 0 when coming from SharedSegmentSequence.loadBody()
                // In all other cases this has to be true (checked by addToLRUSet):
                // locSegment.seq > this.collabWindow.currentSeq
                else if ((locSegment.seq > this.collabWindow.minSeq) &&
                    MergeTree.options.zamboniSegments) {
                    this.addToLRUSet(locSegment, locSegment.seq);
                }
            }
        };
        const onLeaf = (segment, pos, context) => {
            const segmentChanges = {};
            if (segment) {
                // Insert before segment
                segmentChanges.replaceCurrent = context.candidateSegment;
                segmentChanges.next = segment;
            }
            else {
                segmentChanges.next = context.candidateSegment;
            }
            return segmentChanges;
        };
        // TODO: build tree from segs and insert all at once
        let insertPos = pos;
        for (const newSegment of newSegments) {
            segIsLocal = false;
            if (newSegment.cachedLength > 0) {
                newSegment.seq = seq;
                newSegment.localSeq = localSeq;
                newSegment.clientId = clientId;
                if (Marker.is(newSegment)) {
                    const markerId = newSegment.getId();
                    if (markerId) {
                        this.mapIdToSegment(markerId, newSegment);
                    }
                }
                const splitNode = this.insertingWalk(this.root, insertPos, refSeq, clientId, seq, { leaf: onLeaf, candidateSegment: newSegment, continuePredicate: continueFrom });
                if (newSegment.parent === undefined) {
                    throw new Error(`MergeTree insert failed: ${JSON.stringify({
                        currentSeq: this.collabWindow.currentSeq,
                        minSeq: this.collabWindow.minSeq,
                        segSeq: newSegment.seq,
                    })}`);
                }
                this.updateRoot(splitNode);
                saveIfLocal(newSegment);
                insertPos += newSegment.cachedLength;
            }
        }
    }
    ensureIntervalBoundary(pos, refSeq, clientId) {
        const splitNode = this.insertingWalk(this.root, pos, refSeq, clientId, _constants__WEBPACK_IMPORTED_MODULE_4__.TreeMaintenanceSequenceNumber, { leaf: this.splitLeafSegment });
        this.updateRoot(splitNode);
    }
    // Assume called only when pos == len
    breakTie(pos, len, node, refSeq, clientId, candidateSegment) {
        if (node.isLeaf()) {
            if (pos === 0) {
                const segment = node;
                const removalInfo = this.getRemovalInfo(segment);
                if (removalInfo.removedSeq
                    && removalInfo.removedSeq <= refSeq
                    && removalInfo.removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) {
                    return false;
                }
                // Local change see everything
                if (clientId === this.collabWindow.clientId) {
                    return true;
                }
                if (node.seq !== _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) {
                    // Ensure we merge right. newer segments should come before older segments
                    return true;
                }
            }
            return false;
        }
        else {
            return true;
        }
    }
    // Visit segments starting from node's left siblings, then up to node's parent
    leftExcursion(node, leafAction) {
        let go = true;
        let startNode = node;
        let parent = startNode.parent;
        while (parent) {
            const children = parent.children;
            let childIndex;
            let node;
            let matchedStart = false;
            for (childIndex = parent.childCount - 1; childIndex >= 0; childIndex--) {
                node = children[childIndex];
                if (matchedStart) {
                    if (!node.isLeaf()) {
                        const childBlock = node;
                        go = this.nodeMapReverse(childBlock, leafAction, 0, _constants__WEBPACK_IMPORTED_MODULE_4__.UniversalSequenceNumber, this.collabWindow.clientId);
                    }
                    else {
                        go = leafAction(node, 0, _constants__WEBPACK_IMPORTED_MODULE_4__.UniversalSequenceNumber, this.collabWindow.clientId, 0, 0, undefined);
                    }
                    if (!go) {
                        return;
                    }
                }
                else {
                    matchedStart = (startNode === node);
                }
            }
            startNode = parent;
            parent = parent.parent;
        }
    }
    // Visit segments starting from node's right siblings, then up to node's parent
    rightExcursion(node, leafAction) {
        const actions = { leaf: leafAction };
        let go = true;
        let startNode = node;
        let parent = startNode.parent;
        while (parent) {
            const children = parent.children;
            let childIndex;
            let node;
            let matchedStart = false;
            for (childIndex = 0; childIndex < parent.childCount; childIndex++) {
                node = children[childIndex];
                if (matchedStart) {
                    if (!node.isLeaf()) {
                        const childBlock = node;
                        go = this.nodeMap(childBlock, actions, 0, _constants__WEBPACK_IMPORTED_MODULE_4__.UniversalSequenceNumber, this.collabWindow.clientId, undefined);
                    }
                    else {
                        go = leafAction(node, 0, _constants__WEBPACK_IMPORTED_MODULE_4__.UniversalSequenceNumber, this.collabWindow.clientId, 0, 0, undefined);
                    }
                    if (!go) {
                        return;
                    }
                }
                else {
                    matchedStart = (startNode === node);
                }
            }
            startNode = parent;
            parent = parent.parent;
        }
    }
    insertingWalk(block, pos, refSeq, clientId, seq, context) {
        let _pos = pos;
        const children = block.children;
        let childIndex;
        let child;
        let newNode;
        let fromSplit;
        let found = false;
        for (childIndex = 0; childIndex < block.childCount; childIndex++) {
            child = children[childIndex];
            const len = this.nodeLength(child, refSeq, clientId);
            if (MergeTree.traceTraversal) {
                let segInfo;
                if ((!child.isLeaf()) && this.collabWindow.collaborating) {
                    segInfo = `minLength: ${child.partialLengths.minLength}`;
                }
                else {
                    const segment = child;
                    segInfo = `cli: ${glc(this, segment.clientId)} seq: ${segment.seq} text: ${segment.toString()}`;
                    if (segment.removedSeq !== undefined) {
                        segInfo += ` rcli: ${glc(this, segment.removedClientId)} rseq: ${segment.removedSeq}`;
                    }
                }
                console.log(`@tcli: ${glc(this, this.collabWindow.clientId)} len: ${len} pos: ${_pos} ${segInfo}`);
            }
            if ((_pos < len) || ((_pos === len) && this.breakTie(_pos, len, child, refSeq, clientId, context.candidateSegment))) {
                // Found entry containing pos
                found = true;
                if (!child.isLeaf()) {
                    const childBlock = child;
                    // Internal node
                    const splitNode = this.insertingWalk(childBlock, _pos, refSeq, clientId, seq, context);
                    if (splitNode === undefined) {
                        if (context.structureChange) {
                            this.nodeUpdateLengthNewStructure(block);
                        }
                        else {
                            this.blockUpdateLength(block, seq, clientId);
                        }
                        return undefined;
                    }
                    else if (splitNode === MergeTree.theUnfinishedNode) {
                        if (MergeTree.traceTraversal) {
                            console.log(`@cli ${glc(this, this.collabWindow.clientId)} unfinished bus pos ${_pos} len ${len}`);
                        }
                        _pos -= len; // Act as if shifted segment
                        continue;
                    }
                    else {
                        newNode = splitNode;
                        fromSplit = splitNode;
                        childIndex++; // Insert after
                    }
                }
                else {
                    if (MergeTree.traceTraversal) {
                        console.log(`@tcli: ${glc(this, this.collabWindow.clientId)}: leaf action`);
                    }
                    const segment = child;
                    const segmentChanges = context.leaf(segment, _pos, context);
                    if (segmentChanges.replaceCurrent) {
                        if (MergeTree.traceOrdinals) {
                            console.log(`assign from leaf with block ord ${ordinalToArray(block.ordinal)}`);
                        }
                        block.assignChild(segmentChanges.replaceCurrent, childIndex, false);
                        segmentChanges.replaceCurrent.ordinal = child.ordinal;
                    }
                    if (segmentChanges.next) {
                        newNode = segmentChanges.next;
                        childIndex++; // Insert after
                    }
                    else {
                        // No change
                        if (context.structureChange) {
                            this.nodeUpdateLengthNewStructure(block);
                        }
                        return undefined;
                    }
                }
                break;
            }
            else {
                _pos -= len;
            }
        }
        if (MergeTree.traceTraversal) {
            if ((!found) && (_pos > 0)) {
                console.log(`inserting walk fell through pos ${_pos} len: ${this.blockLength(this.root, refSeq, clientId)}`);
            }
        }
        if (!newNode) {
            if (_pos === 0) {
                if ((seq !== _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) && context.continuePredicate &&
                    context.continuePredicate(block)) {
                    return MergeTree.theUnfinishedNode;
                }
                else {
                    if (MergeTree.traceTraversal) {
                        console.log(`@tcli: ${glc(this, this.collabWindow.clientId)}: leaf action pos 0`);
                    }
                    const segmentChanges = context.leaf(undefined, _pos, context);
                    newNode = segmentChanges.next;
                    // Assert segmentChanges.replaceCurrent === undefined
                }
            }
        }
        if (newNode) {
            for (let i = block.childCount; i > childIndex; i--) {
                block.children[i] = block.children[i - 1];
                block.children[i].index = i;
            }
            block.assignChild(newNode, childIndex, false);
            block.childCount++;
            block.setOrdinal(newNode, childIndex);
            if (block.childCount < MaxNodesInBlock) {
                if (fromSplit) {
                    if (MergeTree.traceOrdinals) {
                        console.log(`split ord ${ordinalToArray(fromSplit.ordinal)}`);
                    }
                    this.nodeUpdateOrdinals(fromSplit);
                }
                if (context.structureChange) {
                    this.nodeUpdateLengthNewStructure(block);
                }
                else {
                    this.blockUpdateLength(block, seq, clientId);
                }
                return undefined;
            }
            else {
                // Don't update ordinals because higher block will do it
                return this.split(block);
            }
        }
        else {
            return undefined;
        }
    }
    split(node) {
        const halfCount = MaxNodesInBlock / 2;
        const newNode = this.makeBlock(halfCount);
        node.childCount = halfCount;
        // Update ordinals to reflect lowered child count
        this.nodeUpdateOrdinals(node);
        for (let i = 0; i < halfCount; i++) {
            newNode.assignChild(node.children[halfCount + i], i, false);
            node.children[halfCount + i] = undefined;
        }
        this.nodeUpdateLengthNewStructure(node);
        this.nodeUpdateLengthNewStructure(newNode);
        return newNode;
    }
    ordinalIntegrity() {
        console.log("chk ordnls");
        this.nodeOrdinalIntegrity(this.root);
    }
    nodeOrdinalIntegrity(block) {
        const olen = block.ordinal.length;
        for (let i = 0; i < block.childCount; i++) {
            const child = block.children[i];
            if (child.ordinal) {
                if (olen !== (child.ordinal.length - 1)) {
                    console.log("node integrity issue");
                }
                if (i > 0) {
                    if (child.ordinal <= block.children[i - 1].ordinal) {
                        console.log("node sib integrity issue");
                        console.log(`??: prnt chld prev ${ordinalToArray(block.ordinal)} ${ordinalToArray(child.ordinal)} ${(i > 0) ? ordinalToArray(block.children[i - 1].ordinal) : "NA"}`);
                    }
                }
                if (!child.isLeaf()) {
                    this.nodeOrdinalIntegrity(child);
                }
            }
            else {
                console.log(`node child ordinal not set ${i}`);
                console.log(`??: prnt ${ordinalToArray(block.ordinal)}`);
            }
        }
    }
    nodeUpdateOrdinals(block) {
        if (MergeTree.traceOrdinals) {
            console.log(`update ordinals for children of node with ordinal ${ordinalToArray(block.ordinal)}`);
        }
        let clockStart;
        if (MergeTree.options.measureOrdinalTime) {
            clockStart = clock();
        }
        for (let i = 0; i < block.childCount; i++) {
            const child = block.children[i];
            block.setOrdinal(child, i);
            if (!child.isLeaf()) {
                this.nodeUpdateOrdinals(child);
            }
        }
        if (clockStart) {
            const elapsed = elapsedMicroseconds(clockStart);
            if (elapsed > this.maxOrdTime) {
                this.maxOrdTime = elapsed;
            }
            this.ordTime += elapsed;
        }
    }
    addOverlappingClient(removalInfo, clientId) {
        if (!removalInfo.removedClientOverlap) {
            removalInfo.removedClientOverlap = [];
        }
        if (MergeTree.diagOverlappingRemove) {
            console.log(`added cli ${glc(this, clientId)} to rseq: ${removalInfo.removedSeq}`);
        }
        removalInfo.removedClientOverlap.push(clientId);
    }
    /**
     * Annotate a range with properties
     * @param start - The inclusive start postition of the range to annotate
     * @param end - The exclusive end position of the range to annotate
     * @param props - The properties to annotate the range with
     * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
     * @param refSeq - The reference sequence number to use to apply the annotate
     * @param clientId - The id of the client making the annotate
     * @param seq - The sequence number of the annotate operation
     * @param opArgs - The op args for the annotate op. this is passed to the merge tree callback if there is one
     */
    annotateRange(start, end, props, combiningOp, refSeq, clientId, seq, opArgs) {
        this.ensureIntervalBoundary(start, refSeq, clientId);
        this.ensureIntervalBoundary(end, refSeq, clientId);
        const deltaSegments = [];
        const localSeq = seq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;
        let segmentGroup;
        const annotateSegment = (segment) => {
            const propertyDeltas = segment.addProperties(props, combiningOp, seq, this.collabWindow);
            deltaSegments.push({ segment, propertyDeltas });
            if (this.collabWindow.collaborating) {
                if (seq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) {
                    segmentGroup = this.addToPendingList(segment, segmentGroup, localSeq);
                }
                else {
                    if (MergeTree.options.zamboniSegments) {
                        this.addToLRUSet(segment, seq);
                    }
                }
            }
            return true;
        };
        this.mapRange({ leaf: annotateSegment }, refSeq, clientId, undefined, start, end);
        // OpArgs == undefined => test code
        if (this.mergeTreeDeltaCallback) {
            this.mergeTreeDeltaCallback(opArgs, {
                operation: 2 /* ANNOTATE */,
                deltaSegments,
            });
        }
        if (this.collabWindow.collaborating && (seq !== _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber)) {
            if (MergeTree.options.zamboniSegments) {
                this.zamboniSegments();
            }
        }
    }
    markRangeRemoved(start, end, refSeq, clientId, seq, overwrite = false, opArgs) {
        let _overwrite = overwrite;
        this.ensureIntervalBoundary(start, refSeq, clientId);
        this.ensureIntervalBoundary(end, refSeq, clientId);
        let segmentGroup;
        const removedSegments = [];
        const savedLocalRefs = [];
        const localSeq = seq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;
        const markRemoved = (segment, pos, start, end) => {
            const removalInfo = this.getRemovalInfo(segment);
            if (removalInfo.removedSeq !== undefined) {
                if (MergeTree.diagOverlappingRemove) {
                    console.log(`yump @seq ${seq} cli ${glc(this, this.collabWindow.clientId)}: overlaps deleted segment ${removalInfo.removedSeq} text '${segment.toString()}'`);
                }
                _overwrite = true;
                if (removalInfo.removedSeq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) {
                    // replace because comes later
                    removalInfo.removedClientId = clientId;
                    removalInfo.removedSeq = seq;
                    segment.localRemovedSeq = undefined;
                }
                else {
                    // Do not replace earlier sequence number for remove
                    this.addOverlappingClient(removalInfo, clientId);
                }
            }
            else {
                removalInfo.removedClientId = clientId;
                removalInfo.removedSeq = seq;
                segment.localRemovedSeq = localSeq;
                removedSegments.push({ segment });
                if (segment.localRefs && !segment.localRefs.empty) {
                    savedLocalRefs.push(segment.localRefs);
                }
                segment.localRefs = undefined;
            }
            // Save segment so can assign removed sequence number when acked by server
            if (this.collabWindow.collaborating) {
                // Use removal information
                const removalInfo = this.getRemovalInfo(segment);
                if ((removalInfo.removedSeq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) && (clientId === this.collabWindow.clientId)) {
                    segmentGroup = this.addToPendingList(segment, segmentGroup, localSeq);
                }
                else {
                    if (MergeTree.options.zamboniSegments) {
                        this.addToLRUSet(segment, seq);
                    }
                }
                // console.log(`saved local removed seg with text: ${textSegment.text}`);
            }
            return true;
        };
        const afterMarkRemoved = (node, pos, start, end) => {
            if (_overwrite) {
                this.nodeUpdateLengthNewStructure(node);
            }
            else {
                this.blockUpdateLength(node, seq, clientId);
            }
            return true;
        };
        // MergeTree.traceTraversal = true;
        this.mapRange({ leaf: markRemoved, post: afterMarkRemoved }, refSeq, clientId, undefined, start, end);
        if (savedLocalRefs.length > 0) {
            const length = this.getLength(refSeq, clientId);
            let refSegment;
            if (start < length) {
                const afterSegOff = this.getContainingSegment(start, refSeq, clientId);
                refSegment = afterSegOff.segment;
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!refSegment, 0x052 /* "Missing reference segment!" */);
                if (!refSegment.localRefs) {
                    refSegment.localRefs = new _localReference__WEBPACK_IMPORTED_MODULE_9__.LocalReferenceCollection(refSegment);
                }
                refSegment.localRefs.addBeforeTombstones(...savedLocalRefs);
            }
            else if (length > 0) {
                const beforeSegOff = this.getContainingSegment(length - 1, refSeq, clientId);
                refSegment = beforeSegOff.segment;
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!refSegment, 0x053 /* "Missing reference segment!" */);
                if (!refSegment.localRefs) {
                    refSegment.localRefs = new _localReference__WEBPACK_IMPORTED_MODULE_9__.LocalReferenceCollection(refSegment);
                }
                refSegment.localRefs.addAfterTombstones(...savedLocalRefs);
            }
            else {
                // TODO: The tree is empty, so there isn't anywhere to put these
                // they should be preserved somehow
                for (const refsCollection of savedLocalRefs) {
                    refsCollection.clear();
                }
            }
            if (refSegment) {
                this.blockUpdatePathLengths(refSegment.parent, _constants__WEBPACK_IMPORTED_MODULE_4__.TreeMaintenanceSequenceNumber, _constants__WEBPACK_IMPORTED_MODULE_4__.LocalClientId);
            }
        }
        // opArgs == undefined => test code
        if (this.mergeTreeDeltaCallback) {
            this.mergeTreeDeltaCallback(opArgs, {
                operation: 1 /* REMOVE */,
                deltaSegments: removedSegments,
            });
        }
        if (this.collabWindow.collaborating && (seq !== _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber)) {
            if (MergeTree.options.zamboniSegments) {
                this.zamboniSegments();
            }
        }
        // MergeTree.traceTraversal = false;
    }
    nodeUpdateLengthNewStructure(node, recur = false) {
        this.blockUpdate(node);
        if (this.collabWindow.collaborating) {
            node.partialLengths = _partialLengths__WEBPACK_IMPORTED_MODULE_10__.PartialSequenceLengths.combine(this, node, this.collabWindow, recur);
        }
    }
    removeLocalReference(segment, lref) {
        if (segment.localRefs) {
            const removedRef = segment.localRefs.removeLocalRef(lref);
            if (removedRef) {
                this.blockUpdatePathLengths(segment.parent, _constants__WEBPACK_IMPORTED_MODULE_4__.TreeMaintenanceSequenceNumber, _constants__WEBPACK_IMPORTED_MODULE_4__.LocalClientId);
            }
        }
    }
    addLocalReference(lref) {
        const segment = lref.segment;
        let localRefs = segment.localRefs;
        if (!localRefs) {
            localRefs = new _localReference__WEBPACK_IMPORTED_MODULE_9__.LocalReferenceCollection(segment);
            segment.localRefs = localRefs;
        }
        localRefs.addLocalRef(lref);
        this.blockUpdatePathLengths(segment.parent, _constants__WEBPACK_IMPORTED_MODULE_4__.TreeMaintenanceSequenceNumber, _constants__WEBPACK_IMPORTED_MODULE_4__.LocalClientId);
    }
    blockUpdate(block) {
        let len = 0;
        const hierBlock = block.hierBlock();
        if (hierBlock) {
            hierBlock.rightmostTiles = _properties__WEBPACK_IMPORTED_MODULE_2__.createMap();
            hierBlock.leftmostTiles = _properties__WEBPACK_IMPORTED_MODULE_2__.createMap();
            hierBlock.rangeStacks = {};
        }
        for (let i = 0; i < block.childCount; i++) {
            const child = block.children[i];
            len += nodeTotalLength(this, child);
            if (hierBlock) {
                hierBlock.addNodeReferences(this, child);
            }
            if (this.blockUpdateActions) {
                this.blockUpdateActions.child(block, i);
            }
        }
        block.cachedLength = len;
    }
    blockUpdatePathLengths(startBlock, seq, clientId, newStructure = false) {
        let block = startBlock;
        while (block !== undefined) {
            if (newStructure) {
                this.nodeUpdateLengthNewStructure(block);
            }
            else {
                this.blockUpdateLength(block, seq, clientId);
            }
            block = block.parent;
        }
    }
    blockUpdateLength(node, seq, clientId) {
        this.blockUpdate(node);
        if (this.collabWindow.collaborating && (seq !== _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) && (seq !== _constants__WEBPACK_IMPORTED_MODULE_4__.TreeMaintenanceSequenceNumber)) {
            if (node.partialLengths !== undefined && MergeTree.options.incrementalUpdate && clientId !== _constants__WEBPACK_IMPORTED_MODULE_4__.NonCollabClient) {
                node.partialLengths.update(this, node, seq, clientId, this.collabWindow);
            }
            else {
                node.partialLengths = _partialLengths__WEBPACK_IMPORTED_MODULE_10__.PartialSequenceLengths.combine(this, node, this.collabWindow);
            }
        }
    }
    map(actions, refSeq, clientId, accum) {
        // TODO: optimize to avoid comparisons
        this.nodeMap(this.root, actions, 0, refSeq, clientId, accum);
    }
    mapRange(actions, refSeq, clientId, accum, start, end, splitRange = false) {
        if (splitRange) {
            if (start) {
                this.ensureIntervalBoundary(start, refSeq, clientId);
            }
            if (end) {
                this.ensureIntervalBoundary(end, refSeq, clientId);
            }
        }
        this.nodeMap(this.root, actions, 0, refSeq, clientId, accum, start, end);
    }
    nodeToString(block, strbuf, indentCount = 0) {
        let _strbuf = strbuf;
        _strbuf += internedSpaces(indentCount);
        _strbuf += `Node (len ${block.cachedLength}) p len (${block.parent ? block.parent.cachedLength : 0}) ord ${ordinalToArray(block.ordinal)} with ${block.childCount} segs:\n`;
        if (MergeTree.blockUpdateMarkers) {
            _strbuf += internedSpaces(indentCount);
            _strbuf += block.hierToString(indentCount);
        }
        if (this.collabWindow.collaborating) {
            _strbuf += internedSpaces(indentCount);
            _strbuf += `${block.partialLengths.toString((id) => glc(this, id), indentCount)}\n`;
        }
        const children = block.children;
        for (let childIndex = 0; childIndex < block.childCount; childIndex++) {
            const child = children[childIndex];
            if (!child.isLeaf()) {
                _strbuf = this.nodeToString(child, _strbuf, indentCount + 4);
            }
            else {
                const segment = child;
                _strbuf += internedSpaces(indentCount + 4);
                _strbuf += `cli: ${glc(this, segment.clientId)} seq: ${segment.seq} ord: ${ordinalToArray(segment.ordinal)}`;
                const removalInfo = this.getRemovalInfo(segment);
                if (removalInfo.removedSeq !== undefined) {
                    _strbuf += ` rcli: ${glc(this, removalInfo.removedClientId)} rseq: ${removalInfo.removedSeq}`;
                }
                _strbuf += "\n";
                _strbuf += internedSpaces(indentCount + 4);
                _strbuf += segment.toString();
                _strbuf += "\n";
            }
        }
        return _strbuf;
    }
    toString() {
        return this.nodeToString(this.root, "", 0);
    }
    incrementalBlockMap(stateStack) {
        while (!stateStack.empty()) {
            // We already check the stack is not empty
            const state = stateStack.top();
            if (state.op !== IncrementalExecOp.Go) {
                return;
            }
            if (state.childIndex === 0) {
                if (state.start === undefined) {
                    state.start = 0;
                }
                if (state.end === undefined) {
                    state.end = this.blockLength(state.block, state.refSeq, state.clientId);
                }
                if (state.actions.pre) {
                    state.actions.pre(state);
                }
            }
            if ((state.op === IncrementalExecOp.Go) && (state.childIndex < state.block.childCount)) {
                const child = state.block.children[state.childIndex];
                const len = this.nodeLength(child, state.refSeq, state.clientId);
                if (MergeTree.traceIncrTraversal) {
                    if (child.isLeaf()) {
                        // eslint-disable-next-line @typescript-eslint/dot-notation
                        console.log(`considering (r ${state.refSeq} c ${glc(this, state.clientId)}) seg with text ${child["text"]} len ${len} seq ${child.seq} rseq ${child.removedSeq} cli ${glc(this, child.clientId)}`);
                    }
                }
                if ((len > 0) && (state.start < len) && (state.end > 0)) {
                    if (!child.isLeaf()) {
                        const childState = new IncrementalMapState(child, state.actions, state.pos, state.refSeq, state.clientId, state.context, state.start, state.end, 0);
                        stateStack.push(childState);
                    }
                    else {
                        if (MergeTree.traceIncrTraversal) {
                            // eslint-disable-next-line @typescript-eslint/dot-notation
                            console.log(`action on seg with text ${child["text"]}`);
                        }
                        state.actions.leaf(child, state);
                    }
                }
                state.pos += len;
                state.start -= len;
                state.end -= len;
                state.childIndex++;
            }
            else {
                if (state.childIndex === state.block.childCount) {
                    if ((state.op === IncrementalExecOp.Go) && state.actions.post) {
                        state.actions.post(state);
                    }
                    stateStack.pop();
                }
            }
        }
    }
    nodeMap(node, actions, pos, refSeq, clientId, accum, start, end) {
        let _start = start;
        let _end = end;
        let _pos = pos;
        if (_start === undefined) {
            _start = 0;
        }
        if (_end === undefined) {
            _end = this.blockLength(node, refSeq, clientId);
        }
        let go = true;
        if (actions.pre) {
            go = actions.pre(node, _pos, refSeq, clientId, _start, _end, accum);
            if (!go) {
                // Cancel this node but not entire traversal
                return true;
            }
        }
        const children = node.children;
        for (let childIndex = 0; childIndex < node.childCount; childIndex++) {
            const child = children[childIndex];
            const len = this.nodeLength(child, refSeq, clientId);
            if (MergeTree.traceTraversal) {
                let segInfo;
                if ((!child.isLeaf()) && this.collabWindow.collaborating) {
                    segInfo = `minLength: ${child.partialLengths.minLength}`;
                }
                else {
                    const segment = child;
                    segInfo = `cli: ${glc(this, segment.clientId)} seq: ${segment.seq} text: '${segment.toString()}'`;
                    if (segment.removedSeq !== undefined) {
                        segInfo += ` rcli: ${glc(this, segment.removedClientId)} rseq: ${segment.removedSeq}`;
                    }
                }
                console.log(`@tcli ${glc(this, this.collabWindow.clientId)}: map len: ${len} start: ${_start} end: ${_end} ${segInfo}`);
            }
            if (go && (_end > 0) && (len > 0) && (_start < len)) {
                // Found entry containing pos
                if (!child.isLeaf()) {
                    if (go) {
                        go = this.nodeMap(child, actions, _pos, refSeq, clientId, accum, _start, _end);
                    }
                }
                else {
                    if (MergeTree.traceTraversal) {
                        console.log(`@tcli ${glc(this, this.collabWindow.clientId)}: map leaf action`);
                    }
                    if (actions.leaf) {
                        go = actions.leaf(child, _pos, refSeq, clientId, _start, _end, accum);
                    }
                }
            }
            if (!go) {
                break;
            }
            if (actions.shift) {
                actions.shift(child, _pos, refSeq, clientId, _start, _end, accum);
            }
            _pos += len;
            _start -= len;
            _end -= len;
        }
        if (go && actions.post) {
            go = actions.post(node, _pos, refSeq, clientId, _start, _end, accum);
        }
        return go;
    }
    // Invokes the leaf action for all segments.  Note that *all* segments are visited
    // regardless of if they would be visible to the current `clientId` and `refSeq`.
    walkAllSegments(block, action, accum) {
        let go = true;
        const children = block.children;
        for (let childIndex = 0; go && childIndex < block.childCount; childIndex++) {
            const child = children[childIndex];
            go = child.isLeaf()
                ? action(child, accum)
                : this.walkAllSegments(child, action, accum);
        }
        return go;
    }
    // Straight call every segment; goes until leaf action returns false
    nodeMapReverse(block, leafAction, pos, refSeq, clientId) {
        let go = true;
        const children = block.children;
        for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {
            const child = children[childIndex];
            if (go) {
                // Found entry containing pos
                if (!child.isLeaf()) {
                    if (go) {
                        go = this.nodeMapReverse(child, leafAction, pos, refSeq, clientId);
                    }
                }
                else {
                    go = leafAction(child, pos, refSeq, clientId, 0, 0, undefined);
                }
            }
            if (!go) {
                break;
            }
        }
        return go;
    }
}
// Maximum length of text segment to be considered to be merged with other segment.
// Maximum segment length is at least 2x of it (not taking into account initial segment creation).
// The bigger it is, the more expensive it is to break segment into sub-segments (on edits)
// The smaller it is, the more segments we have in snapshots (and in memory) - it's more expensive to load snapshots.
// Small number also makes ReplayTool produce false positives ("same" snapshots have slightly different binary representations).
// More measurements needs to be done, but it's very likely the right spot is somewhere between 1K-2K mark.
// That said, we also break segments on newline and there are very few segments that are longer than 256 because of it.
// must be an even number
MergeTree.TextSegmentGranularity = 256;
MergeTree.zamboniSegmentsMaxCount = 2;
MergeTree.options = {
    incrementalUpdate: true,
    insertAfterRemovedSegs: true,
    measureOrdinalTime: true,
    measureWindowTime: true,
    zamboniSegments: true,
};
MergeTree.traceAppend = false;
MergeTree.traceZRemove = false;
MergeTree.traceOrdinals = false;
MergeTree.traceGatherText = false;
MergeTree.diagInsertTie = false;
MergeTree.skipLeftShift = true;
MergeTree.diagOverlappingRemove = false;
MergeTree.traceTraversal = false;
MergeTree.traceIncrTraversal = false;
MergeTree.theUnfinishedNode = { childCount: -1 };
// WARNING:
// Setting blockUpdateMarkers to false will result in eventual consistency issues
// for property updates on markers when loading from snapshots
MergeTree.blockUpdateMarkers = true;
//# sourceMappingURL=mergeTree.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/mergeTreeTracking.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/mergeTreeTracking.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TrackingGroupCollection": () => (/* binding */ TrackingGroupCollection)
/* harmony export */ });
/* unused harmony export TrackingGroup */
/* harmony import */ var _sortedSegmentSet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sortedSegmentSet */ "../../node_modules/@fluidframework/merge-tree/lib/sortedSegmentSet.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

class TrackingGroup {
    constructor() {
        this.segmentSet = new _sortedSegmentSet__WEBPACK_IMPORTED_MODULE_0__.SortedSegmentSet();
    }
    get segments() {
        return this.segmentSet.items;
    }
    get size() {
        return this.segmentSet.size;
    }
    has(segment) {
        return this.segmentSet.has(segment);
    }
    link(segment) {
        if (!this.segmentSet.has(segment)) {
            this.segmentSet.addOrUpdate(segment);
            segment.trackingCollection.link(this);
        }
    }
    unlink(segment) {
        if (this.segmentSet.remove(segment)) {
            segment.trackingCollection.unlink(this);
        }
    }
}
class TrackingGroupCollection {
    constructor(segment) {
        this.segment = segment;
        this.trackingGroups = new Set();
    }
    link(trackingGroup) {
        if (trackingGroup) {
            if (!this.trackingGroups.has(trackingGroup)) {
                this.trackingGroups.add(trackingGroup);
            }
            if (!trackingGroup.has(this.segment)) {
                trackingGroup.link(this.segment);
            }
        }
    }
    unlink(trackingGroup) {
        if (trackingGroup.has(this.segment)) {
            trackingGroup.unlink(this.segment);
        }
        this.trackingGroups.delete(trackingGroup);
    }
    copyTo(segment) {
        this.trackingGroups.forEach((sg) => segment.trackingCollection.link(sg));
    }
    get empty() {
        return this.trackingGroups.size === 0;
    }
    matches(trackingCollection) {
        if (!trackingCollection
            || this.trackingGroups.size !== trackingCollection.trackingGroups.size) {
            return false;
        }
        for (const tg of this.trackingGroups.values()) {
            if (!trackingCollection.trackingGroups.has(tg)) {
                return false;
            }
        }
        return true;
    }
}
//# sourceMappingURL=mergeTreeTracking.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/opBuilder.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/opBuilder.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAnnotateMarkerOp": () => (/* binding */ createAnnotateMarkerOp),
/* harmony export */   "createAnnotateRangeOp": () => (/* binding */ createAnnotateRangeOp),
/* harmony export */   "createRemoveRangeOp": () => (/* binding */ createRemoveRangeOp),
/* harmony export */   "createInsertSegmentOp": () => (/* binding */ createInsertSegmentOp),
/* harmony export */   "createInsertOp": () => (/* binding */ createInsertOp),
/* harmony export */   "createInsertFromRegisterOp": () => (/* binding */ createInsertFromRegisterOp),
/* harmony export */   "createInsertToRegisterOp": () => (/* binding */ createInsertToRegisterOp),
/* harmony export */   "createGroupOp": () => (/* binding */ createGroupOp)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Creates the op for annotating the markers with the provided properties
 * @param marker - The marker to annotate
 * @param props - The properties to annotate the marker with
 * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
 * @returns The annotate op
 */
function createAnnotateMarkerOp(marker, props, combiningOp) {
    const id = marker.getId();
    if (!id) {
        return undefined;
    }
    return {
        combiningOp,
        props,
        relativePos1: { id, before: true },
        relativePos2: { id },
        type: 2 /* ANNOTATE */,
    };
}
/**
 * Creates the op for annotating the range with the provided properties
 * @param start - The inclusive start postition of the range to annotate
 * @param end - The exclusive end position of the range to annotate
 * @param props - The properties to annotate the range with
 * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
 * @returns The annotate op
 */
function createAnnotateRangeOp(start, end, props, combiningOp) {
    return {
        combiningOp,
        pos1: start,
        pos2: end,
        props,
        type: 2 /* ANNOTATE */,
    };
}
/**
 * Creates the op to remove a range and puts the content of the removed range in a register
 * if a register name is provided
 *
 * @param start - The inclusive start of the range to remove
 * @param end - The exclusive end of the range to remove
 * @param register - Optional. The name of the register to store the removed range in
 */
function createRemoveRangeOp(start, end, register) {
    return {
        pos1: start,
        pos2: end,
        register,
        type: 1 /* REMOVE */,
    };
}
/**
 *
 * @param pos - The position to insert the segment at
 * @param segment - The segment to insert
 */
function createInsertSegmentOp(pos, segment) {
    return createInsertOp(pos, segment.toJSONObject());
}
function createInsertOp(pos, segSpec) {
    return {
        pos1: pos,
        seg: segSpec,
        type: 0 /* INSERT */,
    };
}
/**
 *
 * @param pos - The position to insert the register contents at
 * @param register - The name of the register to insert the value of
 */
function createInsertFromRegisterOp(pos, register) {
    return {
        pos1: pos,
        register,
        type: 0 /* INSERT */,
    };
}
/**
 *
 * @param start - The inclusive start of the range to insert into the register
 * @param end - The exclusive end of the range to insert into the register
 * @param register - The name of the register to insert the range contents into
 */
function createInsertToRegisterOp(start, end, register) {
    return {
        pos1: start,
        pos2: end,
        register,
        type: 0 /* INSERT */,
    };
}
/**
 *
 * @param ops - The ops to group
 */
function createGroupOp(...ops) {
    return {
        ops,
        type: 3 /* GROUP */,
    };
}
//# sourceMappingURL=opBuilder.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/ops.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/ops.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReferenceType": () => (/* binding */ ReferenceType),
/* harmony export */   "IntervalType": () => (/* binding */ IntervalType)
/* harmony export */ });
/* unused harmony export MergeTreeDeltaType */
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var ReferenceType;
(function (ReferenceType) {
    ReferenceType[ReferenceType["Simple"] = 0] = "Simple";
    ReferenceType[ReferenceType["Tile"] = 1] = "Tile";
    ReferenceType[ReferenceType["NestBegin"] = 2] = "NestBegin";
    ReferenceType[ReferenceType["NestEnd"] = 4] = "NestEnd";
    ReferenceType[ReferenceType["RangeBegin"] = 16] = "RangeBegin";
    ReferenceType[ReferenceType["RangeEnd"] = 32] = "RangeEnd";
    ReferenceType[ReferenceType["SlideOnRemove"] = 64] = "SlideOnRemove";
    ReferenceType[ReferenceType["Transient"] = 256] = "Transient";
})(ReferenceType || (ReferenceType = {}));
var IntervalType;
(function (IntervalType) {
    IntervalType[IntervalType["Simple"] = 0] = "Simple";
    IntervalType[IntervalType["Nest"] = 1] = "Nest";
    IntervalType[IntervalType["SlideOnRemove"] = 2] = "SlideOnRemove";
    IntervalType[IntervalType["Transient"] = 4] = "Transient";
})(IntervalType || (IntervalType = {}));
// Note: Assigned positive integers to avoid clashing with MergeTreeMaintenanceType
var MergeTreeDeltaType;
(function (MergeTreeDeltaType) {
    MergeTreeDeltaType[MergeTreeDeltaType["INSERT"] = 0] = "INSERT";
    MergeTreeDeltaType[MergeTreeDeltaType["REMOVE"] = 1] = "REMOVE";
    MergeTreeDeltaType[MergeTreeDeltaType["ANNOTATE"] = 2] = "ANNOTATE";
    MergeTreeDeltaType[MergeTreeDeltaType["GROUP"] = 3] = "GROUP";
})(MergeTreeDeltaType || (MergeTreeDeltaType = {}));
//# sourceMappingURL=ops.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/partialLengths.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/partialLengths.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PartialSequenceLengths": () => (/* binding */ PartialSequenceLengths)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./collections */ "../../node_modules/@fluidframework/merge-tree/lib/collections.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "../../node_modules/@fluidframework/merge-tree/lib/constants.js");
/* harmony import */ var _mergeTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergeTree */ "../../node_modules/@fluidframework/merge-tree/lib/mergeTree.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */




/**
 * Returns the partial length whose sequence number is
 * the greatest sequence number within a that is
 * less than or equal to key.
 * @param a - array of partial segment lengths
 * @param key - sequence number
 */
function latestLEQ(a, key) {
    let best = -1;
    let lo = 0;
    let hi = a.length - 1;
    while (lo <= hi) {
        const mid = lo + Math.floor((hi - lo) / 2);
        if (a[mid].seq <= key) {
            if ((best < 0) || (a[best].seq < a[mid].seq)) {
                best = mid;
            }
            lo = mid + 1;
        }
        else {
            hi = mid - 1;
        }
    }
    return best;
}
/**
 * Keep track of partial sums of segment lengths for all sequence numbers
 * in the current collaboration window (if any).  Only used during active
 * collaboration.
 */
class PartialSequenceLengths {
    constructor(minSeq) {
        this.minSeq = minSeq;
        this.minLength = 0;
        this.segmentCount = 0;
        this.partialLengths = [];
        this.clientSeqNumbers = [];
    }
    static combine(mergeTree, block, collabWindow, recur = false) {
        return PartialSequenceLengths.combineBranch(mergeTree, block, collabWindow, recur);
    }
    /**
     * Combine the partial lengths of block's children
     * @param block - an interior node; it is assumed that each interior node child of this block
     * has its partials up to date
     * @param collabWindow - segment window of the segment tree containing textSegmentBlock
     */
    static combineBranch(mergeTree, block, collabWindow, recur = false) {
        let combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);
        PartialSequenceLengths.fromLeaves(mergeTree, combinedPartialLengths, block, collabWindow);
        let prevPartial;
        function cloneOverlapRemoveClients(oldTree) {
            if (!oldTree) {
                return undefined;
            }
            const newTree = new _collections__WEBPACK_IMPORTED_MODULE_0__.RedBlackTree(_mergeTree__WEBPACK_IMPORTED_MODULE_1__.compareNumbers);
            oldTree.map((bProp) => {
                newTree.put(bProp.data.clientId, Object.assign({}, bProp.data));
                return true;
            });
            return newTree;
        }
        function combineOverlapClients(a, b) {
            const overlapRemoveClientsA = a.overlapRemoveClients;
            if (overlapRemoveClientsA) {
                if (b.overlapRemoveClients) {
                    b.overlapRemoveClients.map((bProp) => {
                        const aProp = overlapRemoveClientsA.get(bProp.key);
                        if (aProp) {
                            aProp.data.seglen += bProp.data.seglen;
                        }
                        else {
                            overlapRemoveClientsA.put(bProp.data.clientId, Object.assign({}, bProp.data));
                        }
                        return true;
                    });
                }
            }
            else {
                a.overlapRemoveClients = cloneOverlapRemoveClients(b.overlapRemoveClients);
            }
        }
        function addNext(partialLength) {
            const seq = partialLength.seq;
            let pLen = 0;
            if (prevPartial) {
                if (prevPartial.seq === partialLength.seq) {
                    prevPartial.seglen += partialLength.seglen;
                    prevPartial.len += partialLength.seglen;
                    combineOverlapClients(prevPartial, partialLength);
                    return;
                }
                else {
                    pLen = prevPartial.len;
                    // Previous sequence number is finished
                    combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);
                }
            }
            prevPartial = {
                clientId: partialLength.clientId,
                len: pLen + partialLength.seglen,
                overlapRemoveClients: cloneOverlapRemoveClients(partialLength.overlapRemoveClients),
                seglen: partialLength.seglen,
                seq,
            };
            combinedPartialLengths.partialLengths.push(prevPartial);
        }
        const childPartials = [];
        for (let i = 0; i < block.childCount; i++) {
            const child = block.children[i];
            if (!child.isLeaf()) {
                const childBlock = child;
                if (recur) {
                    childBlock.partialLengths =
                        PartialSequenceLengths.combine(mergeTree, childBlock, collabWindow, true);
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                childPartials.push(childBlock.partialLengths);
            }
        }
        let childPartialsLen = childPartials.length;
        if (childPartialsLen !== 0) {
            // Some children are interior nodes
            if (combinedPartialLengths.partialLengths.length > 0) {
                // Some children were leaves; add combined partials from these segments
                childPartials.push(combinedPartialLengths);
                childPartialsLen++;
                combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);
            }
            const indices = new Array(childPartialsLen);
            const childPartialsCounts = new Array(childPartialsLen);
            for (let i = 0; i < childPartialsLen; i++) {
                indices[i] = 0;
                childPartialsCounts[i] = childPartials[i].partialLengths.length;
                combinedPartialLengths.minLength += childPartials[i].minLength;
                combinedPartialLengths.segmentCount += childPartials[i].segmentCount;
            }
            let outerIndexOfEarliest = 0;
            let earliestPartialLength;
            while (outerIndexOfEarliest >= 0) {
                outerIndexOfEarliest = -1;
                for (let k = 0; k < childPartialsLen; k++) {
                    // Find next earliest sequence number
                    if (indices[k] < childPartialsCounts[k]) {
                        const cpLen = childPartials[k].partialLengths[indices[k]];
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        if ((outerIndexOfEarliest < 0) || (cpLen.seq < earliestPartialLength.seq)) {
                            outerIndexOfEarliest = k;
                            earliestPartialLength = cpLen;
                        }
                    }
                }
                if (outerIndexOfEarliest >= 0) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    addNext(earliestPartialLength);
                    indices[outerIndexOfEarliest]++;
                }
            }
            // Add client entry for last partial, if any
            if (prevPartial) {
                combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);
            }
        }
        // TODO: incremental zamboni during build
        // console.log(combinedPartialLengths.toString());
        // console.log(`ZZZ...(min ${segmentWindow.minSeq})`);
        if (PartialSequenceLengths.options.zamboni) {
            combinedPartialLengths.zamboni(collabWindow);
        }
        if (PartialSequenceLengths.options.verify) {
            combinedPartialLengths.verify();
        }
        // console.log(combinedPartialLengths.toString());
        return combinedPartialLengths;
    }
    static fromLeaves(mergeTree, combinedPartialLengths, block, collabWindow) {
        combinedPartialLengths.minLength = 0;
        combinedPartialLengths.segmentCount = block.childCount;
        function seqLTE(seq, minSeq) {
            return (seq !== _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber) && (seq <= minSeq);
        }
        for (let i = 0; i < block.childCount; i++) {
            const child = block.children[i];
            if (child.isLeaf()) {
                // Leaf segment
                const segment = child;
                // eslint-disable-next-line max-len
                // console.log(`seg br ${segBranchId} cli ${glc(mergeTree, segment.clientId)} me ${glc(mergeTree, mergeTree.collabWindow.clientId)}`);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                if (seqLTE(segment.seq, collabWindow.minSeq)) {
                    combinedPartialLengths.minLength += segment.cachedLength;
                }
                else {
                    if (segment.seq !== _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber) {
                        PartialSequenceLengths.insertSegment(combinedPartialLengths, segment);
                    }
                }
                const removalInfo = mergeTree.getRemovalInfo(segment);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                if (seqLTE(removalInfo.removedSeq, collabWindow.minSeq)) {
                    combinedPartialLengths.minLength -= segment.cachedLength;
                }
                else {
                    if ((removalInfo.removedSeq !== undefined) &&
                        (removalInfo.removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber)) {
                        PartialSequenceLengths.insertSegment(combinedPartialLengths, segment, removalInfo);
                    }
                }
            }
        }
        // Post-process correctly-ordered partials computing sums and creating
        // lists for each present client id
        const seqPartials = combinedPartialLengths.partialLengths;
        const seqPartialsLen = seqPartials.length;
        let prevLen = 0;
        for (let i = 0; i < seqPartialsLen; i++) {
            seqPartials[i].len = prevLen + seqPartials[i].seglen;
            prevLen = seqPartials[i].len;
            combinedPartialLengths.addClientSeqNumberFromPartial(seqPartials[i]);
        }
        if (PartialSequenceLengths.options.verify) {
            combinedPartialLengths.verify();
        }
    }
    static getOverlapClients(overlapClientids, seglen) {
        const bst = new _collections__WEBPACK_IMPORTED_MODULE_0__.RedBlackTree(_mergeTree__WEBPACK_IMPORTED_MODULE_1__.compareNumbers);
        for (const clientId of overlapClientids) {
            bst.put(clientId, { clientId, seglen });
        }
        return bst;
    }
    static accumulateRemoveClientOverlap(partialLength, overlapRemoveClientIds, seglen) {
        if (partialLength.overlapRemoveClients) {
            for (const clientId of overlapRemoveClientIds) {
                const ovlapClientNode = partialLength.overlapRemoveClients.get(clientId);
                if (!ovlapClientNode) {
                    partialLength.overlapRemoveClients.put(clientId, { clientId, seglen });
                }
                else {
                    ovlapClientNode.data.seglen += seglen;
                }
            }
        }
        else {
            partialLength.overlapRemoveClients =
                PartialSequenceLengths.getOverlapClients(overlapRemoveClientIds, seglen);
        }
    }
    static insertSegment(combinedPartialLengths, segment, removalInfo) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        let seq = segment.seq;
        let segmentLen = segment.cachedLength;
        let clientId = segment.clientId;
        let removeClientOverlap;
        if (removalInfo) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            seq = removalInfo.removedSeq;
            segmentLen = -segmentLen;
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            clientId = removalInfo.removedClientId;
            if (removalInfo.removedClientOverlap) {
                removeClientOverlap = removalInfo.removedClientOverlap;
            }
        }
        const seqPartials = combinedPartialLengths.partialLengths;
        const seqPartialsLen = seqPartials.length;
        // Find the first entry with sequence number greater or equal to seq
        let indexFirstGTE = 0;
        for (; indexFirstGTE < seqPartialsLen; indexFirstGTE++) {
            if (seqPartials[indexFirstGTE].seq >= seq) {
                break;
            }
        }
        if ((indexFirstGTE < seqPartialsLen) && (seqPartials[indexFirstGTE].seq === seq)) {
            seqPartials[indexFirstGTE].seglen += segmentLen;
            if (removeClientOverlap) {
                PartialSequenceLengths.accumulateRemoveClientOverlap(seqPartials[indexFirstGTE], removeClientOverlap, segmentLen);
            }
        }
        else {
            let pLen;
            if (removeClientOverlap) {
                const overlapClients = PartialSequenceLengths.getOverlapClients(removeClientOverlap, segmentLen);
                pLen = { seq, clientId, len: 0, seglen: segmentLen, overlapRemoveClients: overlapClients };
            }
            else {
                pLen = { seq, clientId, len: 0, seglen: segmentLen };
            }
            if (indexFirstGTE < seqPartialsLen) {
                // Shift entries with greater sequence numbers
                // TODO: investigate performance improvement using BST
                for (let k = seqPartialsLen; k > indexFirstGTE; k--) {
                    seqPartials[k] = seqPartials[k - 1];
                }
                seqPartials[indexFirstGTE] = pLen;
            }
            else {
                seqPartials.push(pLen);
            }
        }
    }
    static addSeq(partialLengths, seq, seqSeglen, clientId) {
        let seqPartialLen;
        let penultPartialLen;
        let leqIndex = latestLEQ(partialLengths, seq);
        if (leqIndex >= 0) {
            const pLen = partialLengths[leqIndex];
            if (pLen.seq === seq) {
                seqPartialLen = pLen;
                leqIndex = latestLEQ(partialLengths, seq - 1);
                if (leqIndex >= 0) {
                    penultPartialLen = partialLengths[leqIndex];
                }
            }
            else {
                penultPartialLen = pLen;
            }
        }
        if (seqPartialLen === undefined) {
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            seqPartialLen = {
                clientId,
                seglen: seqSeglen,
                seq,
            };
            partialLengths.push(seqPartialLen);
        }
        else {
            seqPartialLen.seglen = seqSeglen;
            // Assert client id matches
        }
        if (penultPartialLen !== undefined) {
            seqPartialLen.len = seqPartialLen.seglen + penultPartialLen.len;
        }
        else {
            seqPartialLen.len = seqPartialLen.seglen;
        }
    }
    // Assume: seq is latest sequence number; no structural change to sub-tree, but a segment
    // with sequence number seq has been added within the sub-tree
    // TODO: assert client id matches
    update(mergeTree, node, seq, clientId, collabWindow) {
        let seqSeglen = 0;
        let segCount = 0;
        // Compute length for seq across children
        for (let i = 0; i < node.childCount; i++) {
            const child = node.children[i];
            if (!child.isLeaf()) {
                const childBlock = child;
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const branchPartialLengths = childBlock.partialLengths;
                const partialLengths = branchPartialLengths.partialLengths;
                const seqIndex = latestLEQ(partialLengths, seq);
                if (seqIndex >= 0) {
                    const leqPartial = partialLengths[seqIndex];
                    if (leqPartial.seq === seq) {
                        seqSeglen += leqPartial.seglen;
                    }
                }
                segCount += branchPartialLengths.segmentCount;
            }
            else {
                const segment = child;
                const removalInfo = mergeTree.getRemovalInfo(segment);
                if (segment.seq === seq) {
                    if (removalInfo.removedSeq !== seq) {
                        seqSeglen += segment.cachedLength;
                    }
                }
                else {
                    if (removalInfo.removedSeq === seq) {
                        seqSeglen -= segment.cachedLength;
                    }
                }
                segCount++;
            }
        }
        this.segmentCount = segCount;
        PartialSequenceLengths.addSeq(this.partialLengths, seq, seqSeglen, clientId);
        if (this.clientSeqNumbers[clientId] === undefined) {
            this.clientSeqNumbers[clientId] = [];
        }
        PartialSequenceLengths.addSeq(this.clientSeqNumbers[clientId], seq, seqSeglen);
        //    console.log(this.toString());
        if (PartialSequenceLengths.options.zamboni) {
            this.zamboni(collabWindow);
        }
        if (PartialSequenceLengths.options.verify) {
            this.verify();
        }
        //   console.log('ZZZ');
        //   console.log(this.toString());
    }
    getPartialLength(refSeq, clientId) {
        let pLen = this.minLength;
        const seqIndex = latestLEQ(this.partialLengths, refSeq);
        const cliLatestindex = this.cliLatest(clientId);
        const cliSeq = this.clientSeqNumbers[clientId];
        if (seqIndex >= 0) {
            // Add the partial length up to refSeq
            pLen += this.partialLengths[seqIndex].len;
            if (cliLatestindex >= 0) {
                const cliLatest = cliSeq[cliLatestindex];
                if (cliLatest.seq > refSeq) {
                    // The client has local edits after refSeq, add in the length adjustments
                    pLen += cliLatest.len;
                    const precedingCliIndex = this.cliLatestLEQ(clientId, refSeq);
                    if (precedingCliIndex >= 0) {
                        pLen -= cliSeq[precedingCliIndex].len;
                    }
                }
            }
        }
        else {
            // RefSeq is before any of the partial lengths
            // so just add in all local edits of that client (which should all be after the refSeq)
            if (cliLatestindex >= 0) {
                const cliLatest = cliSeq[cliLatestindex];
                pLen += cliLatest.len;
            }
        }
        return pLen;
    }
    toString(glc, indentCount = 0) {
        let buf = "";
        for (const partial of this.partialLengths) {
            buf += `(${partial.seq},${partial.len}) `;
        }
        // eslint-disable-next-line @typescript-eslint/no-for-in-array, no-restricted-syntax
        for (const clientId in this.clientSeqNumbers) {
            if (this.clientSeqNumbers[clientId].length > 0) {
                buf += `Client `;
                if (glc) {
                    buf += `${glc(+clientId)}`;
                }
                else {
                    buf += `${clientId}`;
                }
                buf += "[";
                for (const partial of this.clientSeqNumbers[clientId]) {
                    buf += `(${partial.seq},${partial.len})`;
                }
                buf += "]";
            }
        }
        buf = `min(seq ${this.minSeq}): ${this.minLength}; sc: ${this.segmentCount};${buf}`;
        return buf;
    }
    // Clear away partial sums for sequence numbers earlier than the current window
    zamboni(segmentWindow) {
        function copyDown(partialLengths) {
            const mindex = latestLEQ(partialLengths, segmentWindow.minSeq);
            let minLength = 0;
            // console.log(`mindex ${mindex}`);
            if (mindex >= 0) {
                minLength = partialLengths[mindex].len;
                const seqCount = partialLengths.length;
                if (mindex <= (seqCount - 1)) {
                    // Still some entries remaining
                    const remainingCount = (seqCount - mindex) - 1;
                    // Copy down
                    for (let i = 0; i < remainingCount; i++) {
                        partialLengths[i] = partialLengths[i + mindex + 1];
                        partialLengths[i].len -= minLength;
                    }
                    partialLengths.length = remainingCount;
                }
            }
            return minLength;
        }
        this.minLength += copyDown(this.partialLengths);
        // eslint-disable-next-line @typescript-eslint/no-for-in-array, guard-for-in, no-restricted-syntax
        for (const clientId in this.clientSeqNumbers) {
            const cliPartials = this.clientSeqNumbers[clientId];
            if (cliPartials) {
                copyDown(cliPartials);
            }
        }
    }
    addClientSeqNumber(clientId, seq, seglen) {
        if (this.clientSeqNumbers[clientId] === undefined) {
            this.clientSeqNumbers[clientId] = [];
        }
        const cli = this.clientSeqNumbers[clientId];
        let pLen = seglen;
        if (cli.length > 0) {
            pLen += cli[cli.length - 1].len;
        }
        cli.push({ seq, len: pLen, seglen });
    }
    // Assumes sequence number already coalesced
    addClientSeqNumberFromPartial(partialLength) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.addClientSeqNumber(partialLength.clientId, partialLength.seq, partialLength.seglen);
        if (partialLength.overlapRemoveClients) {
            partialLength.overlapRemoveClients.map((oc) => {
                this.addClientSeqNumber(oc.data.clientId, partialLength.seq, oc.data.seglen);
                return true;
            });
        }
    }
    cliLatestLEQ(clientId, refSeq) {
        const cliSeqs = this.clientSeqNumbers[clientId];
        if (cliSeqs) {
            return latestLEQ(cliSeqs, refSeq);
        }
        else {
            return -1;
        }
    }
    cliLatest(clientId) {
        const cliSeqs = this.clientSeqNumbers[clientId];
        if (cliSeqs && (cliSeqs.length > 0)) {
            return cliSeqs.length - 1;
        }
        else {
            return -1;
        }
    }
    // Debug only
    verifyPartialLengths(partialLengths, clientPartials) {
        if (partialLengths.length === 0) {
            return 0;
        }
        let lastSeqNum = 0;
        let accumSegLen = 0;
        let count = 0;
        for (const partialLength of partialLengths) {
            // Count total number of partial length
            count++;
            // Sequence number should be larger or equal to minseq
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.minSeq <= partialLength.seq, 0x054 /* "Sequence number less than minSeq!" */);
            // Sequence number should be sorted
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(lastSeqNum < partialLength.seq, 0x055 /* "Sequence number is not sorted!" */);
            lastSeqNum = partialLength.seq;
            // Len is a accumulation of all the seglen adjustments
            accumSegLen += partialLength.seglen;
            if (accumSegLen !== partialLength.len) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(false, 0x056 /* "Unexpected total for accumulation of all seglen adjustments!" */);
            }
            if (clientPartials) {
                // Client partials used to track local edits so we can account for them some refSeq.
                // But the information we keep track of are since minSeq, so we keep track of more history
                // then needed, and some of them doesn't make sense to be used for length calculations
                // e.g. if you have this sequence, where the minSeq is #5 because of other clients
                //    seq 10: client 1: insert seg #1
                //    seq 11: client 2: delete seg #2 refseq: 10
                // minLength is 0, we would have keep a record of seglen: -1 for clientPartialLengths for client 2
                // So if you ask for partial length for client 2 @ seq 5, we will have return -1.
                // However, that combination is invalid, since we should never see any ops with refseq < 10 for
                // client 2 after seq 11.
            }
            else {
                // Len adjustment should not make length negative
                if (this.minLength + partialLength.len < 0) {
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(false, 0x057 /* "Negative length after length adjustment!" */);
                }
            }
            if (partialLength.overlapRemoveClients) {
                // Only the flat partialLengths can have overlapRemoveClients, the per client view shouldn't
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!clientPartials, 0x058 /* "Both overlapRemoveClients and clientPartials are set!" */);
                // Each overlap client count as one
                count += partialLength.overlapRemoveClients.size();
            }
        }
        return count;
    }
    verify() {
        if (this.clientSeqNumbers) {
            let cliCount = 0;
            for (const cliSeq of this.clientSeqNumbers) {
                if (cliSeq) {
                    cliCount += this.verifyPartialLengths(cliSeq, true);
                }
            }
            // If we have client view, we should have the flat view
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.partialLengths, 0x059 /* "Client view exists but flat view does not!" */);
            const flatCount = this.verifyPartialLengths(this.partialLengths, false);
            // The number of partial lengths on the client view and flat view should be the same
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(flatCount === cliCount, 0x05a /* "Mismatch between number of partial lengths on client and flat views!" */);
        }
        else {
            // If we don't have a client view, we shouldn't have the flat view either
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.partialLengths, 0x05b /* "Flat view exists but client view does not!" */);
        }
    }
}
PartialSequenceLengths.options = {
    verify: false,
    zamboni: true,
};
//# sourceMappingURL=partialLengths.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/properties.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/properties.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "combine": () => (/* binding */ combine),
/* harmony export */   "matchProperties": () => (/* binding */ matchProperties),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "addProperties": () => (/* binding */ addProperties),
/* harmony export */   "extendIfUndefined": () => (/* binding */ extendIfUndefined),
/* harmony export */   "createMap": () => (/* binding */ createMap)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
function combine(combiningInfo, currentValue, newValue, seq) {
    let _currentValue = currentValue;
    if (_currentValue === undefined) {
        _currentValue = combiningInfo.defaultValue;
    }
    // Fixed set of operations for now
    /* eslint-disable default-case */
    switch (combiningInfo.name) {
        case "incr":
            _currentValue += newValue;
            if (combiningInfo.minValue) {
                if (_currentValue < combiningInfo.minValue) {
                    _currentValue = combiningInfo.minValue;
                }
            }
            break;
        case "consensus":
            if (_currentValue === undefined) {
                const cv = {
                    value: newValue,
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    seq: seq,
                };
                _currentValue = cv;
            }
            else {
                const cv = _currentValue;
                if (cv.seq === -1) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    cv.seq = seq;
                }
            }
            break;
    }
    /* eslint-enable default-case */
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return _currentValue;
}
function matchProperties(a, b) {
    if (a) {
        if (!b) {
            return false;
        }
        else {
            // For now, straightforward; later use hashing
            // eslint-disable-next-line no-restricted-syntax
            for (const key in a) {
                if (b[key] === undefined) {
                    return false;
                }
                else if (typeof b[key] === "object") {
                    if (!matchProperties(a[key], b[key])) {
                        return false;
                    }
                }
                else if (b[key] !== a[key]) {
                    return false;
                }
            }
            // eslint-disable-next-line no-restricted-syntax
            for (const key in b) {
                if (a[key] === undefined) {
                    return false;
                }
            }
        }
    }
    else {
        if (b) {
            return false;
        }
    }
    return true;
}
function extend(base, extension, combiningOp, seq) {
    if (extension !== undefined) {
        if ((typeof extension !== "object")) {
            console.log(`oh my ${extension}`);
        }
        // eslint-disable-next-line guard-for-in, no-restricted-syntax
        for (const key in extension) {
            const v = extension[key];
            if (v === null) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete base[key];
            }
            else {
                if (combiningOp && (combiningOp.name !== "rewrite")) {
                    base[key] = combine(combiningOp, base[key], v, seq);
                }
                else {
                    base[key] = v;
                }
            }
        }
    }
    return base;
}
function clone(extension) {
    if (extension === undefined) {
        return undefined;
    }
    const cloneMap = createMap();
    // eslint-disable-next-line guard-for-in, no-restricted-syntax
    for (const key in extension) {
        const v = extension[key];
        if (v !== null) {
            cloneMap[key] = v;
        }
    }
    return cloneMap;
}
function addProperties(oldProps, newProps, op, seq) {
    let _oldProps = oldProps;
    if ((!_oldProps) || (op && (op.name === "rewrite"))) {
        _oldProps = createMap();
    }
    extend(_oldProps, newProps, op, seq);
    return _oldProps;
}
function extendIfUndefined(base, extension) {
    if (extension !== undefined) {
        if ((typeof extension !== "object")) {
            console.log(`oh my ${extension}`);
        }
        // eslint-disable-next-line no-restricted-syntax
        for (const key in extension) {
            if (base[key] === undefined) {
                base[key] = extension[key];
            }
        }
    }
    return base;
}
// Create a MapLike with good performance.
function createMap() {
    const map = Object.create(null);
    // Using 'delete' on an object causes V8 to put the object in dictionary mode.
    // This disables creation of hidden classes, which are expensive when an object is
    // constantly changing shape.
    // eslint-disable-next-line @typescript-eslint/dot-notation
    map["__"] = undefined;
    // eslint-disable-next-line @typescript-eslint/dot-notation, @typescript-eslint/no-dynamic-delete
    delete map["__"];
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return map;
}
//# sourceMappingURL=properties.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/segmentGroupCollection.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/segmentGroupCollection.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SegmentGroupCollection": () => (/* binding */ SegmentGroupCollection)
/* harmony export */ });
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./collections */ "../../node_modules/@fluidframework/merge-tree/lib/collections.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

class SegmentGroupCollection {
    constructor(segment) {
        this.segment = segment;
        this.segmentGroups = (0,_collections__WEBPACK_IMPORTED_MODULE_0__.ListMakeHead)();
    }
    get size() {
        return this.segmentGroups.count();
    }
    get empty() {
        return this.segmentGroups.empty();
    }
    enqueue(segmentGroup) {
        this.segmentGroups.enqueue(segmentGroup);
        segmentGroup.segments.push(this.segment);
    }
    dequeue() {
        return this.segmentGroups.dequeue();
    }
    clear() {
        this.segmentGroups.clear();
    }
    copyTo(segment) {
        this.segmentGroups.walk((sg) => segment.segmentGroups.enqueue(sg));
    }
}
//# sourceMappingURL=segmentGroupCollection.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/segmentPropertiesManager.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/segmentPropertiesManager.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SegmentPropertiesManager": () => (/* binding */ SegmentPropertiesManager)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "../../node_modules/@fluidframework/merge-tree/lib/constants.js");
/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./properties */ "../../node_modules/@fluidframework/merge-tree/lib/properties.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/* eslint-disable @typescript-eslint/no-non-null-assertion */



class SegmentPropertiesManager {
    constructor(segment) {
        this.segment = segment;
        this.pendingRewriteCount = 0;
    }
    ackPendingProperties(annotateOp) {
        var _a, _b;
        if (annotateOp.combiningOp && annotateOp.combiningOp.name === "rewrite") {
            this.pendingRewriteCount--;
        }
        for (const key of Object.keys(annotateOp.props)) {
            if (((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) !== undefined) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.pendingKeyUpdateCount[key] > 0, 0x05c /* "Trying to update more annotate props than do exist!" */);
                this.pendingKeyUpdateCount[key]--;
                if (((_b = this.pendingKeyUpdateCount) === null || _b === void 0 ? void 0 : _b[key]) === 0) {
                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                    delete this.pendingKeyUpdateCount[key];
                }
            }
        }
    }
    addProperties(newProps, op, seq, collabWindow) {
        var _a;
        if (!this.segment.properties) {
            this.segment.properties = _properties__WEBPACK_IMPORTED_MODULE_1__.createMap();
            this.pendingKeyUpdateCount = _properties__WEBPACK_IMPORTED_MODULE_1__.createMap();
        }
        const collaborating = collabWindow && collabWindow.collaborating;
        // There are outstanding local rewrites, so block all non-local changes
        if (this.pendingRewriteCount > 0 && seq !== _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber && collaborating) {
            return undefined;
        }
        const rewrite = (op && op.name === "rewrite");
        const combiningOp = !rewrite ? op ? op : undefined : undefined;
        const shouldModifyKey = (key) => {
            var _a;
            if (seq === _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber
                || ((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) === undefined
                || combiningOp) {
                return true;
            }
            return false;
        };
        const deltas = {};
        if (rewrite) {
            if (collaborating && seq === _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber) {
                this.pendingRewriteCount++;
            }
            // We are re-writting so delete all the properties
            // not in the new props
            for (const key of Object.keys(this.segment.properties)) {
                if (!newProps[key] && shouldModifyKey(key)) {
                    deltas[key] = this.segment.properties[key];
                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                    delete this.segment.properties[key];
                }
            }
        }
        for (const key of Object.keys(newProps)) {
            if (collaborating) {
                if (seq === _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber) {
                    if (((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) === undefined) {
                        this.pendingKeyUpdateCount[key] = 0;
                    }
                    this.pendingKeyUpdateCount[key]++;
                }
                else if (!shouldModifyKey(key)) {
                    continue;
                }
            }
            const previousValue = this.segment.properties[key];
            // The delta should be null if undefined, as thats how we encode delete
            deltas[key] = (previousValue === undefined) ? null : previousValue;
            let newValue;
            if (combiningOp) {
                newValue = _properties__WEBPACK_IMPORTED_MODULE_1__.combine(combiningOp, previousValue, newValue, seq);
            }
            else {
                newValue = newProps[key];
            }
            if (newValue === null) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete this.segment.properties[key];
            }
            else {
                this.segment.properties[key] = newValue;
            }
        }
        return deltas;
    }
    copyTo(leafSegment) {
        if (this.segment.properties) {
            leafSegment.properties = _properties__WEBPACK_IMPORTED_MODULE_1__.createMap();
            for (const key of Object.keys(this.segment.properties)) {
                leafSegment.properties[key] = this.segment.properties[key];
            }
            if (this.segment.propertyManager) {
                leafSegment.propertyManager = new SegmentPropertiesManager(leafSegment);
                leafSegment.propertyManager.pendingRewriteCount = this.pendingRewriteCount;
                leafSegment.propertyManager.pendingKeyUpdateCount = _properties__WEBPACK_IMPORTED_MODULE_1__.createMap();
                for (const key of Object.keys(this.pendingKeyUpdateCount)) {
                    leafSegment.propertyManager.pendingKeyUpdateCount[key] = this.pendingKeyUpdateCount[key];
                }
            }
        }
    }
    hasPendingProperties() {
        return this.pendingRewriteCount > 0 || Object.keys(this.pendingKeyUpdateCount).length > 0;
    }
}
//# sourceMappingURL=segmentPropertiesManager.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/snapshotChunks.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/snapshotChunks.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasMergeInfo": () => (/* binding */ hasMergeInfo),
/* harmony export */   "serializeAsMinSupportedVersion": () => (/* binding */ serializeAsMinSupportedVersion),
/* harmony export */   "serializeAsMaxSupportedVersion": () => (/* binding */ serializeAsMaxSupportedVersion),
/* harmony export */   "toLatestVersion": () => (/* binding */ toLatestVersion)
/* harmony export */ });
/* harmony import */ var _snapshotlegacy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./snapshotlegacy */ "../../node_modules/@fluidframework/merge-tree/lib/snapshotlegacy.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Returns true if the given 'spec' is an IJSONSegmentWithMergeInfo.
 */
function hasMergeInfo(spec) {
    return !!spec && typeof spec === "object" && "json" in spec;
}
function serializeAsMinSupportedVersion(path, chunk, logger, options, serializer, bind) {
    let targetChuck;
    if (chunk.version !== undefined) {
        logger.send({
            eventName: "MergeTreeChunk:serializeAsMinSupportedVersion",
            category: "generic",
            fromChunkVersion: chunk.version,
            toChunkVersion: undefined,
        });
    }
    switch (chunk.version) {
        case undefined:
            targetChuck = chunk;
            targetChuck.headerMetadata = buildHeaderMetadataForLegecyChunk(path, targetChuck, options);
            break;
        case "1":
            const chunkV1 = chunk;
            const headerMetadata = path === _snapshotlegacy__WEBPACK_IMPORTED_MODULE_0__.SnapshotLegacy.header ? chunkV1.headerMetadata : undefined;
            targetChuck = {
                version: undefined,
                chunkStartSegmentIndex: chunkV1.startIndex,
                chunkLengthChars: chunkV1.length,
                chunkSegmentCount: chunkV1.segmentCount,
                segmentTexts: chunkV1.segments,
                totalLengthChars: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.totalLength,
                totalSegmentCount: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.totalSegmentCount,
                chunkSequenceNumber: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.sequenceNumber,
                chunkMinSequenceNumber: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.minSequenceNumber,
                headerMetadata,
            };
            break;
        default:
            throw new Error(`Unsupported chunk path: ${path} version: ${chunk.version}`);
    }
    return serializer.stringify(targetChuck, bind);
}
function serializeAsMaxSupportedVersion(path, chunk, logger, options, serializer, bind) {
    const targetChuck = toLatestVersion(path, chunk, logger, options);
    return serializer.stringify(targetChuck, bind);
}
function toLatestVersion(path, chunk, logger, options) {
    switch (chunk.version) {
        case undefined: {
            const chunkLegacy = chunk;
            return {
                version: "1",
                length: chunkLegacy.chunkLengthChars,
                segmentCount: chunkLegacy.chunkSegmentCount,
                headerMetadata: buildHeaderMetadataForLegecyChunk(path, chunkLegacy, options),
                segments: chunkLegacy.segmentTexts,
                startIndex: chunkLegacy.chunkStartSegmentIndex,
            };
        }
        case "1":
            return chunk;
        default:
            throw new Error(`Unsupported chunk path: ${path} version: ${chunk.version}`);
    }
}
function buildHeaderMetadataForLegecyChunk(path, chunk, options) {
    if (path === _snapshotlegacy__WEBPACK_IMPORTED_MODULE_0__.SnapshotLegacy.header) {
        if (chunk.headerMetadata !== undefined) {
            return chunk.headerMetadata;
        }
        const chunkIds = [{ id: _snapshotlegacy__WEBPACK_IMPORTED_MODULE_0__.SnapshotLegacy.header }];
        if (chunk.chunkLengthChars < chunk.totalLengthChars) {
            chunkIds.push({ id: _snapshotlegacy__WEBPACK_IMPORTED_MODULE_0__.SnapshotLegacy.body });
        }
        return {
            orderedChunkMetadata: chunkIds,
            minSequenceNumber: chunk.chunkMinSequenceNumber,
            sequenceNumber: chunk.chunkSequenceNumber,
            totalLength: chunk.totalLengthChars,
            totalSegmentCount: chunk.totalSegmentCount,
        };
    }
    return undefined;
}
//# sourceMappingURL=snapshotChunks.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/snapshotLoader.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/snapshotLoader.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SnapshotLoader": () => (/* binding */ SnapshotLoader)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/bufferBrowser.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @fluidframework/container-definitions */ "../../node_modules/@fluidframework/container-definitions/lib/runtime.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "../../node_modules/@fluidframework/merge-tree/lib/constants.js");
/* harmony import */ var _snapshotChunks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./snapshotChunks */ "../../node_modules/@fluidframework/merge-tree/lib/snapshotChunks.js");
/* harmony import */ var _snapshotV1__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./snapshotV1 */ "../../node_modules/@fluidframework/merge-tree/lib/snapshotV1.js");
/* harmony import */ var _snapshotlegacy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./snapshotlegacy */ "../../node_modules/@fluidframework/merge-tree/lib/snapshotlegacy.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/* eslint-disable @typescript-eslint/no-non-null-assertion */







class SnapshotLoader {
    constructor(runtime, client, mergeTree, logger, serializer) {
        this.runtime = runtime;
        this.client = client;
        this.mergeTree = mergeTree;
        this.serializer = serializer;
        this.specToSegment = (spec) => {
            let seg;
            if ((0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_0__.hasMergeInfo)(spec)) {
                seg = this.client.specToSegment(spec.json);
                // `specToSegment()` initializes `seg` with the LocalClientId.  Overwrite this with
                // the `spec` client (if specified).  Otherwise overwrite with `NonCollabClient`.
                seg.clientId = spec.client !== undefined
                    ? this.client.getOrAddShortClientId(spec.client)
                    : _constants__WEBPACK_IMPORTED_MODULE_1__.NonCollabClient;
                seg.seq = spec.seq !== undefined
                    ? spec.seq
                    : _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber;
                if (spec.removedSeq !== undefined) {
                    seg.removedSeq = spec.removedSeq;
                }
                if (spec.removedClient !== undefined) {
                    seg.removedClientId = this.client.getOrAddShortClientId(spec.removedClient);
                }
            }
            else {
                seg = this.client.specToSegment(spec);
                seg.seq = _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber;
                // `specToSegment()` initializes `seg` with the LocalClientId.  We must overwrite this with
                // `NonCollabClient`.
                seg.clientId = _constants__WEBPACK_IMPORTED_MODULE_1__.NonCollabClient;
            }
            return seg;
        };
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.ChildLogger.create(logger, "SnapshotLoader");
    }
    async initialize(services) {
        const headerLoadedP = services.readBlob(_snapshotlegacy__WEBPACK_IMPORTED_MODULE_3__.SnapshotLegacy.header).then((header) => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(!!header, 0x05f /* "Missing blob header on legacy snapshot!" */);
            return this.loadHeader((0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.bufferToString)(header, "utf8"));
        });
        const catchupOpsP = this.loadBodyAndCatchupOps(headerLoadedP, services);
        catchupOpsP.catch((err) => this.logger.sendErrorEvent({ eventName: "CatchupOpsLoadFailure" }, err));
        await headerLoadedP;
        return { catchupOpsP };
    }
    async loadBodyAndCatchupOps(headerChunkP, services) {
        const blobsP = services.list("");
        const headerChunk = await headerChunkP;
        // TODO we shouldn't need to wait on the body being complete to finish initialization.
        // To fully support this we need to be able to process inbound ops for pending segments.
        await this.loadBody(headerChunk, services);
        const blobs = await blobsP;
        if (blobs.length === headerChunk.headerMetadata.orderedChunkMetadata.length + 1) {
            headerChunk.headerMetadata.orderedChunkMetadata.forEach((md) => blobs.splice(blobs.indexOf(md.id), 1));
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(blobs.length === 1, 0x060 /* `There should be only one blob with catch up ops: ${blobs.length}` */);
            // TODO: The 'Snapshot.catchupOps' tree entry is purely for backwards compatibility.
            //       (See https://github.com/microsoft/FluidFramework/issues/84)
            return this.loadCatchupOps(services.readBlob(blobs[0]));
        }
        else if (blobs.length !== headerChunk.headerMetadata.orderedChunkMetadata.length) {
            throw new Error("Unexpected blobs in snapshot");
        }
        return [];
    }
    loadHeader(header) {
        var _a;
        const chunk = _snapshotV1__WEBPACK_IMPORTED_MODULE_6__.SnapshotV1.processChunk(_snapshotlegacy__WEBPACK_IMPORTED_MODULE_3__.SnapshotLegacy.header, header, this.logger, this.mergeTree.options, this.serializer);
        const segs = chunk.segments.map(this.specToSegment);
        this.mergeTree.reloadFromSegments(segs);
        if (chunk.headerMetadata === undefined) {
            throw new Error("header metadata not available");
        }
        // If we load a detached container from snapshot, then we don't supply a default clientId
        // because we don't want to start collaboration.
        if (this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.AttachState.Detached) {
            // specify a default client id, "snapshot" here as we
            // should enter collaboration/op sending mode if we load
            // a snapshot in any case (summary or attach message)
            // once we get a client id this will be called with that
            // clientId in the connected event
            this.client.startOrUpdateCollaboration((_a = this.runtime.clientId) !== null && _a !== void 0 ? _a : "snapshot", 
            // TODO: Make 'minSeq' non-optional once the new snapshot format becomes the default?
            //       (See https://github.com/microsoft/FluidFramework/issues/84)
            /* minSeq: */ chunk.headerMetadata.minSequenceNumber !== undefined
                ? chunk.headerMetadata.minSequenceNumber
                : chunk.headerMetadata.sequenceNumber, 
            /* currentSeq: */ chunk.headerMetadata.sequenceNumber);
        }
        return chunk;
    }
    async loadBody(chunk1, services) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(chunk1.length <= chunk1.headerMetadata.totalLength, 0x061 /* "Mismatch in totalLength" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(chunk1.segmentCount <= chunk1.headerMetadata.totalSegmentCount, 0x062 /* "Mismatch in totalSegmentCount" */);
        if (chunk1.segmentCount === chunk1.headerMetadata.totalSegmentCount) {
            return;
        }
        const segs = [];
        let lengthSofar = chunk1.length;
        for (let chunkIndex = 1; chunkIndex < chunk1.headerMetadata.orderedChunkMetadata.length; chunkIndex++) {
            const chunk = await _snapshotV1__WEBPACK_IMPORTED_MODULE_6__.SnapshotV1.loadChunk(services, chunk1.headerMetadata.orderedChunkMetadata[chunkIndex].id, this.logger, this.mergeTree.options, this.serializer);
            lengthSofar += chunk.length;
            // Deserialize each chunk segment and append it to the end of the MergeTree.
            segs.push(...chunk.segments.map(this.specToSegment));
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(lengthSofar === chunk1.headerMetadata.totalLength, 0x063 /* "Mismatch in totalLength" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(chunk1.segmentCount + segs.length === chunk1.headerMetadata.totalSegmentCount, 0x064 /* "Mismatch in totalSegmentCount" */);
        // Helper to insert segments at the end of the MergeTree.
        const mergeTree = this.mergeTree;
        const append = (segments, cli, seq) => {
            mergeTree.insertSegments(mergeTree.root.cachedLength, segments, 
            /* refSeq: */ _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber, cli, seq, undefined);
        };
        // Helpers to batch-insert segments that are below the min seq
        const batch = [];
        const flushBatch = () => {
            if (batch.length > 0) {
                append(batch, _constants__WEBPACK_IMPORTED_MODULE_1__.NonCollabClient, _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber);
            }
        };
        for (const seg of segs) {
            const cli = seg.clientId;
            const seq = seg.seq;
            // If the segment can be batch inserted, add it to the 'batch' array.  Otherwise, flush
            // any batched segments and then insert the current segment individually.
            if (cli === _constants__WEBPACK_IMPORTED_MODULE_1__.NonCollabClient && seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber) {
                batch.push(seg);
            }
            else {
                flushBatch();
                append([seg], cli, seq);
            }
        }
        flushBatch();
    }
    /**
     * If loading from a snapshot, get the catchup messages.
     * @param rawMessages - The messages in original encoding
     * @returns The decoded messages, but handles aren't parsed.  Matches the format that will be passed in
     * SharedObject.processCore.
     */
    async loadCatchupOps(rawMessages) {
        return JSON.parse((0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.bufferToString)(await rawMessages, "utf8"));
    }
}
//# sourceMappingURL=snapshotLoader.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/snapshotV1.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/snapshotV1.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SnapshotV1": () => (/* binding */ SnapshotV1)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/bufferBrowser.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/storage.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ "../../node_modules/@fluidframework/merge-tree/lib/constants.js");
/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./properties */ "../../node_modules/@fluidframework/merge-tree/lib/properties.js");
/* harmony import */ var _snapshotChunks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./snapshotChunks */ "../../node_modules/@fluidframework/merge-tree/lib/snapshotChunks.js");
/* harmony import */ var _snapshotlegacy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./snapshotlegacy */ "../../node_modules/@fluidframework/merge-tree/lib/snapshotlegacy.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */







class SnapshotV1 {
    constructor(mergeTree, logger, filename, onCompletion) {
        var _a, _b;
        this.mergeTree = mergeTree;
        this.filename = filename;
        this.onCompletion = onCompletion;
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.ChildLogger.create(logger, "Snapshot");
        this.chunkSize = (_b = (_a = mergeTree === null || mergeTree === void 0 ? void 0 : mergeTree.options) === null || _a === void 0 ? void 0 : _a.mergeTreeSnapshotChunkSize) !== null && _b !== void 0 ? _b : SnapshotV1.chunkSize;
        const { currentSeq, minSeq } = mergeTree.getCollabWindow();
        this.header = {
            minSequenceNumber: minSeq,
            sequenceNumber: currentSeq,
            orderedChunkMetadata: [],
            totalLength: 0,
            totalSegmentCount: 0,
        };
        this.segments = [];
        this.segmentLengths = [];
    }
    getSeqLengthSegs(allSegments, allLengths, approxSequenceLength, startIndex = 0) {
        const segments = [];
        let length = 0;
        let segmentCount = 0;
        while ((length < approxSequenceLength) && ((startIndex + segmentCount) < allSegments.length)) {
            const pseg = allSegments[startIndex + segmentCount];
            segments.push(pseg);
            length += allLengths[startIndex + segmentCount];
            segmentCount++;
        }
        return {
            version: "1",
            segmentCount,
            length,
            segments,
            startIndex,
            headerMetadata: undefined,
        };
    }
    /**
     * Emits the snapshot to an ITree. If provided the optional IFluidSerializer will be used when serializing
     * the summary data rather than JSON.stringify.
     */
    emit(serializer, bind) {
        const chunks = [];
        this.header.totalSegmentCount = 0;
        this.header.totalLength = 0;
        do {
            const chunk = this.getSeqLengthSegs(this.segments, this.segmentLengths, this.chunkSize, this.header.totalSegmentCount);
            chunks.push(chunk);
            this.header.totalSegmentCount += chunk.segmentCount;
            this.header.totalLength += chunk.length;
        } while (this.header.totalSegmentCount < this.segments.length);
        // The do while loop should have added at least one chunk
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const headerChunk = chunks.shift();
        headerChunk.headerMetadata = this.header;
        headerChunk.headerMetadata.orderedChunkMetadata = [{ id: _snapshotlegacy__WEBPACK_IMPORTED_MODULE_1__.SnapshotLegacy.header }];
        const entries = chunks.map((chunk, index) => {
            const id = `${_snapshotlegacy__WEBPACK_IMPORTED_MODULE_1__.SnapshotLegacy.body}_${index}`;
            this.header.orderedChunkMetadata.push({ id });
            return {
                mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.FileMode.File,
                path: id,
                type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.TreeEntry.Blob,
                value: {
                    contents: (0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_3__.serializeAsMaxSupportedVersion)(id, chunk, this.logger, this.mergeTree.options, serializer, bind),
                    encoding: "utf-8",
                },
            };
        });
        const tree = {
            entries: [
                {
                    mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.FileMode.File,
                    path: _snapshotlegacy__WEBPACK_IMPORTED_MODULE_1__.SnapshotLegacy.header,
                    type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.TreeEntry.Blob,
                    value: {
                        contents: (0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_3__.serializeAsMaxSupportedVersion)(_snapshotlegacy__WEBPACK_IMPORTED_MODULE_1__.SnapshotLegacy.header, headerChunk, this.logger, this.mergeTree.options, serializer, bind),
                        encoding: "utf-8",
                    },
                },
                ...entries,
            ],
        };
        return tree;
    }
    extractSync() {
        const mergeTree = this.mergeTree;
        const minSeq = this.header.minSequenceNumber;
        // Helper to add the given `MergeTreeChunkV0SegmentSpec` to the snapshot.
        const pushSegRaw = (json, length) => {
            this.segments.push(json);
            this.segmentLengths.push(length);
        };
        // Helper to serialize the given `segment` and add it to the snapshot (if a segment is provided).
        const pushSeg = (segment) => {
            if (segment) {
                pushSegRaw(segment.toJSONObject(), segment.cachedLength);
            }
        };
        let prev;
        const extractSegment = (segment) => {
            // Elide segments that do not need to be included in the snapshot.  A segment may be elided if
            // either condition is true:
            //   a) The segment has not yet been ACKed.  We do not need to snapshot unACKed segments because
            //      there is a pending insert op that will deliver the segment on reconnection.
            //   b) The segment was removed at or below the MSN.  Pending ops can no longer reference this
            //      segment, and therefore we can discard it.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (segment.seq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber || segment.removedSeq <= minSeq) {
                return true;
            }
            // Next determine if the snapshot needs to preserve information required for merging the segment
            // (seq, client, etc.)  This information is only needed if the segment is above the MSN (and doesn't
            // have a pending remove.)
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if ((segment.seq <= minSeq) // Segment is below the MSN, and...
                && (segment.removedSeq === undefined // .. Segment has not been removed, or...
                    || segment.removedSeq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) // .. Removal op to be delivered on reconnect
            ) {
                // This segment is below the MSN, which means that future ops will not reference it.  Attempt to
                // coalesce the new segment with the previous (if any).
                if (!prev) {
                    // We do not have a previous candidate for coalescing.  Make the current segment the new candidate.
                    prev = segment;
                }
                else if (prev.canAppend(segment) && _properties__WEBPACK_IMPORTED_MODULE_5__.matchProperties(prev.properties, segment.properties)) {
                    // We have a compatible pair.  Replace `prev` with the coalesced segment.  Clone to avoid
                    // modifying the segment instances currently in the MergeTree.
                    prev = prev.clone();
                    prev.append(segment.clone());
                }
                else {
                    // The segment pair could not be coalesced.  Record the `prev` segment in the snapshot
                    // and make the current segment the new candidate for coalescing.
                    pushSeg(prev);
                    prev = segment;
                }
            }
            else {
                // This segment needs to preserve it's metadata as it may be referenced by future ops.  It's ineligible
                // for coalescing, so emit the 'prev' segment now (if any).
                pushSeg(prev);
                prev = undefined;
                const raw = { json: segment.toJSONObject() };
                // If the segment insertion is above the MSN, record the insertion merge info.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                if (segment.seq > minSeq) {
                    raw.seq = segment.seq;
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    raw.client = mergeTree.getLongClientId(segment.clientId);
                }
                // We have already dispensed with removed segments below the MSN and removed segments with unassigned
                // sequence numbers.  Any remaining removal info should be preserved.
                if (segment.removedSeq !== undefined) {
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(segment.removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber && segment.removedSeq > minSeq, 0x065 /* "On removal info preservation, segment has invalid removed sequence number!" */);
                    raw.removedSeq = segment.removedSeq;
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    raw.removedClient = mergeTree.getLongClientId(segment.removedClientId);
                }
                // Sanity check that we are preserving either the seq < minSeq or a removed segment's info.
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(raw.seq !== undefined && raw.client !== undefined
                    || raw.removedSeq !== undefined && raw.removedClient !== undefined, 0x066 /* "Corrupted preservation of segment metadata!" */);
                // Record the segment with it's required metadata.
                pushSegRaw(raw, segment.cachedLength);
            }
            return true;
        };
        mergeTree.walkAllSegments(mergeTree.root, extractSegment, this);
        // If the last segment in the walk was coalescable, push it now.
        pushSeg(prev);
        return this.segments;
    }
    static async loadChunk(storage, path, logger, options, serializer) {
        const blob = await storage.readBlob(path);
        const chunkAsString = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.bufferToString)(blob, "utf8");
        return SnapshotV1.processChunk(path, chunkAsString, logger, options, serializer);
    }
    static processChunk(path, chunk, logger, options, serializer) {
        const chunkObj = serializer ? serializer.parse(chunk) : JSON.parse(chunk);
        return (0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_3__.toLatestVersion)(path, chunkObj, logger, options);
    }
}
// Split snapshot into two entries - headers (small) and body (overflow) for faster loading initial content
// Please note that this number has no direct relationship to anything other than size of raw text (characters).
// As we produce json for the blob (and then send over the wire compressed), this number
// is really hard to correlate with any actual metric that matters (like bytes over the wire).
// For test with small number of chunks it would be closer to blob size,
// for very chunky text, blob size can easily be 4x-8x of that number.
SnapshotV1.chunkSize = 10000;
//# sourceMappingURL=snapshotV1.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/snapshotlegacy.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/snapshotlegacy.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SnapshotLegacy": () => (/* binding */ SnapshotLegacy)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/storage.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ "../../node_modules/@fluidframework/merge-tree/lib/constants.js");
/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./properties */ "../../node_modules/@fluidframework/merge-tree/lib/properties.js");
/* harmony import */ var _snapshotChunks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./snapshotChunks */ "../../node_modules/@fluidframework/merge-tree/lib/snapshotChunks.js");
/* eslint-disable @typescript-eslint/no-non-null-assertion */
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */






class SnapshotLegacy {
    constructor(mergeTree, logger, filename, onCompletion) {
        var _a, _b;
        this.mergeTree = mergeTree;
        this.filename = filename;
        this.onCompletion = onCompletion;
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.ChildLogger.create(logger, "Snapshot");
        this.chunkSize = (_b = (_a = mergeTree === null || mergeTree === void 0 ? void 0 : mergeTree.options) === null || _a === void 0 ? void 0 : _a.mergeTreeSnapshotChunkSize) !== null && _b !== void 0 ? _b : SnapshotLegacy.sizeOfFirstChunk;
    }
    getSeqLengthSegs(allSegments, allLengths, approxSequenceLength, startIndex = 0) {
        const segs = [];
        let sequenceLength = 0;
        let segCount = 0;
        while ((sequenceLength < approxSequenceLength) && ((startIndex + segCount) < allSegments.length)) {
            const pseg = allSegments[startIndex + segCount];
            segs.push(pseg);
            sequenceLength += allLengths[startIndex + segCount];
            segCount++;
        }
        return {
            version: undefined,
            chunkStartSegmentIndex: startIndex,
            chunkSegmentCount: segCount,
            chunkLengthChars: sequenceLength,
            totalLengthChars: this.header.segmentsTotalLength,
            totalSegmentCount: allSegments.length,
            chunkSequenceNumber: this.header.seq,
            segmentTexts: segs,
        };
    }
    /**
     * Emits the snapshot to an ITree. If provided the optional IFluidSerializer will be used when serializing
     * the summary data rather than JSON.stringify.
     */
    emit(catchUpMsgs, serializer, bind) {
        var _a, _b;
        const chunk1 = this.getSeqLengthSegs(this.segments, this.segmentLengths, this.chunkSize);
        let length = chunk1.chunkLengthChars;
        let segments = chunk1.chunkSegmentCount;
        const tree = {
            entries: [
                {
                    mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.FileMode.File,
                    path: SnapshotLegacy.header,
                    type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Blob,
                    value: {
                        contents: (0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_2__.serializeAsMinSupportedVersion)(SnapshotLegacy.header, chunk1, this.logger, this.mergeTree.options, serializer, bind),
                        encoding: "utf-8",
                    },
                },
            ],
        };
        if (chunk1.chunkSegmentCount < chunk1.totalSegmentCount) {
            const chunk2 = this.getSeqLengthSegs(this.segments, this.segmentLengths, this.header.segmentsTotalLength, chunk1.chunkSegmentCount);
            length += chunk2.chunkLengthChars;
            segments += chunk2.chunkSegmentCount;
            tree.entries.push({
                mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.FileMode.File,
                path: SnapshotLegacy.body,
                type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Blob,
                value: {
                    contents: (0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_2__.serializeAsMinSupportedVersion)(SnapshotLegacy.body, chunk2, this.logger, this.mergeTree.options, serializer, bind),
                    encoding: "utf-8",
                },
            });
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(length === this.header.segmentsTotalLength, 0x05d /* "emit: mismatch in segmentsTotalLength" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(segments === chunk1.totalSegmentCount, 0x05e /* "emit: mismatch in totalSegmentCount" */);
        if (catchUpMsgs !== undefined && catchUpMsgs.length > 0) {
            tree.entries.push({
                mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.FileMode.File,
                path: (_b = (_a = this.mergeTree.options) === null || _a === void 0 ? void 0 : _a.catchUpBlobName) !== null && _b !== void 0 ? _b : SnapshotLegacy.catchupOps,
                type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Blob,
                value: {
                    contents: serializer ? serializer.stringify(catchUpMsgs, bind) : JSON.stringify(catchUpMsgs),
                    encoding: "utf-8",
                },
            });
        }
        return tree;
    }
    extractSync() {
        const collabWindow = this.mergeTree.getCollabWindow();
        this.seq = collabWindow.minSeq;
        this.header = {
            segmentsTotalLength: this.mergeTree.getLength(this.mergeTree.collabWindow.minSeq, _constants__WEBPACK_IMPORTED_MODULE_4__.NonCollabClient),
            seq: this.mergeTree.collabWindow.minSeq,
        };
        const segs = [];
        let prev;
        const extractSegment = 
        // eslint-disable-next-line max-len
        (segment, pos, refSeq, clientId, start, end) => {
            // eslint-disable-next-line eqeqeq
            if ((segment.seq != _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) && (segment.seq <= this.seq) &&
                // eslint-disable-next-line eqeqeq
                ((segment.removedSeq === undefined) || (segment.removedSeq == _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) ||
                    (segment.removedSeq > this.seq))) {
                if (prev && prev.canAppend(segment)
                    && _properties__WEBPACK_IMPORTED_MODULE_5__.matchProperties(prev.properties, segment.properties)) {
                    prev = prev.clone();
                    prev.append(segment.clone());
                }
                else {
                    if (prev) {
                        segs.push(prev);
                    }
                    prev = segment;
                }
            }
            return true;
        };
        this.mergeTree.map({ leaf: extractSegment }, this.seq, _constants__WEBPACK_IMPORTED_MODULE_4__.NonCollabClient, undefined);
        if (prev) {
            segs.push(prev);
        }
        this.segments = [];
        this.segmentLengths = [];
        let totalLength = 0;
        segs.map((segment) => {
            totalLength += segment.cachedLength;
            this.segments.push(segment.toJSONObject());
            this.segmentLengths.push(segment.cachedLength);
        });
        // We observed this.header.segmentsTotalLength < totalLength to happen in some cases
        // When this condition happens, we might not write out all segments in getSeqLengthSegs()
        // when writing out "body". Issue #1995 tracks following up on the core of the problem.
        // In the meantime, this code makes sure we will write out all segments properly
        // eslint-disable-next-line eqeqeq
        if (this.header.segmentsTotalLength != totalLength) {
            this.logger.sendErrorEvent({
                eventName: "SegmentsTotalLengthMismatch",
                totalLength,
                segmentsTotalLength: this.header.segmentsTotalLength,
            });
            this.header.segmentsTotalLength = totalLength;
        }
        return this.segments;
    }
}
SnapshotLegacy.header = "header";
SnapshotLegacy.body = "body";
SnapshotLegacy.catchupOps = "catchupOps";
// Split snapshot into two entries - headers (small) and body (overflow) for faster loading initial content
// Please note that this number has no direct relationship to anything other than size of raw text (characters).
// As we produce json for the blob (and then send over the wire compressed), this number
// is really hard to correlate with any actual metric that matters (like bytes over the wire).
// For test with small number of chunks it would be closer to blob size,
// for very chunky text, blob size can easily be 4x-8x of that number.
SnapshotLegacy.sizeOfFirstChunk = 10000;
//# sourceMappingURL=snapshotlegacy.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/sortedSegmentSet.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/sortedSegmentSet.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SortedSegmentSet": () => (/* binding */ SortedSegmentSet)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Stores a unique and sorted set of segments, or objects with segments
 *
 * This differs from a normal sorted set in that the keys are not fixed.
 * The segments are sorted via their ordinals which can change as the merge tree is modified.
 * Eventhough the values of the ordinals can change their ordering and uniqueness cannot, so the order of a set of
 * segments ordered by their ordinals will always have the same order even if the ordinal values on
 * the segments changes. This invarient allows ensure the segments stay ordered and unique, and that new segments
 * can be inserted into that order.
 */
class SortedSegmentSet {
    constructor() {
        this.oridinalSortedItems = [];
    }
    get size() {
        return this.oridinalSortedItems.length;
    }
    get items() {
        return this.oridinalSortedItems;
    }
    addOrUpdate(newItem, update) {
        const postition = this.findOrdinalPosition(this.getOrdinal(newItem));
        if (postition.exists) {
            if (update) {
                update(this.oridinalSortedItems[postition.index], newItem);
            }
        }
        else {
            this.oridinalSortedItems.splice(postition.index, 0, newItem);
        }
    }
    remove(item) {
        const position = this.findOrdinalPosition(this.getOrdinal(item));
        if (position.exists) {
            this.oridinalSortedItems.splice(position.index, 1);
            return true;
        }
        return false;
    }
    has(item) {
        const position = this.findOrdinalPosition(this.getOrdinal(item));
        return position.exists;
    }
    getOrdinal(item) {
        const maybeObject = item;
        if (maybeObject && maybeObject.segment) {
            return maybeObject.segment.ordinal;
        }
        const maybeSegment = item;
        return maybeSegment.ordinal;
    }
    findOrdinalPosition(ordinal, start, end) {
        if (this.oridinalSortedItems.length === 0) {
            return { exists: false, index: 0 };
        }
        if (start === undefined || end === undefined) {
            return this.findOrdinalPosition(ordinal, 0, this.oridinalSortedItems.length - 1);
        }
        const index = start + Math.floor((end - start) / 2);
        if (this.getOrdinal(this.oridinalSortedItems[index]) > ordinal) {
            if (start === index) {
                return { exists: false, index };
            }
            return this.findOrdinalPosition(ordinal, start, index - 1);
        }
        else if (this.getOrdinal(this.oridinalSortedItems[index]) < ordinal) {
            if (index === end) {
                return { exists: false, index: index + 1 };
            }
            return this.findOrdinalPosition(ordinal, index + 1, end);
        }
        return { exists: true, index };
    }
}
//# sourceMappingURL=sortedSegmentSet.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/merge-tree/lib/textSegment.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@fluidframework/merge-tree/lib/textSegment.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextSegment": () => (/* binding */ TextSegment),
/* harmony export */   "MergeTreeTextHelper": () => (/* binding */ MergeTreeTextHelper)
/* harmony export */ });
/* harmony import */ var _mergeTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mergeTree */ "../../node_modules/@fluidframework/merge-tree/lib/mergeTree.js");
/* harmony import */ var _localReference__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./localReference */ "../../node_modules/@fluidframework/merge-tree/lib/localReference.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


class TextSegment extends _mergeTree__WEBPACK_IMPORTED_MODULE_0__.BaseSegment {
    constructor(text) {
        super();
        this.text = text;
        this.type = TextSegment.type;
        this.cachedLength = text.length;
    }
    static is(segment) {
        return segment.type === TextSegment.type;
    }
    static make(text, props) {
        const tseg = new TextSegment(text);
        if (props) {
            tseg.addProperties(props);
        }
        return tseg;
    }
    static fromJSONObject(spec) {
        if (typeof spec === "string") {
            return new TextSegment(spec);
        }
        else if (spec && typeof spec === "object" && "text" in spec) {
            const textSpec = spec;
            return TextSegment.make(textSpec.text, textSpec.props);
        }
        return undefined;
    }
    toJSONObject() {
        // To reduce snapshot/ops size, we serialize a TextSegment as a plain 'string' if it is
        // not annotated.
        return this.properties
            ? { text: this.text, props: this.properties }
            : this.text;
    }
    clone(start = 0, end) {
        const text = this.text.substring(start, end);
        const b = TextSegment.make(text, this.properties);
        this.cloneInto(b);
        return b;
    }
    canAppend(segment) {
        return !this.text.endsWith("\n")
            && TextSegment.is(segment)
            && (this.cachedLength <= _mergeTree__WEBPACK_IMPORTED_MODULE_0__.MergeTree.TextSegmentGranularity ||
                segment.cachedLength <= _mergeTree__WEBPACK_IMPORTED_MODULE_0__.MergeTree.TextSegmentGranularity);
    }
    toString() {
        return this.text;
    }
    append(segment) {
        if (TextSegment.is(segment)) {
            // Note: Must call 'appendLocalRefs' before modifying this segment's length as
            // 'this.cachedLength' is used to adjust the offsets of the local refs.
            _localReference__WEBPACK_IMPORTED_MODULE_1__.LocalReferenceCollection.append(this, segment);
            this.text += segment.text;
            this.cachedLength = this.text.length;
        }
        else {
            throw new Error("can only append text segment");
        }
    }
    // TODO: retain removed text for undo
    // returns true if entire string removed
    removeRange(start, end) {
        let remnantString = "";
        const len = this.text.length;
        if (start > 0) {
            remnantString += this.text.substring(0, start);
        }
        if (end < len) {
            remnantString += this.text.substring(end);
        }
        this.text = remnantString;
        this.cachedLength = remnantString.length;
        return (remnantString.length === 0);
    }
    createSplitSegmentAt(pos) {
        if (pos > 0) {
            const remainingText = this.text.substring(pos);
            this.text = this.text.substring(0, pos);
            this.cachedLength = this.text.length;
            const leafSegment = new TextSegment(remainingText);
            return leafSegment;
        }
    }
}
TextSegment.type = "TextSegment";
function isTextAndMarkerAccumulator(accum) {
    return accum.parallelArrays === true;
}
class MergeTreeTextHelper {
    constructor(mergeTree) {
        this.mergeTree = mergeTree;
        this.gatherText = (segment, pos, refSeq, clientId, start, end, accumText) => {
            let _start = start;
            if (TextSegment.is(segment)) {
                if (_mergeTree__WEBPACK_IMPORTED_MODULE_0__.MergeTree.traceGatherText) {
                    console.log(
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    `@cli ${this.mergeTree.getLongClientId(this.mergeTree.collabWindow.clientId)} ` +
                        `gather seg seq ${segment.seq} rseq ${segment.removedSeq} text ${segment.text}`);
                }
                let beginTags = "";
                let endTags = "";
                if (isTextAndMarkerAccumulator(accumText)) {
                    // TODO: let clients pass in function to get tag
                    const tags = [];
                    const initTags = [];
                    if (segment.properties && (segment.properties["font-weight"])) {
                        tags.push("b");
                    }
                    if (segment.properties && (segment.properties["text-decoration"])) {
                        tags.push("u");
                    }
                    const remTags = [];
                    if (tags.length > 0) {
                        for (const tag of tags) {
                            if (!accumText.tagsInProgress.includes(tag)) {
                                beginTags += `<${tag}>`;
                                initTags.push(tag);
                            }
                        }
                        for (const accumTag of accumText.tagsInProgress) {
                            if (!tags.includes(accumTag)) {
                                endTags += `</${accumTag}>`;
                                remTags.push(accumTag);
                            }
                        }
                        for (const initTag of initTags.reverse()) {
                            accumText.tagsInProgress.push(initTag);
                        }
                    }
                    else {
                        for (const accumTag of accumText.tagsInProgress) {
                            endTags += `</${accumTag}>`;
                            remTags.push(accumTag);
                        }
                    }
                    for (const remTag of remTags) {
                        const remdex = accumText.tagsInProgress.indexOf(remTag);
                        if (remdex >= 0) {
                            accumText.tagsInProgress.splice(remdex, 1);
                        }
                    }
                }
                accumText.textSegment.text += endTags;
                accumText.textSegment.text += beginTags;
                if ((_start <= 0) && (end >= segment.text.length)) {
                    accumText.textSegment.text += segment.text;
                }
                else {
                    if (_start < 0) {
                        _start = 0;
                    }
                    if (end >= segment.text.length) {
                        accumText.textSegment.text += segment.text.substring(_start);
                    }
                    else {
                        accumText.textSegment.text += segment.text.substring(_start, end);
                    }
                }
            }
            else {
                if (accumText.placeholder && (accumText.placeholder.length > 0)) {
                    if (accumText.placeholder === "*") {
                        const marker = segment;
                        accumText.textSegment.text += `\n${marker.toString()}`;
                    }
                    else {
                        for (let i = 0; i < segment.cachedLength; i++) {
                            accumText.textSegment.text += accumText.placeholder;
                        }
                    }
                }
                else if (isTextAndMarkerAccumulator(accumText)) {
                    const marker = segment;
                    if (marker.hasTileLabel(accumText.parallelMarkerLabel)) {
                        accumText.parallelMarkers.push(marker);
                        accumText.parallelText.push(accumText.textSegment.text);
                        accumText.textSegment.text = "";
                    }
                }
            }
            return true;
        };
    }
    getTextAndMarkers(refSeq, clientId, label, start, end) {
        const range = this.getValidRange(start, end, refSeq, clientId);
        const accum = {
            parallelArrays: true,
            parallelMarkerLabel: label,
            parallelMarkers: [],
            parallelText: [],
            tagsInProgress: [],
            textSegment: new TextSegment(""),
        };
        if (_mergeTree__WEBPACK_IMPORTED_MODULE_0__.MergeTree.traceGatherText) {
            console.log(`get text on cli ${(0,_mergeTree__WEBPACK_IMPORTED_MODULE_0__.glc)(this.mergeTree, this.mergeTree.collabWindow.clientId)} ` +
                `ref cli ${(0,_mergeTree__WEBPACK_IMPORTED_MODULE_0__.glc)(this.mergeTree, clientId)} refSeq ${refSeq}`);
        }
        this.mergeTree.mapRange({ leaf: this.gatherText }, refSeq, clientId, accum, range.start, range.end);
        return { parallelText: accum.parallelText, parallelMarkers: accum.parallelMarkers };
    }
    getText(refSeq, clientId, placeholder = "", start, end) {
        const range = this.getValidRange(start, end, refSeq, clientId);
        const accum = { textSegment: new TextSegment(""), placeholder };
        if (_mergeTree__WEBPACK_IMPORTED_MODULE_0__.MergeTree.traceGatherText) {
            console.log(`get text on cli ${(0,_mergeTree__WEBPACK_IMPORTED_MODULE_0__.glc)(this.mergeTree, this.mergeTree.collabWindow.clientId)} ` +
                `ref cli ${(0,_mergeTree__WEBPACK_IMPORTED_MODULE_0__.glc)(this.mergeTree, clientId)} refSeq ${refSeq}`);
        }
        this.mergeTree.mapRange({ leaf: this.gatherText }, refSeq, clientId, accum, range.start, range.end);
        return accum.textSegment.text;
    }
    getValidRange(start, end, refSeq, clientId) {
        const range = {
            end: end !== null && end !== void 0 ? end : this.mergeTree.getLength(refSeq, clientId),
            start: start !== null && start !== void 0 ? start : 0,
        };
        return range;
    }
}
//# sourceMappingURL=textSegment.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/protocol-base/lib/blobs.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@fluidframework/protocol-base/lib/blobs.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildHierarchy": () => (/* binding */ buildHierarchy),
/* harmony export */   "BlobTreeEntry": () => (/* binding */ BlobTreeEntry),
/* harmony export */   "TreeTreeEntry": () => (/* binding */ TreeTreeEntry),
/* harmony export */   "AttachmentTreeEntry": () => (/* binding */ AttachmentTreeEntry),
/* harmony export */   "addBlobToTree": () => (/* binding */ addBlobToTree)
/* harmony export */ });
/* unused harmony exports getGitMode, getGitType, CommitTreeEntry */
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/storage.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/unreachable.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Take a summary object and returns its git mode.
 *
 * @param value - summary object
 * @returns the git mode of summary object
 */
function getGitMode(value) {
    const type = value.type === 3 /* Handle */ ? value.handleType : value.type;
    switch (type) {
        case 2 /* Blob */:
        case 4 /* Attachment */:
            return _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.FileMode.File;
        case 1 /* Tree */:
            return _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.FileMode.Directory;
        default:
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.unreachableCase)(type, `Unknown type: ${type}`);
    }
}
/**
 * Take a summary object and returns its type.
 *
 * @param value - summary object
 * @returns the type of summary object
 */
function getGitType(value) {
    const type = value.type === 3 /* Handle */ ? value.handleType : value.type;
    switch (type) {
        case 2 /* Blob */:
        case 4 /* Attachment */:
            return "blob";
        case 1 /* Tree */:
            return "tree";
        default:
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.unreachableCase)(type, `Unknown type: ${type}`);
    }
}
/**
 * Build a tree hierarchy base on a flat tree
 *
 * @param flatTree - a flat tree
 * @param blobsShaToPathCache - Map with blobs sha as keys and values as path of the blob.
 * @returns the hierarchical tree
 */
function buildHierarchy(flatTree, blobsShaToPathCache = new Map()) {
    const lookup = {};
    const root = { id: flatTree.sha, blobs: {}, commits: {}, trees: {} };
    lookup[""] = root;
    for (const entry of flatTree.tree) {
        const lastIndex = entry.path.lastIndexOf("/");
        const entryPathDir = entry.path.slice(0, Math.max(0, lastIndex));
        const entryPathBase = entry.path.slice(lastIndex + 1);
        // The flat output is breadth-first so we can assume we see tree nodes prior to their contents
        const node = lookup[entryPathDir];
        // Add in either the blob or tree
        if (entry.type === "tree") {
            const newTree = { id: entry.sha, blobs: {}, commits: {}, trees: {} };
            node.trees[decodeURIComponent(entryPathBase)] = newTree;
            lookup[entry.path] = newTree;
        }
        else if (entry.type === "blob") {
            node.blobs[decodeURIComponent(entryPathBase)] = entry.sha;
            blobsShaToPathCache.set(entry.sha, `/${entry.path}`);
        }
        else if (entry.type === "commit") {
            node.commits[decodeURIComponent(entryPathBase)] = entry.sha;
        }
    }
    return root;
}
/**
 * Basic implementation of a blob ITreeEntry
 */
class BlobTreeEntry {
    /**
     * Creates a blob ITreeEntry
     * @param path - path of entry
     * @param contents - blob contents
     * @param encoding - encoding of contents; defaults to utf-8
     */
    constructor(path, contents, encoding = "utf-8") {
        this.path = path;
        this.mode = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.FileMode.File;
        this.type = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.TreeEntry.Blob;
        this.value = { contents, encoding };
    }
}
/**
 * Basic implementation of a commit ITreeEntry
 */
class CommitTreeEntry {
    /**
     * Creates a commit ITreeEntry
     * @param path - path of entry
     * @param value - commit value
     */
    constructor(path, value) {
        this.path = path;
        this.value = value;
        this.mode = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.FileMode.Commit;
        this.type = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.TreeEntry.Commit;
    }
}
/**
 * Basic implementation of a tree ITreeEntry
 */
class TreeTreeEntry {
    /**
     * Creates a tree ITreeEntry
     * @param path - path of entry
     * @param value - subtree
     */
    constructor(path, value) {
        this.path = path;
        this.value = value;
        this.mode = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.FileMode.Directory;
        this.type = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.TreeEntry.Tree;
    }
}
/**
 * Basic implementation of an attachment ITreeEntry
 */
class AttachmentTreeEntry {
    /**
     * Creates an attachment ITreeEntry
     * @param path - path of entry
     * @param id - id of external blob attachment
     */
    constructor(path, id) {
        this.path = path;
        this.id = id;
        this.mode = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.FileMode.File;
        this.type = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.TreeEntry.Attachment;
        this.value = { id };
    }
}
// eslint-disable-next-line @typescript-eslint/ban-types
function addBlobToTree(tree, blobName, content) {
    tree.entries.push({
        mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.FileMode.File,
        path: blobName,
        type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.TreeEntry.Blob,
        value: {
            contents: JSON.stringify(content),
            encoding: "utf-8",
        },
    });
}
//# sourceMappingURL=blobs.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/protocol-base/lib/protocol.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@fluidframework/protocol-base/lib/protocol.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isSystemMessage": () => (/* binding */ isSystemMessage),
/* harmony export */   "ProtocolOpHandler": () => (/* binding */ ProtocolOpHandler)
/* harmony export */ });
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/protocol.js");
/* harmony import */ var _quorum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quorum */ "../../node_modules/@fluidframework/protocol-base/lib/quorum.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


function isSystemMessage(message) {
    switch (message.type) {
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientJoin:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientLeave:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Propose:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Reject:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.NoOp:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.NoClient:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Summarize:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.SummaryAck:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.SummaryNack:
            return true;
        default:
            return false;
    }
}
/**
 * Handles protocol specific ops.
 */
class ProtocolOpHandler {
    constructor(minimumSequenceNumber, sequenceNumber, term, members, proposals, values, sendProposal, sendReject) {
        this.minimumSequenceNumber = minimumSequenceNumber;
        this.sequenceNumber = sequenceNumber;
        this.term = term !== null && term !== void 0 ? term : 1;
        this.quorum = new _quorum__WEBPACK_IMPORTED_MODULE_1__.Quorum(minimumSequenceNumber, members, proposals, values, sendProposal, sendReject);
    }
    close() {
        this.quorum.close();
    }
    processMessage(message, local) {
        let immediateNoOp = false;
        switch (message.type) {
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientJoin:
                const systemJoinMessage = message;
                const join = JSON.parse(systemJoinMessage.data);
                const member = {
                    client: join.detail,
                    sequenceNumber: systemJoinMessage.sequenceNumber,
                };
                this.quorum.addMember(join.clientId, member);
                break;
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientLeave:
                const systemLeaveMessage = message;
                const clientId = JSON.parse(systemLeaveMessage.data);
                this.quorum.removeMember(clientId);
                break;
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Propose:
                const proposal = message.contents;
                this.quorum.addProposal(proposal.key, proposal.value, message.sequenceNumber, local, message.clientSequenceNumber);
                // On a quorum proposal, immediately send a response to expedite the approval.
                immediateNoOp = true;
                break;
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Reject:
                const sequenceNumber = message.contents;
                this.quorum.rejectProposal(message.clientId, sequenceNumber);
                break;
            default:
        }
        // Update tracked sequence numbers
        this.minimumSequenceNumber = message.minimumSequenceNumber;
        this.sequenceNumber = message.sequenceNumber;
        // Notify the quorum of the MSN from the message. We rely on it to handle duplicate values but may
        // want to move that logic to this class.
        immediateNoOp = this.quorum.updateMinimumSequenceNumber(message) || immediateNoOp;
        return { immediateNoOp };
    }
    getProtocolState() {
        const quorumSnapshot = this.quorum.snapshot();
        return {
            members: quorumSnapshot.members,
            minimumSequenceNumber: this.minimumSequenceNumber,
            proposals: quorumSnapshot.proposals,
            sequenceNumber: this.sequenceNumber,
            values: quorumSnapshot.values,
        };
    }
}
//# sourceMappingURL=protocol.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/protocol-base/lib/quorum.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@fluidframework/protocol-base/lib/quorum.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Quorum": () => (/* binding */ Quorum),
/* harmony export */   "QuorumProxy": () => (/* binding */ QuorumProxy)
/* harmony export */ });
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/cloneDeep */ "../../node_modules/lodash/cloneDeep.js");
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/typedEventEmitter.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/promises.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/eventForwarder.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/disposal.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
// eslint-disable-next-line import/no-internal-modules


/**
 * Appends a deferred and rejection count to a sequenced proposal. For locally generated promises this allows us to
 * attach a Deferred which we will resolve once the proposal is either accepted or rejected.
 */
class PendingProposal {
    constructor(sendReject, sequenceNumber, key, value, rejections, deferred) {
        this.sendReject = sendReject;
        this.sequenceNumber = sequenceNumber;
        this.key = key;
        this.value = value;
        this.deferred = deferred;
        this.canReject = true;
        this.rejections = new Set(rejections);
    }
    reject() {
        if (!this.canReject) {
            throw new Error("Can no longer reject this proposal");
        }
        this.sendReject(this.sequenceNumber);
    }
    get rejectionDisabled() {
        return !this.canReject;
    }
    disableRejection() {
        this.canReject = false;
    }
    addRejection(clientId) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.rejections.has(clientId), 0x1cd /* `!this.rejections.has(${clientId})` */);
        this.rejections.add(clientId);
    }
}
/**
 * A quorum represents all clients currently within the collaboration window. As well as the values
 * they have agreed upon and any pending proposals.
 */
class Quorum extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.TypedEventEmitter {
    constructor(minimumSequenceNumber, members, proposals, values, sendProposal, sendReject) {
        super();
        this.minimumSequenceNumber = minimumSequenceNumber;
        this.sendProposal = sendProposal;
        this.sendReject = sendReject;
        this.isDisposed = false;
        // Locally generated proposals
        this.localProposals = new Map();
        this.members = new Map(members);
        this.proposals = new Map(proposals.map(([, proposal, rejections]) => {
            return [
                proposal.sequenceNumber,
                new PendingProposal(this.sendReject, proposal.sequenceNumber, proposal.key, proposal.value, rejections),
            ];
        }));
        this.values = new Map(values);
        this.pendingCommit = new Map(values
            .filter((value) => value[1].commitSequenceNumber === -1));
    }
    get disposed() { return this.isDisposed; }
    close() {
        this.removeAllListeners();
    }
    snapshot() {
        const serializedProposals = Array.from(this.proposals).map(([sequenceNumber, proposal]) => [
            sequenceNumber,
            { sequenceNumber, key: proposal.key, value: proposal.value },
            Array.from(proposal.rejections)
        ]);
        const snapshot = {
            members: [...this.members],
            proposals: serializedProposals,
            values: [...this.values],
        };
        return lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default()(snapshot);
    }
    /**
     * Returns whether the quorum has achieved a consensus for the given key.
     */
    has(key) {
        return this.values.has(key);
    }
    /**
     * Returns the consensus value for the given key
     */
    get(key) {
        const keyMap = this.values.get(key);
        if (keyMap !== undefined) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return keyMap.value;
        }
    }
    /**
     * Returns additional data about the approved consensus value
     */
    getApprovalData(key) {
        const proposal = this.values.get(key);
        return proposal ? lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default()(proposal) : undefined;
    }
    /**
     * Adds a new client to the quorum
     */
    addMember(clientId, details) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.members.has(clientId), 0x1ce /* `!this.members.has(${clientId})` */);
        this.members.set(clientId, details);
        this.emit("addMember", clientId, details);
    }
    /**
     * Removes a client from the quorum
     */
    removeMember(clientId) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.members.has(clientId), 0x1cf /* `this.members.has(${clientId})` */);
        this.members.delete(clientId);
        this.emit("removeMember", clientId);
    }
    /**
     * Retrieves all the members in the quorum
     */
    getMembers() {
        return new Map(this.members);
    }
    /**
     * Retrieves a specific member of the quorum
     */
    getMember(clientId) {
        return this.members.get(clientId);
    }
    /**
     * Proposes a new value. Returns a promise that will resolve when the proposal is either accepted or rejected.
     *
     * TODO: Right now we will only submit proposals for connected clients and not attempt to resubmit on any
     * nack/disconnect. The correct answer for this should become more clear as we build scenarios on top of the loader.
     */
    async propose(key, value) {
        const clientSequenceNumber = this.sendProposal(key, value);
        if (clientSequenceNumber < 0) {
            this.emit("error", { eventName: "ProposalInDisconnectedState", key });
            return Promise.reject(new Error("Can't proposal in disconnected state"));
        }
        const deferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Deferred();
        this.localProposals.set(clientSequenceNumber, deferred);
        return deferred.promise;
    }
    /**
     * Begins tracking a new proposal
     */
    addProposal(key, value, sequenceNumber, local, clientSequenceNumber) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.proposals.has(sequenceNumber), 0x1d0 /* `!this.proposals.has(${sequenceNumber})` */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!local || this.localProposals.has(clientSequenceNumber), 0x1d1 /* `!${local} || this.localProposals.has(${clientSequenceNumber})` */);
        const proposal = new PendingProposal(this.sendReject, sequenceNumber, key, value, [], local ? this.localProposals.get(clientSequenceNumber) : undefined);
        this.proposals.set(sequenceNumber, proposal);
        // Emit the event - which will also provide clients an opportunity to reject the proposal. We require
        // clients to make a rejection decision at the time of receiving the proposal and so disable rejecting it
        // after we have emitted the event.
        this.emit("addProposal", proposal);
        proposal.disableRejection();
        if (local) {
            this.localProposals.delete(clientSequenceNumber);
        }
    }
    /**
     * Rejects the given proposal
     */
    rejectProposal(clientId, sequenceNumber) {
        // Proposals require unanimous approval so any rejection results in a rejection of the proposal. For error
        // detection we will keep a rejected proposal in the pending list until the MSN advances so that we can
        // track the total number of rejections.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.proposals.has(sequenceNumber), 0x1d2 /* `this.proposals.has(${sequenceNumber})` */);
        const proposal = this.proposals.get(sequenceNumber);
        if (proposal !== undefined) {
            proposal.addRejection(clientId);
        }
        // We will emit approval and rejection messages once the MSN advances past the sequence number of the
        // proposal. This will allow us to convey all clients who rejected the proposal.
        return;
    }
    /**
     * Updates the minimum sequence number. If the MSN advances past the sequence number for any proposal without
     * a rejection then it becomes an accepted consensus value.  If the MSN advances past the sequence number
     * that the proposal was accepted, then it becomes a committed consensus value.
     * Returns true if immediate no-op is required.
     */
    updateMinimumSequenceNumber(message) {
        const value = message.minimumSequenceNumber;
        if (this.minimumSequenceNumber !== undefined) {
            if (value < this.minimumSequenceNumber) {
                this.emit("error", {
                    currentValue: this.minimumSequenceNumber,
                    eventName: "QuorumMinSeqNumberError",
                    newValue: value,
                });
            }
            if (value <= this.minimumSequenceNumber) {
                return false;
            }
        }
        this.minimumSequenceNumber = value;
        let immediateNoOp = false;
        // Accept proposals and reject proposals whose sequenceNumber is <= the minimumSequenceNumber
        // Return a sorted list of approved proposals. We sort so that we apply them in their sequence number order
        // TODO this can be optimized if necessary to avoid the linear search+sort
        const completed = [];
        for (const [sequenceNumber, proposal] of this.proposals) {
            if (sequenceNumber <= this.minimumSequenceNumber) {
                completed.push(proposal);
            }
        }
        completed.sort((a, b) => a.sequenceNumber - b.sequenceNumber);
        for (const proposal of completed) {
            const approved = proposal.rejections.size === 0;
            // If it was a local proposal - resolve the promise
            if (proposal.deferred) {
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                approved
                    ? proposal.deferred.resolve()
                    : proposal.deferred.reject(`Rejected by ${Array.from(proposal.rejections)}`);
            }
            if (approved) {
                const committedProposal = {
                    approvalSequenceNumber: message.sequenceNumber,
                    commitSequenceNumber: -1,
                    key: proposal.key,
                    sequenceNumber: proposal.sequenceNumber,
                    value: proposal.value,
                };
                // TODO do we want to notify when a proposal doesn't make it to the commit phase - i.e. because
                // a new proposal was made before it made it to the committed phase? For now we just will never
                // emit this message
                this.values.set(committedProposal.key, committedProposal);
                this.pendingCommit.set(committedProposal.key, committedProposal);
                // Send no-op on approval to expedite commit
                // accept means that all clients have seen the proposal and nobody has rejected it
                // commit means that all clients have seen that the proposal was accepted by everyone
                immediateNoOp = true;
                this.emit("approveProposal", committedProposal.sequenceNumber, committedProposal.key, committedProposal.value, committedProposal.approvalSequenceNumber);
            }
            else {
                this.emit("rejectProposal", proposal.sequenceNumber, proposal.key, proposal.value, Array.from(proposal.rejections));
            }
            this.proposals.delete(proposal.sequenceNumber);
        }
        // Move values to the committed stage and notify
        if (this.pendingCommit.size > 0) {
            Array.from(this.pendingCommit.values())
                .filter((pendingCommit) => pendingCommit.approvalSequenceNumber <= value)
                .sort((a, b) => a.sequenceNumber - b.sequenceNumber)
                .forEach((pendingCommit) => {
                pendingCommit.commitSequenceNumber = message.sequenceNumber;
                this.emit("commitProposal", pendingCommit.sequenceNumber, pendingCommit.key, pendingCommit.value, pendingCommit.approvalSequenceNumber, pendingCommit.commitSequenceNumber);
                this.pendingCommit.delete(pendingCommit.key);
            });
        }
        return immediateNoOp;
    }
    setConnectionState(connected, clientId) {
        if (!connected) {
            this.localProposals.forEach((deferral) => {
                deferral.reject(new Error("Client got disconnected"));
            });
            this.localProposals.clear();
        }
    }
    dispose() {
        throw new Error("Not implemented.");
        this.isDisposed = true;
    }
}
/**
 * Proxies Quorum events.
 */
class QuorumProxy extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.EventForwarder {
    constructor(quorum) {
        super(quorum);
        this.propose = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.doIfNotDisposed)(this, quorum.propose.bind(quorum));
        this.has = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.doIfNotDisposed)(this, quorum.has.bind(quorum));
        this.get = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.doIfNotDisposed)(this, quorum.get.bind(quorum));
        this.getApprovalData = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.doIfNotDisposed)(this, quorum.getApprovalData.bind(quorum));
        this.getMembers = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.doIfNotDisposed)(this, quorum.getMembers.bind(quorum));
        this.getMember = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.doIfNotDisposed)(this, quorum.getMember.bind(quorum));
    }
}
//# sourceMappingURL=quorum.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/protocol-definitions/lib/protocol.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/protocol-definitions/lib/protocol.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MessageType": () => (/* binding */ MessageType)
/* harmony export */ });
/* unused harmony export NackErrorType */
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var MessageType;
(function (MessageType) {
    // Empty operation message. Used to send an updated reference sequence number.
    MessageType["NoOp"] = "noop";
    // System message sent to indicate a new client has joined the collaboration
    MessageType["ClientJoin"] = "join";
    // System message sent to indicate a client has left the collaboration
    MessageType["ClientLeave"] = "leave";
    // Proposes a new consensus value
    MessageType["Propose"] = "propose";
    // Message used to reject a pending proposal
    MessageType["Reject"] = "reject";
    // Summary op
    MessageType["Summarize"] = "summarize";
    // Summary op written
    MessageType["SummaryAck"] = "summaryAck";
    // Summary op write failure
    MessageType["SummaryNack"] = "summaryNack";
    // Channel operation.
    MessageType["Operation"] = "op";
    // Forced snapshot
    MessageType["Save"] = "saveOp";
    // Message to indicate the need of a remote agent for a document.
    MessageType["RemoteHelp"] = "remoteHelp";
    // Message to indicate that no active clients are present.
    MessageType["NoClient"] = "noClient";
    // Message to indicate successful round trip.
    MessageType["RoundTrip"] = "tripComplete";
    // Service specific control messages that are never sequenced.
    MessageType["Control"] = "control";
})(MessageType || (MessageType = {}));
/**
 * Type of the Nack.
 * InvalidScopeError: Client's token is not valid for the intended op.
 * ThrottlingError: Retryable after retryAfter number.
 * BadRequestError: Clients op is invalid and should retry immediately with a valid op.
 * LimitExceededError: Service is having issues. Client should not retry.
 */
var NackErrorType;
(function (NackErrorType) {
    NackErrorType["ThrottlingError"] = "ThrottlingError";
    NackErrorType["InvalidScopeError"] = "InvalidScopeError";
    NackErrorType["BadRequestError"] = "BadRequestError";
    NackErrorType["LimitExceededError"] = "LimitExceededError";
})(NackErrorType || (NackErrorType = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/protocol-definitions/lib/scopes.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@fluidframework/protocol-definitions/lib/scopes.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScopeType": () => (/* binding */ ScopeType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var ScopeType;
(function (ScopeType) {
    ScopeType["DocRead"] = "doc:read";
    ScopeType["DocWrite"] = "doc:write";
    ScopeType["SummaryWrite"] = "summary:write";
})(ScopeType || (ScopeType = {}));
//# sourceMappingURL=scopes.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/protocol-definitions/lib/storage.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/protocol-definitions/lib/storage.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileMode": () => (/* binding */ FileMode),
/* harmony export */   "TreeEntry": () => (/* binding */ TreeEntry)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var FileMode;
(function (FileMode) {
    FileMode["File"] = "100644";
    FileMode["Executable"] = "100755";
    FileMode["Directory"] = "040000";
    FileMode["Commit"] = "160000";
    FileMode["Symlink"] = "120000";
})(FileMode || (FileMode = {}));
/**
 * Type of entries that can be stored in a tree
 */
var TreeEntry;
(function (TreeEntry) {
    TreeEntry["Blob"] = "Blob";
    TreeEntry["Commit"] = "Commit";
    TreeEntry["Tree"] = "Tree";
    TreeEntry["Attachment"] = "Attachment";
})(TreeEntry || (TreeEntry = {}));
//# sourceMappingURL=storage.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/register-collection/lib/consensusRegisterCollection.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/register-collection/lib/consensusRegisterCollection.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConsensusRegisterCollection": () => (/* binding */ ConsensusRegisterCollection)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/bufferBrowser.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/unreachable.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/storage.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/protocol.js");
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/shared-object-base */ "../../node_modules/@fluidframework/shared-object-base/lib/sharedObject.js");
/* harmony import */ var _consensusRegisterCollectionFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./consensusRegisterCollectionFactory */ "../../node_modules/@fluidframework/register-collection/lib/consensusRegisterCollectionFactory.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./debug */ "../../node_modules/@fluidframework/register-collection/lib/debug.js");
/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interfaces */ "../../node_modules/@fluidframework/register-collection/lib/interfaces.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */






const newLocalRegister = (sequenceNumber, value) => ({
    sequenceNumber,
    value: {
        type: "Plain",
        value,
    },
});
/** Distinguish between incoming op formats so we know which type it is */
const incomingOpMatchesCurrentFormat = (op) => "serializedValue" in op;
const snapshotFileName = "header";
/**
 * Implementation of a consensus register collection
 */
class ConsensusRegisterCollection extends _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.SharedObject {
    /**
     * Constructs a new consensus register collection. If the object is non-local an id and service interfaces will
     * be provided
     */
    constructor(id, runtime, attributes) {
        super(id, runtime, attributes);
        this.data = new Map();
    }
    /**
     * Create a new consensus register collection
     *
     * @param runtime - data store runtime the new consensus register collection belongs to
     * @param id - optional name of the consensus register collection
     * @returns newly create consensus register collection (but not attached yet)
     */
    // eslint-disable-next-line @typescript-eslint/no-shadow
    static create(runtime, id) {
        return runtime.createChannel(id, _consensusRegisterCollectionFactory__WEBPACK_IMPORTED_MODULE_1__.ConsensusRegisterCollectionFactory.Type);
    }
    /**
     * Get a factory for ConsensusRegisterCollection to register with the data store.
     *
     * @returns a factory that creates and load ConsensusRegisterCollection
     */
    static getFactory() {
        return new _consensusRegisterCollectionFactory__WEBPACK_IMPORTED_MODULE_1__.ConsensusRegisterCollectionFactory();
    }
    /**
     * Creates a new register or writes a new value.
     * Returns a promise that will resolve when the write is acked.
     *
     * @returns Promise<true> if write was non-concurrent
     */
    async write(key, value) {
        const serializedValue = this.stringify(value, this.serializer);
        if (!this.isAttached()) {
            // JSON-roundtrip value for local writes to match the behavior of going through the wire
            this.processInboundWrite(key, this.parse(serializedValue, this.serializer), 0, 0, true);
            return true;
        }
        const message = {
            key,
            type: "write",
            serializedValue,
            refSeq: this.runtime.deltaManager.lastSequenceNumber,
        };
        return this.newAckBasedPromise((resolve) => {
            // Send the resolve function as the localOpMetadata. This will be provided back to us when the
            // op is ack'd.
            this.submitLocalMessage(message, resolve);
            // If we fail due to runtime being disposed, it's better to return false then unhandled exception.
        }).catch((error) => false);
    }
    /**
     * Returns the most recent local value of a register.
     * @param key - The key to read
     * @param readPolicy - The ReadPolicy to apply. Defaults to Atomic.
     */
    read(key, readPolicy = _interfaces__WEBPACK_IMPORTED_MODULE_2__.ReadPolicy.Atomic) {
        if (readPolicy === _interfaces__WEBPACK_IMPORTED_MODULE_2__.ReadPolicy.Atomic) {
            return this.readAtomic(key);
        }
        const versions = this.readVersions(key);
        if (versions !== undefined) {
            // We don't support deletion. So there should be at least one value.
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(versions.length > 0, 0x06c /* "Value should be undefined or non-empty" */);
            return versions[versions.length - 1];
        }
    }
    readVersions(key) {
        const data = this.data.get(key);
        return data === null || data === void 0 ? void 0 : data.versions.map((element) => element.value.value);
    }
    keys() {
        return [...this.data.keys()];
    }
    snapshotCore(serializer) {
        const dataObj = {};
        this.data.forEach((v, k) => { dataObj[k] = v; });
        const tree = {
            entries: [
                {
                    mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_4__.FileMode.File,
                    path: snapshotFileName,
                    type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_4__.TreeEntry.Blob,
                    value: {
                        contents: this.stringify(dataObj, serializer),
                        encoding: "utf-8",
                    },
                },
            ],
        };
        return tree;
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}
     */
    async loadCore(storage) {
        var _a;
        const blob = await storage.readBlob(snapshotFileName);
        const header = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.bufferToString)(blob, "utf8");
        const dataObj = this.parse(header, this.serializer);
        for (const key of Object.keys(dataObj)) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(((_a = dataObj[key].atomic) === null || _a === void 0 ? void 0 : _a.value.type) !== "Shared", 
            // eslint-disable-next-line max-len
            0x06d /* "SharedObjects contained in ConsensusRegisterCollection can no longer be deserialized as of 0.17" */);
            this.data.set(key, dataObj[key]);
        }
    }
    registerCore() { }
    onDisconnect() {
        (0,_debug__WEBPACK_IMPORTED_MODULE_6__.debug)(`ConsensusRegisterCollection ${this.id} is now disconnected`);
    }
    processCore(message, local, localOpMetadata) {
        if (message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_7__.MessageType.Operation) {
            const op = message.contents;
            switch (op.type) {
                case "write": {
                    // backward compatibility: File at rest written with runtime <= 0.13 do not have refSeq
                    // when the refSeq property didn't exist
                    if (op.refSeq === undefined) {
                        op.refSeq = message.referenceSequenceNumber;
                    }
                    // Message can be delivered with delay - e.g. resubmitted on reconnect.
                    // Use the refSeq from when the op was created, not when it was transmitted
                    const refSeqWhenCreated = op.refSeq;
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(refSeqWhenCreated <= message.referenceSequenceNumber, 0x06e /* "Message's reference sequence number < op's reference sequence number!" */);
                    const value = incomingOpMatchesCurrentFormat(op)
                        ? this.parse(op.serializedValue, this.serializer)
                        : op.value.value;
                    const winner = this.processInboundWrite(op.key, value, refSeqWhenCreated, message.sequenceNumber, local);
                    if (local) {
                        // Resolve the pending promise for this operation now that we have received an ack for it.
                        const resolve = localOpMetadata;
                        resolve(winner);
                    }
                    break;
                }
                default: (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.unreachableCase)(op.type);
            }
        }
    }
    readAtomic(key) {
        const data = this.data.get(key);
        return data === null || data === void 0 ? void 0 : data.atomic.value.value;
    }
    /**
     * Process an inbound write op
     * @param key - Key that was written to
     * @param value - Incoming value
     * @param refSeq - RefSeq at the time of write on the remote client
     * @param sequenceNumber - Sequence Number of this write op
     * @param local - Did this write originate on this client
     */
    processInboundWrite(key, value, refSeq, sequenceNumber, local) {
        let data = this.data.get(key);
        // Atomic update if it's a new register or the write was not concurrent,
        // meaning our state was known to the remote client at the time of write
        const winner = data === undefined || refSeq >= data.atomic.sequenceNumber;
        if (winner) {
            const atomicUpdate = newLocalRegister(sequenceNumber, value);
            if (data === undefined) {
                data = {
                    atomic: atomicUpdate,
                    versions: [],
                };
                this.data.set(key, data);
            }
            else {
                data.atomic = atomicUpdate;
            }
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!data, 0x06f /* "data missing for non-atomic inbound update!" */);
        }
        // Remove versions that were known to the remote client at the time of write
        while (data.versions.length > 0 && refSeq >= data.versions[0].sequenceNumber) {
            data.versions.shift();
        }
        const versionUpdate = newLocalRegister(sequenceNumber, value);
        // Asserts for data integrity
        if (!this.isAttached()) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(refSeq === 0 && sequenceNumber === 0, 0x070 /* "sequence numbers are expected to be 0 when unattached" */);
        }
        else if (data.versions.length > 0) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(sequenceNumber > data.versions[data.versions.length - 1].sequenceNumber, 0x071 /* "Versions should naturally be ordered by sequenceNumber" */);
        }
        // Push the new element.
        data.versions.push(versionUpdate);
        // Raise events at the end, to avoid reentrancy issues
        if (winner) {
            this.emit("atomicChanged", key, value, local);
        }
        this.emit("versionChanged", key, value, local);
        return winner;
    }
    stringify(value, serializer) {
        return serializer.stringify(value, this.handle);
    }
    parse(content, serializer) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return serializer.parse(content);
    }
    applyStashedOp() {
        // empty implementation
        return () => { };
    }
}
//# sourceMappingURL=consensusRegisterCollection.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/register-collection/lib/consensusRegisterCollectionFactory.js":
/*!********************************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/register-collection/lib/consensusRegisterCollectionFactory.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConsensusRegisterCollectionFactory": () => (/* binding */ ConsensusRegisterCollectionFactory)
/* harmony export */ });
/* harmony import */ var _consensusRegisterCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consensusRegisterCollection */ "../../node_modules/@fluidframework/register-collection/lib/consensusRegisterCollection.js");
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packageVersion */ "../../node_modules/@fluidframework/register-collection/lib/packageVersion.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * The factory that defines the consensus queue
 */
class ConsensusRegisterCollectionFactory {
    get type() {
        return ConsensusRegisterCollectionFactory.Type;
    }
    get attributes() {
        return ConsensusRegisterCollectionFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     */
    async load(runtime, id, services, attributes) {
        const collection = new _consensusRegisterCollection__WEBPACK_IMPORTED_MODULE_0__.ConsensusRegisterCollection(id, runtime, attributes);
        await collection.load(services);
        return collection;
    }
    create(document, id) {
        const collection = new _consensusRegisterCollection__WEBPACK_IMPORTED_MODULE_0__.ConsensusRegisterCollection(id, document, ConsensusRegisterCollectionFactory.Attributes);
        collection.initializeLocal();
        return collection;
    }
}
ConsensusRegisterCollectionFactory.Type = "https://graph.microsoft.com/types/consensus-register-collection";
ConsensusRegisterCollectionFactory.Attributes = {
    type: ConsensusRegisterCollectionFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgVersion,
};
//# sourceMappingURL=consensusRegisterCollectionFactory.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/register-collection/lib/debug.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@fluidframework/register-collection/lib/debug.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debug": () => (/* binding */ debug)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "../../node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packageVersion */ "../../node_modules/@fluidframework/register-collection/lib/packageVersion.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


const debug = debug__WEBPACK_IMPORTED_MODULE_0___default()("fluid:consensus-register-collection");
debug(`Package: ${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgName} - Version: ${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgVersion}`);
//# sourceMappingURL=debug.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/register-collection/lib/interfaces.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/register-collection/lib/interfaces.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReadPolicy": () => (/* binding */ ReadPolicy)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Read policies used when reading the map value.
 */
var ReadPolicy;
(function (ReadPolicy) {
    // On a concurrent update, returns the first agreed upon value amongst all clients.
    ReadPolicy[ReadPolicy["Atomic"] = 0] = "Atomic";
    // Last writer wins. Simply returns the last written value.
    ReadPolicy[ReadPolicy["LWW"] = 1] = "LWW";
})(ReadPolicy || (ReadPolicy = {}));
//# sourceMappingURL=interfaces.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/register-collection/lib/packageVersion.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/register-collection/lib/packageVersion.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pkgName": () => (/* binding */ pkgName),
/* harmony export */   "pkgVersion": () => (/* binding */ pkgVersion)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
const pkgName = "@fluidframework/register-collection";
const pkgVersion = "0.37.4";
//# sourceMappingURL=packageVersion.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/request-handler/lib/requestHandlers.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/request-handler/lib/requestHandlers.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "innerRequestHandler": () => (/* binding */ innerRequestHandler),
/* harmony export */   "handleFromLegacyUri": () => (/* binding */ handleFromLegacyUri)
/* harmony export */ });
/* unused harmony export createFluidObjectResponse */
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * @deprecated - please avoid adding new references to this API!
 * It exposes internal container guts to external world, which is not ideal.
 * It also relies heavily on internal routing schema (formation of handle URIs) which will change in future
 * And last, but not least, it does not allow any policy to be implemented around GC of data stores exposed
 * through internal URIs. I.e. if there are no other references to such objects, they will be GC'd and
 * external links would get broken. Maybe that's what is needed in some cases, but better, more centralized
 * handling of external URI to internal handle is required (in future, we will support weak handle references,
 * that will allow any GC policy to be implemented by container authors.)
 */
const innerRequestHandler = async (request, runtime) => runtime.IFluidHandleContext.resolveHandle(request);
const createFluidObjectResponse = (fluidObject) => {
    return { status: 200, mimeType: "fluid/object", value: fluidObject };
};
class LegacyUriHandle {
    constructor(absolutePath, runtime) {
        this.absolutePath = absolutePath;
        this.runtime = runtime;
        this.isAttached = true;
    }
    get IFluidHandle() { return this; }
    attachGraph() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 0x0ca /* "Trying to use legacy graph attach!" */);
    }
    async get() {
        const response = await this.runtime.IFluidHandleContext.resolveHandle({ url: this.absolutePath });
        if (response.status === 200 && response.mimeType === "fluid/object") {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return response.value;
        }
        throw new Error(`Failed to resolve container path ${this.absolutePath}`);
    }
    bind(handle) {
        throw new Error("Cannot bind to LegacyUriHandle");
    }
}
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function handleFromLegacyUri(uri, runtime) {
    return new LegacyUriHandle(uri, runtime);
}
//# sourceMappingURL=requestHandlers.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/request-handler/lib/runtimeRequestHandlerBuilder.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/request-handler/lib/runtimeRequestHandlerBuilder.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildRuntimeRequestHandler": () => (/* binding */ buildRuntimeRequestHandler)
/* harmony export */ });
/* unused harmony export RuntimeRequestHandlerBuilder */
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/requestParser.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHelpers.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
  * The RuntimeRequestHandlerBuilder creates a runtime request handler based on request handlers.
  * The provided handlers sequentially applied until one is able to satisfy the request.
  */
class RuntimeRequestHandlerBuilder {
    constructor() {
        this.handlers = [];
    }
    pushHandler(...handlers) {
        if (handlers !== undefined) {
            this.handlers.push(...handlers);
        }
    }
    async handleRequest(request, runtime) {
        const parser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.RequestParser.create(request);
        for (const handler of this.handlers) {
            const response = await handler(parser, runtime);
            if (response !== undefined) {
                return response;
            }
        }
        return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__.create404Response)(request);
    }
}
function buildRuntimeRequestHandler(...handlers) {
    const builder = new RuntimeRequestHandlerBuilder();
    builder.pushHandler(...handlers);
    return async (request, runtime) => builder.handleRequest(request, runtime);
}
//# sourceMappingURL=runtimeRequestHandlerBuilder.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-definitions/dist/dataStoreContext.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-definitions/dist/dataStoreContext.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlushMode = void 0;
/**
 * Runtime flush mode handling
 */
var FlushMode;
(function (FlushMode) {
    /**
     * In automatic flush mode the runtime will immediately send all operations to the driver layer.
     */
    FlushMode[FlushMode["Automatic"] = 0] = "Automatic";
    /**
     * When in manual flush mode the runtime will buffer operations in the current turn and send them as a single
     * batch at the end of the turn. The flush call on the runtime can be used to force send the current batch.
     */
    FlushMode[FlushMode["Manual"] = 1] = "Manual";
})(FlushMode = exports.FlushMode || (exports.FlushMode = {}));
//# sourceMappingURL=dataStoreContext.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-definitions/dist/dataStoreFactory.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-definitions/dist/dataStoreFactory.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IFluidDataStoreFactory = void 0;
exports.IFluidDataStoreFactory = "IFluidDataStoreFactory";
//# sourceMappingURL=dataStoreFactory.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-definitions/dist/dataStoreRegistry.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-definitions/dist/dataStoreRegistry.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IFluidDataStoreRegistry = void 0;
exports.IFluidDataStoreRegistry = "IFluidDataStoreRegistry";
//# sourceMappingURL=dataStoreRegistry.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-definitions/dist/garbageCollection.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-definitions/dist/garbageCollection.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.gcBlobKey = void 0;
// The key to use for storing garbage collection blob in summary.
exports.gcBlobKey = "gc";
//# sourceMappingURL=garbageCollection.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-definitions/dist/index.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-definitions/dist/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./dataStoreFactory */ "../../node_modules/@fluidframework/runtime-definitions/dist/dataStoreFactory.js"), exports);
__exportStar(__webpack_require__(/*! ./dataStoreRegistry */ "../../node_modules/@fluidframework/runtime-definitions/dist/dataStoreRegistry.js"), exports);
__exportStar(__webpack_require__(/*! ./dataStoreContext */ "../../node_modules/@fluidframework/runtime-definitions/dist/dataStoreContext.js"), exports);
__exportStar(__webpack_require__(/*! ./garbageCollection */ "../../node_modules/@fluidframework/runtime-definitions/dist/garbageCollection.js"), exports);
__exportStar(__webpack_require__(/*! ./protocol */ "../../node_modules/@fluidframework/runtime-definitions/dist/protocol.js"), exports);
__exportStar(__webpack_require__(/*! ./summary */ "../../node_modules/@fluidframework/runtime-definitions/dist/summary.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-definitions/dist/protocol.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-definitions/dist/protocol.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=protocol.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-definitions/dist/summary.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-definitions/dist/summary.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.channelsTreeName = exports.CreateSummarizerNodeSource = void 0;
var CreateSummarizerNodeSource;
(function (CreateSummarizerNodeSource) {
    CreateSummarizerNodeSource[CreateSummarizerNodeSource["FromSummary"] = 0] = "FromSummary";
    CreateSummarizerNodeSource[CreateSummarizerNodeSource["FromAttach"] = 1] = "FromAttach";
    CreateSummarizerNodeSource[CreateSummarizerNodeSource["Local"] = 2] = "Local";
})(CreateSummarizerNodeSource = exports.CreateSummarizerNodeSource || (exports.CreateSummarizerNodeSource = {}));
exports.channelsTreeName = ".channels";
//# sourceMappingURL=summary.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHandleContextUtils.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHandleContextUtils.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateHandleContextPath": () => (/* binding */ generateHandleContextPath)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Generates the absolute path for an IFluidHandleContext given its path and its parent routeContext.
 */
function generateHandleContextPath(path, routeContext) {
    let result;
    if (path === "") {
        // The `path` is empty.
        // If the routeContext does not exist, this is the root and it shouldn't have an absolute path.
        // If the routeContext exists, the absolute path is the same as that of the routeContext.
        result = routeContext === undefined ? "" : routeContext.absolutePath;
    }
    else {
        // If the routeContext does not exist, path is the absolute path.
        // If the routeContext exists, absolute path is routeContext's absolute path plus the path.
        result = routeContext === undefined ? `/${path}` : `${routeContext.absolutePath}/${path}`;
    }
    return result;
}
//# sourceMappingURL=dataStoreHandleContextUtils.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHelpers.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHelpers.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "exceptionToResponse": () => (/* binding */ exceptionToResponse),
/* harmony export */   "responseToException": () => (/* binding */ responseToException),
/* harmony export */   "requestFluidObject": () => (/* binding */ requestFluidObject),
/* harmony export */   "create404Response": () => (/* binding */ create404Response),
/* harmony export */   "createResponseError": () => (/* binding */ createResponseError)
/* harmony export */ });
/* unused harmony exports getStack, createDataStoreFactory */
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

function getStack() {
    const err = new Error();
    if (err.stack !== undefined) {
        return err.stack;
    }
    try {
        throw err;
    }
    catch (err2) {
        return err2.stack;
    }
}
function exceptionToResponse(err) {
    var _a;
    const status = 500;
    // eslint-disable-next-line no-null/no-null
    if (err !== null && typeof err === "object" && err.errorFromRequestFluidObject === true) {
        const responseErr = err;
        return {
            mimeType: "text/plain",
            status: responseErr.code,
            value: responseErr.message,
            stack: (_a = responseErr.stack) !== null && _a !== void 0 ? _a : getStack(),
        };
    }
    return {
        mimeType: "text/plain",
        status,
        value: `${err}`,
        stack: getStack(),
    };
}
function responseToException(response, request) {
    const message = response.value;
    const err = new Error(message);
    const responseErr = err;
    responseErr.errorFromRequestFluidObject = true;
    responseErr.message = message;
    responseErr.code = response.status;
    if (response.stack !== undefined) {
        try {
            // not clear if all browsers allow overwriting stack
            responseErr.stack = response.stack;
        }
        catch (err2) { }
    }
    return err;
}
async function requestFluidObject(router, url) {
    const request = typeof url === "string" ? { url } : url;
    const response = await router.request(request);
    if (response.status !== 200 || response.mimeType !== "fluid/object") {
        throw responseToException(response, request);
    }
    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(response.value, 0x19a /* "Invalid response value for Fluid object request" */);
    return response.value;
}
const create404Response = (request) => createResponseError(404, "not found", request);
function createResponseError(status, value, request) {
    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(status !== 200, 0x19b /* "Cannot not create response error on 200 status" */);
    return {
        mimeType: "text/plain",
        status,
        value: request.url === undefined ? value : `${value}: ${request.url}`,
        stack: getStack(),
    };
}
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function createDataStoreFactory(type, factory) {
    return {
        type,
        get IFluidDataStoreFactory() { return this; },
        get IFluidDataStoreRegistry() { return this; },
        instantiateDataStore: async (context) => (await factory).instantiateDataStore(context),
        get: async (name) => { var _a; return (_a = (await factory).IFluidDataStoreRegistry) === null || _a === void 0 ? void 0 : _a.get(name); },
    };
}
//# sourceMappingURL=dataStoreHelpers.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-utils/lib/objectstoragepartition.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-utils/lib/objectstoragepartition.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObjectStoragePartition": () => (/* binding */ ObjectStoragePartition)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Returns a new IChannelStorageService that resolves the given `path` as root.
 */
class ObjectStoragePartition {
    constructor(storage, path) {
        this.storage = storage;
        this.path = path;
        // `path` must not include the trailing separator.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!path.endsWith("/"), 0x19c /* "storage service path has trailing separator" */);
    }
    async readBlob(path) {
        return this.storage.readBlob(`${this.path}/${path}`);
    }
    async contains(path) {
        return this.storage.contains(`${this.path}/${path}`);
    }
    async list(path) {
        return this.storage.list(`${this.path}/${path}`);
    }
}
//# sourceMappingURL=objectstoragepartition.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-utils/lib/objectstorageutils.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-utils/lib/objectstorageutils.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getNormalizedObjectStoragePathParts": () => (/* binding */ getNormalizedObjectStoragePathParts)
/* harmony export */ });
/* unused harmony export listBlobsAtTreePath */
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
function getNormalizedObjectStoragePathParts(path) {
    let normalizePath = path;
    if (normalizePath.startsWith("/")) {
        normalizePath = normalizePath.substr(1);
    }
    if (normalizePath.endsWith("/")) {
        normalizePath = normalizePath.substr(0, normalizePath.length - 1);
    }
    if (normalizePath.length > 0) {
        return normalizePath.split("/");
    }
    return [];
}
async function listBlobsAtTreePath(inputTree, path) {
    const pathParts = getNormalizedObjectStoragePathParts(path);
    let tree = inputTree;
    while ((tree === null || tree === void 0 ? void 0 : tree.entries) !== undefined && pathParts.length > 0) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const part = pathParts.shift();
        const index = tree.entries.findIndex((value) => {
            if (value.type === "Tree" && value.path === part) {
                return true;
            }
            else {
                return false;
            }
        });
        if (index === -1) {
            tree = undefined;
        }
        else {
            const treeEntry = tree.entries[index];
            tree = treeEntry.value;
        }
    }
    if ((tree === null || tree === void 0 ? void 0 : tree.entries) === undefined || pathParts.length !== 0) {
        throw new Error("path does not exist");
    }
    return tree.entries.filter((e) => e.type === "Blob").map((e) => e.path);
}
//# sourceMappingURL=objectstorageutils.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-utils/lib/remoteObjectHandle.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-utils/lib/remoteObjectHandle.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RemoteFluidObjectHandle": () => (/* binding */ RemoteFluidObjectHandle)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _dataStoreHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dataStoreHelpers */ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHelpers.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * This handle is used to dynamically load a Fluid object on a remote client and is created on parsing a serialized
 * FluidObjectHandle.
 * This class is used to generate an IFluidHandle when de-serializing any all handles (including handles to DDSs, custom
 * objects) that are stored in SharedObjects. The Data Store or SharedObject corresponding to the IFluidHandle can be
 * retrieved by calling `get` on it.
 */
class RemoteFluidObjectHandle {
    /**
     * Creates a new RemoteFluidObjectHandle when parsing an IFluidHandle.
     * @param absolutePath - The absolute path to the handle from the container runtime.
     * @param routeContext - The root IFluidHandleContext that has a route to this handle.
     */
    constructor(absolutePath, routeContext) {
        this.absolutePath = absolutePath;
        this.routeContext = routeContext;
        this.isAttached = true;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(absolutePath.startsWith("/"), 0x19d /* "Handles should always have absolute paths" */);
    }
    get IFluidRouter() { return this; }
    get IFluidHandleContext() { return this; }
    get IFluidHandle() { return this; }
    /**
     * @deprecated - This returns the absolute path.
     */
    get path() {
        return this.absolutePath;
    }
    async get() {
        if (this.objectP === undefined) {
            const request = { url: this.absolutePath };
            this.objectP = this.routeContext.resolveHandle(request)
                .then((response) => {
                if (response.mimeType === "fluid/object") {
                    return response.value;
                }
                throw (0,_dataStoreHelpers__WEBPACK_IMPORTED_MODULE_1__.responseToException)(response, request);
            });
        }
        return this.objectP;
    }
    attachGraph() {
        return;
    }
    bind(handle) {
        handle.attachGraph();
    }
    async request(request) {
        try {
            const object = await this.get();
            const router = object.IFluidRouter;
            return router !== undefined
                ? router.request(request)
                : (0,_dataStoreHelpers__WEBPACK_IMPORTED_MODULE_1__.create404Response)(request);
        }
        catch (error) {
            return (0,_dataStoreHelpers__WEBPACK_IMPORTED_MODULE_1__.exceptionToResponse)(error);
        }
    }
}
//# sourceMappingURL=remoteObjectHandle.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-utils/lib/requestParser.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-utils/lib/requestParser.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RequestParser": () => (/* binding */ RequestParser)
/* harmony export */ });
/**
 * The Request Parser takes an IRequest provides parsing and sub request creation
 */
class RequestParser {
    constructor(request) {
        this.request = request;
        const queryStartIndex = this.request.url.indexOf("?");
        if (queryStartIndex >= 0) {
            this.query = this.request.url.substring(queryStartIndex);
        }
        else {
            this.query = "";
        }
    }
    /**
     * Splits the path of the url and decodes each path part
     * @param url - the url to get path parts of
     */
    static getPathParts(url) {
        const queryStartIndex = url.indexOf("?");
        return url
            .substring(0, queryStartIndex < 0 ? url.length : queryStartIndex)
            .split("/")
            .reduce((pv, cv) => {
            if (cv !== undefined && cv.length > 0) {
                pv.push(decodeURIComponent(cv));
            }
            return pv;
        }, []);
    }
    static create(request) {
        // Perf optimizations.
        if (request instanceof RequestParser) {
            return request;
        }
        return new RequestParser(request);
    }
    get url() {
        return this.request.url;
    }
    get headers() {
        return this.request.headers;
    }
    /**
     * Returns the decoded path parts of the request's url
     */
    get pathParts() {
        if (this.requestPathParts === undefined) {
            this.requestPathParts = RequestParser.getPathParts(this.url);
        }
        return this.requestPathParts;
    }
    /**
     * Returns true if it's a terminating path, i.e. no more elements after `elements` entries and empty query.
     * @param elements - number of elements in path
     */
    isLeaf(elements) {
        return this.query === "" && this.pathParts.length === elements;
    }
    /**
     * Creates a sub request starting at a specific path part of this request's url
     * The sub request url always has a leading slash, and always include query params if original url has any
     * e.g. original url is /a/b/?queryParams, createSubRequest(0) is /a/b/?queryParams
     * createSubRequest(1) is /b/?queryParams
     * createSubRequest(2) is /?queryParams
     * createSubRequest(n) where n is bigger than parts length, e.g. 2, or n is less than 0 will throw an exception
     *
     * note: query params are not counted towards path parts.
     *
     * @param startingPathIndex - The index of the first path part of the sub request
     */
    createSubRequest(startingPathIndex) {
        const pathLen = this.pathParts.length;
        if (startingPathIndex < 0 || startingPathIndex > pathLen) {
            throw new Error("incorrect sub-request");
        }
        if (startingPathIndex === pathLen && this.url.includes("?")) {
            return {
                url: `/${this.query}`,
                headers: this.headers,
            };
        }
        const path = `/${this.pathParts.slice(startingPathIndex).join("/")}`;
        return {
            url: this.query === "" ? path : `${path}/${this.query}`,
            headers: this.headers,
        };
    }
}
//# sourceMappingURL=requestParser.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-utils/lib/serializer.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-utils/lib/serializer.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FluidSerializer": () => (/* binding */ FluidSerializer)
/* harmony export */ });
/* harmony import */ var _remoteObjectHandle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./remoteObjectHandle */ "../../node_modules/@fluidframework/runtime-utils/lib/remoteObjectHandle.js");
/* harmony import */ var _dataStoreHandleContextUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dataStoreHandleContextUtils */ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHandleContextUtils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "../../node_modules/@fluidframework/runtime-utils/lib/utils.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * Data Store serializer implementation
 */
class FluidSerializer {
    constructor(context) {
        this.context = context;
        this.root = this.context;
        while (this.root.routeContext !== undefined) {
            this.root = this.root.routeContext;
        }
    }
    get IFluidSerializer() { return this; }
    replaceHandles(input, bind) {
        // If the given 'input' cannot contain handles, return it immediately.  Otherwise,
        // return the result of 'recursivelyReplaceHandles()'.
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions,@typescript-eslint/no-unsafe-return
        return !!input && typeof input === "object"
            ? this.recursivelyReplaceHandles(input, bind)
            : input;
    }
    stringify(input, bind) {
        return JSON.stringify(input, (key, value) => {
            // If the current 'value' is not a handle, return it unmodified.  Otherwise,
            // return the result of 'serializeHandle'.
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            const handle = !!value && value.IFluidHandle;
            // TODO - understand why handle === false in some of our tests
            // eslint-disable-next-line max-len
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions,@typescript-eslint/no-unsafe-return
            return handle
                ? this.serializeHandle(handle, bind)
                : value;
        });
    }
    // Parses the serialized data - context must match the context with which the JSON was stringified
    parse(input) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return JSON.parse(input, (key, value) => {
            if (!(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isSerializedHandle)(value)) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return value;
            }
            // Old documents may have handles with relative path in their summaries. Convert these to absolute
            // paths. This will ensure that future summaries will have absolute paths for these handles.
            const absolutePath = value.url.startsWith("/")
                ? value.url
                : (0,_dataStoreHandleContextUtils__WEBPACK_IMPORTED_MODULE_1__.generateHandleContextPath)(value.url, this.context);
            return new _remoteObjectHandle__WEBPACK_IMPORTED_MODULE_2__.RemoteFluidObjectHandle(absolutePath, this.root);
        });
    }
    // Invoked by `replaceHandles()` for non-null objects to recursively replace IFluidHandle references
    // with serialized handles (cloning as-needed to avoid mutating the original `input` object.)
    recursivelyReplaceHandles(input, bind) {
        // If the current input is an IFluidHandle instance, replace this leaf in the object graph with
        // the handle's serialized from.
        // Note: Caller is responsible for ensuring that `input` is a non-null object.
        const handle = input.IFluidHandle;
        if (handle !== undefined) {
            return this.serializeHandle(handle, bind);
        }
        // eslint-disable-next-line @typescript-eslint/ban-types
        let clone;
        for (const key of Object.keys(input)) {
            const value = input[key];
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (!!value && typeof value === "object") {
                // Note: Except for IFluidHandle, `input` must not contain circular references (as object must
                //       be JSON serializable.)  Therefore, guarding against infinite recursion here would only
                //       lead to a later error when attempting to stringify().
                const replaced = this.recursivelyReplaceHandles(value, bind);
                // If the `replaced` object is different than the original `value` then the subgraph contained one
                // or more handles.  If this happens, we need to return a clone of the `input` object where the
                // current property is replaced by the `replaced` value.
                if (replaced !== value) {
                    // Lazily create a shallow clone of the `input` object if we haven't done so already.
                    clone = clone !== null && clone !== void 0 ? clone : (Array.isArray(input)
                        ? [...input]
                        : Object.assign({}, input));
                    // Overwrite the current property `key` in the clone with the `replaced` value.
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    clone[key] = replaced;
                }
            }
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return clone !== null && clone !== void 0 ? clone : input;
    }
    serializeHandle(handle, bind) {
        bind.bind(handle);
        return {
            type: "__fluid_handle__",
            url: handle.absolutePath,
        };
    }
}
//# sourceMappingURL=serializer.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-utils/lib/summarizerNode/summarizerNode.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-utils/lib/summarizerNode/summarizerNode.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummarizerNode": () => (/* binding */ SummarizerNode)
/* harmony export */ });
/* unused harmony export createRootSummarizerNode */
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/runtime-definitions */ "../../node_modules/@fluidframework/runtime-definitions/dist/index.js");
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/unreachable.js");
/* harmony import */ var _summaryUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../summaryUtils */ "../../node_modules/@fluidframework/runtime-utils/lib/summaryUtils.js");
/* harmony import */ var _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./summarizerNodeUtils */ "../../node_modules/@fluidframework/runtime-utils/lib/summarizerNode/summarizerNodeUtils.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */




/**
 * Encapsulates the summarizing work and state of an individual tree node in the
 * summary tree. It tracks changes and allows for optimizations when unchanged, or
 * can allow for fallback summaries to be generated when an error is encountered.
 * Usage is for the root node to call startSummary first to begin tracking a WIP
 * (work in progress) summary. Then all nodes will call summarize to summaries their
 * individual parts. Once completed and uploaded to storage, the root node will call
 * completeSummary or clearSummary to clear the WIP summary tracking state if something
 * went wrong. The SummarizerNodes will track all pending summaries that have been
 * recorded by the completeSummary call. When one of them is acked, the root node should
 * call refreshLatestSummary to inform the tree of SummarizerNodes of the new baseline
 * latest successful summary.
 */
class SummarizerNode {
    /**
     * Do not call constructor directly.
     * Use createRootSummarizerNode to create root node, or createChild to create child nodes.
     */
    constructor(defaultLogger, summarizeInternalFn, config, _changeSequenceNumber, 
    /** Undefined means created without summary */
    latestSummary, initialSummary, wipSummaryLogger) {
        var _a;
        this.defaultLogger = defaultLogger;
        this.summarizeInternalFn = summarizeInternalFn;
        this._changeSequenceNumber = _changeSequenceNumber;
        this.latestSummary = latestSummary;
        this.initialSummary = initialSummary;
        this.wipSummaryLogger = wipSummaryLogger;
        this.children = new Map();
        this.pendingSummaries = new Map();
        this.outstandingOps = [];
        this.wipSkipRecursion = false;
        this.canReuseHandle = (_a = config.canReuseHandle) !== null && _a !== void 0 ? _a : true;
        // BUGBUG: Seeing issues with differential summaries.
        // this will disable them, and throw instead
        // while we continue to investigate
        this.throwOnError = true; // config.throwOnFailure ?? false;
        this.trackingSequenceNumber = this._changeSequenceNumber;
    }
    /**
     * The reference sequence number of the most recent acked summary.
     * Returns 0 if there is not yet an acked summary.
     */
    get referenceSequenceNumber() {
        var _a, _b;
        return (_b = (_a = this.latestSummary) === null || _a === void 0 ? void 0 : _a.referenceSequenceNumber) !== null && _b !== void 0 ? _b : 0;
    }
    startSummary(referenceSequenceNumber, summaryLogger) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.wipSummaryLogger === undefined, 0x19f /* "wipSummaryLogger should not be set yet in startSummary" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.wipReferenceSequenceNumber === undefined, 0x1a0 /* "Already tracking a summary" */);
        this.wipSummaryLogger = summaryLogger;
        for (const child of this.children.values()) {
            child.startSummary(referenceSequenceNumber, this.wipSummaryLogger);
        }
        this.wipReferenceSequenceNumber = referenceSequenceNumber;
    }
    async summarize(fullTree) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isTrackingInProgress(), 0x1a1 /* "summarize should not be called when not tracking the summary" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.wipSummaryLogger !== undefined, 0x1a2 /* "wipSummaryLogger should have been set in startSummary or ctor" */);
        // Try to reuse the tree if unchanged
        if (this.canReuseHandle && !fullTree && !this.hasChanged()) {
            const latestSummary = this.latestSummary;
            if (latestSummary !== undefined) {
                this.wipLocalPaths = {
                    localPath: latestSummary.localPath,
                    additionalPath: latestSummary.additionalPath,
                };
                this.wipSkipRecursion = true;
                const stats = (0,_summaryUtils__WEBPACK_IMPORTED_MODULE_1__.mergeStats)();
                stats.handleNodeCount++;
                return {
                    summary: {
                        type: 3 /* Handle */,
                        handle: latestSummary.fullPath.path,
                        handleType: 1 /* Tree */,
                    },
                    stats,
                };
            }
        }
        try {
            const result = await this.summarizeInternalFn(fullTree);
            this.wipLocalPaths = { localPath: _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.EscapedPath.create(result.id) };
            if (result.pathPartsForChildren !== undefined) {
                this.wipLocalPaths.additionalPath = _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.EscapedPath.createAndConcat(result.pathPartsForChildren);
            }
            return { summary: result.summary, stats: result.stats };
        }
        catch (error) {
            if (this.throwOnError || this.trackingSequenceNumber < this._changeSequenceNumber) {
                throw error;
            }
            const latestSummary = this.latestSummary;
            const initialSummary = this.initialSummary;
            let encodeParam;
            let localPath;
            if (latestSummary !== undefined) {
                // Create using handle of latest acked summary
                encodeParam = {
                    fromSummary: true,
                    summaryNode: latestSummary,
                };
                localPath = latestSummary.localPath;
            }
            else if ((initialSummary === null || initialSummary === void 0 ? void 0 : initialSummary.summary) !== undefined) {
                // Create using initial summary from attach op
                encodeParam = {
                    fromSummary: false,
                    initialSummary: initialSummary.summary,
                };
                localPath = _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.EscapedPath.create(initialSummary.id);
            }
            else {
                // No base summary to reference
                throw error;
            }
            this.wipSummaryLogger.sendErrorEvent({
                eventName: "SummarizingWithBasePlusOps",
            }, error);
            const summary = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.encodeSummary)(encodeParam, this.outstandingOps);
            this.wipLocalPaths = {
                localPath,
                additionalPath: summary.additionalPath,
            };
            this.wipSkipRecursion = true;
            return { summary: summary.summary, stats: summary.stats };
        }
    }
    /**
     * Complete the WIP summary for the given proposalHandle
     */
    completeSummary(proposalHandle) {
        this.completeSummaryCore(proposalHandle, undefined, false);
    }
    /**
     * Recursive implementation for completeSummary, with additional internal-only parameters
     */
    completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.wipSummaryLogger !== undefined, 0x1a3 /* "wipSummaryLogger should have been set in startSummary or ctor" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.wipReferenceSequenceNumber !== undefined, 0x1a4 /* "Not tracking a summary" */);
        let localPathsToUse = this.wipLocalPaths;
        if (parentSkipRecursion) {
            const latestSummary = this.latestSummary;
            if (latestSummary !== undefined) {
                // This case the parent node created a failure summary or was reused.
                // This node and all children should only try to reference their path
                // by its last known good state in the actual summary tree.
                // If parent fails or is reused, the child summarize is not called so
                // it did not get a chance to change its paths.
                // In this case, essentially only propagate the new summary ref seq num.
                localPathsToUse = {
                    localPath: latestSummary.localPath,
                    additionalPath: latestSummary.additionalPath,
                };
            }
            else {
                // This case the child is added after the latest non-failure summary.
                // This node and all children should consider themselves as still not
                // having a successful summary yet.
                // We cannot "reuse" this node if unchanged since that summary, because
                // handles will be unable to point to that node. It never made it to the
                // tree itself, and only exists as an attach op in the _outstandingOps.
                this.clearSummary();
                return;
            }
        }
        // This should come from wipLocalPaths in normal cases, or from the latestSummary
        // if parentIsFailure or parentIsReused is true.
        // If there is no latestSummary, clearSummary and return before reaching this code.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!localPathsToUse, 0x1a5 /* "Tracked summary local paths not set" */);
        const summary = new _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.SummaryNode(Object.assign(Object.assign({}, localPathsToUse), { referenceSequenceNumber: this.wipReferenceSequenceNumber, basePath: parentPath }));
        const fullPathForChildren = summary.fullPathForChildren;
        for (const child of this.children.values()) {
            child.completeSummaryCore(proposalHandle, fullPathForChildren, this.wipSkipRecursion || parentSkipRecursion);
        }
        // Note that this overwrites existing pending summary with
        // the same proposalHandle. If proposalHandle is something like
        // a hash or unique identifier, this should be fine. If storage
        // can return the same proposalHandle for a different summary,
        // this should still be okay, because we should be proposing the
        // newer one later which would have to overwrite the previous one.
        this.pendingSummaries.set(proposalHandle, summary);
        this.clearSummary();
    }
    clearSummary() {
        this.wipReferenceSequenceNumber = undefined;
        this.wipLocalPaths = undefined;
        this.wipSkipRecursion = false;
        this.wipSummaryLogger = undefined;
        for (const child of this.children.values()) {
            child.clearSummary();
        }
    }
    async refreshLatestSummary(proposalHandle, getSnapshot, readAndParseBlob, correlatedSummaryLogger) {
        if (proposalHandle !== undefined) {
            const maybeSummaryNode = this.pendingSummaries.get(proposalHandle);
            if (maybeSummaryNode !== undefined) {
                this.refreshLatestSummaryFromPending(proposalHandle, maybeSummaryNode.referenceSequenceNumber);
                return;
            }
        }
        const snapshotTree = await getSnapshot();
        const referenceSequenceNumber = await (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.seqFromTree)(snapshotTree, readAndParseBlob);
        await this.refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, undefined, _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.EscapedPath.create(""), correlatedSummaryLogger, readAndParseBlob);
    }
    refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber) {
        const summaryNode = this.pendingSummaries.get(proposalHandle);
        if (summaryNode === undefined) {
            // This should only happen if parent skipped recursion AND no prior summary existed.
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.latestSummary === undefined, 0x1a6 /* "Not found pending summary, but this node has previously completed a summary" */);
            return;
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(referenceSequenceNumber === summaryNode.referenceSequenceNumber, 
            // eslint-disable-next-line max-len
            0x1a7 /* `Pending summary reference sequence number should be consistent: ${summaryNode.referenceSequenceNumber} != ${referenceSequenceNumber}` */);
            // Clear earlier pending summaries
            this.pendingSummaries.delete(proposalHandle);
        }
        this.refreshLatestSummaryCore(referenceSequenceNumber);
        this.latestSummary = summaryNode;
        // Propagate update to all child nodes
        for (const child of this.children.values()) {
            child.refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber);
        }
    }
    async refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob) {
        // Possible re-entrancy. If we have already seen a summary later than this one, ignore it.
        if (this.referenceSequenceNumber >= referenceSequenceNumber) {
            return;
        }
        this.refreshLatestSummaryCore(referenceSequenceNumber);
        const { baseSummary, pathParts } = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.decodeSummary)(snapshotTree, correlatedSummaryLogger);
        this.latestSummary = new _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.SummaryNode({
            referenceSequenceNumber,
            basePath,
            localPath,
        });
        const { childrenTree, childrenPathPart } = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.parseSummaryForSubtrees)(baseSummary);
        if (childrenPathPart !== undefined) {
            pathParts.push(childrenPathPart);
        }
        if (pathParts.length > 0) {
            this.latestSummary.additionalPath = _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.EscapedPath.createAndConcat(pathParts);
        }
        // Propagate update to all child nodes
        const pathForChildren = this.latestSummary.fullPathForChildren;
        await Promise.all(Array.from(this.children)
            .filter(([id]) => {
            // Assuming subtrees missing from snapshot are newer than the snapshot,
            // but might be nice to assert this using earliest seq for node.
            return childrenTree.trees[id] !== undefined;
        }).map(async ([id, child]) => {
            return child.refreshLatestSummaryFromSnapshot(referenceSequenceNumber, childrenTree.trees[id], pathForChildren, _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.EscapedPath.create(id), correlatedSummaryLogger, readAndParseBlob);
        }));
    }
    refreshLatestSummaryCore(referenceSequenceNumber) {
        for (const [key, value] of this.pendingSummaries) {
            if (value.referenceSequenceNumber < referenceSequenceNumber) {
                this.pendingSummaries.delete(key);
            }
        }
        // Clear earlier outstanding ops
        while (this.outstandingOps.length > 0
            && this.outstandingOps[0].sequenceNumber <= referenceSequenceNumber) {
            this.outstandingOps.shift();
        }
    }
    loadBaseSummaryWithoutDifferential(snapshot) {
        // Check base summary to see if it has any additional path parts
        // separating child SummarizerNodes. Checks for .channels subtrees.
        const { childrenPathPart } = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.parseSummaryForSubtrees)(snapshot);
        if (childrenPathPart !== undefined && this.latestSummary !== undefined) {
            this.latestSummary.additionalPath = _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.EscapedPath.create(childrenPathPart);
        }
    }
    async loadBaseSummary(snapshot, readAndParseBlob) {
        const decodedSummary = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.decodeSummary)(snapshot, this.defaultLogger);
        const outstandingOps = await decodedSummary.getOutstandingOps(readAndParseBlob);
        const { childrenPathPart } = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.parseSummaryForSubtrees)(decodedSummary.baseSummary);
        if (childrenPathPart !== undefined) {
            decodedSummary.pathParts.push(childrenPathPart);
        }
        if (decodedSummary.pathParts.length > 0 && this.latestSummary !== undefined) {
            this.latestSummary.additionalPath = _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.EscapedPath.createAndConcat(decodedSummary.pathParts);
        }
        // Defensive assertion: tracking number should already exceed this number.
        // This is probably a little excessive; can remove when stable.
        if (outstandingOps.length > 0) {
            const newOpsLatestSeq = outstandingOps[outstandingOps.length - 1].sequenceNumber;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(newOpsLatestSeq <= this.trackingSequenceNumber, 0x1a9 /* "When loading base summary, expected outstanding ops <= tracking sequence number" */);
        }
        return {
            baseSummary: decodedSummary.baseSummary,
            outstandingOps,
        };
    }
    recordChange(op) {
        const lastOp = this.outstandingOps[this.outstandingOps.length - 1];
        if (lastOp !== undefined) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(lastOp.sequenceNumber < op.sequenceNumber, 0x1aa /* `Out of order change recorded: ${lastOp.sequenceNumber} > ${op.sequenceNumber}` */);
        }
        this.invalidate(op.sequenceNumber);
        this.trackingSequenceNumber = op.sequenceNumber;
        this.outstandingOps.push(op);
    }
    invalidate(sequenceNumber) {
        if (sequenceNumber > this._changeSequenceNumber) {
            this._changeSequenceNumber = sequenceNumber;
        }
    }
    /**
     * True if a change has been recorded with sequence number exceeding
     * the latest successfully acked summary reference sequence number.
     * False implies that the previous summary can be reused.
     */
    hasChanged() {
        return this._changeSequenceNumber > this.referenceSequenceNumber;
    }
    createChild(
    /** Summarize function */
    summarizeInternalFn, 
    /** Initial id or path part of this node */
    id, 
    /**
     * Information needed to create the node.
     * If it is from a base summary, it will assert that a summary has been seen.
     * Attach information if it is created from an attach op.
     */
    createParam, config = {}) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.children.has(id), 0x1ab /* "Create SummarizerNode child already exists" */);
        const createDetails = this.getCreateDetailsForChild(id, createParam);
        const child = new SummarizerNode(this.defaultLogger, summarizeInternalFn, config, createDetails.changeSequenceNumber, createDetails.latestSummary, createDetails.initialSummary, this.wipSummaryLogger);
        // There may be additional state that has to be updated in this child. For example, if a summary is being
        // tracked, the child's summary tracking state needs to be updated too.
        this.maybeUpdateChildState(child);
        this.children.set(id, child);
        return child;
    }
    getChild(id) {
        return this.children.get(id);
    }
    /**
     * Returns the details needed to create a child node.
     * @param id - Initial id or path part of the child node.
     * @param createParam - Information needed to create the node.
     * @returns the details needed to create the child node.
     */
    getCreateDetailsForChild(id, createParam) {
        var _a;
        let initialSummary;
        let latestSummary;
        let changeSequenceNumber;
        const parentLatestSummary = this.latestSummary;
        switch (createParam.type) {
            case _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.CreateSummarizerNodeSource.FromAttach: {
                if (parentLatestSummary !== undefined
                    && createParam.sequenceNumber <= parentLatestSummary.referenceSequenceNumber) {
                    // Prioritize latest summary if it was after this node was attached.
                    latestSummary = parentLatestSummary.createForChild(id);
                }
                else {
                    const summary = (0,_summaryUtils__WEBPACK_IMPORTED_MODULE_1__.convertToSummaryTree)(createParam.snapshot);
                    initialSummary = {
                        sequenceNumber: createParam.sequenceNumber,
                        id,
                        summary,
                    };
                }
                changeSequenceNumber = createParam.sequenceNumber;
                break;
            }
            case _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.CreateSummarizerNodeSource.FromSummary: {
                if (this.initialSummary === undefined) {
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!parentLatestSummary, 0x1ac /* "Cannot create child from summary if parent does not have latest summary" */);
                }
                // fallthrough to local
            }
            case _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.CreateSummarizerNodeSource.Local: {
                const parentInitialSummary = this.initialSummary;
                if (parentInitialSummary !== undefined) {
                    let childSummary;
                    if (parentInitialSummary.summary !== undefined) {
                        const { childrenTree } = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.parseSummaryTreeForSubtrees)(parentInitialSummary.summary.summary);
                        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(childrenTree.type === 1 /* Tree */, 0x1d6 /* "Parent summary object is not a tree" */);
                        childSummary = childrenTree.tree[id];
                    }
                    if (createParam.type === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.CreateSummarizerNodeSource.FromSummary) {
                        // Locally created would not have differential subtree.
                        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!childSummary, 0x1ad /* "Missing child summary tree" */);
                    }
                    let childSummaryWithStats;
                    if (childSummary !== undefined) {
                        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(childSummary.type === 1 /* Tree */, 0x1ae /* "Child summary object is not a tree" */);
                        childSummaryWithStats = {
                            summary: childSummary,
                            stats: (0,_summaryUtils__WEBPACK_IMPORTED_MODULE_1__.calculateStats)(childSummary),
                        };
                    }
                    initialSummary = {
                        sequenceNumber: parentInitialSummary.sequenceNumber,
                        id,
                        summary: childSummaryWithStats,
                    };
                }
                latestSummary = parentLatestSummary === null || parentLatestSummary === void 0 ? void 0 : parentLatestSummary.createForChild(id);
                changeSequenceNumber = (_a = parentLatestSummary === null || parentLatestSummary === void 0 ? void 0 : parentLatestSummary.referenceSequenceNumber) !== null && _a !== void 0 ? _a : -1;
                break;
            }
            default: {
                const type = createParam.type;
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.unreachableCase)(createParam, `Unexpected CreateSummarizerNodeSource: ${type}`);
            }
        }
        return {
            initialSummary,
            latestSummary,
            changeSequenceNumber,
        };
    }
    /**
     * Updates the state of the child if required. For example, if a summary is currently being  tracked, the child's
     * summary tracking state needs to be updated too.
     * @param child - The child node whose state is to be updated.
     */
    maybeUpdateChildState(child) {
        // If we are tracking a summary, this child was created after the tracking started. So, we need to update the
        // child's tracking state as well.
        if (this.isTrackingInProgress()) {
            child.wipReferenceSequenceNumber = this.wipReferenceSequenceNumber;
        }
    }
    /**
     * Tells whether summary tracking is in progress. True if "startSummary" API is called before summarize.
     */
    isTrackingInProgress() {
        return this.wipReferenceSequenceNumber !== undefined;
    }
}
/**
 * Creates a root summarizer node.
 * @param logger - Logger to use within SummarizerNode
 * @param summarizeInternalFn - Function to generate summary
 * @param changeSequenceNumber - Sequence number of latest change to new node/subtree
 * @param referenceSequenceNumber - Reference sequence number of last acked summary,
 * or undefined if not loaded from summary
 * @param config - Configure behavior of summarizer node
 */
const createRootSummarizerNode = (logger, summarizeInternalFn, changeSequenceNumber, referenceSequenceNumber, config = {}) => new SummarizerNode(logger, summarizeInternalFn, config, changeSequenceNumber, referenceSequenceNumber === undefined ? undefined : _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_2__.SummaryNode.createForRoot(referenceSequenceNumber));
//# sourceMappingURL=summarizerNode.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-utils/lib/summarizerNode/summarizerNodeUtils.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-utils/lib/summarizerNode/summarizerNodeUtils.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "seqFromTree": () => (/* binding */ seqFromTree),
/* harmony export */   "EscapedPath": () => (/* binding */ EscapedPath),
/* harmony export */   "SummaryNode": () => (/* binding */ SummaryNode),
/* harmony export */   "decodeSummary": () => (/* binding */ decodeSummary),
/* harmony export */   "encodeSummary": () => (/* binding */ encodeSummary),
/* harmony export */   "parseSummaryForSubtrees": () => (/* binding */ parseSummaryForSubtrees),
/* harmony export */   "parseSummaryTreeForSubtrees": () => (/* binding */ parseSummaryTreeForSubtrees)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/runtime-definitions */ "../../node_modules/@fluidframework/runtime-definitions/dist/index.js");
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _summaryUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../summaryUtils */ "../../node_modules/@fluidframework/runtime-utils/lib/summaryUtils.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */



const baseSummaryTreeKey = "_baseSummary";
const outstandingOpsBlobKey = "_outstandingOps";
const maxDecodeDepth = 100;
/**
 * Fetches the sequence number of the snapshot tree by examining the protocol.
 * @param tree - snapshot tree to examine
 * @param readAndParseBlob - function to read blob contents from storage
 * and parse the result from JSON.
 */
async function seqFromTree(tree, readAndParseBlob) {
    const attributesHash = tree.trees[".protocol"].blobs.attributes;
    const attrib = await readAndParseBlob(attributesHash);
    return attrib.sequenceNumber;
}
/** Path for nodes in a tree with escaped special characters */
class EscapedPath {
    constructor(path) {
        this.path = path;
    }
    static create(path) {
        return new EscapedPath(encodeURIComponent(path));
    }
    static createAndConcat(pathParts) {
        var _a;
        let ret = EscapedPath.create((_a = pathParts[0]) !== null && _a !== void 0 ? _a : "");
        for (let i = 1; i < pathParts.length; i++) {
            ret = ret.concat(EscapedPath.create(pathParts[i]));
        }
        return ret;
    }
    toString() {
        return this.path;
    }
    concat(path) {
        return new EscapedPath(`${this.path}/${path.path}`);
    }
}
/** Information about a summary relevant to a specific node in the tree */
class SummaryNode {
    constructor(summary) {
        this.summary = summary;
    }
    /** Creates an instance that is valid for the root with specific basePath and localPath */
    static createForRoot(referenceSequenceNumber) {
        return new SummaryNode({
            referenceSequenceNumber,
            basePath: undefined,
            localPath: EscapedPath.create(""),
        });
    }
    /** Summary reference sequence number, i.e. last sequence number seen when it was created */
    get referenceSequenceNumber() {
        return this.summary.referenceSequenceNumber;
    }
    /** Full path to parent node, or undefined if this is the root */
    get basePath() {
        return this.summary.basePath;
    }
    /** Relative path to this node from its parent node */
    get localPath() {
        return this.summary.localPath;
    }
    /** Relative path from this node to its node innermost base summary */
    get additionalPath() {
        return this.summary.additionalPath;
    }
    set additionalPath(additionalPath) {
        this.summary.additionalPath = additionalPath;
    }
    /** Gets the full path to this node, to be used when sending a handle */
    get fullPath() {
        var _a, _b;
        return (_b = (_a = this.basePath) === null || _a === void 0 ? void 0 : _a.concat(this.localPath)) !== null && _b !== void 0 ? _b : this.localPath;
    }
    /**
     * Gets the full path to this node's innermost base summary.
     * The children nodes can use this as their basePath to determine their path.
     */
    get fullPathForChildren() {
        return this.additionalPath !== undefined
            ? this.fullPath.concat(this.additionalPath)
            : this.fullPath;
    }
    /**
     * Creates a new node within the same summary for a child of this node.
     * @param id - id of the child node
     */
    createForChild(id) {
        return new SummaryNode({
            referenceSequenceNumber: this.referenceSequenceNumber,
            basePath: this.fullPathForChildren,
            localPath: EscapedPath.create(id),
        });
    }
}
/**
 * Checks if the snapshot is created by referencing a previous successful
 * summary plus outstanding ops. If so, it will recursively "decode" it until
 * it gets to the last successful summary (the base summary) and returns that
 * as well as a function for fetching the outstanding ops. Also returns the
 * full path to the previous base summary for child summarizer nodes to use as
 * their base path when necessary.
 * @param snapshot - snapshot tree to decode
 */
function decodeSummary(snapshot, logger) {
    let baseSummary = snapshot;
    const pathParts = [];
    const opsBlobs = [];
    for (let i = 0;; i++) {
        if (i > maxDecodeDepth) {
            logger.sendTelemetryEvent({
                eventName: "DecodeSummaryMaxDepth",
                maxDecodeDepth,
            });
        }
        const outstandingOpsBlob = baseSummary.blobs[outstandingOpsBlobKey];
        const newBaseSummary = baseSummary.trees[baseSummaryTreeKey];
        if (outstandingOpsBlob === undefined && newBaseSummary === undefined) {
            return {
                baseSummary,
                pathParts,
                async getOutstandingOps(readAndParseBlob) {
                    let outstandingOps = [];
                    for (const opsBlob of opsBlobs) {
                        const newOutstandingOps = await readAndParseBlob(opsBlob);
                        if (outstandingOps.length > 0 && newOutstandingOps.length > 0) {
                            const latestSeq = outstandingOps[outstandingOps.length - 1].sequenceNumber;
                            const newEarliestSeq = newOutstandingOps[0].sequenceNumber;
                            if (newEarliestSeq <= latestSeq) {
                                logger.sendTelemetryEvent({
                                    eventName: "DuplicateOutstandingOps",
                                    category: "generic",
                                    // eslint-disable-next-line max-len
                                    message: `newEarliestSeq <= latestSeq in decodeSummary: ${newEarliestSeq} <= ${latestSeq}`,
                                });
                                while (newOutstandingOps.length > 0
                                    && newOutstandingOps[0].sequenceNumber <= latestSeq) {
                                    newOutstandingOps.shift();
                                }
                            }
                        }
                        outstandingOps = outstandingOps.concat(newOutstandingOps);
                    }
                    return outstandingOps;
                },
            };
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!outstandingOpsBlob, 0x1af /* "Outstanding ops blob missing, but base summary tree exists" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(newBaseSummary !== undefined, 0x1b0 /* "Base summary tree missing, but outstanding ops blob exists" */);
        baseSummary = newBaseSummary;
        pathParts.push(baseSummaryTreeKey);
        opsBlobs.unshift(outstandingOpsBlob);
    }
}
/**
 * Creates a summary tree which is a handle of the previous successfully acked summary
 * and a blob of the outstanding ops since that summary. If there is no acked summary yet,
 * it will create with the tree found in the initial attach op and the blob of outstanding ops.
 * @param summaryParam - information about last acked summary and paths to encode if from summary,
 * otherwise the initial summary from the attach op.
 * @param outstandingOps - outstanding ops since last acked summary
 */
function encodeSummary(summaryParam, outstandingOps) {
    let additionalPath = EscapedPath.create(baseSummaryTreeKey);
    const builder = new _summaryUtils__WEBPACK_IMPORTED_MODULE_1__.SummaryTreeBuilder();
    builder.addBlob(outstandingOpsBlobKey, JSON.stringify(outstandingOps));
    if (summaryParam.fromSummary) {
        // Create using handle of latest acked summary
        const summaryNode = summaryParam.summaryNode;
        if (summaryNode.additionalPath !== undefined) {
            additionalPath = additionalPath.concat(summaryNode.additionalPath);
        }
        builder.addHandle(baseSummaryTreeKey, 1 /* Tree */, summaryNode.fullPath.path);
    }
    else {
        // Create using initial summary from attach op
        builder.addWithStats(baseSummaryTreeKey, summaryParam.initialSummary);
    }
    const summary = builder.getSummaryTree();
    return Object.assign(Object.assign({}, summary), { additionalPath });
}
/**
 * Checks if the summary contains .channels subtree where the children subtrees
 * would be located if exists.
 * @param baseSummary - summary to check
 */
function parseSummaryForSubtrees(baseSummary) {
    // New versions of snapshots have child nodes isolated in .channels subtree
    const channelsSubtree = baseSummary.trees[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_2__.channelsTreeName];
    if (channelsSubtree !== undefined) {
        return {
            childrenTree: channelsSubtree,
            childrenPathPart: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_2__.channelsTreeName,
        };
    }
    return {
        childrenTree: baseSummary,
        childrenPathPart: undefined,
    };
}
/**
 * Checks if the summary contains .channels subtree where the children subtrees
 * would be located if exists.
 * @param baseSummary - summary to check
 */
function parseSummaryTreeForSubtrees(summary) {
    // New versions of snapshots have child nodes isolated in .channels subtree
    const channelsSubtree = summary.tree[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_2__.channelsTreeName];
    if (channelsSubtree !== undefined) {
        return {
            childrenTree: channelsSubtree,
            childrenPathPart: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_2__.channelsTreeName,
        };
    }
    return {
        childrenTree: summary,
        childrenPathPart: undefined,
    };
}
//# sourceMappingURL=summarizerNodeUtils.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-utils/lib/summarizerNode/summarizerNodeWithGc.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-utils/lib/summarizerNode/summarizerNodeWithGc.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRootSummarizerNodeWithGC": () => (/* binding */ createRootSummarizerNodeWithGC)
/* harmony export */ });
/* unused harmony export SummarizerNodeWithGC */
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/promises.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/garbage-collector */ "../../node_modules/@fluidframework/garbage-collector/lib/utils.js");
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/runtime-definitions */ "../../node_modules/@fluidframework/runtime-definitions/dist/index.js");
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _summarizerNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./summarizerNode */ "../../node_modules/@fluidframework/runtime-utils/lib/summarizerNode/summarizerNode.js");
/* harmony import */ var _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./summarizerNodeUtils */ "../../node_modules/@fluidframework/runtime-utils/lib/summarizerNode/summarizerNodeUtils.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */





// Extend SummaryNode to add used routes tracking to it.
class SummaryNodeWithGC extends _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_0__.SummaryNode {
    constructor(serializedUsedRoutes, summary) {
        super(summary);
        this.serializedUsedRoutes = serializedUsedRoutes;
    }
}
/**
 * Extends the functionality of SummarizerNode to manage this node's garbage collection data:
 * - Adds a new API `getGCData` to return GC data of this node.
 * - Caches the result of `getGCData` to be used if nothing changes between summaries.
 * - Adds GC data to the result of summarize.
 * - Manages the used routes of this node. These are used to identify if this node is referenced in the document
 *   and to determine if the node's used state changed since last summary.
 * - Adds trackState param to summarize. If trackState is false, it bypasses the SummarizerNode and calls
 *   directly into summarizeInternal method.
 */
class SummarizerNodeWithGC extends _summarizerNode__WEBPACK_IMPORTED_MODULE_1__.SummarizerNode {
    /**
     * Do not call constructor directly.
     * Use createRootSummarizerNodeWithGC to create root node, or createChild to create child nodes.
     */
    constructor(logger, summarizeFn, config, changeSequenceNumber, 
    /** Undefined means created without summary */
    latestSummary, initialSummary, wipSummaryLogger, getGCDataFn, getInitialGCSummaryDetailsFn) {
        super(logger, async (fullTree) => this.summarizeInternal(fullTree, true /* trackState */), config, changeSequenceNumber, latestSummary, initialSummary, wipSummaryLogger);
        this.summarizeFn = summarizeFn;
        this.getGCDataFn = getGCDataFn;
        // Set used routes to have self route by default. This makes the node referenced by default. This is done to ensure
        // that this node is not marked as collected when running GC has been disabled. Once, the option to disable GC is
        // removed (from runGC flag in IContainerRuntimeOptions), this should be changed to be have no routes by default.
        this._usedRoutes = [""];
        this.gcDisabled = config.gcDisabled === true;
        this.gcDetailsInInitialSummaryP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.LazyPromise(async () => {
            // back-compat: 0.32. getInitialGCSummaryDetailsFn() returns undefined in 0.31. Remove undefined check
            // when N > 34.
            const gcSummaryDetails = await (getInitialGCSummaryDetailsFn === null || getInitialGCSummaryDetailsFn === void 0 ? void 0 : getInitialGCSummaryDetailsFn());
            return gcSummaryDetails !== null && gcSummaryDetails !== void 0 ? gcSummaryDetails : { usedRoutes: [] };
        });
    }
    get usedRoutes() {
        return this._usedRoutes;
    }
    /**
     * Loads state from this node's initial GC summary details. This contains the following data from the last summary
     * seen by the server for this client:
     * - usedRoutes: This is used to figure out if the used state of this node changed since last summary.
     * - gcData: The garbage collection data of this node that is required for running GC.
     */
    async loadInitialGCSummaryDetails() {
        // If referenceUsedRoutes is not undefined, don't do anything because we have already initialized.
        if (this.referenceUsedRoutes === undefined) {
            const gcDetailsInInitialSummary = await this.gcDetailsInInitialSummaryP;
            this.referenceUsedRoutes = gcDetailsInInitialSummary.usedRoutes;
            // If the GC details has GC data, initialize our GC data from it.
            if (gcDetailsInInitialSummary.gcData !== undefined) {
                this.gcData = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_3__.cloneGCData)(gcDetailsInInitialSummary.gcData);
            }
        }
    }
    async summarize(fullTree, trackState = true) {
        // Load GC details from the initial summary, if it's not already loaded. If this is the first time this node is
        // being summarized, the used routes in it are needed to find out if this node has changed since last summary.
        // If it hasn't changed, the GC data in it needs to be returned as part of the summary.
        await this.loadInitialGCSummaryDetails();
        // If GC is not disabled and we are tracking a summary, GC should have run and updated the used routes for this
        //  summary by calling updateUsedRoutes which sets wipSerializedUsedRoutes.
        if (!this.gcDisabled && this.isTrackingInProgress()) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(this.wipSerializedUsedRoutes !== undefined, 0x1b1 /* "wip used routes should be set if tracking a summary" */);
        }
        // If trackState is true, get summary from base summarizer node which tracks summary state.
        // If trackState is false, get summary from summarizeInternal.
        if (trackState) {
            const summarizeResult = await super.summarize(fullTree);
            // If there is no cached GC data, return empty data in summarize result. It is the caller's responsibility
            // to ensure that GC data is available by calling getGCData before calling summarize.
            const gcData = this.gcData !== undefined ? (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_3__.cloneGCData)(this.gcData) : { gcNodes: {} };
            return Object.assign(Object.assign({}, summarizeResult), { gcData });
        }
        else {
            return this.summarizeInternal(fullTree, trackState);
        }
    }
    async summarizeInternal(fullTree, trackState) {
        const summarizeResult = await this.summarizeFn(fullTree, trackState);
        this.gcData = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_3__.cloneGCData)(summarizeResult.gcData);
        return summarizeResult;
    }
    /**
     * Returns the GC data of this node. If nothing has changed since last summary, it tries to reuse the data from
     * the previous summary. Else, it gets new GC data from the underlying Fluid object.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(!this.gcDisabled, 0x1b2 /* "Getting GC data should not be called when GC is disabled!" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(this.getGCDataFn !== undefined, 0x1b3 /* "GC data cannot be retrieved without getGCDataFn" */);
        // Load GC details from the initial summary, if not already loaded. If this is the first time this function is
        // called and the node's data has not changed since last summary, the GC data in initial details is returned.
        await this.loadInitialGCSummaryDetails();
        // If there is no new data since last summary and we have GC data from the previous run, return it. We may not
        // have data from previous GC run for clients with older summary format before GC was added. They won't have
        // GC details in their initial summary.
        if (!fullGC && !this.hasDataChanged() && this.gcData !== undefined) {
            return (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_3__.cloneGCData)(this.gcData);
        }
        const gcData = await this.getGCDataFn(fullGC);
        this.gcData = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_3__.cloneGCData)(gcData);
        return gcData;
    }
    /**
     * Called during the start of a summary. Updates the work-in-progress used routes.
     */
    startSummary(referenceSequenceNumber, summaryLogger) {
        // If GC is disabled, skip setting wip used routes since we should not track GC state.
        if (!this.gcDisabled) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(this.wipSerializedUsedRoutes === undefined, 0x1b4 /* "We should not already be tracking used routes when to track a new summary" */);
            // back-compat: 0.33 - This will be done in `updateUsedRoutes`. Older clients do not have that method, so
            // keeping this one for now.
            this.wipSerializedUsedRoutes = JSON.stringify(this.usedRoutes);
        }
        super.startSummary(referenceSequenceNumber, summaryLogger);
    }
    /**
     * Called after summary has been uploaded to the server. Add the work-in-progress state to the pending
     * summary queue. We track this until we get an ack from the server for this summary.
     */
    completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion) {
        let wipSerializedUsedRoutes;
        // If GC is disabled, don't set wip used routes.
        if (!this.gcDisabled) {
            wipSerializedUsedRoutes = this.wipSerializedUsedRoutes;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(wipSerializedUsedRoutes !== undefined, 0x1b5 /* "We should have been tracking used routes" */);
        }
        super.completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion);
        // If GC is disabled, skip setting pending summary with GC state.
        if (!this.gcDisabled) {
            const summaryNode = this.pendingSummaries.get(proposalHandle);
            if (summaryNode !== undefined) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const summaryNodeWithGC = new SummaryNodeWithGC(wipSerializedUsedRoutes, summaryNode);
                this.pendingSummaries.set(proposalHandle, summaryNodeWithGC);
            }
        }
    }
    /**
     * Clears the work-in-progress state.
     */
    clearSummary() {
        this.wipSerializedUsedRoutes = undefined;
        super.clearSummary();
    }
    /**
     * Called when we get an ack from the server for a summary we sent. Update the reference state of this node
     * from the state in the pending summary queue.
     */
    refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber) {
        // If GC is disabled, skip setting referenced used routes since we are not tracking GC state.
        if (!this.gcDisabled) {
            const summaryNode = this.pendingSummaries.get(proposalHandle);
            if (summaryNode !== undefined) {
                this.referenceUsedRoutes = JSON.parse(summaryNode.serializedUsedRoutes);
            }
        }
        return super.refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber);
    }
    /**
     * Called when we need to upload the reference state from the given summary. Read the GC blob and get the state
     * to upload from it.
     */
    async refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob) {
        // If GC is disabled, skip setting referenced used routes since we are not tracking GC state.
        if (!this.gcDisabled) {
            const gcDetailsBlob = snapshotTree.blobs[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__.gcBlobKey];
            if (gcDetailsBlob !== undefined) {
                const gcDetails = await readAndParseBlob(gcDetailsBlob);
                // Possible re-entrancy. If we have already seen a summary later than this one, ignore it.
                if (this.referenceSequenceNumber >= referenceSequenceNumber) {
                    return;
                }
                this.referenceUsedRoutes = gcDetails.usedRoutes;
            }
        }
        return super.refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob);
    }
    /**
     * Override the createChild method to return an instance of SummarizerNodeWithGC.
     */
    createChild(
    /** Summarize function */
    summarizeInternalFn, 
    /** Initial id or path part of this node */
    id, 
    /**
     * Information needed to create the node.
     * If it is from a base summary, it will assert that a summary has been seen.
     * Attach information if it is created from an attach op.
     */
    createParam, config = {}, getGCDataFn, getInitialGCSummaryDetailsFn) {
        var _a;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(!this.children.has(id), 0x1b6 /* "Create SummarizerNode child already exists" */);
        const createDetails = this.getCreateDetailsForChild(id, createParam);
        const child = new SummarizerNodeWithGC(this.defaultLogger, summarizeInternalFn, Object.assign(Object.assign({}, config), { 
            // Propagate our gcDisabled state to the child if its not explicity specified in child's config.
            gcDisabled: (_a = config.gcDisabled) !== null && _a !== void 0 ? _a : this.gcDisabled }), createDetails.changeSequenceNumber, createDetails.latestSummary, createDetails.initialSummary, this.wipSummaryLogger, getGCDataFn, getInitialGCSummaryDetailsFn);
        // back-compat: 0.33 - If a child is created during summarize, its wip used routes will updated in
        // `updateUsedRoutes` method. For older clients, do it here since that method does not exist.
        // There may be additional state that has to be updated in this child. For example, if a summary is being
        // tracked, the child's summary tracking state needs to be updated too.
        this.maybeUpdateChildState(child);
        this.children.set(id, child);
        return child;
    }
    /**
     * Override the getChild method to return an instance of SummarizerNodeWithGC.
     */
    getChild(id) {
        return this.children.get(id);
    }
    isReferenced() {
        return this.usedRoutes.includes("") || this.usedRoutes.includes("/");
    }
    updateUsedRoutes(usedRoutes) {
        // Sort the given routes before updating. This will ensure that the routes compared in hasUsedStateChanged()
        // are in the same order.
        this._usedRoutes = usedRoutes.sort();
        // If GC is not disabled and we are tracking a summary, update the work-in-progress used routes so that it can
        // be tracked for this summary.
        if (!this.gcDisabled && this.isTrackingInProgress()) {
            this.wipSerializedUsedRoutes = JSON.stringify(this.usedRoutes);
        }
    }
    /**
     * Override the hasChanged method. If this node data or its used state changed, the node is considered changed.
     */
    hasChanged() {
        return this.hasDataChanged() || this.hasUsedStateChanged();
    }
    /**
     * This tells whether the data in this node has changed or not.
     */
    hasDataChanged() {
        return super.hasChanged();
    }
    /**
     * This tells whether the used state of this node has changed since last successful summary. If the used routes
     * of this node changed, its used state is considered changed. Basically, if this node or any of its child nodes
     * was previously used and became unused (or vice versa), its used state has changed.
     */
    hasUsedStateChanged() {
        // If GC is disabled, we are not tracking used state, return false.
        if (this.gcDisabled) {
            return false;
        }
        return this.referenceUsedRoutes === undefined ||
            JSON.stringify(this.usedRoutes) !== JSON.stringify(this.referenceUsedRoutes);
    }
    /**
     * Updates the work-in-progress state of the child if summary is in progress.
     * @param child - The child node to be updated.
     */
    maybeUpdateChildState(child) {
        if (this.isTrackingInProgress()) {
            // Update the child's work-in-progress used routes.
            child.updateUsedRoutes(child.usedRoutes);
        }
        super.maybeUpdateChildState(child);
    }
}
/**
 * Creates a root summarizer node with GC functionality built-in.
 * @param logger - Logger to use within SummarizerNode
 * @param summarizeInternalFn - Function to generate summary
 * @param changeSequenceNumber - Sequence number of latest change to new node/subtree
 * @param referenceSequenceNumber - Reference sequence number of last acked summary,
 * or undefined if not loaded from summary
 * @param config - Configure behavior of summarizer node
 * @param getGCDataFn - Function to get the GC data of this node
 * @param gcDetailsInInitialSummaryP - Function to get the initial GC details of this node
 */
const createRootSummarizerNodeWithGC = (logger, summarizeInternalFn, changeSequenceNumber, referenceSequenceNumber, config = {}, getGCDataFn, getInitialGCSummaryDetailsFn) => new SummarizerNodeWithGC(logger, summarizeInternalFn, config, changeSequenceNumber, referenceSequenceNumber === undefined ? undefined : _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_0__.SummaryNode.createForRoot(referenceSequenceNumber), undefined /* initialSummary */, undefined /* wipSummaryLogger */, getGCDataFn, getInitialGCSummaryDetailsFn);
//# sourceMappingURL=summarizerNodeWithGc.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-utils/lib/summaryUtils.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-utils/lib/summaryUtils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mergeStats": () => (/* binding */ mergeStats),
/* harmony export */   "calculateStats": () => (/* binding */ calculateStats),
/* harmony export */   "addBlobToSummary": () => (/* binding */ addBlobToSummary),
/* harmony export */   "addTreeToSummary": () => (/* binding */ addTreeToSummary),
/* harmony export */   "SummaryTreeBuilder": () => (/* binding */ SummaryTreeBuilder),
/* harmony export */   "convertToSummaryTreeWithStats": () => (/* binding */ convertToSummaryTreeWithStats),
/* harmony export */   "convertToSummaryTree": () => (/* binding */ convertToSummaryTree),
/* harmony export */   "convertSnapshotTreeToSummaryTree": () => (/* binding */ convertSnapshotTreeToSummaryTree),
/* harmony export */   "convertSummaryTreeToITree": () => (/* binding */ convertSummaryTreeToITree)
/* harmony export */ });
/* unused harmony exports getBlobSize, convertContainerToDriverSerializedFormat */
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/bufferBrowser.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/base64Encoding.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/unreachable.js");
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/protocol-base */ "../../node_modules/@fluidframework/protocol-base/lib/blobs.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/storage.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * Combines summary stats by adding their totals together.
 * Returns empty stats if called without args.
 * @param stats - stats to merge
 */
function mergeStats(...stats) {
    const results = {
        treeNodeCount: 0,
        blobNodeCount: 0,
        handleNodeCount: 0,
        totalBlobSize: 0,
    };
    for (const stat of stats) {
        results.treeNodeCount += stat.treeNodeCount;
        results.blobNodeCount += stat.blobNodeCount;
        results.handleNodeCount += stat.handleNodeCount;
        results.totalBlobSize += stat.totalBlobSize;
    }
    return results;
}
function getBlobSize(content) {
    if (typeof content === "string") {
        return (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.stringToBuffer)(content, "utf8").byteLength;
    }
    else {
        return content.byteLength;
    }
}
function calculateStatsCore(summaryObject, stats) {
    switch (summaryObject.type) {
        case 1 /* Tree */: {
            stats.treeNodeCount++;
            for (const value of Object.values(summaryObject.tree)) {
                calculateStatsCore(value, stats);
            }
            return;
        }
        case 3 /* Handle */: {
            stats.handleNodeCount++;
            return;
        }
        case 2 /* Blob */: {
            stats.blobNodeCount++;
            stats.totalBlobSize += getBlobSize(summaryObject.content);
            return;
        }
        default: return;
    }
}
function calculateStats(summary) {
    const stats = mergeStats();
    calculateStatsCore(summary, stats);
    return stats;
}
function addBlobToSummary(summary, key, content) {
    const blob = {
        type: 2 /* Blob */,
        content,
    };
    summary.summary.tree[key] = blob;
    summary.stats.blobNodeCount++;
    summary.stats.totalBlobSize += getBlobSize(content);
}
function addTreeToSummary(summary, key, summarizeResult) {
    summary.summary.tree[key] = summarizeResult.summary;
    summary.stats = mergeStats(summary.stats, summarizeResult.stats);
}
class SummaryTreeBuilder {
    constructor() {
        this.attachmentCounter = 0;
        this.summaryTree = {};
        this.summaryStats = mergeStats();
        this.summaryStats.treeNodeCount++;
    }
    get summary() {
        return {
            type: 1 /* Tree */,
            tree: Object.assign({}, this.summaryTree),
        };
    }
    get stats() {
        return Object.assign({}, this.summaryStats);
    }
    addBlob(key, content) {
        // Prevent cloning by directly referencing underlying private properties
        addBlobToSummary({
            summary: {
                type: 1 /* Tree */,
                tree: this.summaryTree,
            },
            stats: this.summaryStats,
        }, key, content);
    }
    addHandle(key, handleType, handle) {
        this.summaryTree[key] = {
            type: 3 /* Handle */,
            handleType,
            handle,
        };
        this.summaryStats.handleNodeCount++;
    }
    addWithStats(key, summarizeResult) {
        this.summaryTree[key] = summarizeResult.summary;
        this.summaryStats = mergeStats(this.summaryStats, summarizeResult.stats);
    }
    addAttachment(id) {
        this.summaryTree[this.attachmentCounter++] = { id, type: 4 /* Attachment */ };
    }
    getSummaryTree() {
        return { summary: this.summary, stats: this.stats };
    }
}
/**
 * Converts snapshot ITree to ISummaryTree format and tracks stats.
 * @param snapshot - snapshot in ITree format
 * @param fullTree - true to never use handles, even if id is specified
 */
function convertToSummaryTreeWithStats(snapshot, fullTree = false) {
    const builder = new SummaryTreeBuilder();
    for (const entry of snapshot.entries) {
        switch (entry.type) {
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Blob: {
                const blob = entry.value;
                let content;
                if (blob.encoding === "base64") {
                    content = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(blob.contents, "base64");
                }
                else {
                    content = blob.contents;
                }
                builder.addBlob(entry.path, content);
                break;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Tree: {
                const subtree = convertToSummaryTree(entry.value, fullTree);
                builder.addWithStats(entry.path, subtree);
                break;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Attachment: {
                const id = entry.value.id;
                builder.addAttachment(id);
                break;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Commit:
                throw new Error("Should not have Commit TreeEntry in summary");
            default:
                throw new Error("Unexpected TreeEntry type");
        }
    }
    return builder.getSummaryTree();
}
/**
 * Converts snapshot ITree to ISummaryTree format and tracks stats.
 * @param snapshot - snapshot in ITree format
 * @param fullTree - true to never use handles, even if id is specified
 */
function convertToSummaryTree(snapshot, fullTree = false) {
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    if (snapshot.id && !fullTree) {
        const stats = mergeStats();
        stats.handleNodeCount++;
        return {
            summary: {
                handle: snapshot.id,
                handleType: 1 /* Tree */,
                type: 3 /* Handle */,
            },
            stats,
        };
    }
    else {
        return convertToSummaryTreeWithStats(snapshot, fullTree);
    }
}
/**
 * Converts ISnapshotTree to ISummaryTree format and tracks stats. This snapshot tree was
 * was taken by serialize api in detached container.
 * @param snapshot - snapshot in ISnapshotTree format
 */
function convertSnapshotTreeToSummaryTree(snapshot) {
    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(Object.keys(snapshot.commits).length === 0, 0x19e /* "There should not be commit tree entries in snapshot" */);
    const builder = new SummaryTreeBuilder();
    for (const [key, value] of Object.entries(snapshot.blobs)) {
        // The entries in blobs are supposed to be blobPath -> blobId and blobId -> blobValue
        // and we want to push blobPath to blobValue in tree entries.
        if (snapshot.blobs[value] !== undefined) {
            const decoded = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.fromBase64ToUtf8)(snapshot.blobs[value]);
            builder.addBlob(key, decoded);
        }
    }
    for (const [key, tree] of Object.entries(snapshot.trees)) {
        const subtree = convertSnapshotTreeToSummaryTree(tree);
        builder.addWithStats(key, subtree);
    }
    return builder.getSummaryTree();
}
/**
 * Utility to convert serialized snapshot taken in detached container to format where we can use it to
 * attach the container.
 * @param serializedSnapshotTree - serialized snapshot tree to be converted to summary tree for attach.
 */
function convertContainerToDriverSerializedFormat(serializedSnapshotTree) {
    const snapshotTree = JSON.parse(serializedSnapshotTree);
    const summaryTree = convertSnapshotTreeToSummaryTree(snapshotTree).summary;
    const appSummaryTree = {
        type: 1 /* Tree */,
        tree: {},
    };
    const entries = Object.entries(summaryTree.tree);
    for (const [key, subTree] of entries) {
        if (key !== ".protocol") {
            appSummaryTree.tree[key] = subTree;
            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete summaryTree.tree[key];
        }
    }
    summaryTree.tree[".app"] = appSummaryTree;
    return summaryTree;
}
/**
 * Converts ISummaryTree to ITree format. This is needed for back-compat while we get rid of snapshot.
 * @param summaryTree - summary tree in ISummaryTree format
 */
function convertSummaryTreeToITree(summaryTree) {
    const entries = [];
    for (const [key, value] of Object.entries(summaryTree.tree)) {
        switch (value.type) {
            case 2 /* Blob */: {
                let parsedContent;
                let encoding = "utf-8";
                if (typeof value.content === "string") {
                    parsedContent = value.content;
                }
                else {
                    parsedContent = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Uint8ArrayToString)(value.content, "base64");
                    encoding = "base64";
                }
                entries.push(new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__.BlobTreeEntry(key, parsedContent, encoding));
                break;
            }
            case 1 /* Tree */: {
                entries.push(new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__.TreeTreeEntry(key, convertSummaryTreeToITree(value)));
                break;
            }
            case 4 /* Attachment */: {
                entries.push(new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__.AttachmentTreeEntry(key, value.id));
                break;
            }
            case 3 /* Handle */: {
                throw new Error("Should not have Handle type in summary tree");
            }
            default:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.unreachableCase)(value, "Unexpected summary tree type");
        }
    }
    return {
        entries,
    };
}
//# sourceMappingURL=summaryUtils.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/runtime-utils/lib/utils.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@fluidframework/runtime-utils/lib/utils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isSerializedHandle": () => (/* binding */ isSerializedHandle)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const isSerializedHandle = (value) => (value === null || value === void 0 ? void 0 : value.type) === "__fluid_handle__";
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/sequence/lib/debug.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@fluidframework/sequence/lib/debug.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debug": () => (/* binding */ debug)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "../../node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packageVersion */ "../../node_modules/@fluidframework/sequence/lib/packageVersion.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


const debug = debug__WEBPACK_IMPORTED_MODULE_0___default()("fluid:sequence");
debug(`Package: ${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgName} - Version: ${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgVersion}`);
//# sourceMappingURL=debug.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/sequence/lib/intervalCollection.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@fluidframework/sequence/lib/intervalCollection.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SequenceIntervalCollectionValueType": () => (/* binding */ SequenceIntervalCollectionValueType)
/* harmony export */ });
/* unused harmony exports Interval, SequenceInterval, defaultIntervalConflictResolver, createIntervalIndex, LocalIntervalCollection, IntervalCollectionValueType, IntervalCollectionView, IntervalCollection */
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/properties.js");
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/mergeTree.js");
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/localReference.js");
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/ops.js");
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/collections.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/* eslint-disable no-bitwise */


class Interval {
    constructor(start, end, props) {
        this.start = start;
        this.end = end;
        if (props) {
            this.addProperties(props);
        }
    }
    getAdditionalPropertySets() {
        return this.auxProps;
    }
    addPropertySet(props) {
        if (this.auxProps === undefined) {
            this.auxProps = [];
        }
        this.auxProps.push(props);
    }
    serialize(client) {
        let seq = 0;
        if (client) {
            seq = client.getCurrentSeq();
        }
        const serializedInterval = {
            end: this.end,
            intervalType: 0,
            sequenceNumber: seq,
            start: this.start,
        };
        if (this.properties) {
            serializedInterval.properties = this.properties;
        }
        return serializedInterval;
    }
    clone() {
        return new Interval(this.start, this.end, this.properties);
    }
    compare(b) {
        const startResult = this.start - b.start;
        if (startResult === 0) {
            return (this.end - b.end);
        }
        else {
            return startResult;
        }
    }
    overlaps(b) {
        const result = (this.start < b.end) &&
            (this.end >= b.start);
        return result;
    }
    union(b) {
        return new Interval(Math.min(this.start, b.start), Math.max(this.end, b.end), this.properties);
    }
    getProperties() {
        return this.properties;
    }
    addProperties(newProps, op) {
        this.properties = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.addProperties(this.properties, newProps, op);
    }
}
class SequenceInterval {
    constructor(start, end, intervalType, props) {
        this.start = start;
        this.end = end;
        this.intervalType = intervalType;
        if (props) {
            this.addProperties(props);
        }
    }
    serialize(client) {
        const startPosition = this.start.toPosition();
        const endPosition = this.end.toPosition();
        const serializedInterval = {
            end: endPosition,
            intervalType: this.intervalType,
            sequenceNumber: client.getCurrentSeq(),
            start: startPosition,
        };
        if (this.properties) {
            serializedInterval.properties = this.properties;
        }
        return serializedInterval;
    }
    clone() {
        return new SequenceInterval(this.start, this.end, this.intervalType);
    }
    compare(b) {
        const startResult = this.start.compare(b.start);
        if (startResult === 0) {
            return (this.end.compare(b.end));
        }
        else {
            return startResult;
        }
    }
    overlaps(b) {
        const result = (this.start.compare(b.end) < 0) &&
            (this.end.compare(b.start) >= 0);
        if (this.checkMergeTree) {
            this.checkOverlaps(b, result);
        }
        return result;
    }
    union(b) {
        return new SequenceInterval(this.start.min(b.start), this.end.max(b.end), this.intervalType);
    }
    addProperties(newProps, op) {
        this.properties = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.addProperties(this.properties, newProps, op);
    }
    overlapsPos(bstart, bend) {
        const startPos = this.start.toPosition();
        const endPos = this.start.toPosition();
        return (endPos > bstart) && (startPos < bend);
    }
    checkOverlaps(b, result) {
        const astart = this.start.toPosition();
        const bstart = b.start.toPosition();
        const aend = this.end.toPosition();
        const bend = b.end.toPosition();
        const checkResult = ((astart < bend) && (bstart < aend));
        if (checkResult !== result) {
            // eslint-disable-next-line max-len
            console.log(`check mismatch: res ${result} ${this.start.segment === b.end.segment} ${b.start.segment === this.end.segment}`);
            console.log(`as ${astart} ae ${aend} bs ${bstart} be ${bend}`);
            console.log(`as ${_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.ordinalToArray(this.start.segment.ordinal)}@${this.start.offset}`);
            console.log(`ae ${_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.ordinalToArray(this.end.segment.ordinal)}@${this.end.offset}`);
            console.log(`bs ${_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.ordinalToArray(b.start.segment.ordinal)}@${b.start.offset}`);
            console.log(`be ${_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.ordinalToArray(b.end.segment.ordinal)}@${b.end.offset}`);
            console.log(this.checkMergeTree.nodeToString(b.start.segment.parent, ""));
        }
    }
}
function createPositionReference(client, pos, refType) {
    const segoff = client.getContainingSegment(pos);
    if (segoff && segoff.segment) {
        const lref = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.LocalReference(client, segoff.segment, segoff.offset, refType);
        if (refType !== _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.Transient) {
            client.addLocalReference(lref);
        }
        return lref;
    }
    return new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.LocalReference(client, undefined);
}
function createSequenceInterval(label, start, end, client, intervalType) {
    let beginRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.RangeBegin;
    let endRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.RangeEnd;
    if (intervalType === _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.IntervalType.Nest) {
        beginRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestBegin;
        endRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestEnd;
    }
    else if (intervalType === _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.IntervalType.Transient) {
        beginRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.Transient;
        endRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.Transient;
    }
    // TODO: Should SlideOnRemove be the default behavior?
    if (intervalType & _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.IntervalType.SlideOnRemove) {
        beginRefType |= _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.SlideOnRemove;
        endRefType |= _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.SlideOnRemove;
    }
    const startLref = createPositionReference(client, start, beginRefType);
    const endLref = createPositionReference(client, end, endRefType);
    if (startLref && endLref) {
        startLref.pairedRef = endLref;
        endLref.pairedRef = startLref;
        const rangeProp = {
            [_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.reservedRangeLabelsKey]: [label],
        };
        startLref.addProperties(rangeProp);
        endLref.addProperties(rangeProp);
        const ival = new SequenceInterval(startLref, endLref, intervalType, rangeProp);
        return ival;
    }
}
function defaultIntervalConflictResolver(a, b) {
    a.addPropertySet(b.properties);
    return a;
}
function createIntervalIndex(conflict) {
    const helpers = {
        compareEnds: compareIntervalEnds,
        create: createInterval,
    };
    const lc = new LocalIntervalCollection(undefined, "", helpers);
    if (conflict) {
        lc.addConflictResolver(conflict);
    }
    else {
        lc.addConflictResolver(defaultIntervalConflictResolver);
    }
    return lc;
}
class LocalIntervalCollection {
    constructor(client, label, helpers) {
        this.client = client;
        this.label = label;
        this.helpers = helpers;
        this.intervalTree = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_5__.IntervalTree();
        this.endIntervalTree =
            // eslint-disable-next-line @typescript-eslint/unbound-method
            new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_5__.RedBlackTree(helpers.compareEnds);
    }
    addConflictResolver(conflictResolver) {
        this.conflictResolver = conflictResolver;
        this.endConflictResolver =
            (key, currentKey) => {
                const ival = this.conflictResolver(key, currentKey);
                return {
                    data: ival,
                    key: ival,
                };
            };
    }
    map(fn) {
        this.intervalTree.map(fn);
    }
    findOverlappingIntervals(startPosition, endPosition) {
        if (!this.intervalTree.intervals.isEmpty()) {
            const transientInterval = this.helpers.create("transient", startPosition, endPosition, this.client, _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.IntervalType.Transient);
            const overlappingIntervalNodes = this.intervalTree.match(transientInterval);
            return overlappingIntervalNodes.map((node) => node.key);
        }
        else {
            return [];
        }
    }
    previousInterval(pos) {
        const transientInterval = this.helpers.create("transient", pos, pos, this.client, _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.IntervalType.Transient);
        const rbNode = this.endIntervalTree.floor(transientInterval);
        if (rbNode) {
            return rbNode.data;
        }
    }
    nextInterval(pos) {
        const transientInterval = this.helpers.create("transient", pos, pos, this.client, _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.IntervalType.Transient);
        const rbNode = this.endIntervalTree.ceil(transientInterval);
        if (rbNode) {
            return rbNode.data;
        }
    }
    removeInterval(startPosition, endPosition) {
        const transientInterval = this.helpers.create("transient", startPosition, endPosition, this.client, _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.IntervalType.Transient);
        this.intervalTree.remove(transientInterval);
        this.endIntervalTree.remove(transientInterval);
        return transientInterval;
    }
    createInterval(start, end, intervalType) {
        return this.helpers.create(this.label, start, end, this.client, intervalType);
    }
    // TODO: remove interval, handle duplicate intervals
    addInterval(start, end, intervalType, props) {
        const interval = this.createInterval(start, end, intervalType);
        if (interval) {
            interval.addProperties(props);
            if (this.label && (this.label.length > 0)) {
                interval.properties[_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.reservedRangeLabelsKey] = [this.label];
            }
            this.intervalTree.put(interval, this.conflictResolver);
            this.endIntervalTree.put(interval, interval, this.endConflictResolver);
        }
        return interval;
    }
    serialize() {
        const client = this.client;
        const intervals = this.intervalTree.intervals.keys();
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return intervals.map((interval) => interval.serialize(client));
    }
}
const compareSequenceIntervalEnds = (a, b) => a.end.compare(b.end);
class SequenceIntervalCollectionFactory {
    load(emitter, raw = []) {
        const helpers = {
            compareEnds: compareSequenceIntervalEnds,
            create: createSequenceInterval,
        };
        return new IntervalCollection(helpers, true, emitter, raw);
    }
    store(value) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return value.serializeInternal();
    }
}
class SequenceIntervalCollectionValueType {
    get name() {
        return SequenceIntervalCollectionValueType.Name;
    }
    get factory() {
        return SequenceIntervalCollectionValueType._factory;
    }
    get ops() {
        return SequenceIntervalCollectionValueType._ops;
    }
}
SequenceIntervalCollectionValueType.Name = "sharedStringIntervalCollection";
SequenceIntervalCollectionValueType._factory = new SequenceIntervalCollectionFactory();
SequenceIntervalCollectionValueType._ops = new Map([[
        "add",
        {
            process: (value, params, local, op) => {
                // Local ops were applied when the message was created
                if (local) {
                    return;
                }
                value.addInternal(params, local, op);
            },
        },
    ],
    [
        "delete",
        {
            process: (value, params, local, op) => {
                if (local) {
                    return;
                }
                value.deleteInterval(params, local, op);
            },
        },
    ]]);
const compareIntervalEnds = (a, b) => a.end - b.end;
function createInterval(label, start, end, client) {
    let rangeProp;
    if (label && (label.length > 0)) {
        rangeProp = {
            [_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.reservedRangeLabelsKey]: [label],
        };
    }
    return new Interval(start, end, rangeProp);
}
class IntervalCollectionFactory {
    load(emitter, raw = []) {
        const helpers = {
            compareEnds: compareIntervalEnds,
            create: createInterval,
        };
        const collection = new IntervalCollection(helpers, false, emitter, raw);
        collection.attachGraph(undefined, "");
        return collection;
    }
    store(value) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return value.serializeInternal();
    }
}
class IntervalCollectionValueType {
    get name() {
        return IntervalCollectionValueType.Name;
    }
    get factory() {
        return IntervalCollectionValueType._factory;
    }
    get ops() {
        return IntervalCollectionValueType._ops;
    }
}
IntervalCollectionValueType.Name = "sharedIntervalCollection";
IntervalCollectionValueType._factory = new IntervalCollectionFactory();
IntervalCollectionValueType._ops = new Map([[
        "add",
        {
            process: (value, params, local, op) => {
                // Local ops were applied when the message was created
                if (local) {
                    return;
                }
                value.addInternal(params, local, op);
            },
        },
    ],
    [
        "delete",
        {
            process: (value, params, local, op) => {
                if (local) {
                    return;
                }
                value.deleteInterval(params, local, op);
            },
        },
    ]]);
class IntervalCollectionView extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor(client, savedSerializedIntervals, label, helpers, emitter) {
        super();
        this.client = client;
        this.emitter = emitter;
        // Instantiate the local interval collection based on the saved intervals
        this.localCollection = new LocalIntervalCollection(client, label, helpers);
        if (savedSerializedIntervals) {
            for (const serializedInterval of savedSerializedIntervals) {
                this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties);
            }
        }
    }
    attachDeserializer(onDeserialize) {
        this.attachDeserializerCore(onDeserialize);
    }
    addConflictResolver(conflictResolver) {
        this.localCollection.addConflictResolver(conflictResolver);
    }
    findOverlappingIntervals(startPosition, endPosition) {
        return this.localCollection.findOverlappingIntervals(startPosition, endPosition);
    }
    map(fn) {
        this.localCollection.map(fn);
    }
    previousInterval(pos) {
        return this.localCollection.previousInterval(pos);
    }
    nextInterval(pos) {
        return this.localCollection.nextInterval(pos);
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    add(start, end, intervalType, props) {
        let seq = 0;
        if (this.client) {
            seq = this.client.getCurrentSeq();
        }
        const serializedInterval = {
            end,
            intervalType,
            properties: props,
            sequenceNumber: seq,
            start,
        };
        this.addInternal(serializedInterval, true, undefined);
    }
    delete(start, end) {
        let sequenceNumber = 0;
        if (this.client) {
            sequenceNumber = this.client.getCurrentSeq();
        }
        const serializedInterval = {
            start,
            end,
            sequenceNumber,
            intervalType: _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.IntervalType.Transient,
        };
        this.deleteInterval(serializedInterval, true, undefined);
    }
    // TODO: error cases
    addInternal(serializedInterval, local, op) {
        const interval = this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties);
        if (interval) {
            // Local ops get submitted to the server. Remote ops have the deserializer run.
            if (local) {
                this.emitter.emit("add", undefined, serializedInterval);
            }
            else {
                if (this.onDeserialize) {
                    this.onDeserialize(interval);
                }
            }
        }
        this.emit("addInterval", interval, local, op);
        return this;
    }
    deleteInterval(serializedInterval, local, op) {
        const interval = this.localCollection.removeInterval(serializedInterval.start, serializedInterval.end);
        if (interval) {
            // Local ops get submitted to the server. Remote ops have the deserializer run.
            if (local) {
                this.emitter.emit("delete", undefined, serializedInterval);
            }
            else {
                if (this.onDeserialize) {
                    this.onDeserialize(interval);
                }
            }
        }
        this.emit("deleteInterval", interval, local, op);
        return this;
    }
    serializeInternal() {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this.localCollection.serialize();
    }
    attachDeserializerCore(onDeserialize) {
        // If no deserializer is specified can skip all processing work
        if (!onDeserialize) {
            return;
        }
        // Start by storing the callbacks so that any subsequent modifications make use of them
        this.onDeserialize = onDeserialize;
        // Trigger the async prepare work across all values in the collection
        this.localCollection.map((interval) => {
            this.onDeserialize(interval);
        });
    }
}
class IntervalCollection {
    constructor(helpers, requiresClient, emitter, serializedIntervals) {
        this.helpers = helpers;
        this.requiresClient = requiresClient;
        this.emitter = emitter;
        this.savedSerializedIntervals = serializedIntervals;
    }
    get attached() {
        return !!this.view;
    }
    attachGraph(client, label) {
        if (this.view) {
            throw new Error("Only supports one Sequence attach");
        }
        if ((client === undefined) && (this.requiresClient)) {
            throw new Error("Client required for this collection");
        }
        this.view = new IntervalCollectionView(client, this.savedSerializedIntervals, label, this.helpers, this.emitter);
        this.savedSerializedIntervals = undefined;
    }
    add(startPosition, endPosition, intervalType, props) {
        if (!this.view) {
            throw new Error("attach must be called prior to adding intervals");
        }
        this.view.add(startPosition, endPosition, intervalType, props);
    }
    delete(startPosition, endPosition) {
        if (!this.view) {
            throw new Error("attach must be called prior to deleting intervals");
        }
        this.view.delete(startPosition, endPosition);
    }
    addConflictResolver(conflictResolver) {
        this.view.addConflictResolver(conflictResolver);
    }
    async getView(onDeserialize) {
        if (!this.view) {
            return Promise.reject(new Error("attachSequence must be called prior to retrieving the view"));
        }
        // Attach custom deserializers if specified
        if (onDeserialize) {
            this.view.attachDeserializer(onDeserialize);
        }
        return this.view;
    }
    addInternal(serializedInterval, local, op) {
        if (!this.view) {
            throw new Error("attachSequence must be called");
        }
        return this.view.addInternal(serializedInterval, local, op);
    }
    deleteInterval(serializedInterval, local, op) {
        if (!this.view) {
            throw new Error("attach must be called prior to deleting intervals");
        }
        this.view.deleteInterval(serializedInterval, local, op);
    }
    serializeInternal() {
        if (!this.view) {
            throw new Error("attachSequence must be called");
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this.view.serializeInternal();
    }
}
//# sourceMappingURL=intervalCollection.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/sequence/lib/packageVersion.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@fluidframework/sequence/lib/packageVersion.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pkgName": () => (/* binding */ pkgName),
/* harmony export */   "pkgVersion": () => (/* binding */ pkgVersion)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
const pkgName = "@fluidframework/sequence";
const pkgVersion = "0.37.4";
//# sourceMappingURL=packageVersion.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/sequence/lib/sequence.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@fluidframework/sequence/lib/sequence.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SharedSegmentSequence": () => (/* binding */ SharedSegmentSequence)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/promises.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/bufferBrowser.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/map */ "../../node_modules/@fluidframework/map/lib/mapKernel.js");
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/client.js");
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/properties.js");
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/opBuilder.js");
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/localReference.js");
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/ops.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/storage.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/protocol.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/objectstoragepartition.js");
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/shared-object-base */ "../../node_modules/@fluidframework/shared-object-base/lib/sharedObject.js");
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @fluidframework/shared-object-base */ "../../node_modules/@fluidframework/shared-object-base/lib/utils.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./debug */ "../../node_modules/@fluidframework/sequence/lib/debug.js");
/* harmony import */ var _intervalCollection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./intervalCollection */ "../../node_modules/@fluidframework/sequence/lib/intervalCollection.js");
/* harmony import */ var _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sequenceDeltaEvent */ "../../node_modules/@fluidframework/sequence/lib/sequenceDeltaEvent.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */










const snapshotFileName = "header";
const contentPath = "content";
class SharedSegmentSequence extends _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.SharedObject {
    constructor(dataStoreRuntime, id, attributes, segmentFromSpec) {
        super(id, dataStoreRuntime, attributes);
        this.dataStoreRuntime = dataStoreRuntime;
        this.id = id;
        this.segmentFromSpec = segmentFromSpec;
        // Deferred that triggers once the object is loaded
        this.loadedDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Deferred();
        // cache out going ops created when parital loading
        this.loadedDeferredOutgoingOps = [];
        // cache incoming ops that arrive when partial loading
        this.deferIncomingOps = true;
        this.loadedDeferredIncomingOps = [];
        this.messagesSinceMSNChange = [];
        this.loadedDeferred.promise.catch((error) => {
            this.logger.sendErrorEvent({ eventName: "SequenceLoadFailed" }, error);
        });
        this.client = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.Client(segmentFromSpec, _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.ChildLogger.create(this.logger, "SharedSegmentSequence.MergeTreeClient"), dataStoreRuntime.options);
        super.on("newListener", (event) => {
            switch (event) {
                case "sequenceDelta":
                    if (!this.client.mergeTreeDeltaCallback) {
                        this.client.mergeTreeDeltaCallback = (opArgs, deltaArgs) => {
                            this.emit("sequenceDelta", new _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__.SequenceDeltaEvent(opArgs, deltaArgs, this.client), this);
                        };
                    }
                    break;
                case "maintenance":
                    if (!this.client.mergeTreeMaintenanceCallback) {
                        this.client.mergeTreeMaintenanceCallback = (args, opArgs) => {
                            this.emit("maintenance", new _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__.SequenceMaintenanceEvent(opArgs, args, this.client), this);
                        };
                    }
                    break;
                default:
            }
        });
        super.on("removeListener", (event) => {
            switch (event) {
                case "sequenceDelta":
                    if (super.listenerCount(event) === 0) {
                        this.client.mergeTreeDeltaCallback = undefined;
                    }
                    break;
                case "maintenance":
                    if (super.listenerCount(event) === 0) {
                        this.client.mergeTreeMaintenanceCallback = undefined;
                    }
                    break;
                default:
                    break;
            }
        });
        this.intervalMapKernel = new _fluidframework_map__WEBPACK_IMPORTED_MODULE_5__.MapKernel(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), () => this.isAttached(), [new _intervalCollection__WEBPACK_IMPORTED_MODULE_6__.SequenceIntervalCollectionValueType()]);
    }
    get loaded() {
        return this.loadedDeferred.promise;
    }
    static createOpsFromDelta(event) {
        const ops = [];
        for (const r of event.ranges) {
            switch (event.deltaOperation) {
                case 2 /* ANNOTATE */: {
                    const lastAnnotate = ops[ops.length - 1];
                    const props = {};
                    for (const key of Object.keys(r.propertyDeltas)) {
                        props[key] =
                            // eslint-disable-next-line no-null/no-null
                            r.segment.properties[key] === undefined ? null : r.segment.properties[key];
                    }
                    if (lastAnnotate && lastAnnotate.pos2 === r.position &&
                        _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__.matchProperties(lastAnnotate.props, props)) {
                        lastAnnotate.pos2 += r.segment.cachedLength;
                    }
                    else {
                        ops.push(_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_8__.createAnnotateRangeOp(r.position, r.position + r.segment.cachedLength, props, undefined));
                    }
                    break;
                }
                case 0 /* INSERT */:
                    ops.push(_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_8__.createInsertOp(r.position, r.segment.clone().toJSONObject()));
                    break;
                case 1 /* REMOVE */: {
                    const lastRem = ops[ops.length - 1];
                    if ((lastRem === null || lastRem === void 0 ? void 0 : lastRem.pos1) === r.position) {
                        lastRem.pos2 += r.segment.cachedLength;
                    }
                    else {
                        ops.push(_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_8__.createRemoveRangeOp(r.position, r.position + r.segment.cachedLength));
                    }
                    break;
                }
                default:
            }
        }
        return ops;
    }
    /**
     * @param start - The inclusive start of the range to remove
     * @param end - The exclusive end of the range to remove
     */
    removeRange(start, end) {
        const removeOp = this.client.removeRangeLocal(start, end);
        if (removeOp) {
            this.submitSequenceMessage(removeOp);
        }
        return removeOp;
    }
    /**
     * Removes the range and puts the content of the removed range in a register
     *
     * @param start - The inclusive start of the range to remove
     * @param end - The exclusive end of the range to remove
     * @param register - The name of the register to store the removed range in
     */
    cut(start, end, register) {
        const removeOp = this.client.removeRangeLocal(start, end, register);
        if (removeOp) {
            this.submitSequenceMessage(removeOp);
        }
    }
    /**
     * Inserts the content of the register.
     *
     * @param pos - The postition to insert the content at.
     * @param register - The name of the register to get the content from
     */
    paste(pos, register) {
        const insertOp = this.client.pasteLocal(pos, register);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
        return pos;
    }
    /**
     * Puts the content of the range in a register
     *
     * @param start - The inclusive start of the range
     * @param end - The exclusive end of the range
     * @param register - The name of the register to store the range in
     */
    copy(start, end, register) {
        const insertOp = this.client.copyLocal(start, end, register);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    groupOperation(groupOp) {
        this.client.localTransaction(groupOp);
        this.submitSequenceMessage(groupOp);
    }
    getContainingSegment(pos) {
        return this.client.getContainingSegment(pos);
    }
    /**
     * Returns the length of the current sequence for the client
     */
    getLength() {
        return this.client.getLength();
    }
    /**
     * Returns the current position of a segment, and -1 if the segment
     * does not exist in this sequence
     * @param segment - The segment to get the position of
     */
    getPosition(segment) {
        return this.client.getPosition(segment);
    }
    /**
     * Annotates the range with the provided properties
     *
     * @param start - The inclusive start postition of the range to annotate
     * @param end - The exclusive end position of the range to annotate
     * @param props - The properties to annotate the range with
     * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
     *
     */
    annotateRange(start, end, props, combiningOp) {
        const annotateOp = this.client.annotateRangeLocal(start, end, props, combiningOp);
        if (annotateOp) {
            this.submitSequenceMessage(annotateOp);
        }
    }
    getPropertiesAtPosition(pos) {
        return this.client.getPropertiesAtPosition(pos);
    }
    getRangeExtentsOfPosition(pos) {
        return this.client.getRangeExtentsOfPosition(pos);
    }
    createPositionReference(segment, offset, refType) {
        const lref = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_9__.LocalReference(this.client, segment, offset, refType);
        if (refType !== _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_10__.ReferenceType.Transient) {
            this.addLocalReference(lref);
        }
        return lref;
    }
    localRefToPos(localRef) {
        if (localRef.segment) {
            return localRef.offset + this.getPosition(localRef.segment);
        }
        else {
            return -1;
        }
    }
    /**
     * Resolves a remote client's position against the local sequence
     * and returns the remote client's position relative to the local
     * sequence
     * @param remoteClientPosition - The remote client's position to resolve
     * @param remoteClientRefSeq - The reference sequence number of the remote client
     * @param remoteClientId - The client id of the remote client
     */
    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {
        return this.client.resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId);
    }
    submitSequenceMessage(message) {
        if (!this.isAttached()) {
            return;
        }
        const translated = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_11__.makeHandlesSerializable)(message, this.serializer, this.handle);
        const metadata = this.client.peekPendingSegmentGroups(message.type === 3 /* GROUP */ ? message.ops.length : 1);
        // if loading isn't complete, we need to cache
        // local ops until loading is complete, and then
        // they will be resent
        if (!this.loadedDeferred.isCompleted) {
            this.loadedDeferredOutgoingOps.push([translated, metadata]);
        }
        else {
            this.submitLocalMessage(translated, metadata);
        }
    }
    addLocalReference(lref) {
        return this.client.addLocalReference(lref);
    }
    removeLocalReference(lref) {
        return this.client.removeLocalReference(lref);
    }
    /**
     * Given a position specified relative to a marker id, lookup the marker
     * and convert the position to a character position.
     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.
     */
    posFromRelativePos(relativePos) {
        return this.client.posFromRelativePos(relativePos);
    }
    /**
     * Walk the underlying segments of the sequence.
     * The walked segments may extend beyond the range
     * if the segments cross the ranges start or end boundaries.
     * Set split range to true to ensure only segments within the
     * range are walked.
     *
     * @param handler - The function to handle each segment
     * @param start - Optional. The start of range walk.
     * @param end - Optional. The end of range walk
     * @param accum - Optional. An object that will be passed to the handler for accumulation
     * @param splitRange - Optional. Splits boundary segments on the range boundaries
     */
    walkSegments(handler, start, end, accum, splitRange = false) {
        return this.client.walkSegments(handler, start, end, accum, splitRange);
    }
    getStackContext(startPos, rangeLabels) {
        return this.client.getStackContext(startPos, rangeLabels);
    }
    getCurrentSeq() {
        return this.client.getCurrentSeq();
    }
    insertAtReferencePosition(pos, segment) {
        const insertOp = this.client.insertAtReferencePositionLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    async waitIntervalCollection(label) {
        return this.intervalMapKernel.wait(this.getIntervalCollectionPath(label));
    }
    // TODO: fix race condition on creation by putting type on every operation
    getIntervalCollection(label) {
        const labelPath = this.getIntervalCollectionPath(label);
        if (!this.intervalMapKernel.has(labelPath)) {
            this.intervalMapKernel.createValueType(labelPath, _intervalCollection__WEBPACK_IMPORTED_MODULE_6__.SequenceIntervalCollectionValueType.Name, undefined);
        }
        const sharedCollection = this.intervalMapKernel.get(labelPath);
        return sharedCollection;
    }
    snapshotCore(serializer) {
        const entries = [];
        // conditionally write the interval collection blob
        // only if it has entries
        if (this.intervalMapKernel.size > 0) {
            entries.push({
                mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__.FileMode.File,
                path: snapshotFileName,
                type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__.TreeEntry.Blob,
                value: {
                    contents: this.intervalMapKernel.serialize(serializer),
                    encoding: "utf-8",
                },
            });
        }
        entries.push({
            mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__.FileMode.Directory,
            path: contentPath,
            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__.TreeEntry.Tree,
            value: this.snapshotMergeTree(serializer),
        });
        const tree = {
            entries,
        };
        return tree;
    }
    /**
     * Replace the range specified from start to end with the provided segment
     * This is done by inserting the segment at the end of the range, followed
     * by removing the contents of the range
     * For a zero or reverse range (start \>= end), insert at end do not remove anything
     * @param start - The start of the range to replace
     * @param end - The end of the range to replace
     * @param segment - The segment that will replace the range
     */
    replaceRange(start, end, segment) {
        // Insert at the max end of the range when start > end, but still remove the range later
        const insertIndex = Math.max(start, end);
        // Insert first, so local references can slide to the inserted seg if any
        const insert = this.client.insertSegmentLocal(insertIndex, segment);
        if (insert) {
            if (start < end) {
                const remove = this.client.removeRangeLocal(start, end);
                this.submitSequenceMessage(_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_8__.createGroupOp(insert, remove));
            }
            else {
                this.submitSequenceMessage(insert);
            }
        }
    }
    onConnect() {
        // Update merge tree collaboration information with new client ID and then resend pending ops
        this.client.startOrUpdateCollaboration(this.runtime.clientId);
    }
    onDisconnect() {
        (0,_debug__WEBPACK_IMPORTED_MODULE_13__.debug)(`${this.id} is now disconnected`);
    }
    reSubmitCore(content, localOpMetadata) {
        if (!this.intervalMapKernel.trySubmitMessage(content, localOpMetadata)) {
            this.submitSequenceMessage(this.client.regeneratePendingOp(content, localOpMetadata));
        }
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}
     */
    async loadCore(storage) {
        var _a;
        if (await storage.contains(snapshotFileName)) {
            const blob = await storage.readBlob(snapshotFileName);
            const header = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_14__.bufferToString)(blob, "utf8");
            this.intervalMapKernel.populate(header);
        }
        try {
            // this will load the header, and return a promise
            // that will resolve when the body is loaded
            // and the catchup ops are available.
            const { catchupOpsP } = await this.client.load(this.runtime, new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_15__.ObjectStoragePartition(storage, contentPath), this.serializer);
            // setup a promise to process the
            // catch up ops, and finishing the loading process
            const loadCatchUpOps = catchupOpsP
                .then((msgs) => {
                msgs.forEach((m) => {
                    const collabWindow = this.client.getCollabWindow();
                    if (m.minimumSequenceNumber < collabWindow.minSeq
                        || m.referenceSequenceNumber < collabWindow.minSeq
                        || m.sequenceNumber <= collabWindow.minSeq
                        || m.sequenceNumber <= collabWindow.currentSeq) {
                        throw new Error(`Invalid catchup operations in snapshot: ${JSON.stringify({
                            op: {
                                seq: m.sequenceNumber,
                                minSeq: m.minimumSequenceNumber,
                                refSeq: m.referenceSequenceNumber,
                            },
                            collabWindow: {
                                seq: collabWindow.currentSeq,
                                minSeq: collabWindow.minSeq,
                            },
                        })}`);
                    }
                    this.processMergeTreeMsg(m);
                });
                this.loadFinished();
            })
                .catch((error) => {
                this.loadFinished(error);
            });
            if (((_a = this.dataStoreRuntime.options) === null || _a === void 0 ? void 0 : _a.sequenceInitializeFromHeaderOnly) !== true) {
                // if we not doing parital load, await the catch up ops,
                // and the finalization of the load
                await loadCatchUpOps;
            }
        }
        catch (error) {
            this.loadFinished(error);
        }
    }
    processCore(message, local, localOpMetadata) {
        // if loading isn't complete, we need to cache all
        // incoming ops to be applied after loading is complete
        if (this.deferIncomingOps) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_16__.assert)(!local, 0x072 /* "Unexpected local op when loading not finished" */);
            this.loadedDeferredIncomingOps.push(message);
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_16__.assert)(message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_17__.MessageType.Operation, 0x073 /* "Sequence message not operation" */);
            const handled = this.intervalMapKernel.tryProcessMessage(message.contents, local, message, localOpMetadata);
            if (!handled) {
                this.processMergeTreeMsg(message);
            }
        }
    }
    registerCore() {
        for (const value of this.intervalMapKernel.values()) {
            if (_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.SharedObject.is(value)) {
                value.bindToContext();
            }
        }
        this.client.startOrUpdateCollaboration(this.runtime.clientId);
    }
    didAttach() {
        var _a;
        // If we are not local, and we've attached we need to start generating and sending ops
        // so start collaboration and provide a default client id incase we are not connected
        if (this.isAttached()) {
            this.client.startOrUpdateCollaboration((_a = this.runtime.clientId) !== null && _a !== void 0 ? _a : "attached");
        }
    }
    initializeLocalCore() {
        super.initializeLocalCore();
        this.loadFinished();
    }
    snapshotMergeTree(serializer) {
        // Are we fully loaded? If not, things will go south
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_16__.assert)(this.loadedDeferred.isCompleted, 0x074 /* "Snapshot called when not fully loaded" */);
        const minSeq = this.runtime.deltaManager.minimumSequenceNumber;
        this.processMinSequenceNumberChanged(minSeq);
        this.messagesSinceMSNChange.forEach((m) => m.minimumSequenceNumber = minSeq);
        return this.client.snapshot(this.runtime, this.handle, serializer, this.messagesSinceMSNChange);
    }
    processMergeTreeMsg(rawMessage) {
        var _a, _b;
        const message = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_11__.parseHandles)(rawMessage, this.serializer);
        const ops = [];
        function transfromOps(event) {
            ops.push(...SharedSegmentSequence.createOpsFromDelta(event));
        }
        const needsTransformation = message.referenceSequenceNumber !== message.sequenceNumber - 1;
        let stashMessage = message;
        if (((_a = this.runtime.options) === null || _a === void 0 ? void 0 : _a.newMergeTreeSnapshotFormat) !== true) {
            if (needsTransformation) {
                this.on("sequenceDelta", transfromOps);
            }
        }
        this.client.applyMsg(message);
        if (((_b = this.runtime.options) === null || _b === void 0 ? void 0 : _b.newMergeTreeSnapshotFormat) !== true) {
            if (needsTransformation) {
                this.removeListener("sequenceDelta", transfromOps);
                // shallow clone the message as we only overwrite top level properties,
                // like referenceSequenceNumber and content only
                stashMessage = Object.assign(Object.assign({}, message), { referenceSequenceNumber: stashMessage.sequenceNumber - 1, contents: ops.length !== 1 ? _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_8__.createGroupOp(...ops) : ops[0] });
            }
            this.messagesSinceMSNChange.push(stashMessage);
            // Do GC every once in a while...
            if (this.messagesSinceMSNChange.length > 20
                && this.messagesSinceMSNChange[20].sequenceNumber < message.minimumSequenceNumber) {
                this.processMinSequenceNumberChanged(message.minimumSequenceNumber);
            }
        }
    }
    getIntervalCollectionPath(label) {
        return `intervalCollections/${label}`;
    }
    processMinSequenceNumberChanged(minSeq) {
        let index = 0;
        for (; index < this.messagesSinceMSNChange.length; index++) {
            if (this.messagesSinceMSNChange[index].sequenceNumber > minSeq) {
                break;
            }
        }
        if (index !== 0) {
            this.messagesSinceMSNChange = this.messagesSinceMSNChange.slice(index);
        }
    }
    loadFinished(error) {
        if (!this.loadedDeferred.isCompleted) {
            // Initialize the interval collections
            this.initializeIntervalCollections();
            if (error) {
                this.loadedDeferred.reject(error);
                throw error;
            }
            else {
                // it is important this series remains synchronous
                // first we stop defering incoming ops, and apply then all
                this.deferIncomingOps = false;
                while (this.loadedDeferredIncomingOps.length > 0) {
                    this.processCore(this.loadedDeferredIncomingOps.shift(), false, undefined);
                }
                // then resolve the loaded promise
                // and resubmit all the outstanding ops, as the snapshot
                // is fully loaded, and all outstanding ops are applied
                this.loadedDeferred.resolve();
                while (this.loadedDeferredOutgoingOps.length > 0) {
                    const opData = this.loadedDeferredOutgoingOps.shift();
                    this.reSubmitCore(opData[0], opData[1]);
                }
            }
        }
    }
    initializeIntervalCollections() {
        // Listen and initialize new SharedIntervalCollections
        this.intervalMapKernel.eventEmitter.on("valueChanged", (ev) => {
            const intervalCollection = this.intervalMapKernel.get(ev.key);
            if (!intervalCollection.attached) {
                intervalCollection.attachGraph(this.client, ev.key);
            }
        });
        // Initialize existing SharedIntervalCollections
        for (const key of this.intervalMapKernel.keys()) {
            const intervalCollection = this.intervalMapKernel.get(key);
            intervalCollection.attachGraph(this.client, key);
        }
    }
    applyStashedOp() {
        throw new Error("not implemented");
    }
}
//# sourceMappingURL=sequence.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/sequence/lib/sequenceDeltaEvent.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@fluidframework/sequence/lib/sequenceDeltaEvent.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SequenceDeltaEvent": () => (/* binding */ SequenceDeltaEvent),
/* harmony export */   "SequenceMaintenanceEvent": () => (/* binding */ SequenceMaintenanceEvent)
/* harmony export */ });
/* unused harmony export SequenceEvent */
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/sortedSegmentSet.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Base class for SequenceDeltaEvent and SequenceMaintenanceEvent.
 *
 * The properties of this object and its sub-objects represent a point in time state
 * at the time the operation was applied. They will not take into any future modifications
 * performed to the underlying sequence and merge tree.
 */
class SequenceEvent {
    constructor(deltaArgs, mergeTreeClient) {
        this.deltaArgs = deltaArgs;
        this.mergeTreeClient = mergeTreeClient;
        this.isEmpty = deltaArgs.deltaSegments.length === 0;
        this.deltaOperation = deltaArgs.operation;
        this.sortedRanges = new Lazy(() => {
            const set = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.SortedSegmentSet();
            this.deltaArgs.deltaSegments.forEach((delta) => {
                const newRange = {
                    operation: this.deltaArgs.operation,
                    position: this.mergeTreeClient.getPosition(delta.segment),
                    propertyDeltas: delta.propertyDeltas,
                    segment: delta.segment,
                };
                set.addOrUpdate(newRange);
            });
            return set;
        });
        this.pFirst = new Lazy(() => {
            if (this.isEmpty) {
                return undefined;
            }
            return this.sortedRanges.value.items[0];
        });
        this.pLast = new Lazy(() => {
            if (this.isEmpty) {
                return undefined;
            }
            return this.sortedRanges.value.items[this.sortedRanges.value.size - 1];
        });
    }
    /**
     * The in-order ranges affected by this delta.
     * These may not be continous.
     */
    get ranges() {
        return this.sortedRanges.value.items;
    }
    /**
     * The client id of the client that made the change which caused the delta event
     */
    get clientId() {
        return this.mergeTreeClient.longClientId;
    }
    get first() {
        return this.pFirst.value;
    }
    get last() {
        return this.pLast.value;
    }
}
/**
 * The event object returned on sequenceDelta events.
 *
 * The properties of this object and its sub-objects represent a point in time state
 * at the time the operation was applied. They will not take into any future modifications
 * performed to the underlying sequence and merge tree.
 *
 * For group ops, each op will get it's own event, and the group op property will be set on the op args.
 *
 * Ops may get multiple events. For instance, an insert-replace will get a remove then an insert event.
 */
class SequenceDeltaEvent extends SequenceEvent {
    constructor(opArgs, deltaArgs, mergeTreeClient) {
        super(deltaArgs, mergeTreeClient);
        this.opArgs = opArgs;
        this.isLocal = opArgs.sequencedMessage === undefined;
    }
}
/**
 * The event object returned on maintenance events.
 *
 * The properties of this object and its sub-objects represent a point in time state
 * at the time the operation was applied. They will not take into any future modifications
 * performed to the underlying sequence and merge tree.
 */
class SequenceMaintenanceEvent extends SequenceEvent {
    constructor(opArgs, deltaArgs, mergeTreeClient) {
        super(deltaArgs, mergeTreeClient);
        this.opArgs = opArgs;
    }
}
class Lazy {
    constructor(valueGenerator) {
        this.valueGenerator = valueGenerator;
        this.pEvaluated = false;
    }
    get evaluated() {
        return this.pEvaluated;
    }
    get value() {
        if (!this.pEvaluated) {
            this.pEvaluated = true;
            this.pValue = this.valueGenerator();
        }
        return this.pValue;
    }
}
//# sourceMappingURL=sequenceDeltaEvent.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/sequence/lib/sequenceFactory.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@fluidframework/sequence/lib/sequenceFactory.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SharedStringFactory": () => (/* binding */ SharedStringFactory),
/* harmony export */   "SharedObjectSequenceFactory": () => (/* binding */ SharedObjectSequenceFactory),
/* harmony export */   "SharedNumberSequenceFactory": () => (/* binding */ SharedNumberSequenceFactory)
/* harmony export */ });
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/textSegment.js");
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/mergeTree.js");
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./packageVersion */ "../../node_modules/@fluidframework/sequence/lib/packageVersion.js");
/* harmony import */ var _sharedNumberSequence__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sharedNumberSequence */ "../../node_modules/@fluidframework/sequence/lib/sharedNumberSequence.js");
/* harmony import */ var _sharedObjectSequence__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sharedObjectSequence */ "../../node_modules/@fluidframework/sequence/lib/sharedObjectSequence.js");
/* harmony import */ var _sharedSequence__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sharedSequence */ "../../node_modules/@fluidframework/sequence/lib/sharedSequence.js");
/* harmony import */ var _sharedString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sharedString */ "../../node_modules/@fluidframework/sequence/lib/sharedString.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */






class SharedStringFactory {
    static segmentFromSpec(spec) {
        const maybeText = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.TextSegment.fromJSONObject(spec);
        if (maybeText) {
            return maybeText;
        }
        const maybeMarker = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.Marker.fromJSONObject(spec);
        if (maybeMarker) {
            return maybeMarker;
        }
    }
    get type() {
        return SharedStringFactory.Type;
    }
    get attributes() {
        return SharedStringFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     */
    async load(runtime, id, services, attributes) {
        const sharedString = new _sharedString__WEBPACK_IMPORTED_MODULE_2__.SharedString(runtime, id, attributes);
        await sharedString.load(services);
        return sharedString;
    }
    create(document, id) {
        const sharedString = new _sharedString__WEBPACK_IMPORTED_MODULE_2__.SharedString(document, id, this.attributes);
        sharedString.initializeLocal();
        return sharedString;
    }
}
// TODO rename back to https://graph.microsoft.com/types/mergeTree/string once paparazzi is able to dynamically
// load code
SharedStringFactory.Type = "https://graph.microsoft.com/types/mergeTree";
SharedStringFactory.Attributes = {
    type: SharedStringFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_3__.pkgVersion,
};
class SharedObjectSequenceFactory {
    static segmentFromSpec(segSpec) {
        // eslint-disable-next-line @typescript-eslint/ban-types
        const runSegment = segSpec;
        if (runSegment.items) {
            // eslint-disable-next-line @typescript-eslint/ban-types
            const seg = new _sharedSequence__WEBPACK_IMPORTED_MODULE_4__.SubSequence(runSegment.items);
            if (runSegment.props) {
                seg.addProperties(runSegment.props);
            }
            return seg;
        }
    }
    get type() {
        return SharedObjectSequenceFactory.Type;
    }
    get attributes() {
        return SharedObjectSequenceFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     */
    async load(runtime, id, services, attributes) {
        // eslint-disable-next-line @typescript-eslint/ban-types
        const sharedSeq = new _sharedObjectSequence__WEBPACK_IMPORTED_MODULE_5__.SharedObjectSequence(runtime, id, attributes);
        await sharedSeq.load(services);
        return sharedSeq;
    }
    create(document, id) {
        const sharedString = new _sharedObjectSequence__WEBPACK_IMPORTED_MODULE_5__.SharedObjectSequence(document, id, this.attributes);
        sharedString.initializeLocal();
        return sharedString;
    }
}
SharedObjectSequenceFactory.Type = "https://graph.microsoft.com/types/mergeTree/object-sequence";
SharedObjectSequenceFactory.Attributes = {
    type: SharedObjectSequenceFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_3__.pkgVersion,
};
class SharedNumberSequenceFactory {
    static segmentFromSpec(segSpec) {
        const runSegment = segSpec;
        if (runSegment.items) {
            const seg = new _sharedSequence__WEBPACK_IMPORTED_MODULE_4__.SubSequence(runSegment.items);
            if (runSegment.props) {
                seg.addProperties(runSegment.props);
            }
            return seg;
        }
    }
    get type() {
        return SharedNumberSequenceFactory.Type;
    }
    get attributes() {
        return SharedNumberSequenceFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     */
    async load(runtime, id, services, attributes) {
        const sharedSeq = new _sharedNumberSequence__WEBPACK_IMPORTED_MODULE_6__.SharedNumberSequence(runtime, id, attributes);
        await sharedSeq.load(services);
        return sharedSeq;
    }
    create(document, id) {
        const sharedString = new _sharedNumberSequence__WEBPACK_IMPORTED_MODULE_6__.SharedNumberSequence(document, id, this.attributes);
        sharedString.initializeLocal();
        return sharedString;
    }
}
SharedNumberSequenceFactory.Type = "https://graph.microsoft.com/types/mergeTree/number-sequence";
SharedNumberSequenceFactory.Attributes = {
    type: SharedNumberSequenceFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_3__.pkgVersion,
};
//# sourceMappingURL=sequenceFactory.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/sequence/lib/sharedNumberSequence.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/sequence/lib/sharedNumberSequence.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SharedNumberSequence": () => (/* binding */ SharedNumberSequence)
/* harmony export */ });
/* harmony import */ var _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sequenceFactory */ "../../node_modules/@fluidframework/sequence/lib/sequenceFactory.js");
/* harmony import */ var _sharedSequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sharedSequence */ "../../node_modules/@fluidframework/sequence/lib/sharedSequence.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * The SharedNumberSequence holds a sequence of numbers. Each number will be stored
 * at a position within the sequence. See the
 * {@link https://github.com/microsoft/FluidFramework/blob/main/packages/dds/sequence/README.md | sequence readme}
 * for details on working with sequences.
 */
class SharedNumberSequence extends _sharedSequence__WEBPACK_IMPORTED_MODULE_0__.SharedSequence {
    constructor(document, id, attributes) {
        super(document, id, attributes, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedNumberSequenceFactory.segmentFromSpec);
        this.id = id;
    }
    /**
     * Create a new shared number sequence
     *
     * @param runtime - data store runtime the new shared number sequence belongs to
     * @param id - optional name of the shared number sequence
     * @returns newly create shared number sequence (but not attached yet)
     */
    static create(runtime, id) {
        return runtime.createChannel(id, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedNumberSequenceFactory.Type);
    }
    /**
     * Get a factory for SharedNumberSequence to register with the data store.
     *
     * @returns a factory that creates and load SharedNumberSequence
     */
    static getFactory() {
        return new _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedNumberSequenceFactory();
    }
    getRange(start, end) {
        return this.getItems(start, end);
    }
}
//# sourceMappingURL=sharedNumberSequence.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/sequence/lib/sharedObjectSequence.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/sequence/lib/sharedObjectSequence.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SharedObjectSequence": () => (/* binding */ SharedObjectSequence)
/* harmony export */ });
/* harmony import */ var _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sequenceFactory */ "../../node_modules/@fluidframework/sequence/lib/sequenceFactory.js");
/* harmony import */ var _sharedSequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sharedSequence */ "../../node_modules/@fluidframework/sequence/lib/sharedSequence.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * The SharedObjectSequence holds a sequence of serializable objects. Each object will be stored
 * at a position within the sequence. See the
 * {@link https://github.com/microsoft/FluidFramework/blob/main/packages/dds/sequence/README.md | sequence readme}
 * for details on working with sequences.
 */
class SharedObjectSequence extends _sharedSequence__WEBPACK_IMPORTED_MODULE_0__.SharedSequence {
    constructor(document, id, attributes) {
        super(document, id, attributes, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedObjectSequenceFactory.segmentFromSpec);
        this.id = id;
    }
    /**
     * Create a new shared object sequence
     *
     * @param runtime - data store runtime the new shared object sequence belongs to
     * @param id - optional name of the shared object sequence
     * @returns newly create shared object sequence (but not attached yet)
     */
    // eslint-disable-next-line @typescript-eslint/no-shadow
    static create(runtime, id) {
        return runtime.createChannel(id, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedObjectSequenceFactory.Type);
    }
    /**
     * Get a factory for SharedObjectSequence to register with the data store.
     *
     * @returns a factory that creates and load SharedObjectSequence
     */
    static getFactory() {
        return new _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedObjectSequenceFactory();
    }
    getRange(start, end) {
        return this.getItems(start, end);
    }
}
//# sourceMappingURL=sharedObjectSequence.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/sequence/lib/sharedSequence.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@fluidframework/sequence/lib/sharedSequence.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SubSequence": () => (/* binding */ SubSequence),
/* harmony export */   "SharedSequence": () => (/* binding */ SharedSequence)
/* harmony export */ });
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/mergeTree.js");
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/localReference.js");
/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sequence */ "../../node_modules/@fluidframework/sequence/lib/sequence.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


const MaxRun = 128;
class SubSequence extends _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.BaseSegment {
    constructor(items) {
        super();
        this.items = items;
        this.type = SubSequence.typeString;
        this.cachedLength = items.length;
    }
    static is(segment) {
        return segment.type === SubSequence.typeString;
    }
    static fromJSONObject(spec) {
        if (spec && typeof spec === "object" && "items" in spec) {
            const segment = new SubSequence(spec.items);
            if (spec.props) {
                segment.addProperties(spec.props);
            }
            return segment;
        }
        return undefined;
    }
    toJSONObject() {
        const obj = { items: this.items };
        super.addSerializedProps(obj);
        return obj;
    }
    clone(start = 0, end) {
        const clonedItems = this.items.slice(start, end);
        const b = new SubSequence(clonedItems);
        this.cloneInto(b);
        return b;
    }
    canAppend(segment) {
        return SubSequence.is(segment)
            && (this.cachedLength <= MaxRun || segment.cachedLength <= MaxRun);
    }
    toString() {
        return this.items.toString();
    }
    append(segment) {
        if (!SubSequence.is(segment)) {
            throw new Error("can only append another run segment");
        }
        // Note: Must call 'appendLocalRefs' before modifying this segment's length as
        //       'this.cachedLength' is used to adjust the offsets of the local refs.
        _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.LocalReferenceCollection.append(this, segment);
        this.items = this.items.concat(segment.items);
        this.cachedLength = this.items.length;
    }
    // TODO: retain removed items for undo
    // returns true if entire run removed
    removeRange(start, end) {
        let remnantItems = [];
        const len = this.items.length;
        if (start > 0) {
            remnantItems = remnantItems.concat(this.items.slice(0, start));
        }
        if (end < len) {
            remnantItems = remnantItems.concat(this.items.slice(end));
        }
        this.items = remnantItems;
        this.cachedLength = this.items.length;
        return (this.items.length === 0);
    }
    createSplitSegmentAt(pos) {
        if (pos > 0) {
            const remainingItems = this.items.slice(pos);
            this.items = this.items.slice(0, pos);
            this.cachedLength = this.items.length;
            const leafSegment = new SubSequence(remainingItems);
            return leafSegment;
        }
    }
}
SubSequence.typeString = "SubSequence";
class SharedSequence extends _sequence__WEBPACK_IMPORTED_MODULE_2__.SharedSegmentSequence {
    constructor(document, id, attributes, specToSegment) {
        super(document, id, attributes, specToSegment);
        this.id = id;
    }
    /**
     * @param pos - The position to insert the items at.
     * @param items - The items to insert.
     * @param props - Optional. Properties to set on the inserted items.
     */
    insert(pos, items, props) {
        const segment = new SubSequence(items);
        if (props) {
            segment.addProperties(props);
        }
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    /**
     * @param start - The inclusive start of the range to remove
     * @param end - The exclusive end of the range to remove
     */
    remove(start, end) {
        this.removeRange(start, end);
    }
    /**
     * Returns the total count of items in the sequence
     */
    getItemCount() {
        return this.getLength();
    }
    /**
     * Gets the items in the specified range
     *
     * @param start - The inclusive start of the range
     * @param end - The exclusive end of the range
     */
    getItems(start, end) {
        const items = [];
        let firstSegment;
        // Return if the range is incorrect.
        if (end !== undefined && end <= start) {
            return items;
        }
        this.walkSegments((segment) => {
            if (SubSequence.is(segment)) {
                if (firstSegment === undefined) {
                    firstSegment = segment;
                }
                items.push(...segment.items);
            }
            return true;
        }, start, end);
        // The above call to walkSegments adds all the items in the walked
        // segments. However, we only want items beginning at |start| in
        // the first segment. Similarly, if |end| is passed in, we only
        // want items until |end| in the last segment. Remove the rest of
        // the items.
        if (firstSegment !== undefined) {
            items.splice(0, start - this.getPosition(firstSegment));
        }
        if (end !== undefined) {
            items.splice(end - start);
        }
        return items;
    }
}
//# sourceMappingURL=sharedSequence.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/sequence/lib/sharedString.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@fluidframework/sequence/lib/sharedString.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SharedString": () => (/* binding */ SharedString)
/* harmony export */ });
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/mergeTree.js");
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/merge-tree */ "../../node_modules/@fluidframework/merge-tree/lib/textSegment.js");
/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sequence */ "../../node_modules/@fluidframework/sequence/lib/sequence.js");
/* harmony import */ var _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sequenceFactory */ "../../node_modules/@fluidframework/sequence/lib/sequenceFactory.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * The Shared String is a specialized data structure for handling collaborative
 *  text. It is based on a more general Sequence data structure but has
 * additional features that make working with text easier.
 *
 * In addition to text, a Shared String can also contain markers. Markers can be
 * used to store metadata at positions within the text, like the details of an
 * image or Fluid object that should be rendered with the text.
 *
 */
class SharedString extends _sequence__WEBPACK_IMPORTED_MODULE_0__.SharedSegmentSequence {
    constructor(document, id, attributes) {
        super(document, id, attributes, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedStringFactory.segmentFromSpec);
        this.id = id;
        this.mergeTreeTextHelper = this.client.createTextHelper();
    }
    /**
     * Create a new shared string
     *
     * @param runtime - data store runtime the new shared string belongs to
     * @param id - optional name of the shared string
     * @returns newly create shared string (but not attached yet)
     */
    static create(runtime, id) {
        return runtime.createChannel(id, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedStringFactory.Type);
    }
    /**
     * Get a factory for SharedString to register with the data store.
     *
     * @returns a factory that creates and load SharedString
     */
    static getFactory() {
        return new _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedStringFactory();
    }
    get ISharedString() {
        return this;
    }
    /**
     * Inserts a marker at a relative postition
     *
     * @param relativePos1 - The relative postition to insert the marker at
     * @param refType - The reference type of the marker
     * @param props - The properties of the marker
     */
    insertMarkerRelative(relativePos1, refType, props) {
        const segment = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.Marker(refType);
        if (props) {
            segment.addProperties(props);
        }
        const pos = this.posFromRelativePos(relativePos1);
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    /**
     * Inserts a marker at the postition
     *
     * @param pos - The postition to insert the marker at
     * @param refType - The reference type of the marker
     * @param props - The properties of the marker
     */
    insertMarker(pos, refType, props) {
        const segment = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.Marker(refType);
        if (props) {
            segment.addProperties(props);
        }
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
        return insertOp;
    }
    /**
     * Inserts the text at the postition
     *
     * @param relativePos1 - The relative postition to insert the text at
     * @param text - The text to insert
     * @param props - The properties of text
     */
    insertTextRelative(relativePos1, text, props) {
        const segment = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.TextSegment(text);
        if (props) {
            segment.addProperties(props);
        }
        const pos = this.posFromRelativePos(relativePos1);
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    /**
     * Inserts the text at the postition
     *
     * @param pos - The  postition to insert the text at
     * @param text - The text to insert
     * @param props - The properties of text
     */
    insertText(pos, text, props) {
        const segment = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.TextSegment(text);
        if (props) {
            segment.addProperties(props);
        }
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    /**
     * Replaces a range with the provided text.
     *
     * @param start - The inclusive start of the range to replace
     * @param end - The exclusive end of the range to replace
     * @param text - The text to replace the range with
     * @param props - Optional. The properties of the replacement text
     */
    replaceText(start, end, text, props) {
        this.replaceRange(start, end, _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.TextSegment.make(text, props));
    }
    removeText(start, end) {
        return this.removeRange(start, end);
    }
    /**
     * Annotates the marker with the provided properties
     * and calls the callback on concensus.
     *
     * @param marker - The marker to annotate
     * @param props - The properties to annotate the marker with
     * @param consensusCallback - The callback called when consensus is reached
     */
    annotateMarkerNotifyConsensus(marker, props, callback) {
        const annotateOp = this.client.annotateMarkerNotifyConsensus(marker, props, callback);
        if (annotateOp) {
            this.submitSequenceMessage(annotateOp);
        }
    }
    /**
     * Annotates the marker with the provided properties
     *
     * @param marker - The marker to annotate
     * @param props - The properties to annotate the marker with
     * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
     */
    annotateMarker(marker, props, combiningOp) {
        const annotateOp = this.client.annotateMarker(marker, props, combiningOp);
        if (annotateOp) {
            this.submitSequenceMessage(annotateOp);
        }
    }
    findTile(startPos, tileLabel, preceding = true) {
        return this.client.findTile(startPos, tileLabel, preceding);
    }
    getTextAndMarkers(label) {
        const segmentWindow = this.client.getCollabWindow();
        return this.mergeTreeTextHelper.getTextAndMarkers(segmentWindow.currentSeq, segmentWindow.clientId, label);
    }
    getText(start, end) {
        const segmentWindow = this.client.getCollabWindow();
        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, "", start, end);
    }
    /**
     * Adds spaces for markers and handles, so that position calculations account for them
     */
    getTextWithPlaceholders() {
        const segmentWindow = this.client.getCollabWindow();
        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, " ");
    }
    getTextRangeWithPlaceholders(start, end) {
        const segmentWindow = this.client.getCollabWindow();
        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, " ", start, end);
    }
    getTextRangeWithMarkers(start, end) {
        const segmentWindow = this.client.getCollabWindow();
        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, "*", start, end);
    }
    getMarkerFromId(id) {
        return this.client.getMarkerFromId(id);
    }
}
//# sourceMappingURL=sharedString.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/shared-object-base/lib/handle.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@fluidframework/shared-object-base/lib/handle.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SharedObjectHandle": () => (/* binding */ SharedObjectHandle)
/* harmony export */ });
/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/datastore */ "../../node_modules/@fluidframework/datastore/lib/fluidHandle.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/dataStoreHelpers.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Handle for shared object
 * This object is used for already loaded (in-memory) shared object
 * and is used only for serialization purposes.
 * De-serialization process goes through FluidObjectHandle and request flow:
 * FluidDataStoreRuntime.request() recognizes requests in the form of '/<shared object id>'
 * and loads shared object.
 */
class SharedObjectHandle extends _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__.FluidObjectHandle {
    /**
     * Whether services have been attached for the associated shared object.
     */
    get isAttached() {
        return this.value.isAttached();
    }
    /**
     * Creates a new SharedObjectHandle.
     * @param value - The shared object this handle is for.
     * @param path - The id of the shared object. It is also the path to this object relative to the routeContext.
     * @param routeContext - The parent IFluidHandleContext that has a route to this handle.
     */
    constructor(value, path, routeContext) {
        super(value, path, routeContext);
    }
    /**
     * Attaches all bound handles first (which may in turn attach further handles), then attaches this handle.
     * When attaching the handle, it registers the associated shared object.
     */
    attachGraph() {
        this.value.bindToContext();
        super.attachGraph();
    }
    /**
     * Returns 404.
     * @param request - The request to make
     * @returns A 404 error
     */
    async request(request) {
        return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__.create404Response)(request);
    }
}
//# sourceMappingURL=handle.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/shared-object-base/lib/sharedObject.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/shared-object-base/lib/sharedObject.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SharedObject": () => (/* binding */ SharedObject)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ "../../node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/assert.js");
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @fluidframework/container-definitions */ "../../node_modules/@fluidframework/container-definitions/lib/runtime.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/serializer.js");
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/summaryUtils.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/eventEmitterWithErrorHandling.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/* harmony import */ var _handle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./handle */ "../../node_modules/@fluidframework/shared-object-base/lib/handle.js");
/* harmony import */ var _summarySerializer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./summarySerializer */ "../../node_modules/@fluidframework/shared-object-base/lib/summarySerializer.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */







/**
 *  Base class from which all shared objects derive
 */
class SharedObject extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.EventEmitterWithErrorHandling {
    /**
     * @param id - The id of the shared object
     * @param runtime - The IFluidDataStoreRuntime which contains the shared object
     * @param attributes - Attributes of the shared object
     */
    constructor(id, runtime, attributes) {
        super();
        this.id = id;
        this.runtime = runtime;
        this.attributes = attributes;
        /**
         * Connection state
         */
        this._connected = false;
        /**
         * True if the dds is bound to its parent.
         */
        this._isBoundToContext = false;
        /**
         * True while we are summarizing this object's data.
         */
        this._isSummarizing = false;
        this.handle = new _handle__WEBPACK_IMPORTED_MODULE_1__.SharedObjectHandle(this, id, runtime.IFluidHandleContext);
        // Runtime could be null since some package hasn't turn on strictNullChecks yet
        // We should remove the null check once that is done
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.ChildLogger.create(
        // eslint-disable-next-line no-null/no-null
        runtime !== null ? runtime.logger : undefined, undefined, { all: { sharedObjectId: (0,uuid__WEBPACK_IMPORTED_MODULE_3__.default)() } });
        this._serializer = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_4__.FluidSerializer(this.runtime.channelsRoutingContext);
        this.attachListeners();
    }
    /**
     * @param obj - The thing to check if it is a SharedObject
     * @returns Returns true if the thing is a SharedObject
     */
    static is(obj) {
        return (obj === null || obj === void 0 ? void 0 : obj.ISharedObject) !== undefined;
    }
    get ISharedObject() { return this; }
    get IChannel() { return this; }
    get IFluidLoadable() { return this; }
    /**
     * Gets the connection state
     * @returns The state of the connection
     */
    get connected() {
        return this._connected;
    }
    get serializer() {
        /**
         * During summarize, the SummarySerializer keeps track of IFluidHandles that are serialized. These handles
         * represent references to other Fluid objects and are used for garbage collection.
         *
         * This is fine for now. However, if we implement delay loading in DDss, they may load and de-serialize content
         * in summarize. When that happens, they may incorrectly hit this assert and we will have to change this.
         */
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!this._isSummarizing, 0x075 /* "SummarySerializer should be used for serializing data during summary." */);
        return this._serializer;
    }
    attachListeners() {
        this.on("error", (error) => {
            this.runtime.raiseContainerWarning(error);
        });
        // Only listen to these events if not attached.
        if (!this.isAttached()) {
            this.runtime.once("attaching", () => {
                // Calling this will let the dds to do any custom processing based on attached
                // like starting generating ops.
                this.didAttach();
            });
        }
    }
    /**
     * Not supported - use handles instead
     */
    toJSON() {
        throw new Error("Only the handle can be converted to JSON");
    }
    /**
     * A shared object, after construction, can either be loaded in the case that it is already part of
     * a shared document. Or later attached if it is being newly added.
     * @param services - Services used by the shared object
     */
    async load(services) {
        if (this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_6__.AttachState.Detached) {
            this.services = services;
        }
        await this.loadCore(services.objectStorage);
        if (this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_6__.AttachState.Detached) {
            this.attachDeltaHandler();
        }
    }
    /**
     * Initializes the object as a local, non-shared object. This object can become shared after
     * it is attached to the document.
     */
    initializeLocal() {
        this.initializeLocalCore();
    }
    /**
     * {@inheritDoc (ISharedObject:interface).bindToContext}
     */
    bindToContext() {
        if (this._isBoundToContext) {
            return;
        }
        this._isBoundToContext = true;
        this.setOwner();
        // Allow derived classes to perform custom processing prior to registering this object
        this.registerCore();
        this.runtime.bindChannel(this);
    }
    /**
     * {@inheritDoc (ISharedObject:interface).connect}
     */
    connect(services) {
        this.services = services;
        this.attachDeltaHandler();
    }
    /**
     * {@inheritDoc (ISharedObject:interface).isAttached}
     */
    isAttached() {
        return this.services !== undefined && this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_6__.AttachState.Detached;
    }
    /**
     * {@inheritDoc (ISharedObject:interface).summarize}
     */
    summarize(fullTree = false, trackState = false) {
        // Set _isSummarizing to true. This flag is used to ensure that we only use SummarySerializer (created below)
        // to serialize handles in this object's data. The routes of these serialized handles are outbound routes
        // to other Fluid objects.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!this._isSummarizing, 0x076 /* "Possible re-entrancy! Summary should not already be in progress." */);
        this._isSummarizing = true;
        let summaryTree;
        let gcData;
        try {
            const serializer = new _summarySerializer__WEBPACK_IMPORTED_MODULE_7__.SummarySerializer(this.runtime.channelsRoutingContext);
            const snapshot = this.snapshotCore(serializer);
            summaryTree = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_8__.convertToSummaryTreeWithStats)(snapshot, fullTree);
            // Add this channel's garbage collection data to the summarize result. The outbound routes of this channel
            // are all the routes of all the handles that are tracked by the SummarySerializer above.
            gcData = {
                gcNodes: { "/": serializer.getSerializedRoutes() },
            };
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(this._isSummarizing, 0x077 /* "Possible re-entrancy! Summary should have been in progress." */);
        }
        finally {
            this._isSummarizing = false;
        }
        return Object.assign(Object.assign({}, summaryTree), { gcData });
    }
    /**
     * {@inheritDoc (ISharedObject:interface).getGCData}
     */
    getGCData(fullGC = false) {
        // We run the full summarize logic to get the list of outbound routes from this object. This is a little
        // expensive but its okay for now. It will be updated to not use full summarize and make it more efficient.
        // See: https://github.com/microsoft/FluidFramework/issues/4547
        // Set _isSummarizing to true. This flag is used to ensure that we only use SummarySerializer (created below)
        // to serialize handles in this object's data. The routes of these serialized handles are outbound routes
        // to other Fluid objects.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!this._isSummarizing, 0x078 /* "Possible re-entrancy! Summary should not already be in progress." */);
        this._isSummarizing = true;
        let gcData;
        try {
            const serializer = new _summarySerializer__WEBPACK_IMPORTED_MODULE_7__.SummarySerializer(this.runtime.channelsRoutingContext);
            this.snapshotCore(serializer);
            // The GC data for this shared object contains a single GC node. The outbound routes of this node are the
            // routes of handles serialized during snapshot.
            gcData = {
                gcNodes: { "/": serializer.getSerializedRoutes() },
            };
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(this._isSummarizing, 0x079 /* "Possible re-entrancy! Summary should have been in progress." */);
        }
        finally {
            this._isSummarizing = false;
        }
        return gcData;
    }
    /**
     * Set the owner of the object if it is an OwnedSharedObject
     * @returns The owner of the object if it is an OwnedSharedObject, otherwise undefined
     */
    setOwner() {
        return;
    }
    /**
     * Allows the distributed data type to perform custom local loading.
     */
    initializeLocalCore() {
        return;
    }
    /**
     * Allows the distributive data type the ability to perform custom processing once an attach has happened.
     * Also called after non-local data type get loaded.
     */
    didAttach() {
        return;
    }
    /**
     * Submits a message by the local client to the runtime.
     * @param content - Content of the message
     * @param localOpMetadata - The local metadata associated with the message. This is kept locally by the runtime
     * and not sent to the server. This will be sent back when this message is received back from the server. This is
     * also sent if we are asked to resubmit the message.
     */
    submitLocalMessage(content, localOpMetadata = undefined) {
        if (this.isAttached()) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.services.deltaConnection.submit(content, localOpMetadata);
        }
    }
    /**
     * Marks this object as dirty so that it is part of the next summary. It is called by a SharedSummaryBlock
     * that want to be part of summary but does not generate ops.
     */
    dirty() {
        if (!this.isAttached()) {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.services.deltaConnection.dirty();
    }
    /**
     * Called when the object has fully connected to the delta stream
     * Default implementation for DDS, override if different behavior is required.
     */
    onConnect() { }
    /**
     * Called when a message has to be resubmitted. This typically happens after a reconnection for unacked messages.
     * The default implementation here is to resubmit the same message. The client can override if different behavior
     * is required. It can choose to resubmit the same message, submit different / multiple messages or not submit
     * anything at all.
     * @param content - The content of the original message.
     * @param localOpMetadata - The local metadata associated with the original message.
     */
    reSubmitCore(content, localOpMetadata) {
        this.submitLocalMessage(content, localOpMetadata);
    }
    /**
     * Promises that are waiting for an ack from the server before resolving should use this instead of new Promise.
     * It ensures that if something changes that will interrupt that ack (e.g. the FluidDataStoreRuntime disposes),
     * the Promise will reject.
     * If runtime is disposed when this call is made, executor is not run and promise is rejected right away.
     */
    async newAckBasedPromise(executor) {
        let rejectBecauseDispose;
        return new Promise((resolve, reject) => {
            rejectBecauseDispose =
                () => reject(new Error("FluidDataStoreRuntime disposed while this ack-based Promise was pending"));
            if (this.runtime.disposed) {
                rejectBecauseDispose();
                return;
            }
            this.runtime.on("dispose", rejectBecauseDispose);
            executor(resolve, reject);
        }).finally(() => {
            // Note: rejectBecauseDispose will never be undefined here
            this.runtime.off("dispose", rejectBecauseDispose);
        });
    }
    /**
     * Report ignorable errors in code logic or data integrity to the logger.
     * Hosting app / container may want to optimize out these call sites and make them no-op.
     * It may also show assert dialog in non-production builds of application.
     * @param condition - If false, assert is logged
     * @param message - Actual message to log; ideally should be unique message to identify call site
     */
    debugAssert(condition, event) {
        this.logger.debugAssert(condition, event);
    }
    attachDeltaHandler() {
        // Services should already be there in case we are attaching delta handler.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(this.services !== undefined, 0x07a /* "Services should be there to attach delta handler" */);
        this._isBoundToContext = true;
        // Allows objects to do any custom processing if it is attached.
        this.didAttach();
        // attachDeltaHandler is only called after services is assigned
        this.services.deltaConnection.attach({
            process: (message, local, localOpMetadata) => {
                this.process(message, local, localOpMetadata);
            },
            setConnectionState: (connected) => {
                this.setConnectionState(connected);
            },
            reSubmit: (content, localOpMetadata) => {
                this.reSubmit(content, localOpMetadata);
            },
            applyStashedOp: (content) => {
                return this.applyStashedOp(content);
            },
        });
        // Trigger initial state
        // attachDeltaHandler is only called after services is assigned
        this.setConnectionState(this.services.deltaConnection.connected);
    }
    /**
     * Set the state of connection to services.
     * @param connected - true if connected, false otherwise.
     */
    setConnectionState(connected) {
        if (this._connected === connected) {
            // Not changing state, nothing the same.
            return;
        }
        // Should I change the state at the end? So that we *can't* send new stuff before we send old?
        this._connected = connected;
        if (!connected) {
            // Things that are true now...
            // - if we had a connection we can no longer send messages over it
            // - if we had outbound messages some may or may not be ACK'd. Won't know until next message
            //
            // - nack could get a new msn - but might as well do it in the join?
            this.onDisconnect();
        }
        else {
            // Call this for now so that DDSes like ConsensesOrderedCollection that maintain their own pending
            // messages will work.
            this.onConnect();
        }
    }
    /**
     * Handles a message being received from the remote delta server.
     * @param message - The message to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     */
    process(message, local, localOpMetadata) {
        this.emit("pre-op", message, local, this);
        this.processCore(message, local, localOpMetadata);
        this.emit("op", message, local, this);
    }
    /**
     * Called when a message has to be resubmitted. This typically happens for unacked messages after a
     * reconnection.
     * @param content - The content of the original message.
     * @param localOpMetadata - The local metadata associated with the original message.
     */
    reSubmit(content, localOpMetadata) {
        this.reSubmitCore(content, localOpMetadata);
    }
}
//# sourceMappingURL=sharedObject.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/shared-object-base/lib/summarySerializer.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/shared-object-base/lib/summarySerializer.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummarySerializer": () => (/* binding */ SummarySerializer)
/* harmony export */ });
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/runtime-utils */ "../../node_modules/@fluidframework/runtime-utils/lib/serializer.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Serializer implementation for serializing handles during summary.
 */
class SummarySerializer extends _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.FluidSerializer {
    constructor() {
        super(...arguments);
        this.serializedRoutes = new Set();
    }
    getSerializedRoutes() {
        return Array.from(this.serializedRoutes);
    }
    serializeHandle(handle, bind) {
        this.serializedRoutes.add(handle.absolutePath);
        return super.serializeHandle(handle, bind);
    }
}
//# sourceMappingURL=summarySerializer.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/shared-object-base/lib/utils.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@fluidframework/shared-object-base/lib/utils.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "serializeHandles": () => (/* binding */ serializeHandles),
/* harmony export */   "makeHandlesSerializable": () => (/* binding */ makeHandlesSerializable),
/* harmony export */   "parseHandles": () => (/* binding */ parseHandles)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Given a mostly-plain object that may have handle objects embedded within, return a string representation of an object
 * where the handle objects have been replaced with a serializable form.
 * @param value - The mostly-plain object
 * @param serializer - The serializer that knows how to convert handles into serializable format
 * @param context - The handle context for the container
 * @param bind - Bind any other handles we find in the object against this given handle.
 * @returns Result of strigifying an object
 */
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function serializeHandles(value, serializer, bind) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return value !== undefined
        ? serializer.stringify(value, bind)
        : value;
}
/**
 * Given a mostly-plain object that may have handle objects embedded within, will return a fully-plain object
 * where any embedded IFluidHandles have been replaced with a serializable form.
 *
 * The original `input` object is not mutated.  This method will shallowly clones all objects in the path from
 * the root to any replaced handles.  (If no handles are found, returns the original object.)
 *
 * @param input - The mostly-plain object
 * @param context - The handle context for the container
 * @param bind - Bind any other handles we find in the object against this given handle.
 * @returns The fully-plain object
 */
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function makeHandlesSerializable(value, serializer, bind) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return serializer.replaceHandles(value, bind);
}
/**
 * Given a fully-plain object that may have serializable-form handles within, will return the mostly-plain object
 * with handle objects created instead.
 * @param value - The fully-plain object
 * @param serializer - The serializer that knows how to convert serializable-form handles into handle objects
 * @param context - The handle context for the container
 * @returns The mostly-plain object with handle objects within
 */
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function parseHandles(value, serializer) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return value !== undefined ? serializer.parse(JSON.stringify(value)) : value;
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/shared-object-base/lib/valueType.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@fluidframework/shared-object-base/lib/valueType.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ValueType": () => (/* binding */ ValueType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * enum representing the possible types of a shared object
 */
var ValueType;
(function (ValueType) {
    /**
     * The value is a shared object
     * @deprecated Instead store the handle of the shared object, rather than the shared object itself.
     */
    ValueType[ValueType["Shared"] = 0] = "Shared";
    /**
     * The value is a plain JavaScript object or handle.  If a plain object, it may contain handles deeper within.
     */
    ValueType[ValueType["Plain"] = 1] = "Plain";
})(ValueType || (ValueType = {}));
//# sourceMappingURL=valueType.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/synthesize/lib/dependencyContainer.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@fluidframework/synthesize/lib/dependencyContainer.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DependencyContainer": () => (/* binding */ DependencyContainer)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * DependencyContainer is similar to a IoC Container. It takes providers and will
 * synthesize an object based on them when requested.
 */
class DependencyContainer {
    constructor(parent = undefined) {
        this.parent = parent;
        this.providers = new Map();
    }
    get IFluidDependencySynthesizer() { return this; }
    /**
     * {@inheritDoc (IFluidDependencySynthesizer:interface).registeredTypes}
     */
    get registeredTypes() {
        return this.providers.keys();
    }
    /**
     * {@inheritDoc (IFluidDependencySynthesizer:interface).register}
     */
    register(type, provider) {
        if (this.has(type)) {
            throw new Error(`Attempting to register a provider of type ${type} that already exists`);
        }
        this.providers.set(type, provider);
    }
    /**
     * {@inheritDoc (IFluidDependencySynthesizer:interface).unregister}
     */
    unregister(type) {
        if (this.providers.has(type)) {
            this.providers.delete(type);
        }
    }
    /**
     * {@inheritDoc (IFluidDependencySynthesizer:interface).synthesize}
     */
    synthesize(optionalTypes, requiredTypes) {
        const optionalValues = Object.values(optionalTypes);
        const requiredValues = Object.values(requiredTypes);
        // There was nothing passed in so we can return
        if (optionalValues === [] && requiredValues === []) {
            return {};
        }
        const required = this.generateRequired(requiredTypes);
        const optional = this.generateOptional(optionalTypes);
        return Object.assign(Object.assign({}, required), optional);
    }
    /**
     * {@inheritDoc (IFluidDependencySynthesizer:interface).has}
     */
    has(...types) {
        return types.every((type) => {
            return this.providers.has(type);
        });
    }
    /**
     * {@inheritDoc (IFluidDependencySynthesizer:interface).getProvider}
     */
    getProvider(type) {
        // If we have the provider return it
        const provider = this.providers.get(type);
        if (provider) {
            return provider;
        }
        if (this.parent) {
            return this.parent.getProvider(type);
        }
        return undefined;
    }
    generateRequired(types) {
        const values = Object.values(types);
        return Object.assign({}, ...Array.from(values, (t) => {
            const provider = this.getProvider(t);
            if (!provider) {
                throw new Error(`Object attempted to be created without registered required provider ${t}`);
            }
            return this.resolveProvider(provider, t);
        }));
    }
    generateOptional(types) {
        const values = Object.values(types);
        return Object.assign({}, ...Array.from(values, (t) => {
            const provider = this.getProvider(t);
            if (!provider) {
                return { get [t]() { return Promise.resolve(undefined); } };
            }
            return this.resolveProvider(provider, t);
        }));
    }
    resolveProvider(provider, t) {
        // The double nested gets are required for lazy loading the provider resolution
        if (typeof provider === "function") {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const self = this;
            return {
                get [t]() {
                    if (provider && typeof provider === "function") {
                        return Promise.resolve(provider(self)).then((p) => {
                            if (p) {
                                return p[t];
                            }
                        });
                    }
                },
            };
        }
        return {
            get [t]() {
                if (provider) {
                    return Promise.resolve(provider).then((p) => {
                        if (p) {
                            return p[t];
                        }
                    });
                }
            },
        };
    }
}
//# sourceMappingURL=dependencyContainer.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/telemetry-utils/lib/debugLogger.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@fluidframework/telemetry-utils/lib/debugLogger.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebugLogger": () => (/* binding */ DebugLogger)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/performanceBrowser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "../../node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logger */ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * Implementation of debug logger
 */
class DebugLogger extends _logger__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger {
    constructor(debug, debugErr, properties) {
        super(undefined, properties);
        this.debug = debug;
        this.debugErr = debugErr;
    }
    /**
     * Create debug logger - all events are output to debug npm library
     * @param namespace - Telemetry event name prefix to add to all events
     * @param properties - Base properties to add to all events
     * @param propertyGetters - Getters to add additional properties to all events
     */
    static create(namespace, properties) {
        // Setup base logger upfront, such that host can disable it (if needed)
        const debug = (0,debug__WEBPACK_IMPORTED_MODULE_0__.debug)(namespace);
        const debugErr = (0,debug__WEBPACK_IMPORTED_MODULE_0__.debug)(namespace);
        debugErr.log = console.error.bind(console);
        debugErr.enabled = true;
        return new DebugLogger(debug, debugErr, properties);
    }
    /**
     * Mix in debug logger with another logger.
     * Returned logger will output events to both newly created debug logger, as well as base logger
     * @param namespace - Telemetry event name prefix to add to all events
     * @param properties - Base properties to add to all events
     * @param propertyGetters - Getters to add additional properties to all events
     * @param baseLogger - Base logger to output events (in addition to debug logger being created). Can be undefined.
     */
    static mixinDebugLogger(namespace, baseLogger, properties) {
        if (!baseLogger) {
            return DebugLogger.create(namespace, properties);
        }
        const multiSinkLogger = new _logger__WEBPACK_IMPORTED_MODULE_1__.MultiSinkLogger(undefined, properties);
        multiSinkLogger.addLogger(DebugLogger.create(namespace));
        multiSinkLogger.addLogger(_logger__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(baseLogger, namespace));
        return multiSinkLogger;
    }
    /**
     * Send an event to debug loggers
     *
     * @param event - the event to send
     */
    send(event) {
        const newEvent = this.prepareEvent(event);
        const isError = newEvent.category === "error";
        let logger = isError ? this.debugErr : this.debug;
        // Use debug's coloring schema for base of the event
        const index = event.eventName.lastIndexOf(_logger__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.eventNamespaceSeparator);
        const name = event.eventName.substring(index + 1);
        if (index > 0) {
            logger = logger.extend(event.eventName.substring(0, index));
        }
        newEvent.eventName = undefined;
        let tick = "";
        tick = `tick=${_logger__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.formatTick(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.performance.now())}`;
        // Extract stack to put it last, but also to avoid escaping '\n' in it by JSON.stringify below
        const stack = newEvent.stack ? newEvent.stack : "";
        newEvent.stack = undefined;
        // Watch out for circular references - they can come from two sources
        // 1) error object - we do not control it and should remove it and retry
        // 2) properties supplied by telemetry caller - that's a bug that should be addressed!
        let payload;
        try {
            payload = JSON.stringify(newEvent);
        }
        catch (error) {
            newEvent.error = undefined;
            payload = JSON.stringify(newEvent);
        }
        if (payload === "{}") {
            payload = "";
        }
        // Force errors out, to help with diagnostics
        if (isError) {
            logger.enabled = true;
        }
        // Print multi-line.
        logger(`${name} ${payload} ${tick} ${stack}`);
    }
}
//# sourceMappingURL=debugLogger.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/telemetry-utils/lib/eventEmitterWithErrorHandling.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@fluidframework/telemetry-utils/lib/eventEmitterWithErrorHandling.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventEmitterWithErrorHandling": () => (/* binding */ EventEmitterWithErrorHandling)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/typedEventEmitter.js");

/**
 * Event Emitter helper class
 * Any exceptions thrown by listeners will be caught and raised through "error" event.
 * Any exception thrown by "error" listeners will propagate to the caller.
 */
class EventEmitterWithErrorHandling extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {
    emit(event, ...args) {
        try {
            return super.emit(event, ...args);
        }
        catch (error) {
            // Some listener threw an error, we'll try emitting that error via the error event
            // But not if we're already dealing with the error event, in that case just let the error be thrown
            if (event === "error") {
                throw error;
            }
            // Note: This will throw if no listeners are registered for the error event
            return super.emit("error", error);
        }
    }
}
//# sourceMappingURL=eventEmitterWithErrorHandling.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/telemetry-utils/lib/events.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@fluidframework/telemetry-utils/lib/events.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "connectedEventName": () => (/* binding */ connectedEventName),
/* harmony export */   "disconnectedEventName": () => (/* binding */ disconnectedEventName),
/* harmony export */   "safeRaiseEvent": () => (/* binding */ safeRaiseEvent),
/* harmony export */   "raiseConnectedEvent": () => (/* binding */ raiseConnectedEvent)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const connectedEventName = "connected";
const disconnectedEventName = "disconnected";
function safeRaiseEvent(emitter, logger, event, ...args) {
    try {
        emitter.emit(event, ...args);
    }
    catch (error) {
        logger.sendErrorEvent({ eventName: "RaiseEventError", event }, error);
    }
}
function raiseConnectedEvent(logger, emitter, connected, clientId) {
    try {
        if (connected) {
            emitter.emit(connectedEventName, clientId);
        }
        else {
            emitter.emit(disconnectedEventName);
        }
    }
    catch (error) {
        logger.sendErrorEvent({ eventName: "RaiseConnectedEventError" }, error);
    }
}
//# sourceMappingURL=events.js.map

/***/ }),

/***/ "../../node_modules/@fluidframework/telemetry-utils/lib/logger.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@fluidframework/telemetry-utils/lib/logger.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TelemetryLogger": () => (/* binding */ TelemetryLogger),
/* harmony export */   "ChildLogger": () => (/* binding */ ChildLogger),
/* harmony export */   "MultiSinkLogger": () => (/* binding */ MultiSinkLogger),
/* harmony export */   "PerformanceEvent": () => (/* binding */ PerformanceEvent),
/* harmony export */   "TelemetryDataTag": () => (/* binding */ TelemetryDataTag),
/* harmony export */   "LoggingError": () => (/* binding */ LoggingError)
/* harmony export */ });
/* unused harmony exports isTaggedTelemetryPropertyValue, isILoggingError, TelemetryUTLogger */
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/logger.js");
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/common-utils */ "../../node_modules/@fluidframework/common-utils/lib/performanceBrowser.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * TelemetryLogger class contains various helper telemetry methods,
 * encoding in one place schemas for various types of Fluid telemetry events.
 * Creates sub-logger that appends properties to all events
 */
class TelemetryLogger {
    constructor(namespace, properties) {
        this.namespace = namespace;
        this.properties = properties;
    }
    static formatTick(tick) {
        return Math.floor(tick);
    }
    /**
     * Attempts to parse number from string.
     * If fails,returns original string.
     * Used to make telemetry data typed (and support math operations, like comparison),
     * in places where we do expect numbers (like contentsize/duration property in http header)
     */
    static numberFromString(str) {
        if (str === undefined || str === null) {
            return undefined;
        }
        const num = Number(str);
        return Number.isNaN(num) ? str : num;
    }
    static sanitizePkgName(name) {
        return name.replace("@", "").replace("/", "-");
    }
    /**
     * Take an unknown error object and add the appropriate info from it to the event
     * NOTE - message and stack will be copied over from the error object,
     * along with other telemetry properties if it's an ILoggingError
     * @param event - Event being logged
     * @param error - Error to extract info from
     * @param fetchStack - Whether to fetch the current callstack if error.stack is undefined
     */
    static prepareErrorObject(event, error, fetchStack) {
        if (isILoggingError(error)) {
            // First, copy over stack and error message directly
            // Warning: if these were overwritten with PII-tagged props, they will be logged as-is
            const errorAsObject = error;
            event.stack = errorAsObject.stack;
            event.error = errorAsObject.message;
            // Then add any other telemetry properties from the LoggingError
            const taggableProps = error.getTelemetryProperties();
            for (const key of Object.keys(taggableProps)) {
                if (event[key] !== undefined) {
                    // Don't overwrite existing properties on the event
                    continue;
                }
                const taggableProp = taggableProps[key];
                const { value, tag } = (typeof taggableProp === "object")
                    ? taggableProp
                    : { value: taggableProp, tag: undefined };
                switch (tag) {
                    case undefined:
                        // No tag means we can log plainly
                        event[key] = value;
                        break;
                    case TelemetryDataTag.PackageData:
                        // For Microsoft applications, PackageData is safe for now
                        // (we don't load 3P code in 1P apps)
                        // But this determination really belongs in the host layer
                        event[key] = value;
                        break;
                    case TelemetryDataTag.UserData:
                        // Strip out anything tagged explicitly as PII.
                        // Alternate strategy would be to hash these props
                        event[key] = "REDACTED (UserData)";
                        break;
                    default:
                        // This will help us keep this switch statement up to date
                        (function (_) { })(tag);
                        // If we encounter a tag we don't recognize
                        // (e.g. due to interaction between different versions)
                        // then we must assume we should scrub.
                        event[key] = "REDACTED (unknown tag)";
                        break;
                }
            }
        }
        else if (typeof error === "object" && error !== null) {
            // Try to pull the stack and message off even if it's not an ILoggingError
            const errorAsObject = error;
            event.stack = errorAsObject.stack;
            event.error = errorAsObject.message;
        }
        else {
            event.error = error;
        }
        // Collect stack if we were not able to extract it from error
        if (event.stack === undefined && fetchStack) {
            event.stack = TelemetryLogger.getStack();
        }
    }
    static getStack() {
        // Some browsers will populate stack right away, others require throwing Error
        let stack = new Error().stack;
        if (!stack) {
            try {
                throw new Error();
            }
            catch (e) {
                stack = e.stack;
            }
        }
        return stack;
    }
    /**
     * Send a telemetry event with the logger
     *
     * @param event - the event to send
     * @param error - optional error object to log
     */
    sendTelemetryEvent(event, error) {
        var _a;
        const newEvent = Object.assign(Object.assign({}, event), { category: (_a = event.category) !== null && _a !== void 0 ? _a : (error === undefined ? "generic" : "error") });
        if (error !== undefined) {
            TelemetryLogger.prepareErrorObject(newEvent, error, false);
        }
        this.send(newEvent);
    }
    /**
     * Send an error telemetry event with the logger
     *
     * @param event - the event to send
     * @param error - optional error object to log
     */
    sendErrorEvent(event, error) {
        this.sendTelemetryEvent(Object.assign(Object.assign({}, event), { category: "error" }), error);
    }
    /**
     * Send a performance telemetry event with the logger
     *
     * @param event - Event to send
     * @param error - optional error object to log
     */
    sendPerformanceEvent(event, error) {
        const perfEvent = Object.assign(Object.assign({}, event), { category: event.category ? event.category : "performance" });
        if (error !== undefined) {
            TelemetryLogger.prepareErrorObject(perfEvent, error, false);
        }
        if (event.duration) {
            perfEvent.duration = TelemetryLogger.formatTick(event.duration);
        }
        this.send(perfEvent);
    }
    /**
     * @deprecated - use sendErrorEvent
     * Log generic error with the logger
     *
     * @param eventName - the name of the event
     * @param error - the error object to include in the event, require to be JSON-able
     */
    logGenericError(eventName, error) {
        this.sendErrorEvent({ eventName }, error);
    }
    /**
     * @deprecated - use sendErrorEvent
     * Helper method to log exceptions
     * @param event - the event to send
     * @param exception - Exception object to add to an event
     */
    logException(event, exception) {
        this.sendErrorEvent(Object.assign(Object.assign({}, event), { isException: true }), exception);
    }
    /**
     * @deprecated - use sendErrorEvent

     * Log an debug assert with the logger
     *
     * @param condition - the condition to assert on
     * @param event - the event to log if the condition fails
     */
    debugAssert(condition, event) {
        this.shipAssert(condition, event);
    }
    /**
     * @deprecated - use sendErrorEvent
     * Log an ship assert with the logger
     *
     * @param condition - the condition to assert on
     * @param event - the event to log if the condition fails
     */
    shipAssert(condition, event) {
        if (!condition) {
            const realEvent = event === undefined ? { eventName: "Assert" } : event;
            realEvent.isAssert = true;
            realEvent.stack = TelemetryLogger.getStack();
            this.sendErrorEvent(realEvent);
        }
    }
    prepareEvent(event) {
        const includeErrorProps = event.category === "error" || event.error !== undefined;
        const newEvent = Object.assign({}, event);
        if (this.namespace !== undefined) {
            newEvent.eventName = `${this.namespace}${TelemetryLogger.eventNamespaceSeparator}${newEvent.eventName}`;
        }
        if (this.properties) {
            const properties = [];
            properties.push(this.properties.all);
            if (includeErrorProps) {
                properties.push(this.properties.error);
            }
            for (const props of properties) {
                if (props !== undefined) {
                    for (const key of Object.keys(props)) {
                        if (event[key] !== undefined) {
                            continue;
                        }
                        const getterOrValue = props[key];
                        // If this throws, hopefully it is handled elsewhere
                        const value = typeof getterOrValue === "function" ? getterOrValue() : getterOrValue;
                        if (value !== undefined) {
                            newEvent[key] = value;
                        }
                    }
                }
            }
        }
        return newEvent;
    }
}
TelemetryLogger.eventNamespaceSeparator = ":";
/**
 * ChildLogger class contains various helper telemetry methods,
 * encoding in one place schemas for various types of Fluid telemetry events.
 * Creates sub-logger that appends properties to all events
 */
class ChildLogger extends TelemetryLogger {
    constructor(baseLogger, namespace, properties) {
        super(namespace, properties);
        this.baseLogger = baseLogger;
    }
    /**
     * Create child logger
     * @param baseLogger - Base logger to use to output events. If undefined, proper child logger
     * is created, but it does not sends telemetry events anywhere.
     * @param namespace - Telemetry event name prefix to add to all events
     * @param properties - Base properties to add to all events
     * @param propertyGetters - Getters to add additional properties to all events
     */
    static create(baseLogger, namespace, properties) {
        // if we are creating a child of a child, rather than nest, which will increase
        // the callstack overhead, just generate a new logger that includes everything from the previous
        if (baseLogger instanceof ChildLogger) {
            const combinedProperties = {};
            for (const extendedProps of [baseLogger.properties, properties]) {
                if (extendedProps !== undefined) {
                    if (extendedProps.all !== undefined) {
                        combinedProperties.all = Object.assign(Object.assign({}, combinedProperties.all), extendedProps.all);
                    }
                    if (extendedProps.error !== undefined) {
                        combinedProperties.error = Object.assign(Object.assign({}, combinedProperties.error), extendedProps.error);
                    }
                }
            }
            const combinedNamespace = baseLogger.namespace === undefined
                ? namespace
                : namespace === undefined
                    ? baseLogger.namespace
                    : `${baseLogger.namespace}${TelemetryLogger.eventNamespaceSeparator}${namespace}`;
            return new ChildLogger(baseLogger.baseLogger, combinedNamespace, combinedProperties);
        }
        return new ChildLogger(baseLogger ? baseLogger : new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.BaseTelemetryNullLogger(), namespace, properties);
    }
    /**
     * Send an event with the logger
     *
     * @param event - the event to send
     */
    send(event) {
        this.baseLogger.send(this.prepareEvent(event));
    }
}
/**
 * Multi-sink logger
 * Takes multiple ITelemetryBaseLogger objects (sinks) and logs all events into each sink
 * Implements ITelemetryBaseLogger (through static create() method)
 */
class MultiSinkLogger extends TelemetryLogger {
    /**
     * Create multiple sink logger (i.e. logger that sends events to multiple sinks)
     * @param namespace - Telemetry event name prefix to add to all events
     * @param properties - Base properties to add to all events
     * @param propertyGetters - Getters to add additional properties to all events
     */
    constructor(namespace, properties) {
        super(namespace, properties);
        this.loggers = [];
    }
    /**
     * Add logger to send all events to
     * @param logger - Logger to add
     */
    addLogger(logger) {
        if (logger !== undefined && logger !== null) {
            this.loggers.push(logger);
        }
    }
    /**
     * Send an event to the loggers
     *
     * @param event - the event to send to all the registered logger
     */
    send(event) {
        const newEvent = this.prepareEvent(event);
        this.loggers.forEach((logger) => {
            logger.send(newEvent);
        });
    }
}
/**
 * Helper class to log performance events
 */
class PerformanceEvent {
    constructor(logger, event, markers = { start: true, end: true, cancel: "generic" }) {
        this.logger = logger;
        this.markers = markers;
        this.startTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.performance.now();
        this.event = Object.assign({}, event);
        if (this.markers.start) {
            this.reportEvent("start");
        }
        if (typeof window === "object" && window != null && ({"now":(() => 0)})) {
            this.startMark = `${event.eventName}-start`;
            ({"now":(() => 0)}).mark(this.startMark);
        }
    }
    static start(logger, event, markers) {
        return new PerformanceEvent(logger, event, markers);
    }
    static timedExec(logger, event, callback, markers) {
        const perfEvent = PerformanceEvent.start(logger, event, markers);
        try {
            const ret = callback(perfEvent);
            // Event might have been cancelled or ended in the callback
            if (perfEvent.event) {
                perfEvent.end();
            }
            return ret;
        }
        catch (error) {
            perfEvent.cancel(undefined, error);
            throw error;
        }
    }
    static async timedExecAsync(logger, event, callback, markers) {
        const perfEvent = PerformanceEvent.start(logger, event, markers);
        try {
            const ret = await callback(perfEvent);
            // Event might have been cancelled or ended in the callback
            if (perfEvent.event) {
                perfEvent.end();
            }
            return ret;
        }
        catch (error) {
            perfEvent.cancel(undefined, error);
            throw error;
        }
    }
    reportProgress(props, eventNameSuffix = "update") {
        this.reportEvent(eventNameSuffix, props);
    }
    end(props, eventNameSuffix = "end") {
        if (this.markers.end) {
            this.reportEvent(eventNameSuffix, props);
        }
        if (this.startMark && this.event) {
            const endMark = `${this.event.eventName}-${eventNameSuffix}`;
            ({"now":(() => 0)}).mark(endMark);
            ({"now":(() => 0)}).measure(`${this.event.eventName}`, this.startMark, endMark);
            this.startMark = undefined;
        }
        this.event = undefined;
    }
    cancel(props, error) {
        if (this.markers.cancel !== undefined) {
            this.reportEvent("cancel", Object.assign({ category: this.markers.cancel }, props), error);
        }
        this.event = undefined;
    }
    /**
     * Report the event, if it hasn't already been reported.
     */
    reportEvent(eventNameSuffix, props, error) {
        // There are strange sequences involving multiple Promise chains
        // where the event can be cancelled and then later a callback is invoked
        // and the caller attempts to end directly, e.g. issue #3936. Just return.
        if (!this.event) {
            return;
        }
        const event = Object.assign(Object.assign({}, this.event), props);
        event.eventName = `${event.eventName}_${eventNameSuffix}`;
        if (eventNameSuffix !== "start") {
            event.duration = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.performance.now() - this.startTime;
        }
        this.logger.sendPerformanceEvent(event, error);
    }
}
// Note - these Telemetry types should move to common-definitions package
/**
 * Broad classifications to be applied to individual properties as they're prepared to be logged to telemetry.
 * Please do not modify existing entries for backwards compatibility.
 */
var TelemetryDataTag;
(function (TelemetryDataTag) {
    /** Data containing terms from code packages that may have been dynamically loaded */
    TelemetryDataTag["PackageData"] = "PackageData";
    /** Personal data of a variety of classifications that pertains to the user */
    TelemetryDataTag["UserData"] = "UserData";
})(TelemetryDataTag || (TelemetryDataTag = {}));
/**
 * Type guard to identify if a particular value (loosely) appears to be a tagged telemetry property
 */
function isTaggedTelemetryPropertyValue(x) {
    return (typeof (x === null || x === void 0 ? void 0 : x.value) !== "object" && typeof (x === null || x === void 0 ? void 0 : x.tag) === "string");
}
const isILoggingError = (x) => typeof (x === null || x === void 0 ? void 0 : x.getTelemetryProperties) === "function";
/**
 * Walk an object's enumerable properties to find those fit for telemetry.
 */
function getValidTelemetryProps(obj) {
    const props = {};
    for (const key of Object.keys(obj)) {
        const val = obj[key];
        switch (typeof val) {
            case "string":
            case "number":
            case "boolean":
            case "undefined":
                props[key] = val;
                break;
            default: {
                if (isTaggedTelemetryPropertyValue(val)) {
                    props[key] = val;
                }
                else {
                    // We don't support logging arbitrary objects
                    props[key] = "REDACTED (arbitrary object)";
                }
                break;
            }
        }
    }
    return props;
}
/**
 * Helper class for error tracking that can be used to log an error in telemetry.
 * The props passed in (and any set directly on the object after the fact) will be
 * logged in accordance with the given TelemetryDataTag, if present.
 *
 * PLEASE take care to properly tag properties set on this object
 */
class LoggingError extends Error {
    constructor(message, props) {
        super(message);
        if (props) {
            this.addTelemetryProperties(props);
        }
    }
    /**
     * Add additional properties to be logged
     */
    addTelemetryProperties(props) {
        Object.assign(this, props);
    }
    /**
     * Get all properties fit to be logged to telemetry for this error
     */
    getTelemetryProperties() {
        const taggableProps = getValidTelemetryProps(this);
        // Include non-enumerable props inherited from Error that would not be returned by getValidTelemetryProps
        // But if any were overwritten (e.g. with a tagged property), then use the result from getValidTelemetryProps.
        // Not including the 'name' property because it's likely always "Error"
        return Object.assign({ stack: this.stack, message: this.message }, taggableProps);
    }
}
/**
 * Logger that is useful for UT
 * It can be used in places where logger instance is required, but events should be not send over.
 */
class TelemetryUTLogger {
    send(event) {
    }
    sendTelemetryEvent(event, error) {
    }
    sendErrorEvent(event, error) {
        this.reportError("errorEvent in UT logger!", event, error);
    }
    sendPerformanceEvent(event, error) {
    }
    logGenericError(eventName, error) {
        this.reportError(`genericError in UT logger!`, { eventName }, error);
    }
    logException(event, exception) {
        this.reportError("exception in UT logger!", event, exception);
    }
    debugAssert(condition, event) {
        this.reportError("debugAssert in UT logger!");
    }
    shipAssert(condition, event) {
        this.reportError("shipAssert in UT logger!");
    }
    reportError(message, event, err) {
        const error = new Error(message);
        error.error = error;
        error.event = event;
        // report to console as exception can be eaten
        console.error(message);
        console.error(error);
        throw error;
    }
}
//# sourceMappingURL=logger.js.map

/***/ }),

/***/ "../../node_modules/base64-js/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/base64-js/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "../../node_modules/debug/node_modules/ms/index.js":
/*!*********************************************************!*\
  !*** ../../node_modules/debug/node_modules/ms/index.js ***!
  \*********************************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "../../node_modules/debug/src/browser.js":
/*!***********************************************!*\
  !*** ../../node_modules/debug/src/browser.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = "*";
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "../../node_modules/debug/src/common.js":
/*!**********************************************!*\
  !*** ../../node_modules/debug/src/common.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "../../node_modules/debug/node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "../../node_modules/double-ended-queue/js/deque.js":
/*!*********************************************************!*\
  !*** ../../node_modules/double-ended-queue/js/deque.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
/**
 * Copyright (c) 2013 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function Deque(capacity) {
    this._capacity = getCapacity(capacity);
    this._length = 0;
    this._front = 0;
    if (isArray(capacity)) {
        var len = capacity.length;
        for (var i = 0; i < len; ++i) {
            this[i] = capacity[i];
        }
        this._length = len;
    }
}

Deque.prototype.toArray = function Deque$toArray() {
    var len = this._length;
    var ret = new Array(len);
    var front = this._front;
    var capacity = this._capacity;
    for (var j = 0; j < len; ++j) {
        ret[j] = this[(front + j) & (capacity - 1)];
    }
    return ret;
};

Deque.prototype.push = function Deque$push(item) {
    var argsLength = arguments.length;
    var length = this._length;
    if (argsLength > 1) {
        var capacity = this._capacity;
        if (length + argsLength > capacity) {
            for (var i = 0; i < argsLength; ++i) {
                this._checkCapacity(length + 1);
                var j = (this._front + length) & (this._capacity - 1);
                this[j] = arguments[i];
                length++;
                this._length = length;
            }
            return length;
        }
        else {
            var j = this._front;
            for (var i = 0; i < argsLength; ++i) {
                this[(j + length) & (capacity - 1)] = arguments[i];
                j++;
            }
            this._length = length + argsLength;
            return length + argsLength;
        }

    }

    if (argsLength === 0) return length;

    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = item;
    this._length = length + 1;
    return length + 1;
};

Deque.prototype.pop = function Deque$pop() {
    var length = this._length;
    if (length === 0) {
        return void 0;
    }
    var i = (this._front + length - 1) & (this._capacity - 1);
    var ret = this[i];
    this[i] = void 0;
    this._length = length - 1;
    return ret;
};

Deque.prototype.shift = function Deque$shift() {
    var length = this._length;
    if (length === 0) {
        return void 0;
    }
    var front = this._front;
    var ret = this[front];
    this[front] = void 0;
    this._front = (front + 1) & (this._capacity - 1);
    this._length = length - 1;
    return ret;
};

Deque.prototype.unshift = function Deque$unshift(item) {
    var length = this._length;
    var argsLength = arguments.length;


    if (argsLength > 1) {
        var capacity = this._capacity;
        if (length + argsLength > capacity) {
            for (var i = argsLength - 1; i >= 0; i--) {
                this._checkCapacity(length + 1);
                var capacity = this._capacity;
                var j = (((( this._front - 1 ) &
                    ( capacity - 1) ) ^ capacity ) - capacity );
                this[j] = arguments[i];
                length++;
                this._length = length;
                this._front = j;
            }
            return length;
        }
        else {
            var front = this._front;
            for (var i = argsLength - 1; i >= 0; i--) {
                var j = (((( front - 1 ) &
                    ( capacity - 1) ) ^ capacity ) - capacity );
                this[j] = arguments[i];
                front = j;
            }
            this._front = front;
            this._length = length + argsLength;
            return length + argsLength;
        }
    }

    if (argsLength === 0) return length;

    this._checkCapacity(length + 1);
    var capacity = this._capacity;
    var i = (((( this._front - 1 ) &
        ( capacity - 1) ) ^ capacity ) - capacity );
    this[i] = item;
    this._length = length + 1;
    this._front = i;
    return length + 1;
};

Deque.prototype.peekBack = function Deque$peekBack() {
    var length = this._length;
    if (length === 0) {
        return void 0;
    }
    var index = (this._front + length - 1) & (this._capacity - 1);
    return this[index];
};

Deque.prototype.peekFront = function Deque$peekFront() {
    if (this._length === 0) {
        return void 0;
    }
    return this[this._front];
};

Deque.prototype.get = function Deque$get(index) {
    var i = index;
    if ((i !== (i | 0))) {
        return void 0;
    }
    var len = this._length;
    if (i < 0) {
        i = i + len;
    }
    if (i < 0 || i >= len) {
        return void 0;
    }
    return this[(this._front + i) & (this._capacity - 1)];
};

Deque.prototype.isEmpty = function Deque$isEmpty() {
    return this._length === 0;
};

Deque.prototype.clear = function Deque$clear() {
    var len = this._length;
    var front = this._front;
    var capacity = this._capacity;
    for (var j = 0; j < len; ++j) {
        this[(front + j) & (capacity - 1)] = void 0;
    }
    this._length = 0;
    this._front = 0;
};

Deque.prototype.toString = function Deque$toString() {
    return this.toArray().toString();
};

Deque.prototype.valueOf = Deque.prototype.toString;
Deque.prototype.removeFront = Deque.prototype.shift;
Deque.prototype.removeBack = Deque.prototype.pop;
Deque.prototype.insertFront = Deque.prototype.unshift;
Deque.prototype.insertBack = Deque.prototype.push;
Deque.prototype.enqueue = Deque.prototype.push;
Deque.prototype.dequeue = Deque.prototype.shift;
Deque.prototype.toJSON = Deque.prototype.toArray;

Object.defineProperty(Deque.prototype, "length", {
    get: function() {
        return this._length;
    },
    set: function() {
        throw new RangeError("");
    }
});

Deque.prototype._checkCapacity = function Deque$_checkCapacity(size) {
    if (this._capacity < size) {
        this._resizeTo(getCapacity(this._capacity * 1.5 + 16));
    }
};

Deque.prototype._resizeTo = function Deque$_resizeTo(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    if (front + length > oldCapacity) {
        var moveItemsCount = (front + length) & (oldCapacity - 1);
        arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    }
};


var isArray = Array.isArray;

function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function pow2AtLeast(n) {
    n = n >>> 0;
    n = n - 1;
    n = n | (n >> 1);
    n = n | (n >> 2);
    n = n | (n >> 4);
    n = n | (n >> 8);
    n = n | (n >> 16);
    return n + 1;
}

function getCapacity(capacity) {
    if (typeof capacity !== "number") {
        if (isArray(capacity)) {
            capacity = capacity.length;
        }
        else {
            return 16;
        }
    }
    return pow2AtLeast(
        Math.min(
            Math.max(16, capacity), 1073741824)
    );
}

module.exports = Deque;


/***/ }),

/***/ "../../node_modules/events/events.js":
/*!*******************************************!*\
  !*** ../../node_modules/events/events.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.log) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "../../node_modules/lodash/_DataView.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_DataView.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "../../node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "../../node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ "../../node_modules/lodash/_Hash.js":
/*!******************************************!*\
  !*** ../../node_modules/lodash/_Hash.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(/*! ./_hashClear */ "../../node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "../../node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "../../node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "../../node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "../../node_modules/lodash/_hashSet.js");

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ "../../node_modules/lodash/_ListCache.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_ListCache.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "../../node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "../../node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "../../node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "../../node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "../../node_modules/lodash/_listCacheSet.js");

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ "../../node_modules/lodash/_Map.js":
/*!*****************************************!*\
  !*** ../../node_modules/lodash/_Map.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "../../node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "../../node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ "../../node_modules/lodash/_MapCache.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_MapCache.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "../../node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "../../node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "../../node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "../../node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "../../node_modules/lodash/_mapCacheSet.js");

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ "../../node_modules/lodash/_Promise.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_Promise.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "../../node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "../../node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ "../../node_modules/lodash/_Set.js":
/*!*****************************************!*\
  !*** ../../node_modules/lodash/_Set.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "../../node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "../../node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ "../../node_modules/lodash/_Stack.js":
/*!*******************************************!*\
  !*** ../../node_modules/lodash/_Stack.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "../../node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "../../node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "../../node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "../../node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "../../node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "../../node_modules/lodash/_stackSet.js");

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ "../../node_modules/lodash/_Symbol.js":
/*!********************************************!*\
  !*** ../../node_modules/lodash/_Symbol.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "../../node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "../../node_modules/lodash/_Uint8Array.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_Uint8Array.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "../../node_modules/lodash/_root.js");

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ "../../node_modules/lodash/_WeakMap.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_WeakMap.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "../../node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "../../node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ "../../node_modules/lodash/_apply.js":
/*!*******************************************!*\
  !*** ../../node_modules/lodash/_apply.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),

/***/ "../../node_modules/lodash/_arrayEach.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_arrayEach.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ "../../node_modules/lodash/_arrayFilter.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_arrayFilter.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ "../../node_modules/lodash/_arrayLikeKeys.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_arrayLikeKeys.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "../../node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "../../node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "../../node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "../../node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "../../node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "../../node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ "../../node_modules/lodash/_arrayPush.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_arrayPush.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ "../../node_modules/lodash/_assignMergeValue.js":
/*!******************************************************!*\
  !*** ../../node_modules/lodash/_assignMergeValue.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "../../node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "../../node_modules/lodash/eq.js");

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),

/***/ "../../node_modules/lodash/_assignValue.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_assignValue.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "../../node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "../../node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ "../../node_modules/lodash/_assocIndexOf.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_assocIndexOf.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(/*! ./eq */ "../../node_modules/lodash/eq.js");

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ "../../node_modules/lodash/_baseAssign.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_baseAssign.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "../../node_modules/lodash/_copyObject.js"),
    keys = __webpack_require__(/*! ./keys */ "../../node_modules/lodash/keys.js");

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ "../../node_modules/lodash/_baseAssignIn.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_baseAssignIn.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "../../node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "../../node_modules/lodash/keysIn.js");

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ "../../node_modules/lodash/_baseAssignValue.js":
/*!*****************************************************!*\
  !*** ../../node_modules/lodash/_baseAssignValue.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "../../node_modules/lodash/_defineProperty.js");

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ "../../node_modules/lodash/_baseClone.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_baseClone.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "../../node_modules/lodash/_Stack.js"),
    arrayEach = __webpack_require__(/*! ./_arrayEach */ "../../node_modules/lodash/_arrayEach.js"),
    assignValue = __webpack_require__(/*! ./_assignValue */ "../../node_modules/lodash/_assignValue.js"),
    baseAssign = __webpack_require__(/*! ./_baseAssign */ "../../node_modules/lodash/_baseAssign.js"),
    baseAssignIn = __webpack_require__(/*! ./_baseAssignIn */ "../../node_modules/lodash/_baseAssignIn.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "../../node_modules/lodash/_cloneBuffer.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "../../node_modules/lodash/_copyArray.js"),
    copySymbols = __webpack_require__(/*! ./_copySymbols */ "../../node_modules/lodash/_copySymbols.js"),
    copySymbolsIn = __webpack_require__(/*! ./_copySymbolsIn */ "../../node_modules/lodash/_copySymbolsIn.js"),
    getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "../../node_modules/lodash/_getAllKeys.js"),
    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ "../../node_modules/lodash/_getAllKeysIn.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "../../node_modules/lodash/_getTag.js"),
    initCloneArray = __webpack_require__(/*! ./_initCloneArray */ "../../node_modules/lodash/_initCloneArray.js"),
    initCloneByTag = __webpack_require__(/*! ./_initCloneByTag */ "../../node_modules/lodash/_initCloneByTag.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "../../node_modules/lodash/_initCloneObject.js"),
    isArray = __webpack_require__(/*! ./isArray */ "../../node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "../../node_modules/lodash/isBuffer.js"),
    isMap = __webpack_require__(/*! ./isMap */ "../../node_modules/lodash/isMap.js"),
    isObject = __webpack_require__(/*! ./isObject */ "../../node_modules/lodash/isObject.js"),
    isSet = __webpack_require__(/*! ./isSet */ "../../node_modules/lodash/isSet.js"),
    keys = __webpack_require__(/*! ./keys */ "../../node_modules/lodash/keys.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "../../node_modules/lodash/keysIn.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ "../../node_modules/lodash/_baseCreate.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_baseCreate.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "../../node_modules/lodash/isObject.js");

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ "../../node_modules/lodash/_baseFor.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_baseFor.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createBaseFor = __webpack_require__(/*! ./_createBaseFor */ "../../node_modules/lodash/_createBaseFor.js");

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),

/***/ "../../node_modules/lodash/_baseGetAllKeys.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_baseGetAllKeys.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "../../node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "../../node_modules/lodash/isArray.js");

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ "../../node_modules/lodash/_baseGetTag.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_baseGetTag.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../../node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "../../node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "../../node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "../../node_modules/lodash/_baseIsArguments.js":
/*!*****************************************************!*\
  !*** ../../node_modules/lodash/_baseIsArguments.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../../node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../../node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ "../../node_modules/lodash/_baseIsMap.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_baseIsMap.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(/*! ./_getTag */ "../../node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../../node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ "../../node_modules/lodash/_baseIsNative.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_baseIsNative.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "../../node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "../../node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "../../node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "../../node_modules/lodash/_toSource.js");

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ "../../node_modules/lodash/_baseIsSet.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_baseIsSet.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(/*! ./_getTag */ "../../node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../../node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ "../../node_modules/lodash/_baseIsTypedArray.js":
/*!******************************************************!*\
  !*** ../../node_modules/lodash/_baseIsTypedArray.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../../node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "../../node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../../node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "../../node_modules/lodash/_baseKeys.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_baseKeys.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "../../node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "../../node_modules/lodash/_nativeKeys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ "../../node_modules/lodash/_baseKeysIn.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_baseKeysIn.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "../../node_modules/lodash/isObject.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "../../node_modules/lodash/_isPrototype.js"),
    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ "../../node_modules/lodash/_nativeKeysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ "../../node_modules/lodash/_baseMerge.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_baseMerge.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "../../node_modules/lodash/_Stack.js"),
    assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ "../../node_modules/lodash/_assignMergeValue.js"),
    baseFor = __webpack_require__(/*! ./_baseFor */ "../../node_modules/lodash/_baseFor.js"),
    baseMergeDeep = __webpack_require__(/*! ./_baseMergeDeep */ "../../node_modules/lodash/_baseMergeDeep.js"),
    isObject = __webpack_require__(/*! ./isObject */ "../../node_modules/lodash/isObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "../../node_modules/lodash/keysIn.js"),
    safeGet = __webpack_require__(/*! ./_safeGet */ "../../node_modules/lodash/_safeGet.js");

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),

/***/ "../../node_modules/lodash/_baseMergeDeep.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_baseMergeDeep.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ "../../node_modules/lodash/_assignMergeValue.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "../../node_modules/lodash/_cloneBuffer.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "../../node_modules/lodash/_cloneTypedArray.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "../../node_modules/lodash/_copyArray.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "../../node_modules/lodash/_initCloneObject.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "../../node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "../../node_modules/lodash/isArray.js"),
    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ "../../node_modules/lodash/isArrayLikeObject.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "../../node_modules/lodash/isBuffer.js"),
    isFunction = __webpack_require__(/*! ./isFunction */ "../../node_modules/lodash/isFunction.js"),
    isObject = __webpack_require__(/*! ./isObject */ "../../node_modules/lodash/isObject.js"),
    isPlainObject = __webpack_require__(/*! ./isPlainObject */ "../../node_modules/lodash/isPlainObject.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "../../node_modules/lodash/isTypedArray.js"),
    safeGet = __webpack_require__(/*! ./_safeGet */ "../../node_modules/lodash/_safeGet.js"),
    toPlainObject = __webpack_require__(/*! ./toPlainObject */ "../../node_modules/lodash/toPlainObject.js");

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),

/***/ "../../node_modules/lodash/_baseRest.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_baseRest.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(/*! ./identity */ "../../node_modules/lodash/identity.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "../../node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "../../node_modules/lodash/_setToString.js");

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),

/***/ "../../node_modules/lodash/_baseSetToString.js":
/*!*****************************************************!*\
  !*** ../../node_modules/lodash/_baseSetToString.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constant = __webpack_require__(/*! ./constant */ "../../node_modules/lodash/constant.js"),
    defineProperty = __webpack_require__(/*! ./_defineProperty */ "../../node_modules/lodash/_defineProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "../../node_modules/lodash/identity.js");

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),

/***/ "../../node_modules/lodash/_baseTimes.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_baseTimes.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ "../../node_modules/lodash/_baseUnary.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_baseUnary.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "../../node_modules/lodash/_cloneArrayBuffer.js":
/*!******************************************************!*\
  !*** ../../node_modules/lodash/_cloneArrayBuffer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "../../node_modules/lodash/_Uint8Array.js");

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),

/***/ "../../node_modules/lodash/_cloneBuffer.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_cloneBuffer.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(/*! ./_root */ "../../node_modules/lodash/_root.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;


/***/ }),

/***/ "../../node_modules/lodash/_cloneDataView.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_cloneDataView.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "../../node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ "../../node_modules/lodash/_cloneRegExp.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_cloneRegExp.js ***!
  \*************************************************/
/***/ ((module) => {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ "../../node_modules/lodash/_cloneSymbol.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_cloneSymbol.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../../node_modules/lodash/_Symbol.js");

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ "../../node_modules/lodash/_cloneTypedArray.js":
/*!*****************************************************!*\
  !*** ../../node_modules/lodash/_cloneTypedArray.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "../../node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),

/***/ "../../node_modules/lodash/_copyArray.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_copyArray.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),

/***/ "../../node_modules/lodash/_copyObject.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_copyObject.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(/*! ./_assignValue */ "../../node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "../../node_modules/lodash/_baseAssignValue.js");

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ "../../node_modules/lodash/_copySymbols.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_copySymbols.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "../../node_modules/lodash/_copyObject.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "../../node_modules/lodash/_getSymbols.js");

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ "../../node_modules/lodash/_copySymbolsIn.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_copySymbolsIn.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "../../node_modules/lodash/_copyObject.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "../../node_modules/lodash/_getSymbolsIn.js");

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ "../../node_modules/lodash/_coreJsData.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_coreJsData.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "../../node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ "../../node_modules/lodash/_createAssigner.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_createAssigner.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(/*! ./_baseRest */ "../../node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "../../node_modules/lodash/_isIterateeCall.js");

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),

/***/ "../../node_modules/lodash/_createBaseFor.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_createBaseFor.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),

/***/ "../../node_modules/lodash/_defineProperty.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_defineProperty.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "../../node_modules/lodash/_getNative.js");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ "../../node_modules/lodash/_freeGlobal.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_freeGlobal.js ***!
  \************************************************/
/***/ ((module) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal =  true && ({}).Object === Object && ({});

module.exports = freeGlobal;


/***/ }),

/***/ "../../node_modules/lodash/_getAllKeys.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_getAllKeys.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "../../node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "../../node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "../../node_modules/lodash/keys.js");

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ "../../node_modules/lodash/_getAllKeysIn.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_getAllKeysIn.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "../../node_modules/lodash/_baseGetAllKeys.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "../../node_modules/lodash/_getSymbolsIn.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "../../node_modules/lodash/keysIn.js");

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ "../../node_modules/lodash/_getMapData.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_getMapData.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "../../node_modules/lodash/_isKeyable.js");

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ "../../node_modules/lodash/_getNative.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_getNative.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "../../node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "../../node_modules/lodash/_getValue.js");

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ "../../node_modules/lodash/_getPrototype.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_getPrototype.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "../../node_modules/lodash/_overArg.js");

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ "../../node_modules/lodash/_getRawTag.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_getRawTag.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../../node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "../../node_modules/lodash/_getSymbols.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_getSymbols.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "../../node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "../../node_modules/lodash/stubArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ "../../node_modules/lodash/_getSymbolsIn.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_getSymbolsIn.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "../../node_modules/lodash/_arrayPush.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "../../node_modules/lodash/_getPrototype.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "../../node_modules/lodash/_getSymbols.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "../../node_modules/lodash/stubArray.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ "../../node_modules/lodash/_getTag.js":
/*!********************************************!*\
  !*** ../../node_modules/lodash/_getTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DataView = __webpack_require__(/*! ./_DataView */ "../../node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "../../node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "../../node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "../../node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "../../node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../../node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "../../node_modules/lodash/_toSource.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ "../../node_modules/lodash/_getValue.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_getValue.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "../../node_modules/lodash/_hashClear.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_hashClear.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "../../node_modules/lodash/_nativeCreate.js");

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ "../../node_modules/lodash/_hashDelete.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_hashDelete.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ "../../node_modules/lodash/_hashGet.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_hashGet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "../../node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ "../../node_modules/lodash/_hashHas.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_hashHas.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "../../node_modules/lodash/_nativeCreate.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ "../../node_modules/lodash/_hashSet.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_hashSet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "../../node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ "../../node_modules/lodash/_initCloneArray.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_initCloneArray.js ***!
  \****************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ "../../node_modules/lodash/_initCloneByTag.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_initCloneByTag.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "../../node_modules/lodash/_cloneArrayBuffer.js"),
    cloneDataView = __webpack_require__(/*! ./_cloneDataView */ "../../node_modules/lodash/_cloneDataView.js"),
    cloneRegExp = __webpack_require__(/*! ./_cloneRegExp */ "../../node_modules/lodash/_cloneRegExp.js"),
    cloneSymbol = __webpack_require__(/*! ./_cloneSymbol */ "../../node_modules/lodash/_cloneSymbol.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "../../node_modules/lodash/_cloneTypedArray.js");

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ "../../node_modules/lodash/_initCloneObject.js":
/*!*****************************************************!*\
  !*** ../../node_modules/lodash/_initCloneObject.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseCreate = __webpack_require__(/*! ./_baseCreate */ "../../node_modules/lodash/_baseCreate.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "../../node_modules/lodash/_getPrototype.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "../../node_modules/lodash/_isPrototype.js");

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),

/***/ "../../node_modules/lodash/_isIndex.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_isIndex.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ "../../node_modules/lodash/_isIterateeCall.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_isIterateeCall.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(/*! ./eq */ "../../node_modules/lodash/eq.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "../../node_modules/lodash/isArrayLike.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "../../node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "../../node_modules/lodash/isObject.js");

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),

/***/ "../../node_modules/lodash/_isKeyable.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_isKeyable.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ "../../node_modules/lodash/_isMasked.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_isMasked.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "../../node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ "../../node_modules/lodash/_isPrototype.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_isPrototype.js ***!
  \*************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ "../../node_modules/lodash/_listCacheClear.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_listCacheClear.js ***!
  \****************************************************/
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ "../../node_modules/lodash/_listCacheDelete.js":
/*!*****************************************************!*\
  !*** ../../node_modules/lodash/_listCacheDelete.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "../../node_modules/lodash/_assocIndexOf.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ "../../node_modules/lodash/_listCacheGet.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_listCacheGet.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "../../node_modules/lodash/_assocIndexOf.js");

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ "../../node_modules/lodash/_listCacheHas.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_listCacheHas.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "../../node_modules/lodash/_assocIndexOf.js");

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ "../../node_modules/lodash/_listCacheSet.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_listCacheSet.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "../../node_modules/lodash/_assocIndexOf.js");

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ "../../node_modules/lodash/_mapCacheClear.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_mapCacheClear.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(/*! ./_Hash */ "../../node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "../../node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "../../node_modules/lodash/_Map.js");

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ "../../node_modules/lodash/_mapCacheDelete.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_mapCacheDelete.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "../../node_modules/lodash/_getMapData.js");

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ "../../node_modules/lodash/_mapCacheGet.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_mapCacheGet.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "../../node_modules/lodash/_getMapData.js");

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ "../../node_modules/lodash/_mapCacheHas.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_mapCacheHas.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "../../node_modules/lodash/_getMapData.js");

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ "../../node_modules/lodash/_mapCacheSet.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_mapCacheSet.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "../../node_modules/lodash/_getMapData.js");

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ "../../node_modules/lodash/_nativeCreate.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_nativeCreate.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "../../node_modules/lodash/_getNative.js");

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ "../../node_modules/lodash/_nativeKeys.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_nativeKeys.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "../../node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "../../node_modules/lodash/_nativeKeysIn.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_nativeKeysIn.js ***!
  \**************************************************/
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ "../../node_modules/lodash/_nodeUtil.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_nodeUtil.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "../../node_modules/lodash/_freeGlobal.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ "../../node_modules/lodash/_objectToString.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_objectToString.js ***!
  \****************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "../../node_modules/lodash/_overArg.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_overArg.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "../../node_modules/lodash/_overRest.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_overRest.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(/*! ./_apply */ "../../node_modules/lodash/_apply.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),

/***/ "../../node_modules/lodash/_root.js":
/*!******************************************!*\
  !*** ../../node_modules/lodash/_root.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "../../node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "../../node_modules/lodash/_safeGet.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_safeGet.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),

/***/ "../../node_modules/lodash/_setToString.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_setToString.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSetToString = __webpack_require__(/*! ./_baseSetToString */ "../../node_modules/lodash/_baseSetToString.js"),
    shortOut = __webpack_require__(/*! ./_shortOut */ "../../node_modules/lodash/_shortOut.js");

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),

/***/ "../../node_modules/lodash/_shortOut.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_shortOut.js ***!
  \**********************************************/
/***/ ((module) => {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),

/***/ "../../node_modules/lodash/_stackClear.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_stackClear.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "../../node_modules/lodash/_ListCache.js");

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ "../../node_modules/lodash/_stackDelete.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_stackDelete.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ "../../node_modules/lodash/_stackGet.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_stackGet.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ "../../node_modules/lodash/_stackHas.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_stackHas.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ "../../node_modules/lodash/_stackSet.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_stackSet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "../../node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "../../node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "../../node_modules/lodash/_MapCache.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ "../../node_modules/lodash/_toSource.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_toSource.js ***!
  \**********************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ "../../node_modules/lodash/cloneDeep.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/cloneDeep.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(/*! ./_baseClone */ "../../node_modules/lodash/_baseClone.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),

/***/ "../../node_modules/lodash/constant.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/constant.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),

/***/ "../../node_modules/lodash/eq.js":
/*!***************************************!*\
  !*** ../../node_modules/lodash/eq.js ***!
  \***************************************/
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "../../node_modules/lodash/identity.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/identity.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "../../node_modules/lodash/isArguments.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/isArguments.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "../../node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../../node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ "../../node_modules/lodash/isArray.js":
/*!********************************************!*\
  !*** ../../node_modules/lodash/isArray.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "../../node_modules/lodash/isArrayLike.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/isArrayLike.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "../../node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "../../node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "../../node_modules/lodash/isArrayLikeObject.js":
/*!******************************************************!*\
  !*** ../../node_modules/lodash/isArrayLikeObject.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "../../node_modules/lodash/isArrayLike.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../../node_modules/lodash/isObjectLike.js");

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),

/***/ "../../node_modules/lodash/isBuffer.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/isBuffer.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(/*! ./_root */ "../../node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "../../node_modules/lodash/stubFalse.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ "../../node_modules/lodash/isFunction.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/isFunction.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../../node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "../../node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "../../node_modules/lodash/isLength.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/isLength.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "../../node_modules/lodash/isMap.js":
/*!******************************************!*\
  !*** ../../node_modules/lodash/isMap.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMap = __webpack_require__(/*! ./_baseIsMap */ "../../node_modules/lodash/_baseIsMap.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "../../node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "../../node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ "../../node_modules/lodash/isObject.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/isObject.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "../../node_modules/lodash/isObjectLike.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/isObjectLike.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "../../node_modules/lodash/isPlainObject.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/isPlainObject.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../../node_modules/lodash/_baseGetTag.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "../../node_modules/lodash/_getPrototype.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../../node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),

/***/ "../../node_modules/lodash/isSet.js":
/*!******************************************!*\
  !*** ../../node_modules/lodash/isSet.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsSet = __webpack_require__(/*! ./_baseIsSet */ "../../node_modules/lodash/_baseIsSet.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "../../node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "../../node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ "../../node_modules/lodash/isTypedArray.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/isTypedArray.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "../../node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "../../node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "../../node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "../../node_modules/lodash/keys.js":
/*!*****************************************!*\
  !*** ../../node_modules/lodash/keys.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "../../node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "../../node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "../../node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ "../../node_modules/lodash/keysIn.js":
/*!*******************************************!*\
  !*** ../../node_modules/lodash/keysIn.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "../../node_modules/lodash/_arrayLikeKeys.js"),
    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ "../../node_modules/lodash/_baseKeysIn.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "../../node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ "../../node_modules/lodash/merge.js":
/*!******************************************!*\
  !*** ../../node_modules/lodash/merge.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMerge = __webpack_require__(/*! ./_baseMerge */ "../../node_modules/lodash/_baseMerge.js"),
    createAssigner = __webpack_require__(/*! ./_createAssigner */ "../../node_modules/lodash/_createAssigner.js");

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),

/***/ "../../node_modules/lodash/stubArray.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/stubArray.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ "../../node_modules/lodash/stubFalse.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/stubFalse.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "../../node_modules/lodash/toPlainObject.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/toPlainObject.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "../../node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "../../node_modules/lodash/keysIn.js");

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),

/***/ "../../node_modules/path-browserify/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/path-browserify/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;


/***/ }),

/***/ "../../node_modules/querystring/decode.js":
/*!************************************************!*\
  !*** ../../node_modules/querystring/decode.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};


/***/ }),

/***/ "../../node_modules/querystring/encode.js":
/*!************************************************!*\
  !*** ../../node_modules/querystring/encode.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};


/***/ }),

/***/ "../../node_modules/querystring/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/querystring/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "../../node_modules/querystring/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "../../node_modules/querystring/encode.js");


/***/ }),

/***/ "./src/documentComponent.ts":
/*!**********************************!*\
  !*** ./src/documentComponent.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DocumentComponent": () => (/* binding */ DocumentComponent)
/* harmony export */ });
/* harmony import */ var _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/aqueduct */ "../../node_modules/@fluidframework/aqueduct/lib/data-objects/dataObject.js");
/* harmony import */ var _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/aqueduct */ "../../node_modules/@fluidframework/aqueduct/lib/data-object-factories/dataObjectFactory.js");
/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/map */ "../../node_modules/@fluidframework/map/lib/map.js");
/* harmony import */ var _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/sequence */ "../../node_modules/@fluidframework/sequence/lib/sharedString.js");
/* harmony import */ var _documentModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./documentModel */ "./src/documentModel.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 */




class DocumentComponent extends _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_0__.DataObject {
    get documentModel() {
        if (!this._documentModel) {
            throw new Error("documentModel has not been initialized yet");
        }
        return this._documentModel;
    }
    /**
     * @override
     *
     * Called the first time, and *only* the first time, that the DataObject
     * is opened on a client. It is _not_ called on any subsequent clients that
     * open it.
     */
    initializingFirstTime() {
        _documentModel__WEBPACK_IMPORTED_MODULE_1__.DocumentModel.createForNewDocument(this.runtime, this.root);
        return Promise.resolve();
    }
    /**
     * Called every time the DataObject is initialized _from an existing
     * instance_. * Not called the first time the DataObject is initialized.
     */
    // Not implementing this yet for our component as it is not needed.
    // The data stored in DDSs are already loaded even without this.
    // This can be used to provide backwards compatibility when a
    // new instance can consume and upgrade a model from an older client
    // protected async initializingFromExisting(): Promise<void> { }
    /**
     * @override
     */
    hasInitialized() {
        return __awaiter(this, void 0, void 0, function* () {
            // Store references to the Distributed Data Structures in DocumentModel
            this._documentModel = yield _documentModel__WEBPACK_IMPORTED_MODULE_1__.DocumentModel.fromExistingDocument(this.root);
        });
    }
}
DocumentComponent.objectType = "DocumentComponent";
/**
 * Factory for creating a DocumentComponent
 */
DocumentComponent.factory = new _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_2__.DataObjectFactory(DocumentComponent.objectType, DocumentComponent, [_fluidframework_map__WEBPACK_IMPORTED_MODULE_3__.SharedMap.getFactory(), _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_4__.SharedString.getFactory()], {});


/***/ }),

/***/ "./src/documentModel.ts":
/*!******************************!*\
  !*** ./src/documentModel.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DocumentModel": () => (/* binding */ DocumentModel)
/* harmony export */ });
/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/map */ "../../node_modules/@fluidframework/map/lib/map.js");
/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/map */ "../../node_modules/@fluidframework/map/lib/directory.js");
/* harmony import */ var _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/sequence */ "../../node_modules/@fluidframework/sequence/lib/sharedString.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


function setDds(rootDirectory, key, dds) {
    rootDirectory.set(key, dds.handle);
}
function getDds(rootDirectory, key) {
    return __awaiter(this, void 0, void 0, function* () {
        const ddsHandle = rootDirectory.get(key);
        if (!ddsHandle) {
            throw new Error(`Could not get handle to DDS for ${key}`);
        }
        return yield ddsHandle.get();
    });
}
class DocumentModel {
    constructor(textString, presenceMap, snapshotsMap, listDefinitionsMap, listOverridesMap, oartDirectory) {
        this.textString = textString;
        this.presenceMap = presenceMap;
        this.snapshotsMap = snapshotsMap;
        this.listDefinitionsMap = listDefinitionsMap;
        this.listOverridesMap = listOverridesMap;
        this.oartDirectory = oartDirectory;
    }
    /**
     * Populate the given rootDirectory given be a new document
     */
    static createForNewDocument(runtime, rootDirectory) {
        const textString = _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedString.create(runtime);
        textString.insertMarker(0, 1, {
            markerId: "{61E35DF2-8462-4CE1-8EEB-1D00F4AC6457}",
            referenceTileLabels: ["Eop"],
        });
        textString.insertMarker(0, 1, {
            markerId: "{07480EF9-939A-4922-8822-2C0E16253659}",
            referenceTileLabels: ["Eop"],
        });
        textString.insertMarker(0, 1, {
            markerId: "{DC6D36DF-DABF-4BA0-BFCA-0133AF997332}",
            referenceTileLabels: ["Eop"],
        });
        setDds(rootDirectory, "textString", textString);
        const presenceMap = _fluidframework_map__WEBPACK_IMPORTED_MODULE_1__.SharedMap.create(runtime);
        setDds(rootDirectory, "presenceMap", presenceMap);
        const snapshotsMap = _fluidframework_map__WEBPACK_IMPORTED_MODULE_1__.SharedMap.create(runtime);
        setDds(rootDirectory, "snapshotsMap", snapshotsMap);
        const listDefinitionsMap = _fluidframework_map__WEBPACK_IMPORTED_MODULE_1__.SharedMap.create(runtime);
        setDds(rootDirectory, "listDefinitionsMap", listDefinitionsMap);
        const listOverridesMap = _fluidframework_map__WEBPACK_IMPORTED_MODULE_1__.SharedMap.create(runtime);
        setDds(rootDirectory, "listOverridesMap", listOverridesMap);
        const oartDirectory = _fluidframework_map__WEBPACK_IMPORTED_MODULE_2__.SharedDirectory.create(runtime);
        setDds(rootDirectory, "oartDirectory", oartDirectory);
        return new DocumentModel(textString, presenceMap, snapshotsMap, listDefinitionsMap, listOverridesMap, oartDirectory);
    }
    /**
     * When component has finished initializing via hasInitialized(),
     * store references to the ready Distributed Data Structures
     * in the component's root
     */
    static fromExistingDocument(rootDirectory) {
        return __awaiter(this, void 0, void 0, function* () {
            const [textString, presenceMap, snapshotsMap, listDefinitionsMap, listOverridesMap, oartDirectory] = yield Promise.all([
                getDds(rootDirectory, "textString"),
                getDds(rootDirectory, "presenceMap"),
                getDds(rootDirectory, "snapshotsMap"),
                getDds(rootDirectory, "listDefinitionsMap"),
                getDds(rootDirectory, "listOverridesMap"),
                getDds(rootDirectory, "oartDirectory"),
            ]);
            return new DocumentModel(textString, presenceMap, snapshotsMap, listDefinitionsMap, listOverridesMap, oartDirectory);
        });
    }
}


/***/ }),

/***/ "./src/loader.ts":
/*!***********************!*\
  !*** ./src/loader.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WordCodeLoader": () => (/* binding */ WordCodeLoader)
/* harmony export */ });
/* harmony import */ var _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/aqueduct */ "../../node_modules/@fluidframework/aqueduct/lib/container-runtime-factories/containerRuntimeFactoryWithDefaultDataStore.js");
/* harmony import */ var _fluidframework_container_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fluidframework/container-loader */ "../../node_modules/@fluidframework/container-loader/lib/loader.js");
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/telemetry-utils */ "../../node_modules/@fluidframework/telemetry-utils/lib/debugLogger.js");
/* harmony import */ var _documentComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./documentComponent */ "./src/documentComponent.ts");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 */




class WordCodeLoader {
    constructor(enableSummaries) {
        const runtimeOptions = {};
        if (!enableSummaries) {
            runtimeOptions.disableGC = true;
            runtimeOptions.generateSummaries = false;
        }
        this.runtimeFactory = new _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_0__.ContainerRuntimeFactoryWithDefaultDataStore(_documentComponent__WEBPACK_IMPORTED_MODULE_1__.DocumentComponent.factory, new Map([[_documentComponent__WEBPACK_IMPORTED_MODULE_1__.DocumentComponent.objectType, Promise.resolve(_documentComponent__WEBPACK_IMPORTED_MODULE_1__.DocumentComponent.factory)]]), [], [], runtimeOptions);
    }
    /**
     * @inheritdoc
     */
    load(pkg) {
        let source;
        if (typeof pkg.package === "string") {
            source = pkg.package;
        }
        else {
            throw new Error(`Unexpected package type: '${typeof pkg.package}'`);
        }
        if (source !== _documentComponent__WEBPACK_IMPORTED_MODULE_1__.DocumentComponent.objectType) {
            throw new Error(`No factory for '${source}'`);
        }
        return Promise.resolve({ fluidExport: this.runtimeFactory });
    }
    /**
     * Returns the correct container loader
     */
    getLoader(urlResolver, documentServiceFactory, client) {
        const module = { fluidExport: this.runtimeFactory };
        const codeLoader = { load: () => Promise.resolve(module) };
        const loaderProps = {
            codeLoader,
            documentServiceFactory,
            logger: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.DebugLogger.create("Word"),
            options: {
                client,
            },
            urlResolver,
        };
        return new _fluidframework_container_loader__WEBPACK_IMPORTED_MODULE_3__.Loader(loaderProps);
    }
}


/***/ }),

/***/ "./src/ocs/conversionHelpers.ts":
/*!**************************************!*\
  !*** ./src/ocs/conversionHelpers.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applySequenceNumberToFluidMessage": () => (/* binding */ applySequenceNumberToFluidMessage),
/* harmony export */   "convertWpmToFluidSequencedMessages": () => (/* binding */ convertWpmToFluidSequencedMessages),
/* harmony export */   "createFluidClient": () => (/* binding */ createFluidClient)
/* harmony export */ });
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/protocol.js");
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/scopes.js");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 */

const SUPPORTED_DOCUMENT_MESSAGE_TYPES = new Set([
    // Note: join/leave are not in this list because they are system messages
    _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.NoOp,
    _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Operation,
    _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Propose,
    _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Reject,
]);
/**
 * Decodes the JSON stored in a {@link WpmOverOcsSequencedMessagesEncoded} performing validation on the
 * Word-owned envelope. Fluid is responsible for validating the contained messages.
 */
function decodeWpmDeltaMessagesFromJson(json) {
    /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access -- We're going to parse JSON and validate it */
    const raw = JSON.parse(json);
    if (Array.isArray(raw)) {
        for (let i = 0; i < raw.length; i += 1) {
            const group = raw[i];
            if (typeof group.sender !== "string" ||
                group.sender.length === 0 ||
                !Array.isArray(group.messages) ||
                group.messages.length === 0) {
                throw new Error("Malformed delta messages");
            }
            for (let j = 0; j < group.messages.length; j += 1) {
                const msg = group.messages[j];
                // Fluid is responsible for validating the IDocumentMessage format, we're just doing a
                // sanity-check here
                if (typeof msg !== "object" ||
                    // eslint-disable-next-line no-null/no-null -- required to validate the object is safe
                    msg === null ||
                    // minimumSequenceNumber will be set if immediate-ACK was in use
                    (typeof msg.minimimSequenceNumber !== "undefined" && typeof msg.minimimSequenceNumber !== "number")) {
                    throw new Error("Malformed delta messages");
                }
            }
            return { decoded: raw, type: "document" };
        }
    }
    if ((raw.type !== "ClientJoin" && raw.type !== "ClientLeave") ||
        typeof raw.clientId !== "string" ||
        typeof raw.userId !== "string") {
        throw new Error("Malformed delta messages");
    }
    return { decoded: raw, type: "system" };
    /* eslint-enable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access */
}
/**
 * Helper to create either a ClientJoin or ClientLeave Fluid message.
 */
function createFluidSystemMessage(type, data) {
    if (type !== _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientJoin && type !== _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientLeave) {
        throw new Error("Invalid type");
    }
    return {
        clientSequenceNumber: -1,
        // eslint-disable-next-line no-null/no-null -- null is expected by Fluid
        contents: null,
        data: JSON.stringify(data),
        referenceSequenceNumber: -1,
        type,
    };
}
/**
 * Applies a stamped sequence number (and associated metadata) to a Fluid message.
 */
function createSequencedFluidMessage(_type, // Only used for inferring the return type
clientId, message, minimumSequenceNumber, sequenceNumber) {
    return Object.assign(Object.assign({}, message), { clientId,
        minimumSequenceNumber,
        sequenceNumber, 
        // Fluid doesn't seem to care too much about these for our purposes
        term: 1, 
        // This must be zero! That way Fluid is okay with receiving a duplicate ClientJoin message for itself when it
        // fetches via Delta Storage (which we synthesized to unblock booting) and then when it receives the stamped
        // message later.
        //
        // This means we don't store timestamps in the delta stream!
        timestamp: 0 });
}
/**
 * Applies a consistent envelope used by WPM Over OCS for stamping/sequencing to a message.
 *
 * @param clientId - the ID of the client sending the message.
 * @param minimumSequenceNumber - the minimum sequence number of the session.
 * @param sequenceNumber - the sequence number to assign to the message.
 * @param message - the message to sequence/stamp.
 * @returns the sequenced copy of the message.
 */
function applySequenceNumberToFluidMessage(clientId, minimumSequenceNumber, sequenceNumber, message) {
    return createSequencedFluidMessage("document", clientId, message, minimumSequenceNumber, sequenceNumber);
}
/**
 * Converts a {@link WpmOverOcsSequencedDocumentMessages} to an array of Fluid's {@link ISequencedDocumentMessage}.
 */
function convertWpmToFluidSequencedDocumentMessages(startingMinimumSequenceNumber, startingSequenceNumber, decoded) {
    var _a;
    const messages = [];
    let sequenceNumberTracker = startingSequenceNumber;
    let lastMinimumSequenceNumber = startingMinimumSequenceNumber;
    for (let groupIndex = 0; groupIndex < decoded.length; groupIndex += 1) {
        const group = decoded[groupIndex];
        for (let messageIndex = 0; messageIndex < group.messages.length; messageIndex += 1) {
            const messageSequenceNumber = sequenceNumberTracker;
            sequenceNumberTracker += 1;
            // Fluid is responsible for validating this object matches the expected schema
            const message = group.messages[messageIndex];
            if (!SUPPORTED_DOCUMENT_MESSAGE_TYPES.has(message.type)) {
                throw new Error("Unsupported document message type");
            }
            // minimumSequenceNumber will be set on the message if immediate-ACK was in use
            const messageMinimumSequenceNumber = (_a = message.minimumSequenceNumber) !== null && _a !== void 0 ? _a : lastMinimumSequenceNumber;
            if (messageMinimumSequenceNumber < lastMinimumSequenceNumber) {
                throw new Error("Malformed delta message");
            }
            lastMinimumSequenceNumber = messageMinimumSequenceNumber;
            const sequencedMessage = createSequencedFluidMessage("document", group.sender, message, messageMinimumSequenceNumber, messageSequenceNumber);
            messages.push(sequencedMessage);
        }
    }
    if (messages.length === 0) {
        throw new Error("Malformed encoded messages");
    }
    return messages;
}
/**
 * Converts a {@link WpmOverOcsSequencedSystemMessage} to a Fluid {@link ISequencedDocumentSystemMessage}.
 */
function convertWpmToFluidSequencedSystemMessage(startingMinimumSequenceNumber, startingSequenceNumber, decoded) {
    let systemMessage;
    if (decoded.type === "ClientJoin") {
        systemMessage = createFluidSystemMessage(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientJoin, {
            clientId: decoded.clientId,
            detail: createFluidClient(decoded.userId),
        });
    }
    else {
        systemMessage = createFluidSystemMessage(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientLeave, decoded.clientId);
    }
    const sequencedMessage = createSequencedFluidMessage("system", 
    // eslint-disable-next-line no-null/no-null -- Fluid expects null
    null, // clientId
    systemMessage, startingMinimumSequenceNumber, startingSequenceNumber);
    return sequencedMessage;
}
/**
 * Convert messages stored in an OCS dictionary format into the format Fluid expects.
 */
function convertWpmToFluidSequencedMessages(encoded) {
    const deltaMessages = decodeWpmDeltaMessagesFromJson(encoded.json);
    if (deltaMessages.type === "document") {
        return convertWpmToFluidSequencedDocumentMessages(encoded.minimumSequenceNumber, encoded.startingSequenceNumber, deltaMessages.decoded);
    }
    return [
        convertWpmToFluidSequencedSystemMessage(encoded.minimumSequenceNumber, encoded.startingSequenceNumber, deltaMessages.decoded),
    ];
}
/**
 * Creates a Fluid {@link IClient} with a consistent set of properties for use with WPM Over OCS.
 */
function createFluidClient(userId) {
    return {
        details: {
            capabilities: {
                // Not true for Sword but we don't really care
                interactive: true,
            },
        },
        // We don't support read-only Fluid for WPM Over OCS
        mode: "write",
        permission: [],
        // Notice that there is no SummaryWrite here
        scopes: [_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.ScopeType.DocRead, _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.ScopeType.DocWrite],
        user: {
            id: userId,
        },
    };
}


/***/ }),

/***/ "./src/ocs/deltaConnection.ts":
/*!************************************!*\
  !*** ./src/ocs/deltaConnection.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WpmOverOcsDocumentDeltaConnection": () => (/* binding */ WpmOverOcsDocumentDeltaConnection)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/scopes.js");
/* harmony import */ var _urlResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./urlResolver */ "./src/ocs/urlResolver.ts");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 */



/**
 * Implementation of {@link IDocumentDeltaConnection} as part of the WPM Over OCS driver.
 */
class WpmOverOcsDocumentDeltaConnection extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    /**
     * @param _native - interface back into Word native code.
     * @param clientId - the Fluid ID of the connecting client.
     * @param _user - the Fluid identity of the connecting user.
     * @param existing - whether this is for an existing Fluid container (one with a code proposal & populated delta stream).
     * @param _decodeHelper - helper to convert messages stored in a WPM Over OCS dictionary to what Fluid expects.
     * @param _stampingHelper - helper to attach a sequencing metadata to a message.
     */
    constructor(_native, clientId, _user, existing, _decodeHelper, _stampingHelper) {
        super();
        this._native = _native;
        this.clientId = clientId;
        this._user = _user;
        this.existing = existing;
        this._decodeHelper = _decodeHelper;
        this._stampingHelper = _stampingHelper;
        /**
         * @inheritdoc
         */
        this.initialClients = []; // Fluid will figure it out as it goes through the op stream
        /**
         * @inheritdoc
         */
        this.mode = "write"; // We don't support read-only Fluid
        /**
         * @inheritdoc
         */
        this.maxMessageSize = Number.MAX_SAFE_INTEGER; // Technically there is a limit for what we put in the dictionary; just let that fail in native
        /**
         * @inheritdoc
         */
        this.version = "WPMv1"; // Does not have to match ocsfmt
        /**
         * @inheritdoc
         */
        this.initialMessages = []; // Fluid will figure this out from the delta stream
        /**
         * @inheritdoc
         */
        this.initialSignals = []; // Fluid will figure this out from the delta stream
        /**
         * @inheritdoc
         */
        this.serviceConfiguration = {
            // See comment above for maxMessageSize
            blockSize: Number.MAX_SAFE_INTEGER,
            maxMessageSize: Number.MAX_SAFE_INTEGER,
            // We disable summaries when loading the container
            summary: {
                idleTime: Number.MAX_SAFE_INTEGER,
                maxAckWaitTime: Number.MAX_SAFE_INTEGER,
                maxOps: Number.MAX_SAFE_INTEGER,
                maxTime: Number.MAX_SAFE_INTEGER,
            },
        };
        this._bufferedOutgoingMessages = [];
        this._closed = false;
        this._immediateAck = true;
        this._immediateAckNextSeqNumber = 2; // 1 is the ClientJoin generated by native
    }
    /**
     * @inheritdoc
     */
    stopImmediateAck() {
        this._immediateAck = false;
    }
    /**
     * @inheritdoc
     */
    retrieveAndClearBufferedMessages() {
        if (this._bufferedOutgoingMessages.length === 0) {
            throw new Error("No buffered messages available");
        }
        const result = {
            count: this._bufferedOutgoingMessages.length,
            json: JSON.stringify([
                {
                    messages: this._bufferedOutgoingMessages,
                    sender: this.clientId,
                },
            ]),
            refSeqLast: this._bufferedOutgoingMessages[this._bufferedOutgoingMessages.length - 1].referenceSequenceNumber,
        };
        // Clear the buffer
        this._bufferedOutgoingMessages.splice(0, this._bufferedOutgoingMessages.length);
        return result;
    }
    /**
     * @inheritdoc
     */
    submitSequencedMessages(sequencedMessages) {
        const decoded = this._decodeHelper(sequencedMessages);
        this.emit("op", _urlResolver__WEBPACK_IMPORTED_MODULE_1__.WPM_OVER_OCS_DOCUMENT_ID, decoded);
    }
    /**
     * @inheritdoc
     */
    get claims() {
        return {
            documentId: _urlResolver__WEBPACK_IMPORTED_MODULE_1__.WPM_OVER_OCS_DOCUMENT_ID,
            exp: Number.MAX_SAFE_INTEGER,
            iat: Number.MAX_SAFE_INTEGER,
            scopes: [_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.ScopeType.DocRead, _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.ScopeType.DocWrite],
            tenantId: _urlResolver__WEBPACK_IMPORTED_MODULE_1__.WPM_OVER_OCS_TENANT_ID,
            user: this._user,
            ver: this.version,
        };
    }
    /**
     * @inheritdoc
     */
    submit(messages) {
        if (this._closed) {
            throw new Error("Delta connection is closed");
        }
        // Don't try to notify Fluid of messages in the same turn of the event loop. It doesn't like that.
        queueMicrotask(() => {
            if (this._closed) {
                return;
            }
            for (const message of messages) {
                if (this._immediateAck) {
                    // If we're in immediate-ACK mode, then this is the only client, and it controls the collab
                    // window. To make forward progress, we need to keep moving the collab window forward as the
                    // client buffers messages.
                    this._bufferedOutgoingMessages.push(Object.assign(Object.assign({}, message), { minimumSequenceNumber: message.referenceSequenceNumber }));
                }
                else {
                    this._bufferedOutgoingMessages.push(message);
                }
            }
            if (this._immediateAck) {
                // Immediate-ACK mode means we need to immediately stamp the message and tell Fluid about it
                const sequenced = [];
                for (const message of messages) {
                    const sequencedMessage = this._stampingHelper(this.clientId, message.referenceSequenceNumber, this._immediateAckNextSeqNumber, message);
                    this._immediateAckNextSeqNumber += 1;
                    sequenced.push(sequencedMessage);
                }
                this.emit("op", _urlResolver__WEBPACK_IMPORTED_MODULE_1__.WPM_OVER_OCS_DOCUMENT_ID, sequenced);
            }
            // Ring the dinner bell; let native know there's messages it needs to fetch
            this._native.onConnectionMessagesBuffered();
        });
    }
    /**
     * @inheritdoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types -- this API signature comes from Fluid
    submitSignal(_message) {
        throw new Error("We do not expect signals to be used in WPM Over OCS");
    }
    /**
     * @inheritdoc
     */
    close() {
        if (this._closed) {
            throw new Error("Delta connection is already closed");
        }
        this._closed = true;
        this._native.onConnectionClosed();
    }
}


/***/ }),

/***/ "./src/ocs/deltaStorage.ts":
/*!*********************************!*\
  !*** ./src/ocs/deltaStorage.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WpmOverOcsDocumentDeltaStorageService": () => (/* binding */ WpmOverOcsDocumentDeltaStorageService)
/* harmony export */ });
/**
 * Implementation of {@link IDocumentDeltaStorageService} as part of the WPM Over OCS driver.
 */
class WpmOverOcsDocumentDeltaStorageService {
    /**
     * @param native - interface back into native Word code.
     * @param _conversionHelper - helper to convert messages stored in a WPM Over OCS dictionary to what Fluid expects.
     */
    constructor(native, _conversionHelper) {
        this._conversionHelper = _conversionHelper;
        this._native = native;
    }
    /**
     * @inheritdoc
     */
    get(from, to) {
        if (!this._native) {
            throw new Error("We only expect Fluid to fetch one time to simplify the native implementation");
        }
        if (from !== 0) {
            throw new Error("We only expect Fluid to fetch from the very first message to simplify the native implementation");
        }
        const fetched = this._native.retrieveSequencedMessages(from, to);
        const messages = [];
        for (let i = 0; i < fetched.length; i += 1) {
            const encoded = fetched[i];
            const decoded = this._conversionHelper(encoded);
            // Native can't break apart chunks of messages so we need to filter here
            const messagesToAppend = decoded.filter((m) => m.sequenceNumber < to);
            messages.push(...messagesToAppend);
            // If we filtered anything, then anything remaining must be beyond what we're looking for
            if (messagesToAppend.length !== decoded.length) {
                break;
            }
        }
        this._native = undefined;
        return Promise.resolve({
            messages,
            partialResult: false,
        });
    }
}


/***/ }),

/***/ "./src/ocs/documentService.ts":
/*!************************************!*\
  !*** ./src/ocs/documentService.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WpmOverOcsDocumentService": () => (/* binding */ WpmOverOcsDocumentService),
/* harmony export */   "WpmOverOcsDocumentServiceFactory": () => (/* binding */ WpmOverOcsDocumentServiceFactory)
/* harmony export */ });
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fluidframework/protocol-definitions */ "../../node_modules/@fluidframework/protocol-definitions/lib/scopes.js");
/* harmony import */ var _conversionHelpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conversionHelpers */ "./src/ocs/conversionHelpers.ts");
/* harmony import */ var _deltaConnection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./deltaConnection */ "./src/ocs/deltaConnection.ts");
/* harmony import */ var _deltaStorage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./deltaStorage */ "./src/ocs/deltaStorage.ts");
/* harmony import */ var _documentStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./documentStorage */ "./src/ocs/documentStorage.ts");
/* harmony import */ var _urlResolver__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./urlResolver */ "./src/ocs/urlResolver.ts");






/**
 * Implementation of {@link IDocumentService} as part of the WPM Over OCS driver.
 *
 * @see WpmOverOcsDocumentDeltaConnection
 * @see WpmOverOcsDocumentDeltaStorageService
 * @see WpmOverOcsDocumentStorageService
 * @see WpmOverOcsDocumentServiceFactory
 */
class WpmOverOcsDocumentService {
    constructor(native, resolvedUrl, clientId, _user, existing) {
        this.resolvedUrl = resolvedUrl;
        this._user = _user;
        // We don't allow Fluid to make arbitrary/multiple "connections" to OCS. This flag is to enforce that
        // Fluid only connects once.
        this._connected = false;
        /**
         * @inheritdoc
         */
        this.policies = undefined;
        this._storage = new _documentStorage__WEBPACK_IMPORTED_MODULE_0__.WpmOverOcsDocumentStorageService();
        this._deltaStorage = new _deltaStorage__WEBPACK_IMPORTED_MODULE_1__.WpmOverOcsDocumentDeltaStorageService(native, _conversionHelpers__WEBPACK_IMPORTED_MODULE_2__.convertWpmToFluidSequencedMessages);
        this._deltaConnection = new _deltaConnection__WEBPACK_IMPORTED_MODULE_3__.WpmOverOcsDocumentDeltaConnection(native, clientId, _user, existing, _conversionHelpers__WEBPACK_IMPORTED_MODULE_2__.convertWpmToFluidSequencedMessages, _conversionHelpers__WEBPACK_IMPORTED_MODULE_2__.applySequenceNumberToFluidMessage);
    }
    /**
     * @inheritdoc
     */
    connectToStorage() {
        return Promise.resolve(this._storage);
    }
    /**
     * @inheritdoc
     */
    connectToDeltaStorage() {
        return Promise.resolve(this._deltaStorage);
    }
    /**
     * @inheritdoc
     */
    connectToDeltaStream(client) {
        if (this._connected) {
            throw new Error("Multiple/arbitrary connections to OCS are not supported");
        }
        if (client.user.id !== this._user.id ||
            client.mode !== "write" ||
            client.scopes.indexOf(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_4__.ScopeType.DocRead) === -1 ||
            client.scopes.indexOf(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_4__.ScopeType.DocWrite) === -1 ||
            client.scopes.indexOf(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_4__.ScopeType.SummaryWrite) !== -1) {
            throw new Error("Invalid client");
        }
        this._connected = true;
        return Promise.resolve(this._deltaConnection);
    }
    /**
     * @inheritdoc
     */
    getErrorTrackingService() {
        // eslint-disable-next-line no-null/no-null -- this signature is from Fluid
        return null;
    }
    /**
     * @inheritdoc
     */
    stopImmediateAck() {
        this._deltaConnection.stopImmediateAck();
    }
    /**
     * @inheritdoc
     */
    retrieveAndClearBufferedMessages() {
        return this._deltaConnection.retrieveAndClearBufferedMessages();
    }
    /**
     * @inheritdoc
     */
    submitSequencedMessages(sequencedMessages) {
        this._deltaConnection.submitSequencedMessages(sequencedMessages);
    }
}
/**
 * Implementation of {@link IDocumentServiceFactory} as part of the WPM Over OCS driver.
 *
 * @see WpmOverOcsDocumentService
 */
class WpmOverOcsDocumentServiceFactory {
    constructor(documentService) {
        /**
         * @inheritdoc
         */
        this.protocolName = _urlResolver__WEBPACK_IMPORTED_MODULE_5__.WPM_OVER_OCS_FLUID_URL_PROTOCOL;
        this._documentService = documentService;
    }
    /**
     * @inheritdoc
     */
    createDocumentService(resolvedUrl, _logger) {
        if (!(0,_urlResolver__WEBPACK_IMPORTED_MODULE_5__.isWpmOverOcsResolvedUrl)(resolvedUrl)) {
            throw new Error("URL is not supported by WPM Over OCS driver");
        }
        if (this._documentService === undefined) {
            throw new Error("Multiple/arbitrary connections to OCS are not supported");
        }
        const documentService = this._documentService;
        this._documentService = undefined;
        return Promise.resolve(documentService);
    }
    /**
     * @inheritdoc
     */
    createContainer(_createNewSummary, _createNewResolvedUrl, _logger) {
        throw new Error("Not supported in WPM Over OCS");
    }
}


/***/ }),

/***/ "./src/ocs/documentStorage.ts":
/*!************************************!*\
  !*** ./src/ocs/documentStorage.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WpmOverOcsDocumentStorageService": () => (/* binding */ WpmOverOcsDocumentStorageService)
/* harmony export */ });
/**
 * Implementation of {@link IDocumentStorageService} as part of the WPM Over OCS driver.
 */
class WpmOverOcsDocumentStorageService {
    constructor() {
        /**
         * {@inheritdoc}
         */
        this.policies = undefined; // Fluid requires we return something, we can't notReached() in a getter
    }
    notReached() {
        throw new Error("Not expected to be used in WPM Over OCS");
    }
    /**
     * {@inheritdoc}
     */
    get repositoryUrl() {
        return this.notReached();
    }
    /**
     * {@inheritdoc}
     */
    getSnapshotTree(_version) {
        // eslint-disable-next-line no-null/no-null -- this signature is from Fluid
        return Promise.resolve(null);
    }
    /**
     * {@inheritdoc}
     */
    getVersions(_versionId, _count) {
        // Fluid requires we return something here, we can't notReached()
        return Promise.resolve([]);
    }
    /**
     * {@inheritdoc}
     */
    write(_root, _parents, _message, _ref) {
        return this.notReached();
    }
    /**
     * {@inheritdoc}
     */
    createBlob(_file) {
        return this.notReached();
    }
    /**
     * {@inheritdoc}
     */
    readBlob(_id) {
        return this.notReached();
    }
    /**
     * {@inheritdoc}
     */
    uploadSummaryWithContext(_summary, _context) {
        return this.notReached();
    }
    /**
     * {@inheritdoc}
     */
    downloadSummary(_handle) {
        return this.notReached();
    }
}


/***/ }),

/***/ "./src/ocs/ocsDocumentFactory.ts":
/*!***************************************!*\
  !*** ./src/ocs/ocsDocumentFactory.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createWpmOverOcsDocument": () => (/* binding */ createWpmOverOcsDocument),
/* harmony export */   "openWpmOverOcsDocument": () => (/* binding */ openWpmOverOcsDocument)
/* harmony export */ });
/* harmony import */ var _documentComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../documentComponent */ "./src/documentComponent.ts");
/* harmony import */ var _loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../loader */ "./src/loader.ts");
/* harmony import */ var _wordDocument__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../wordDocument */ "./src/wordDocument.ts");
/* harmony import */ var _conversionHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conversionHelpers */ "./src/ocs/conversionHelpers.ts");
/* harmony import */ var _documentService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./documentService */ "./src/ocs/documentService.ts");
/* harmony import */ var _urlResolver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./urlResolver */ "./src/ocs/urlResolver.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






const CODE_PROPOSAL = {
    config: {},
    package: _documentComponent__WEBPACK_IMPORTED_MODULE_0__.DocumentComponent.objectType,
};
/**
 * Creates a new, or loads an existing, WPM document (aka container) for use on WPM Over OCS.
 *
 * @param routeOptions - options for booting Fluid.
 * @param existing - whether to create or load.
 * @returns the {@link WordDocument} in the WPM container, and the object for the host-side
 *          contract of the WPM Over OCS driver.
 */
function loadContainer(routeOptions, existing) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = (0,_conversionHelpers__WEBPACK_IMPORTED_MODULE_1__.createFluidClient)(routeOptions.userId);
        const user = {
            id: routeOptions.userId,
        };
        const urlResolver = new _urlResolver__WEBPACK_IMPORTED_MODULE_2__.WpmOverOcsUrlResolver();
        const documentUrl = "wpm://ocs/document.wpm";
        const resolvedUrlExpected = yield urlResolver.resolve({ url: documentUrl });
        const documentService = new _documentService__WEBPACK_IMPORTED_MODULE_3__.WpmOverOcsDocumentService(routeOptions.native, resolvedUrlExpected, routeOptions.clientId, user, existing);
        const documentServiceFactory = new _documentService__WEBPACK_IMPORTED_MODULE_3__.WpmOverOcsDocumentServiceFactory(documentService);
        if (existing) {
            // We're not bootstrapping so don't try to immediately stamp messages in the driver
            documentService.stopImmediateAck();
        }
        const codeLoader = new _loader__WEBPACK_IMPORTED_MODULE_4__.WordCodeLoader(false /*enable summaries*/);
        const loader = codeLoader.getLoader(urlResolver, documentServiceFactory, client);
        // WPM Over OCS doesn't currently support summaries, so it seems we can't use createDetachedContainer().
        // We get to do all the loading & setup.
        const container = yield loader.resolve({ url: documentUrl });
        let acceptDocumentComponentLambda;
        let rejectDocumentComponentLambda;
        const documentComponentPromise = new Promise((accept, reject) => {
            acceptDocumentComponentLambda = accept;
            rejectDocumentComponentLambda = reject;
        });
        const attach = (loader, url) => __awaiter(this, void 0, void 0, function* () {
            const response = yield loader.request({ url });
            if (response.status !== 200) {
                // We queue up two attach() calls below - one better succeed since we're trying to connect to FluidTestHostComponent
                return;
            }
            if (response.mimeType !== "fluid/object") {
                throw new Error("Invalid response when retrieving DocumentComponent");
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- we go on to validate the type right below here
            const documentComponent = response.value;
            if (!documentComponent || !(documentComponent instanceof _documentComponent__WEBPACK_IMPORTED_MODULE_0__.DocumentComponent)) {
                throw new Error("Invalid DocumentComponent");
            }
            acceptDocumentComponentLambda(documentComponent);
        });
        container.on("contextChanged", () => {
            attach(loader, documentUrl).catch((e) => rejectDocumentComponentLambda(e));
        });
        yield attach(loader, documentUrl);
        if (!container.connected) {
            yield new Promise((resolve) => container.on("connected", () => {
                resolve();
            }));
        }
        const quorum = container.getQuorum();
        if (!quorum.has("code")) {
            yield quorum.propose("code", CODE_PROPOSAL);
        }
        const documentComponent = yield documentComponentPromise;
        const wordDocument = new _wordDocument__WEBPACK_IMPORTED_MODULE_5__.WordDocument(documentComponent, () => container.close());
        return [wordDocument, documentService];
    });
}
/**
 * Creates a new WPM document for use on WPM Over OCS.
 *
 * @param routeOptions - options for booting Fluid.
 * @returns the {@link WordDocument} in the WPM container, and the object for the host-side
 *          contract of the WPM Over OCS driver.
 */
function createWpmOverOcsDocument(routeOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield loadContainer(routeOptions, false /*existing*/);
    });
}
/**
 * Opens an existing WPM document on WPM Over OCS.
 *
 * @param routeOptions - options for booting Fluid.
 * @returns the {@link WordDocument} in the WPM container, and the object for the host-side
 *          contract of the WPM Over OCS driver.
 */
function openWpmOverOcsDocument(routeOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield loadContainer(routeOptions, true /*existing*/);
    });
}


/***/ }),

/***/ "./src/ocs/urlResolver.ts":
/*!********************************!*\
  !*** ./src/ocs/urlResolver.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WPM_OVER_OCS_DOCUMENT_ID": () => (/* binding */ WPM_OVER_OCS_DOCUMENT_ID),
/* harmony export */   "WPM_OVER_OCS_TENANT_ID": () => (/* binding */ WPM_OVER_OCS_TENANT_ID),
/* harmony export */   "WPM_OVER_OCS_FLUID_URL_PROTOCOL": () => (/* binding */ WPM_OVER_OCS_FLUID_URL_PROTOCOL),
/* harmony export */   "isWpmOverOcsResolvedUrl": () => (/* binding */ isWpmOverOcsResolvedUrl),
/* harmony export */   "WpmOverOcsUrlResolver": () => (/* binding */ WpmOverOcsUrlResolver)
/* harmony export */ });
/*
 * Fluid expects some sort of document ID to be used, even if we don't really need one for WPM Over OCS.
 */
const WPM_OVER_OCS_DOCUMENT_ID = "document.wpm";
/*
 * Fluid expects some sort of tenant ID to be used, even if we don't really need one for WPM Over OCS.
 */
const WPM_OVER_OCS_TENANT_ID = "00000000-0000-0000-0000-000000000000";
/**
 * Protocol that when used in Fluid indicates that WPM Over OCS is in use.
 */
const WPM_OVER_OCS_FLUID_URL_PROTOCOL = "fluid-wpm://";
/**
 * Checks if a given URL is for use with WPM Over OCS.
 *
 * @param resolvedUrl - the URL to check.
 * @returns whether the provided URL was resolved by {@link WpmOverOcsUrlResolver}.
 */
function isWpmOverOcsResolvedUrl(resolvedUrl) {
    if (resolvedUrl.type !== "fluid") {
        return false;
    }
    return (resolvedUrl.endpoints["wpm-over-ocs"] === "yes" &&
        resolvedUrl.url === `fluid-wpm://ocs/${WPM_OVER_OCS_TENANT_ID}/${WPM_OVER_OCS_DOCUMENT_ID}`);
}
/**
 * Implementation of {@link IUrlResolver} for WPM Over OCS.
 */
class WpmOverOcsUrlResolver {
    /**
     * @inheritdoc
     */
    resolve(request) {
        if (request.url !== `wpm://ocs/${WPM_OVER_OCS_DOCUMENT_ID}`) {
            throw new Error("Unsupported URL");
        }
        const resolved = {
            endpoints: {
                "wpm-over-ocs": "yes",
            },
            // Fluid demands we provide some sort of token, even if we don't actually use it
            tokens: { jwt: "" },
            type: "fluid",
            // Fluid itself expects a tenant ID in the URL (it doesn't care about the format), so just use a null GUID.
            // Tenant-related stuff is handled in higher layers by the rest of the Office coauth/FIO stack.
            url: `${WPM_OVER_OCS_FLUID_URL_PROTOCOL}ocs/${WPM_OVER_OCS_TENANT_ID}/${WPM_OVER_OCS_DOCUMENT_ID}`,
        };
        return Promise.resolve(resolved);
    }
    /**
     * @inheritdoc
     */
    getAbsoluteUrl(_resolvedUrl, _relativeUrl) {
        throw new Error("Not expected to be used in WPM Over OCS");
    }
}


/***/ }),

/***/ "./src/wordDocument.ts":
/*!*****************************!*\
  !*** ./src/wordDocument.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WordDocument": () => (/* binding */ WordDocument)
/* harmony export */ });
/**
 * Wrapper over Prague collab document for Word
 */
class WordDocument {
    constructor(component, close) {
        this.component = component;
        this.close = close;
    }
    get model() {
        return this.component.documentModel;
    }
    /**
     * Returns text of collab document
     */
    getText() {
        return this.model.textString;
    }
    /**
     * Returns presence of collab document
     */
    getPresence() {
        return this.model.presenceMap;
    }
    /**
     * Returns snapshots of collab document
     */
    getSnapshots() {
        return this.model.snapshotsMap;
    }
    /**
     * Returns listDefinitions of collab document
     */
    getListDefinitions() {
        return this.model.listDefinitionsMap;
    }
    /**
     * Returns listOverrides of collab document
     */
    getListOverrides() {
        return this.model.listOverridesMap;
    }
    /**
     * Returns oartData of collab document
     */
    getOArt() {
        return this.model.oartDirectory;
    }
}


/***/ }),

/***/ "./src/wordapi.ts":
/*!************************!*\
  !*** ./src/wordapi.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeWordApi": () => (/* binding */ makeWordApi)
/* harmony export */ });
/* harmony import */ var _ocs_ocsDocumentFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ocs/ocsDocumentFactory */ "./src/ocs/ocsDocumentFactory.ts");


class WordApi {
    createDocumentOnRouterlicious(documentId, options) {
        if (false) {}
        throw new Error("Routerlicious is not supported");
    }
    openDocumentOnRouterlicious(documentId, options) {
        if (false) {}
        throw new Error("Routerlicious is not supported");
    }
    createDocumentOnOcs(routeOptions) {
        if (true) {
            return (0,_ocs_ocsDocumentFactory__WEBPACK_IMPORTED_MODULE_0__.createWpmOverOcsDocument)(routeOptions);
        }
        throw new Error("WPM Over OCS is not supported");
    }
    openDocumentOnOcs(routeOptions) {
        if (true) {
            return (0,_ocs_ocsDocumentFactory__WEBPACK_IMPORTED_MODULE_0__.openWpmOverOcsDocument)(routeOptions);
        }
        throw new Error("WPM Over OCS is not supported");
    }
}
/**
 * makeWordApi
 *
 * @returns a new instance of the word api
 */
function makeWordApi() {
    return new WordApi();
}


/***/ }),

/***/ "../../node_modules/url/node_modules/punycode/punycode.js":
/*!****************************************************************!*\
  !*** ../../node_modules/url/node_modules/punycode/punycode.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal =  true && ({});
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));


/***/ }),

/***/ "../../node_modules/url/url.js":
/*!*************************************!*\
  !*** ../../node_modules/url/url.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(/*! punycode */ "../../node_modules/url/node_modules/punycode/punycode.js");
var util = __webpack_require__(/*! ./util */ "../../node_modules/url/util.js");

exports.parse = urlParse;
__webpack_unused_export__ = urlResolve;
__webpack_unused_export__ = urlResolveObject;
__webpack_unused_export__ = urlFormat;

__webpack_unused_export__ = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(/*! querystring */ "../../node_modules/querystring/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),

/***/ "../../node_modules/url/util.js":
/*!**************************************!*\
  !*** ../../node_modules/url/util.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),

/***/ "../../node_modules/uuid/dist/esm-browser/regex.js":
/*!*********************************************************!*\
  !*** ../../node_modules/uuid/dist/esm-browser/regex.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-browser/stringify.js":
/*!*************************************************************!*\
  !*** ../../node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "../../node_modules/uuid/dist/esm-browser/validate.js");

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-browser/v4.js":
/*!******************************************************!*\
  !*** ../../node_modules/uuid/dist/esm-browser/v4.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./custom_modules/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "../../node_modules/uuid/dist/esm-browser/stringify.js");



function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.default)(rnds);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-browser/validate.js":
/*!************************************************************!*\
  !*** ../../node_modules/uuid/dist/esm-browser/validate.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "../../node_modules/uuid/dist/esm-browser/regex.js");


function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__.default.test(uuid);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ }),

/***/ "./custom_modules/TextEncoder.js":
/*!***************************************!*\
  !*** ./custom_modules/TextEncoder.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextEncoder": () => (/* binding */ TextEncoder),
/* harmony export */   "TextDecoder": () => (/* binding */ TextDecoder)
/* harmony export */ });


class TextEncoder {
    constructor() {}

    encode(str) {
        let length = str.length;
        var retArr = new Uint8Array(length);
        for (var ich = 0; ich < length; ich++) {
            var ch = str.charCodeAt(ich);
            if (ch < 0x7f) {
                retArr[ich] = ch;
            } else {
                throw new Error("TextEncoder does not support characters > 0x7f");
            }
        }
        return retArr;
    };
}

class TextDecoder {
    constructor() {}

    decode(input){
        var str = "";
        var len = input.length;

        for (var i = 0; i < len; i++) {
            if (input[i] <= 0x7f) {
                str += String.fromCharCode(input[i]);
            } else {
                throw new Error("TextEncoder does not support characters > 0x7f");
            }
        }

        return str;
    }
}

/***/ }),

/***/ "./custom_modules/rng.js":
/*!*******************************!*\
  !*** ./custom_modules/rng.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });


var rnds8 = new Uint8Array(16);
function rng() {
    rnds8[0] = Math.random() * 256;
    rnds8[1] = Math.random() * 256;
    rnds8[2] = Math.random() * 256;
    rnds8[3] = Math.random() * 256;
    rnds8[4] = Math.random() * 256;
    rnds8[5] = Math.random() * 256;
    rnds8[6] = Math.random() * 256;
    rnds8[7] = Math.random() * 256;
    rnds8[8] = Math.random() * 256;
    rnds8[9] = Math.random() * 256;
    rnds8[10] = Math.random() * 256;
    rnds8[11] = Math.random() * 256;
    rnds8[12] = Math.random() * 256;
    rnds8[13] = Math.random() * 256;
    rnds8[14] = Math.random() * 256;
    rnds8[15] = Math.random() * 256;

    return rnds8;
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*********************!*\
  !*** ./src/word.ts ***!
  \*********************/
/* harmony import */ var _wordapi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wordapi */ "./src/wordapi.ts");
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 */

// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- queueMicrotask isn't defined in V8 in native
if ( true && !globalThis.queueMicrotask) {
    const fulfilledPromise = Promise.resolve();
    // eslint-disable-next-line no-inner-declarations -- polyfill
    function wdQueueMicrotaskPolyfill(fn) {
        // Promise completion callback will be queued to the microtask queue
        fulfilledPromise.finally(fn);
    }
    globalThis.queueMicrotask = wdQueueMicrotaskPolyfill;
}
/**
 * init
 *
 * The entry point into this file
 */
function init() {
    onWordApiAvailable((0,_wordapi__WEBPACK_IMPORTED_MODULE_0__.makeWordApi)());
}
init();

})();

/******/ })()
;
//# sourceMappingURL=bundleWord.ocsOnly.js.map